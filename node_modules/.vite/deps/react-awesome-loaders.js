import {
  require_react
} from "./chunk-DRWLMN53.js";
import {
  __commonJS
} from "./chunk-G3PMV62Z.js";

// node_modules/react-awesome-loaders/lib/index.js
var require_lib = __commonJS({
  "node_modules/react-awesome-loaders/lib/index.js"(exports, module) {
    module.exports = function(t) {
      var e = {};
      function n(r) {
        if (e[r]) return e[r].exports;
        var i = e[r] = { i: r, l: false, exports: {} };
        return t[r].call(i.exports, i, i.exports, n), i.l = true, i.exports;
      }
      return n.m = t, n.c = e, n.d = function(t2, e2, r) {
        n.o(t2, e2) || Object.defineProperty(t2, e2, { enumerable: true, get: r });
      }, n.r = function(t2) {
        "undefined" != typeof Symbol && Symbol.toStringTag && Object.defineProperty(t2, Symbol.toStringTag, { value: "Module" }), Object.defineProperty(t2, "__esModule", { value: true });
      }, n.t = function(t2, e2) {
        if (1 & e2 && (t2 = n(t2)), 8 & e2) return t2;
        if (4 & e2 && "object" == typeof t2 && t2 && t2.__esModule) return t2;
        var r = /* @__PURE__ */ Object.create(null);
        if (n.r(r), Object.defineProperty(r, "default", { enumerable: true, value: t2 }), 2 & e2 && "string" != typeof t2) for (var i in t2) n.d(r, i, (function(e3) {
          return t2[e3];
        }).bind(null, i));
        return r;
      }, n.n = function(t2) {
        var e2 = t2 && t2.__esModule ? function() {
          return t2.default;
        } : function() {
          return t2;
        };
        return n.d(e2, "a", e2), e2;
      }, n.o = function(t2, e2) {
        return Object.prototype.hasOwnProperty.call(t2, e2);
      }, n.p = "", n(n.s = 24);
    }([function(t, e) {
      t.exports = require_react();
    }, function(t, e, n) {
      "use strict";
      n.r(e), (function(t2) {
        n.d(e, "ServerStyleSheet", function() {
          return Bt;
        }), n.d(e, "StyleSheetConsumer", function() {
          return it;
        }), n.d(e, "StyleSheetContext", function() {
          return rt;
        }), n.d(e, "StyleSheetManager", function() {
          return lt;
        }), n.d(e, "ThemeConsumer", function() {
          return Rt;
        }), n.d(e, "ThemeContext", function() {
          return Pt;
        }), n.d(e, "ThemeProvider", function() {
          return Ot;
        }), n.d(e, "__PRIVATE__", function() {
          return Ut;
        }), n.d(e, "createGlobalStyle", function() {
          return kt;
        }), n.d(e, "css", function() {
          return xt;
        }), n.d(e, "isStyledComponent", function() {
          return b;
        }), n.d(e, "keyframes", function() {
          return Ft;
        }), n.d(e, "useTheme", function() {
          return Gt;
        }), n.d(e, "version", function() {
          return _;
        }), n.d(e, "withTheme", function() {
          return Ht;
        });
        var r = n(11), i = n(0), o = n.n(i), a = n(21), s = n.n(a), c = n(22), u = n(23), l = n(13), h = n(12), d = n.n(h);
        function p() {
          return (p = Object.assign || function(t3) {
            for (var e2 = 1; e2 < arguments.length; e2++) {
              var n2 = arguments[e2];
              for (var r2 in n2) Object.prototype.hasOwnProperty.call(n2, r2) && (t3[r2] = n2[r2]);
            }
            return t3;
          }).apply(this, arguments);
        }
        var f = function(t3, e2) {
          for (var n2 = [t3[0]], r2 = 0, i2 = e2.length; r2 < i2; r2 += 1) n2.push(e2[r2], t3[r2 + 1]);
          return n2;
        }, m = function(t3) {
          return null !== t3 && "object" == typeof t3 && "[object Object]" === (t3.toString ? t3.toString() : Object.prototype.toString.call(t3)) && !Object(r.typeOf)(t3);
        }, g = Object.freeze([]), v = Object.freeze({});
        function y(t3) {
          return "function" == typeof t3;
        }
        function x(t3) {
          return t3.displayName || t3.name || "Component";
        }
        function b(t3) {
          return t3 && "string" == typeof t3.styledComponentId;
        }
        var w = void 0 !== t2 && (t2.env.REACT_APP_SC_ATTR || t2.env.SC_ATTR) || "data-styled", _ = "5.2.1", M = "undefined" != typeof window && "HTMLElement" in window, S = Boolean("boolean" == typeof SC_DISABLE_SPEEDY ? SC_DISABLE_SPEEDY : void 0 !== t2 && void 0 !== t2.env.REACT_APP_SC_DISABLE_SPEEDY && "" !== t2.env.REACT_APP_SC_DISABLE_SPEEDY ? "false" !== t2.env.REACT_APP_SC_DISABLE_SPEEDY && t2.env.REACT_APP_SC_DISABLE_SPEEDY : void 0 !== t2 && void 0 !== t2.env.SC_DISABLE_SPEEDY && "" !== t2.env.SC_DISABLE_SPEEDY && ("false" !== t2.env.SC_DISABLE_SPEEDY && t2.env.SC_DISABLE_SPEEDY)), T = {};
        function E(t3) {
          for (var e2 = arguments.length, n2 = new Array(e2 > 1 ? e2 - 1 : 0), r2 = 1; r2 < e2; r2++) n2[r2 - 1] = arguments[r2];
          throw new Error("An error occurred. See https://git.io/JUIaE#" + t3 + " for more information." + (n2.length > 0 ? " Args: " + n2.join(", ") : ""));
        }
        var A = function() {
          function t3(t4) {
            this.groupSizes = new Uint32Array(512), this.length = 512, this.tag = t4;
          }
          var e2 = t3.prototype;
          return e2.indexOfGroup = function(t4) {
            for (var e3 = 0, n2 = 0; n2 < t4; n2++) e3 += this.groupSizes[n2];
            return e3;
          }, e2.insertRules = function(t4, e3) {
            if (t4 >= this.groupSizes.length) {
              for (var n2 = this.groupSizes, r2 = n2.length, i2 = r2; t4 >= i2; ) (i2 <<= 1) < 0 && E(16, "" + t4);
              this.groupSizes = new Uint32Array(i2), this.groupSizes.set(n2), this.length = i2;
              for (var o2 = r2; o2 < i2; o2++) this.groupSizes[o2] = 0;
            }
            for (var a2 = this.indexOfGroup(t4 + 1), s2 = 0, c2 = e3.length; s2 < c2; s2++) this.tag.insertRule(a2, e3[s2]) && (this.groupSizes[t4]++, a2++);
          }, e2.clearGroup = function(t4) {
            if (t4 < this.length) {
              var e3 = this.groupSizes[t4], n2 = this.indexOfGroup(t4), r2 = n2 + e3;
              this.groupSizes[t4] = 0;
              for (var i2 = n2; i2 < r2; i2++) this.tag.deleteRule(n2);
            }
          }, e2.getGroup = function(t4) {
            var e3 = "";
            if (t4 >= this.length || 0 === this.groupSizes[t4]) return e3;
            for (var n2 = this.groupSizes[t4], r2 = this.indexOfGroup(t4), i2 = r2 + n2, o2 = r2; o2 < i2; o2++) e3 += this.tag.getRule(o2) + "/*!sc*/\n";
            return e3;
          }, t3;
        }(), C = /* @__PURE__ */ new Map(), L = /* @__PURE__ */ new Map(), P = 1, R = function(t3) {
          if (C.has(t3)) return C.get(t3);
          for (; L.has(P); ) P++;
          var e2 = P++;
          return C.set(t3, e2), L.set(e2, t3), e2;
        }, O = function(t3) {
          return L.get(t3);
        }, D = function(t3, e2) {
          C.set(t3, e2), L.set(e2, t3);
        }, I = "style[" + w + '][data-styled-version="5.2.1"]', N = new RegExp("^" + w + '\\.g(\\d+)\\[id="([\\w\\d-]+)"\\].*?"([^"]*)'), z = function(t3, e2, n2) {
          for (var r2, i2 = n2.split(","), o2 = 0, a2 = i2.length; o2 < a2; o2++) (r2 = i2[o2]) && t3.registerName(e2, r2);
        }, k = function(t3, e2) {
          for (var n2 = e2.innerHTML.split("/*!sc*/\n"), r2 = [], i2 = 0, o2 = n2.length; i2 < o2; i2++) {
            var a2 = n2[i2].trim();
            if (a2) {
              var s2 = a2.match(N);
              if (s2) {
                var c2 = 0 | parseInt(s2[1], 10), u2 = s2[2];
                0 !== c2 && (D(u2, c2), z(t3, u2, s2[3]), t3.getTag().insertRules(c2, r2)), r2.length = 0;
              } else r2.push(a2);
            }
          }
        }, F = function() {
          return n.nc;
        }, B = function(t3) {
          var e2 = document.head, n2 = t3 || e2, r2 = document.createElement("style"), i2 = function(t4) {
            for (var e3 = t4.childNodes, n3 = e3.length; n3 >= 0; n3--) {
              var r3 = e3[n3];
              if (r3 && 1 === r3.nodeType && r3.hasAttribute(w)) return r3;
            }
          }(n2), o2 = void 0 !== i2 ? i2.nextSibling : null;
          r2.setAttribute(w, "active"), r2.setAttribute("data-styled-version", "5.2.1");
          var a2 = F();
          return a2 && r2.setAttribute("nonce", a2), n2.insertBefore(r2, o2), r2;
        }, H = function() {
          function t3(t4) {
            var e3 = this.element = B(t4);
            e3.appendChild(document.createTextNode("")), this.sheet = function(t5) {
              if (t5.sheet) return t5.sheet;
              for (var e4 = document.styleSheets, n2 = 0, r2 = e4.length; n2 < r2; n2++) {
                var i2 = e4[n2];
                if (i2.ownerNode === t5) return i2;
              }
              E(17);
            }(e3), this.length = 0;
          }
          var e2 = t3.prototype;
          return e2.insertRule = function(t4, e3) {
            try {
              return this.sheet.insertRule(e3, t4), this.length++, true;
            } catch (t5) {
              return false;
            }
          }, e2.deleteRule = function(t4) {
            this.sheet.deleteRule(t4), this.length--;
          }, e2.getRule = function(t4) {
            var e3 = this.sheet.cssRules[t4];
            return void 0 !== e3 && "string" == typeof e3.cssText ? e3.cssText : "";
          }, t3;
        }(), G = function() {
          function t3(t4) {
            var e3 = this.element = B(t4);
            this.nodes = e3.childNodes, this.length = 0;
          }
          var e2 = t3.prototype;
          return e2.insertRule = function(t4, e3) {
            if (t4 <= this.length && t4 >= 0) {
              var n2 = document.createTextNode(e3), r2 = this.nodes[t4];
              return this.element.insertBefore(n2, r2 || null), this.length++, true;
            }
            return false;
          }, e2.deleteRule = function(t4) {
            this.element.removeChild(this.nodes[t4]), this.length--;
          }, e2.getRule = function(t4) {
            return t4 < this.length ? this.nodes[t4].textContent : "";
          }, t3;
        }(), U = function() {
          function t3(t4) {
            this.rules = [], this.length = 0;
          }
          var e2 = t3.prototype;
          return e2.insertRule = function(t4, e3) {
            return t4 <= this.length && (this.rules.splice(t4, 0, e3), this.length++, true);
          }, e2.deleteRule = function(t4) {
            this.rules.splice(t4, 1), this.length--;
          }, e2.getRule = function(t4) {
            return t4 < this.length ? this.rules[t4] : "";
          }, t3;
        }(), j = M, V = { isServer: !M, useCSSOMInjection: !S }, W = function() {
          function t3(t4, e3, n2) {
            void 0 === t4 && (t4 = v), void 0 === e3 && (e3 = {}), this.options = p({}, V, {}, t4), this.gs = e3, this.names = new Map(n2), !this.options.isServer && M && j && (j = false, function(t5) {
              for (var e4 = document.querySelectorAll(I), n3 = 0, r2 = e4.length; n3 < r2; n3++) {
                var i2 = e4[n3];
                i2 && "active" !== i2.getAttribute(w) && (k(t5, i2), i2.parentNode && i2.parentNode.removeChild(i2));
              }
            }(this));
          }
          t3.registerId = function(t4) {
            return R(t4);
          };
          var e2 = t3.prototype;
          return e2.reconstructWithOptions = function(e3, n2) {
            return void 0 === n2 && (n2 = true), new t3(p({}, this.options, {}, e3), this.gs, n2 && this.names || void 0);
          }, e2.allocateGSInstance = function(t4) {
            return this.gs[t4] = (this.gs[t4] || 0) + 1;
          }, e2.getTag = function() {
            return this.tag || (this.tag = (n2 = (e3 = this.options).isServer, r2 = e3.useCSSOMInjection, i2 = e3.target, t4 = n2 ? new U(i2) : r2 ? new H(i2) : new G(i2), new A(t4)));
            var t4, e3, n2, r2, i2;
          }, e2.hasNameForId = function(t4, e3) {
            return this.names.has(t4) && this.names.get(t4).has(e3);
          }, e2.registerName = function(t4, e3) {
            if (R(t4), this.names.has(t4)) this.names.get(t4).add(e3);
            else {
              var n2 = /* @__PURE__ */ new Set();
              n2.add(e3), this.names.set(t4, n2);
            }
          }, e2.insertRules = function(t4, e3, n2) {
            this.registerName(t4, e3), this.getTag().insertRules(R(t4), n2);
          }, e2.clearNames = function(t4) {
            this.names.has(t4) && this.names.get(t4).clear();
          }, e2.clearRules = function(t4) {
            this.getTag().clearGroup(R(t4)), this.clearNames(t4);
          }, e2.clearTag = function() {
            this.tag = void 0;
          }, e2.toString = function() {
            return function(t4) {
              for (var e3 = t4.getTag(), n2 = e3.length, r2 = "", i2 = 0; i2 < n2; i2++) {
                var o2 = O(i2);
                if (void 0 !== o2) {
                  var a2 = t4.names.get(o2), s2 = e3.getGroup(i2);
                  if (void 0 !== a2 && 0 !== s2.length) {
                    var c2 = w + ".g" + i2 + '[id="' + o2 + '"]', u2 = "";
                    void 0 !== a2 && a2.forEach(function(t5) {
                      t5.length > 0 && (u2 += t5 + ",");
                    }), r2 += "" + s2 + c2 + '{content:"' + u2 + '"}/*!sc*/\n';
                  }
                }
              }
              return r2;
            }(this);
          }, t3;
        }(), q = /(a)(d)/gi, X = function(t3) {
          return String.fromCharCode(t3 + (t3 > 25 ? 39 : 97));
        };
        function Y(t3) {
          var e2, n2 = "";
          for (e2 = Math.abs(t3); e2 > 52; e2 = e2 / 52 | 0) n2 = X(e2 % 52) + n2;
          return (X(e2 % 52) + n2).replace(q, "$1-$2");
        }
        var Z = function(t3, e2) {
          for (var n2 = e2.length; n2; ) t3 = 33 * t3 ^ e2.charCodeAt(--n2);
          return t3;
        }, J = function(t3) {
          return Z(5381, t3);
        };
        function $(t3) {
          for (var e2 = 0; e2 < t3.length; e2 += 1) {
            var n2 = t3[e2];
            if (y(n2) && !b(n2)) return false;
          }
          return true;
        }
        var Q = J("5.2.1"), K = function() {
          function t3(t4, e2, n2) {
            this.rules = t4, this.staticRulesId = "", this.isStatic = (void 0 === n2 || n2.isStatic) && $(t4), this.componentId = e2, this.baseHash = Z(Q, e2), this.baseStyle = n2, W.registerId(e2);
          }
          return t3.prototype.generateAndInjectStyles = function(t4, e2, n2) {
            var r2 = this.componentId, i2 = [];
            if (this.baseStyle && i2.push(this.baseStyle.generateAndInjectStyles(t4, e2, n2)), this.isStatic && !n2.hash) if (this.staticRulesId && e2.hasNameForId(r2, this.staticRulesId)) i2.push(this.staticRulesId);
            else {
              var o2 = yt(this.rules, t4, e2, n2).join(""), a2 = Y(Z(this.baseHash, o2.length) >>> 0);
              if (!e2.hasNameForId(r2, a2)) {
                var s2 = n2(o2, "." + a2, void 0, r2);
                e2.insertRules(r2, a2, s2);
              }
              i2.push(a2), this.staticRulesId = a2;
            }
            else {
              for (var c2 = this.rules.length, u2 = Z(this.baseHash, n2.hash), l2 = "", h2 = 0; h2 < c2; h2++) {
                var d2 = this.rules[h2];
                if ("string" == typeof d2) l2 += d2;
                else if (d2) {
                  var p2 = yt(d2, t4, e2, n2), f2 = Array.isArray(p2) ? p2.join("") : p2;
                  u2 = Z(u2, f2 + h2), l2 += f2;
                }
              }
              if (l2) {
                var m2 = Y(u2 >>> 0);
                if (!e2.hasNameForId(r2, m2)) {
                  var g2 = n2(l2, "." + m2, void 0, r2);
                  e2.insertRules(r2, m2, g2);
                }
                i2.push(m2);
              }
            }
            return i2.join(" ");
          }, t3;
        }(), tt = /^\s*\/\/.*$/gm, et = [":", "[", ".", "#"];
        function nt(t3) {
          var e2, n2, r2, i2, o2 = void 0 === t3 ? v : t3, a2 = o2.options, s2 = void 0 === a2 ? v : a2, u2 = o2.plugins, l2 = void 0 === u2 ? g : u2, h2 = new c.a(s2), d2 = [], p2 = /* @__PURE__ */ function(t4) {
            function e3(e4) {
              if (e4) try {
                t4(e4 + "}");
              } catch (t5) {
              }
            }
            return function(n3, r3, i3, o3, a3, s3, c2, u3, l3, h3) {
              switch (n3) {
                case 1:
                  if (0 === l3 && 64 === r3.charCodeAt(0)) return t4(r3 + ";"), "";
                  break;
                case 2:
                  if (0 === u3) return r3 + "/*|*/";
                  break;
                case 3:
                  switch (u3) {
                    case 102:
                    case 112:
                      return t4(i3[0] + r3), "";
                    default:
                      return r3 + (0 === h3 ? "/*|*/" : "");
                  }
                case -2:
                  r3.split("/*|*/}").forEach(e3);
              }
            };
          }(function(t4) {
            d2.push(t4);
          }), f2 = function(t4, r3, o3) {
            return 0 === r3 && et.includes(o3[n2.length]) || o3.match(i2) ? t4 : "." + e2;
          };
          function m2(t4, o3, a3, s3) {
            void 0 === s3 && (s3 = "&");
            var c2 = t4.replace(tt, ""), u3 = o3 && a3 ? a3 + " " + o3 + " { " + c2 + " }" : c2;
            return e2 = s3, n2 = o3, r2 = new RegExp("\\" + n2 + "\\b", "g"), i2 = new RegExp("(\\" + n2 + "\\b){2,}"), h2(a3 || !o3 ? "" : o3, u3);
          }
          return h2.use([].concat(l2, [function(t4, e3, i3) {
            2 === t4 && i3.length && i3[0].lastIndexOf(n2) > 0 && (i3[0] = i3[0].replace(r2, f2));
          }, p2, function(t4) {
            if (-2 === t4) {
              var e3 = d2;
              return d2 = [], e3;
            }
          }])), m2.hash = l2.length ? l2.reduce(function(t4, e3) {
            return e3.name || E(15), Z(t4, e3.name);
          }, 5381).toString() : "", m2;
        }
        var rt = o.a.createContext(), it = rt.Consumer, ot = o.a.createContext(), at = (ot.Consumer, new W()), st = nt();
        function ct() {
          return Object(i.useContext)(rt) || at;
        }
        function ut() {
          return Object(i.useContext)(ot) || st;
        }
        function lt(t3) {
          var e2 = Object(i.useState)(t3.stylisPlugins), n2 = e2[0], r2 = e2[1], a2 = ct(), c2 = Object(i.useMemo)(function() {
            var e3 = a2;
            return t3.sheet ? e3 = t3.sheet : t3.target && (e3 = e3.reconstructWithOptions({ target: t3.target }, false)), t3.disableCSSOMInjection && (e3 = e3.reconstructWithOptions({ useCSSOMInjection: false })), e3;
          }, [t3.disableCSSOMInjection, t3.sheet, t3.target]), u2 = Object(i.useMemo)(function() {
            return nt({ options: { prefix: !t3.disableVendorPrefixes }, plugins: n2 });
          }, [t3.disableVendorPrefixes, n2]);
          return Object(i.useEffect)(function() {
            s()(n2, t3.stylisPlugins) || r2(t3.stylisPlugins);
          }, [t3.stylisPlugins]), o.a.createElement(rt.Provider, { value: c2 }, o.a.createElement(ot.Provider, { value: u2 }, t3.children));
        }
        var ht = function() {
          function t3(t4, e2) {
            var n2 = this;
            this.inject = function(t5, e3) {
              void 0 === e3 && (e3 = st);
              var r2 = n2.name + e3.hash;
              t5.hasNameForId(n2.id, r2) || t5.insertRules(n2.id, r2, e3(n2.rules, r2, "@keyframes"));
            }, this.toString = function() {
              return E(12, String(n2.name));
            }, this.name = t4, this.id = "sc-keyframes-" + t4, this.rules = e2;
          }
          return t3.prototype.getName = function(t4) {
            return void 0 === t4 && (t4 = st), this.name + t4.hash;
          }, t3;
        }(), dt = /([A-Z])/, pt = /([A-Z])/g, ft = /^ms-/, mt = function(t3) {
          return "-" + t3.toLowerCase();
        };
        function gt(t3) {
          return dt.test(t3) ? t3.replace(pt, mt).replace(ft, "-ms-") : t3;
        }
        var vt = function(t3) {
          return null == t3 || false === t3 || "" === t3;
        };
        function yt(t3, e2, n2, r2) {
          if (Array.isArray(t3)) {
            for (var i2, o2 = [], a2 = 0, s2 = t3.length; a2 < s2; a2 += 1) "" !== (i2 = yt(t3[a2], e2, n2, r2)) && (Array.isArray(i2) ? o2.push.apply(o2, i2) : o2.push(i2));
            return o2;
          }
          return vt(t3) ? "" : b(t3) ? "." + t3.styledComponentId : y(t3) ? "function" != typeof (c2 = t3) || c2.prototype && c2.prototype.isReactComponent || !e2 ? t3 : yt(t3(e2), e2, n2, r2) : t3 instanceof ht ? n2 ? (t3.inject(n2, r2), t3.getName(r2)) : t3 : m(t3) ? function t4(e3, n3) {
            var r3, i3, o3 = [];
            for (var a3 in e3) e3.hasOwnProperty(a3) && !vt(e3[a3]) && (m(e3[a3]) ? o3.push.apply(o3, t4(e3[a3], a3)) : y(e3[a3]) ? o3.push(gt(a3) + ":", e3[a3], ";") : o3.push(gt(a3) + ": " + (r3 = a3, (null == (i3 = e3[a3]) || "boolean" == typeof i3 || "" === i3 ? "" : "number" != typeof i3 || 0 === i3 || r3 in u.a ? String(i3).trim() : i3 + "px") + ";")));
            return n3 ? [n3 + " {"].concat(o3, ["}"]) : o3;
          }(t3) : t3.toString();
          var c2;
        }
        function xt(t3) {
          for (var e2 = arguments.length, n2 = new Array(e2 > 1 ? e2 - 1 : 0), r2 = 1; r2 < e2; r2++) n2[r2 - 1] = arguments[r2];
          return y(t3) || m(t3) ? yt(f(g, [t3].concat(n2))) : 0 === n2.length && 1 === t3.length && "string" == typeof t3[0] ? t3 : yt(f(t3, n2));
        }
        /* @__PURE__ */ new Set();
        var bt = function(t3, e2, n2) {
          return void 0 === n2 && (n2 = v), t3.theme !== n2.theme && t3.theme || e2 || n2.theme;
        }, wt = /[!"#$%&'()*+,./:;<=>?@[\\\]^`{|}~-]+/g, _t = /(^-|-$)/g;
        function Mt(t3) {
          return t3.replace(wt, "-").replace(_t, "");
        }
        var St = function(t3) {
          return Y(J(t3) >>> 0);
        };
        function Tt(t3) {
          return "string" == typeof t3 && true;
        }
        var Et = function(t3) {
          return "function" == typeof t3 || "object" == typeof t3 && null !== t3 && !Array.isArray(t3);
        }, At = function(t3) {
          return "__proto__" !== t3 && "constructor" !== t3 && "prototype" !== t3;
        };
        function Ct(t3, e2, n2) {
          var r2 = t3[n2];
          Et(e2) && Et(r2) ? Lt(r2, e2) : t3[n2] = e2;
        }
        function Lt(t3) {
          for (var e2 = arguments.length, n2 = new Array(e2 > 1 ? e2 - 1 : 0), r2 = 1; r2 < e2; r2++) n2[r2 - 1] = arguments[r2];
          for (var i2 = 0, o2 = n2; i2 < o2.length; i2++) {
            var a2 = o2[i2];
            if (Et(a2)) for (var s2 in a2) At(s2) && Ct(t3, a2[s2], s2);
          }
          return t3;
        }
        var Pt = o.a.createContext(), Rt = Pt.Consumer;
        function Ot(t3) {
          var e2 = Object(i.useContext)(Pt), n2 = Object(i.useMemo)(function() {
            return function(t4, e3) {
              return t4 ? y(t4) ? t4(e3) : Array.isArray(t4) || "object" != typeof t4 ? E(8) : e3 ? p({}, e3, {}, t4) : t4 : E(14);
            }(t3.theme, e2);
          }, [t3.theme, e2]);
          return t3.children ? o.a.createElement(Pt.Provider, { value: n2 }, t3.children) : null;
        }
        var Dt = {};
        function It(t3, e2, n2) {
          var r2 = b(t3), a2 = !Tt(t3), s2 = e2.attrs, c2 = void 0 === s2 ? g : s2, u2 = e2.componentId, h2 = void 0 === u2 ? function(t4, e3) {
            var n3 = "string" != typeof t4 ? "sc" : Mt(t4);
            Dt[n3] = (Dt[n3] || 0) + 1;
            var r3 = n3 + "-" + St("5.2.1" + n3 + Dt[n3]);
            return e3 ? e3 + "-" + r3 : r3;
          }(e2.displayName, e2.parentComponentId) : u2, f2 = e2.displayName, m2 = void 0 === f2 ? function(t4) {
            return Tt(t4) ? "styled." + t4 : "Styled(" + x(t4) + ")";
          }(t3) : f2, w2 = e2.displayName && e2.componentId ? Mt(e2.displayName) + "-" + e2.componentId : e2.componentId || h2, _2 = r2 && t3.attrs ? Array.prototype.concat(t3.attrs, c2).filter(Boolean) : c2, M2 = e2.shouldForwardProp;
          r2 && t3.shouldForwardProp && (M2 = e2.shouldForwardProp ? function(n3, r3) {
            return t3.shouldForwardProp(n3, r3) && e2.shouldForwardProp(n3, r3);
          } : t3.shouldForwardProp);
          var S2, T2 = new K(n2, w2, r2 ? t3.componentStyle : void 0), E2 = T2.isStatic && 0 === c2.length, A2 = function(t4, e3) {
            return function(t5, e4, n3, r3) {
              var o2 = t5.attrs, a3 = t5.componentStyle, s3 = t5.defaultProps, c3 = t5.foldedComponentIds, u3 = t5.shouldForwardProp, h3 = t5.styledComponentId, d2 = t5.target, f3 = function(t6, e5, n4) {
                void 0 === t6 && (t6 = v);
                var r4 = p({}, e5, { theme: t6 }), i2 = {};
                return n4.forEach(function(t7) {
                  var e6, n5, o3, a4 = t7;
                  for (e6 in y(a4) && (a4 = a4(r4)), a4) r4[e6] = i2[e6] = "className" === e6 ? (n5 = i2[e6], o3 = a4[e6], n5 && o3 ? n5 + " " + o3 : n5 || o3) : a4[e6];
                }), [r4, i2];
              }(bt(e4, Object(i.useContext)(Pt), s3) || v, e4, o2), m3 = f3[0], g2 = f3[1], x2 = function(t6, e5, n4, r4) {
                var i2 = ct(), o3 = ut();
                return e5 ? t6.generateAndInjectStyles(v, i2, o3) : t6.generateAndInjectStyles(n4, i2, o3);
              }(a3, r3, m3), b2 = n3, w3 = g2.$as || e4.$as || g2.as || e4.as || d2, _3 = Tt(w3), M3 = g2 !== e4 ? p({}, e4, {}, g2) : e4, S3 = {};
              for (var T3 in M3) "$" !== T3[0] && "as" !== T3 && ("forwardedAs" === T3 ? S3.as = M3[T3] : (u3 ? u3(T3, l.a) : !_3 || Object(l.a)(T3)) && (S3[T3] = M3[T3]));
              return e4.style && g2.style !== e4.style && (S3.style = p({}, e4.style, {}, g2.style)), S3.className = Array.prototype.concat(c3, h3, x2 !== h3 ? x2 : null, e4.className, g2.className).filter(Boolean).join(" "), S3.ref = b2, Object(i.createElement)(w3, S3);
            }(S2, t4, e3, E2);
          };
          return A2.displayName = m2, (S2 = o.a.forwardRef(A2)).attrs = _2, S2.componentStyle = T2, S2.displayName = m2, S2.shouldForwardProp = M2, S2.foldedComponentIds = r2 ? Array.prototype.concat(t3.foldedComponentIds, t3.styledComponentId) : g, S2.styledComponentId = w2, S2.target = r2 ? t3.target : t3, S2.withComponent = function(t4) {
            var r3 = e2.componentId, i2 = function(t5, e3) {
              if (null == t5) return {};
              var n3, r4, i3 = {}, o3 = Object.keys(t5);
              for (r4 = 0; r4 < o3.length; r4++) n3 = o3[r4], e3.indexOf(n3) >= 0 || (i3[n3] = t5[n3]);
              return i3;
            }(e2, ["componentId"]), o2 = r3 && r3 + "-" + (Tt(t4) ? t4 : Mt(x(t4)));
            return It(t4, p({}, i2, { attrs: _2, componentId: o2 }), n2);
          }, Object.defineProperty(S2, "defaultProps", { get: function() {
            return this._foldedDefaultProps;
          }, set: function(e3) {
            this._foldedDefaultProps = r2 ? Lt({}, t3.defaultProps, e3) : e3;
          } }), S2.toString = function() {
            return "." + S2.styledComponentId;
          }, a2 && d()(S2, t3, { attrs: true, componentStyle: true, displayName: true, foldedComponentIds: true, shouldForwardProp: true, styledComponentId: true, target: true, withComponent: true }), S2;
        }
        var Nt = function(t3) {
          return function t4(e2, n2, i2) {
            if (void 0 === i2 && (i2 = v), !Object(r.isValidElementType)(n2)) return E(1, String(n2));
            var o2 = function() {
              return e2(n2, i2, xt.apply(void 0, arguments));
            };
            return o2.withConfig = function(r2) {
              return t4(e2, n2, p({}, i2, {}, r2));
            }, o2.attrs = function(r2) {
              return t4(e2, n2, p({}, i2, { attrs: Array.prototype.concat(i2.attrs, r2).filter(Boolean) }));
            }, o2;
          }(It, t3);
        };
        ["a", "abbr", "address", "area", "article", "aside", "audio", "b", "base", "bdi", "bdo", "big", "blockquote", "body", "br", "button", "canvas", "caption", "cite", "code", "col", "colgroup", "data", "datalist", "dd", "del", "details", "dfn", "dialog", "div", "dl", "dt", "em", "embed", "fieldset", "figcaption", "figure", "footer", "form", "h1", "h2", "h3", "h4", "h5", "h6", "head", "header", "hgroup", "hr", "html", "i", "iframe", "img", "input", "ins", "kbd", "keygen", "label", "legend", "li", "link", "main", "map", "mark", "marquee", "menu", "menuitem", "meta", "meter", "nav", "noscript", "object", "ol", "optgroup", "option", "output", "p", "param", "picture", "pre", "progress", "q", "rp", "rt", "ruby", "s", "samp", "script", "section", "select", "small", "source", "span", "strong", "style", "sub", "summary", "sup", "table", "tbody", "td", "textarea", "tfoot", "th", "thead", "time", "title", "tr", "track", "u", "ul", "var", "video", "wbr", "circle", "clipPath", "defs", "ellipse", "foreignObject", "g", "image", "line", "linearGradient", "marker", "mask", "path", "pattern", "polygon", "polyline", "radialGradient", "rect", "stop", "svg", "text", "tspan"].forEach(function(t3) {
          Nt[t3] = Nt(t3);
        });
        var zt = function() {
          function t3(t4, e3) {
            this.rules = t4, this.componentId = e3, this.isStatic = $(t4), W.registerId(this.componentId + 1);
          }
          var e2 = t3.prototype;
          return e2.createStyles = function(t4, e3, n2, r2) {
            var i2 = r2(yt(this.rules, e3, n2, r2).join(""), ""), o2 = this.componentId + t4;
            n2.insertRules(o2, o2, i2);
          }, e2.removeStyles = function(t4, e3) {
            e3.clearRules(this.componentId + t4);
          }, e2.renderStyles = function(t4, e3, n2, r2) {
            t4 > 2 && W.registerId(this.componentId + t4), this.removeStyles(t4, n2), this.createStyles(t4, e3, n2, r2);
          }, t3;
        }();
        function kt(t3) {
          for (var e2 = arguments.length, n2 = new Array(e2 > 1 ? e2 - 1 : 0), r2 = 1; r2 < e2; r2++) n2[r2 - 1] = arguments[r2];
          var a2 = xt.apply(void 0, [t3].concat(n2)), s2 = "sc-global-" + St(JSON.stringify(a2)), c2 = new zt(a2, s2);
          function u2(t4) {
            var e3 = ct(), n3 = ut(), r3 = Object(i.useContext)(Pt), o2 = Object(i.useRef)(e3.allocateGSInstance(s2)).current;
            return Object(i.useLayoutEffect)(function() {
              return l2(o2, t4, e3, r3, n3), function() {
                return c2.removeStyles(o2, e3);
              };
            }, [o2, t4, e3, r3, n3]), null;
          }
          function l2(t4, e3, n3, r3, i2) {
            if (c2.isStatic) c2.renderStyles(t4, T, n3, i2);
            else {
              var o2 = p({}, e3, { theme: bt(e3, r3, u2.defaultProps) });
              c2.renderStyles(t4, o2, n3, i2);
            }
          }
          return o.a.memo(u2);
        }
        function Ft(t3) {
          for (var e2 = arguments.length, n2 = new Array(e2 > 1 ? e2 - 1 : 0), r2 = 1; r2 < e2; r2++) n2[r2 - 1] = arguments[r2];
          var i2 = xt.apply(void 0, [t3].concat(n2)).join(""), o2 = St(i2);
          return new ht(o2, i2);
        }
        var Bt = function() {
          function t3() {
            var t4 = this;
            this._emitSheetCSS = function() {
              var e3 = t4.instance.toString(), n2 = F();
              return "<style " + [n2 && 'nonce="' + n2 + '"', w + '="true"', 'data-styled-version="5.2.1"'].filter(Boolean).join(" ") + ">" + e3 + "</style>";
            }, this.getStyleTags = function() {
              return t4.sealed ? E(2) : t4._emitSheetCSS();
            }, this.getStyleElement = function() {
              var e3;
              if (t4.sealed) return E(2);
              var n2 = ((e3 = {})[w] = "", e3["data-styled-version"] = "5.2.1", e3.dangerouslySetInnerHTML = { __html: t4.instance.toString() }, e3), r2 = F();
              return r2 && (n2.nonce = r2), [o.a.createElement("style", p({}, n2, { key: "sc-0-0" }))];
            }, this.seal = function() {
              t4.sealed = true;
            }, this.instance = new W({ isServer: true }), this.sealed = false;
          }
          var e2 = t3.prototype;
          return e2.collectStyles = function(t4) {
            return this.sealed ? E(2) : o.a.createElement(lt, { sheet: this.instance }, t4);
          }, e2.interleaveWithNodeStream = function(t4) {
            return E(3);
          }, t3;
        }(), Ht = function(t3) {
          var e2 = o.a.forwardRef(function(e3, n2) {
            var r2 = Object(i.useContext)(Pt), a2 = t3.defaultProps, s2 = bt(e3, r2, a2);
            return o.a.createElement(t3, p({}, e3, { theme: s2, ref: n2 }));
          });
          return d()(e2, t3), e2.displayName = "WithTheme(" + x(t3) + ")", e2;
        }, Gt = function() {
          return Object(i.useContext)(Pt);
        }, Ut = { StyleSheet: W, masterSheet: at };
        e.default = Nt;
      }).call(this, n(26));
    }, function(t, e, n) {
      var r;
      "undefined" != typeof self && self, t.exports = (r = n(0), function(t2) {
        function e2(r2) {
          if (n2[r2]) return n2[r2].exports;
          var i = n2[r2] = { i: r2, l: false, exports: {} };
          return t2[r2].call(i.exports, i, i.exports, e2), i.l = true, i.exports;
        }
        var n2 = {};
        return e2.m = t2, e2.c = n2, e2.d = function(t3, n3, r2) {
          e2.o(t3, n3) || Object.defineProperty(t3, n3, { configurable: false, enumerable: true, get: r2 });
        }, e2.n = function(t3) {
          var n3 = t3 && t3.__esModule ? function() {
            return t3.default;
          } : function() {
            return t3;
          };
          return e2.d(n3, "a", n3), n3;
        }, e2.o = function(t3, e3) {
          return Object.prototype.hasOwnProperty.call(t3, e3);
        }, e2.p = "", e2(e2.s = 7);
      }([function(t2, e2, n2) {
        "use strict";
        function r2(t3, e3) {
          return function(t4) {
            if (Array.isArray(t4)) return t4;
          }(t3) || function(t4, e4) {
            if ("undefined" != typeof Symbol && Symbol.iterator in Object(t4)) {
              var n3 = [], r3 = true, i2 = false, o2 = void 0;
              try {
                for (var a2, s2 = t4[Symbol.iterator](); !(r3 = (a2 = s2.next()).done) && (n3.push(a2.value), !e4 || n3.length !== e4); r3 = true) ;
              } catch (t5) {
                i2 = true, o2 = t5;
              } finally {
                try {
                  r3 || null == s2.return || s2.return();
                } finally {
                  if (i2) throw o2;
                }
              }
              return n3;
            }
          }(t3, e3) || function(t4, e4) {
            if (t4) {
              if ("string" == typeof t4) return i(t4, e4);
              var n3 = Object.prototype.toString.call(t4).slice(8, -1);
              return "Object" === n3 && t4.constructor && (n3 = t4.constructor.name), "Map" === n3 || "Set" === n3 ? Array.from(t4) : "Arguments" === n3 || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n3) ? i(t4, e4) : void 0;
            }
          }(t3, e3) || function() {
            throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
          }();
        }
        function i(t3, e3) {
          (null == e3 || e3 > t3.length) && (e3 = t3.length);
          for (var n3 = 0, r3 = new Array(e3); n3 < e3; n3++) r3[n3] = t3[n3];
          return r3;
        }
        var o = n2(1), a = n2.n(o), s = n2(8), c = n2.n(s), u = n2(2), l = n2(10), h = n2.n(l), d = n2(3), p = n2(6), f = function(t3) {
          if (!t3) return null;
          var e3 = Object.keys(t3);
          return 0 === e3.length ? null : e3.reduce(function(e4, n3) {
            return e4[Object(u.a)(n3)] = t3[n3], e4;
          }, {});
        }, m = function() {
          var t3 = a.a.useRef(false);
          return a.a.useEffect(function() {
            t3.current = true;
          }, []), t3.current;
        }, g = function(t3) {
          var e3 = function() {
            return function(t4) {
              return t4.query || Object(d.a)(t4);
            }(t3);
          }, n3 = r2(a.a.useState(e3), 2), i2 = n3[0], o2 = n3[1];
          return a.a.useEffect(function() {
            var t4 = e3();
            i2 !== t4 && o2(t4);
          }, [t3]), i2;
        };
        e2.a = function(t3, e3, n3) {
          var i2 = function(t4) {
            var e4 = a.a.useContext(p.a), n4 = function() {
              return f(t4) || f(e4);
            }, i3 = r2(a.a.useState(n4), 2), o3 = i3[0], s3 = i3[1];
            return a.a.useEffect(function() {
              var t5 = n4();
              h()(o3, t5) || s3(t5);
            }, [t4, e4]), o3;
          }(e3), o2 = g(t3);
          if (!o2) throw new Error("Invalid or missing MediaQuery!");
          var s2 = function(t4) {
            var e4 = r2(a.a.useState(t4.matches), 2), n4 = e4[0], i3 = e4[1];
            return a.a.useEffect(function() {
              var e5 = function() {
                i3(t4.matches);
              };
              return t4.addListener(e5), e5(), function() {
                t4.removeListener(e5);
              };
            }, [t4]), n4;
          }(function(t4, e4) {
            var n4 = function() {
              return c()(t4, e4 || {}, !!e4);
            }, i3 = r2(a.a.useState(n4), 2), o3 = i3[0], s3 = i3[1], u3 = m();
            return a.a.useEffect(function() {
              return u3 && s3(n4()), function() {
                o3.dispose();
              };
            }, [t4, e4]), o3;
          }(o2, i2)), u2 = m();
          return a.a.useEffect(function() {
            u2 && n3 && n3(s2);
          }, [s2]), s2;
        };
      }, function(t2, e2) {
        t2.exports = r;
      }, function(t2, e2, n2) {
        "use strict";
        function r2(t3) {
          return "-" + t3.toLowerCase();
        }
        var i = /[A-Z]/g, o = /^ms-/, a = {};
        e2.a = function(t3) {
          if (a.hasOwnProperty(t3)) return a[t3];
          var e3 = t3.replace(i, r2);
          return a[t3] = o.test(e3) ? "-" + e3 : e3;
        };
      }, function(t2, e2, n2) {
        "use strict";
        var r2 = n2(2), i = n2(11);
        e2.a = function(t3) {
          var e3 = [];
          return Object.keys(i.a.all).forEach(function(n3) {
            var i2 = t3[n3];
            null != i2 && e3.push(function(t4, e4) {
              var n4 = Object(r2.a)(t4);
              return "number" == typeof e4 && (e4 = "".concat(e4, "px")), true === e4 ? n4 : false === e4 ? "not ".concat(n4) : "(".concat(n4, ": ").concat(e4, ")");
            }(n3, i2));
          }), e3.join(" and ");
        };
      }, function(t2, e2, n2) {
        "use strict";
        t2.exports = n2(13);
      }, function(t2, e2, n2) {
        "use strict";
        t2.exports = "SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED";
      }, function(t2, e2, n2) {
        "use strict";
        var r2 = n2(1), i = n2.n(r2).a.createContext();
        e2.a = i;
      }, function(t2, e2, n2) {
        "use strict";
        Object.defineProperty(e2, "__esModule", { value: true });
        var r2 = n2(0), i = n2(17), o = n2(3), a = n2(6);
        n2.d(e2, "default", function() {
          return i.a;
        }), n2.d(e2, "useMediaQuery", function() {
          return r2.a;
        }), n2.d(e2, "toQuery", function() {
          return o.a;
        }), n2.d(e2, "Context", function() {
          return a.a;
        });
      }, function(t2, e2, n2) {
        "use strict";
        function r2(t3, e3, n3) {
          function r3(t4) {
            a.matches = t4.matches, a.media = t4.media;
          }
          var a = this;
          if (o && !n3) {
            var s = o.call(window, t3);
            this.matches = s.matches, this.media = s.media, s.addListener(r3);
          } else this.matches = i(t3, e3), this.media = t3;
          this.addListener = function(t4) {
            s && s.addListener(t4);
          }, this.removeListener = function(t4) {
            s && s.removeListener(t4);
          }, this.dispose = function() {
            s && s.removeListener(r3);
          };
        }
        var i = n2(9).match, o = "undefined" != typeof window ? window.matchMedia : null;
        t2.exports = function(t3, e3, n3) {
          return new r2(t3, e3, n3);
        };
      }, function(t2, e2, n2) {
        "use strict";
        function r2(t3) {
          return t3.split(",").map(function(t4) {
            var e3 = (t4 = t4.trim()).match(s), n3 = e3[1], r3 = e3[2], i2 = e3[3] || "", o2 = {};
            return o2.inverse = !!n3 && "not" === n3.toLowerCase(), o2.type = r3 ? r3.toLowerCase() : "all", i2 = i2.match(/\([^\)]+\)/g) || [], o2.expressions = i2.map(function(t5) {
              var e4 = t5.match(c), n4 = e4[1].toLowerCase().match(u);
              return { modifier: n4[1], feature: n4[2], value: e4[2] };
            }), o2;
          });
        }
        function i(t3) {
          var e3, n3 = Number(t3);
          return n3 || (n3 = (e3 = t3.match(/^(\d+)\s*\/\s*(\d+)$/))[1] / e3[2]), n3;
        }
        function o(t3) {
          var e3 = parseFloat(t3);
          switch (String(t3).match(h)[1]) {
            case "dpcm":
              return e3 / 2.54;
            case "dppx":
              return 96 * e3;
            default:
              return e3;
          }
        }
        function a(t3) {
          var e3 = parseFloat(t3);
          switch (String(t3).match(l)[1]) {
            case "em":
            case "rem":
              return 16 * e3;
            case "cm":
              return 96 * e3 / 2.54;
            case "mm":
              return 96 * e3 / 2.54 / 10;
            case "in":
              return 96 * e3;
            case "pt":
              return 72 * e3;
            case "pc":
              return 72 * e3 / 12;
            default:
              return e3;
          }
        }
        e2.match = function(t3, e3) {
          return r2(t3).some(function(t4) {
            var n3 = t4.inverse, r3 = "all" === t4.type || e3.type === t4.type;
            if (r3 && n3 || !r3 && !n3) return false;
            var s2 = t4.expressions.every(function(t5) {
              var n4 = t5.feature, r4 = t5.modifier, s3 = t5.value, c2 = e3[n4];
              if (!c2) return false;
              switch (n4) {
                case "orientation":
                case "scan":
                  return c2.toLowerCase() === s3.toLowerCase();
                case "width":
                case "height":
                case "device-width":
                case "device-height":
                  s3 = a(s3), c2 = a(c2);
                  break;
                case "resolution":
                  s3 = o(s3), c2 = o(c2);
                  break;
                case "aspect-ratio":
                case "device-aspect-ratio":
                case "device-pixel-ratio":
                  s3 = i(s3), c2 = i(c2);
                  break;
                case "grid":
                case "color":
                case "color-index":
                case "monochrome":
                  s3 = parseInt(s3, 10) || 1, c2 = parseInt(c2, 10) || 0;
              }
              switch (r4) {
                case "min":
                  return c2 >= s3;
                case "max":
                  return c2 <= s3;
                default:
                  return c2 === s3;
              }
            });
            return s2 && !n3 || !s2 && n3;
          });
        }, e2.parse = r2;
        var s = /(?:(only|not)?\s*([^\s\(\)]+)(?:\s*and)?\s*)?(.+)?/i, c = /\(\s*([^\s\:\)]+)\s*(?:\:\s*([^\s\)]+))?\s*\)/, u = /^(?:(min|max)-)?(.+)/, l = /(em|rem|px|cm|mm|in|pt|pc)?$/, h = /(dpi|dpcm|dppx)?$/;
      }, function(t2, e2, n2) {
        "use strict";
        t2.exports = function(t3, e3) {
          if (t3 === e3) return true;
          if (!t3 || !e3) return false;
          var n3 = Object.keys(t3), r2 = Object.keys(e3), i = n3.length;
          if (r2.length !== i) return false;
          for (var o = 0; o < i; o++) {
            var a = n3[o];
            if (t3[a] !== e3[a] || !Object.prototype.hasOwnProperty.call(e3, a)) return false;
          }
          return true;
        };
      }, function(t2, e2, n2) {
        "use strict";
        function r2(t3, e3) {
          var n3 = Object.keys(t3);
          if (Object.getOwnPropertySymbols) {
            var r3 = Object.getOwnPropertySymbols(t3);
            e3 && (r3 = r3.filter(function(e4) {
              return Object.getOwnPropertyDescriptor(t3, e4).enumerable;
            })), n3.push.apply(n3, r3);
          }
          return n3;
        }
        function i(t3) {
          for (var e3 = 1; e3 < arguments.length; e3++) {
            var n3 = null != arguments[e3] ? arguments[e3] : {};
            e3 % 2 ? r2(Object(n3), true).forEach(function(e4) {
              o(t3, e4, n3[e4]);
            }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(t3, Object.getOwnPropertyDescriptors(n3)) : r2(Object(n3)).forEach(function(e4) {
              Object.defineProperty(t3, e4, Object.getOwnPropertyDescriptor(n3, e4));
            });
          }
          return t3;
        }
        function o(t3, e3, n3) {
          return e3 in t3 ? Object.defineProperty(t3, e3, { value: n3, enumerable: true, configurable: true, writable: true }) : t3[e3] = n3, t3;
        }
        var a = n2(12), s = n2.n(a), c = s.a.oneOfType([s.a.string, s.a.number]), u = { orientation: s.a.oneOf(["portrait", "landscape"]), scan: s.a.oneOf(["progressive", "interlace"]), aspectRatio: s.a.string, deviceAspectRatio: s.a.string, height: c, deviceHeight: c, width: c, deviceWidth: c, color: s.a.bool, colorIndex: s.a.bool, monochrome: s.a.bool, resolution: c }, l = i({ minAspectRatio: s.a.string, maxAspectRatio: s.a.string, minDeviceAspectRatio: s.a.string, maxDeviceAspectRatio: s.a.string, minHeight: c, maxHeight: c, minDeviceHeight: c, maxDeviceHeight: c, minWidth: c, maxWidth: c, minDeviceWidth: c, maxDeviceWidth: c, minColor: s.a.number, maxColor: s.a.number, minColorIndex: s.a.number, maxColorIndex: s.a.number, minMonochrome: s.a.number, maxMonochrome: s.a.number, minResolution: c, maxResolution: c }, u), h = { all: s.a.bool, grid: s.a.bool, aural: s.a.bool, braille: s.a.bool, handheld: s.a.bool, print: s.a.bool, projection: s.a.bool, screen: s.a.bool, tty: s.a.bool, tv: s.a.bool, embossed: s.a.bool }, d = i(i({}, h), l);
        u.type = Object.keys(h), e2.a = { all: d, types: h, matchers: u, features: l };
      }, function(t2, e2, n2) {
        var r2 = n2(4);
        t2.exports = n2(14)(r2.isElement, true);
      }, function(t2, e2, n2) {
        "use strict";
        !function() {
          function t3(t4) {
            if ("object" == typeof t4 && null !== t4) {
              var e3 = t4.$$typeof;
              switch (e3) {
                case i:
                  var n4 = t4.type;
                  switch (n4) {
                    case h:
                    case d:
                    case a:
                    case c:
                    case s:
                    case f:
                      return n4;
                    default:
                      var r3 = n4 && n4.$$typeof;
                      switch (r3) {
                        case l:
                        case p:
                        case v:
                        case g:
                        case u:
                          return r3;
                        default:
                          return e3;
                      }
                  }
                case o:
                  return e3;
              }
            }
          }
          function n3(e3) {
            return t3(e3) === d;
          }
          var r2 = "function" == typeof Symbol && Symbol.for, i = r2 ? Symbol.for("react.element") : 60103, o = r2 ? Symbol.for("react.portal") : 60106, a = r2 ? Symbol.for("react.fragment") : 60107, s = r2 ? Symbol.for("react.strict_mode") : 60108, c = r2 ? Symbol.for("react.profiler") : 60114, u = r2 ? Symbol.for("react.provider") : 60109, l = r2 ? Symbol.for("react.context") : 60110, h = r2 ? Symbol.for("react.async_mode") : 60111, d = r2 ? Symbol.for("react.concurrent_mode") : 60111, p = r2 ? Symbol.for("react.forward_ref") : 60112, f = r2 ? Symbol.for("react.suspense") : 60113, m = r2 ? Symbol.for("react.suspense_list") : 60120, g = r2 ? Symbol.for("react.memo") : 60115, v = r2 ? Symbol.for("react.lazy") : 60116, y = r2 ? Symbol.for("react.block") : 60121, x = r2 ? Symbol.for("react.fundamental") : 60117, b = r2 ? Symbol.for("react.responder") : 60118, w = r2 ? Symbol.for("react.scope") : 60119, _ = h, M = d, S = l, T = u, E = i, A = p, C = a, L = v, P = g, R = o, O = c, D = s, I = f, N = false;
          e2.AsyncMode = _, e2.ConcurrentMode = M, e2.ContextConsumer = S, e2.ContextProvider = T, e2.Element = E, e2.ForwardRef = A, e2.Fragment = C, e2.Lazy = L, e2.Memo = P, e2.Portal = R, e2.Profiler = O, e2.StrictMode = D, e2.Suspense = I, e2.isAsyncMode = function(e3) {
            return N || (N = true, console.warn("The ReactIs.isAsyncMode() alias has been deprecated, and will be removed in React 17+. Update your code to use ReactIs.isConcurrentMode() instead. It has the exact same API.")), n3(e3) || t3(e3) === h;
          }, e2.isConcurrentMode = n3, e2.isContextConsumer = function(e3) {
            return t3(e3) === l;
          }, e2.isContextProvider = function(e3) {
            return t3(e3) === u;
          }, e2.isElement = function(t4) {
            return "object" == typeof t4 && null !== t4 && t4.$$typeof === i;
          }, e2.isForwardRef = function(e3) {
            return t3(e3) === p;
          }, e2.isFragment = function(e3) {
            return t3(e3) === a;
          }, e2.isLazy = function(e3) {
            return t3(e3) === v;
          }, e2.isMemo = function(e3) {
            return t3(e3) === g;
          }, e2.isPortal = function(e3) {
            return t3(e3) === o;
          }, e2.isProfiler = function(e3) {
            return t3(e3) === c;
          }, e2.isStrictMode = function(e3) {
            return t3(e3) === s;
          }, e2.isSuspense = function(e3) {
            return t3(e3) === f;
          }, e2.isValidElementType = function(t4) {
            return "string" == typeof t4 || "function" == typeof t4 || t4 === a || t4 === d || t4 === c || t4 === s || t4 === f || t4 === m || "object" == typeof t4 && null !== t4 && (t4.$$typeof === v || t4.$$typeof === g || t4.$$typeof === u || t4.$$typeof === l || t4.$$typeof === p || t4.$$typeof === x || t4.$$typeof === b || t4.$$typeof === w || t4.$$typeof === y);
          }, e2.typeOf = t3;
        }();
      }, function(t2, e2, n2) {
        "use strict";
        function r2() {
          return null;
        }
        var i, o = n2(4), a = n2(15), s = n2(5), c = n2(16), u = Function.call.bind(Object.prototype.hasOwnProperty);
        i = function(t3) {
          var e3 = "Warning: " + t3;
          "undefined" != typeof console && console.error(e3);
          try {
            throw new Error(e3);
          } catch (t4) {
          }
        }, t2.exports = function(t3, e3) {
          function n3(t4, e4) {
            return t4 === e4 ? 0 !== t4 || 1 / t4 == 1 / e4 : t4 != t4 && e4 != e4;
          }
          function l(t4) {
            this.message = t4, this.stack = "";
          }
          function h(t4) {
            function n4(n5, a3, c2, u2, h2, d2, p2) {
              if (u2 = u2 || x, d2 = d2 || c2, p2 !== s) {
                if (e3) {
                  var f2 = new Error("Calling PropTypes validators directly is not supported by the `prop-types` package. Use `PropTypes.checkPropTypes()` to call them. Read more at http://fb.me/use-check-prop-types");
                  throw f2.name = "Invariant Violation", f2;
                }
                if ("undefined" != typeof console) {
                  var m2 = u2 + ":" + c2;
                  !r3[m2] && o2 < 3 && (i("You are manually calling a React.PropTypes validation function for the `" + d2 + "` prop on `" + u2 + "`. This is deprecated and will throw in the standalone `prop-types` package. You may be seeing this warning due to a third-party PropTypes library. See https://fb.me/react-warning-dont-call-proptypes for details."), r3[m2] = true, o2++);
                }
              }
              return null == a3[c2] ? n5 ? new l(null === a3[c2] ? "The " + h2 + " `" + d2 + "` is marked as required in `" + u2 + "`, but its value is `null`." : "The " + h2 + " `" + d2 + "` is marked as required in `" + u2 + "`, but its value is `undefined`.") : null : t4(a3, c2, u2, h2, d2);
            }
            var r3 = {}, o2 = 0, a2 = n4.bind(null, false);
            return a2.isRequired = n4.bind(null, true), a2;
          }
          function d(t4) {
            return h(function(e4, n4, r3, i2, o2, a2) {
              var s2 = e4[n4];
              return f(s2) !== t4 ? new l("Invalid " + i2 + " `" + o2 + "` of type `" + m(s2) + "` supplied to `" + r3 + "`, expected `" + t4 + "`.") : null;
            });
          }
          function p(e4) {
            switch (typeof e4) {
              case "number":
              case "string":
              case "undefined":
                return true;
              case "boolean":
                return !e4;
              case "object":
                if (Array.isArray(e4)) return e4.every(p);
                if (null === e4 || t3(e4)) return true;
                var n4 = function(t4) {
                  var e5 = t4 && (v && t4[v] || t4[y]);
                  if ("function" == typeof e5) return e5;
                }(e4);
                if (!n4) return false;
                var r3, i2 = n4.call(e4);
                if (n4 !== e4.entries) {
                  for (; !(r3 = i2.next()).done; ) if (!p(r3.value)) return false;
                } else for (; !(r3 = i2.next()).done; ) {
                  var o2 = r3.value;
                  if (o2 && !p(o2[1])) return false;
                }
                return true;
              default:
                return false;
            }
          }
          function f(t4) {
            var e4 = typeof t4;
            return Array.isArray(t4) ? "array" : t4 instanceof RegExp ? "object" : function(t5, e5) {
              return "symbol" === t5 || !!e5 && ("Symbol" === e5["@@toStringTag"] || "function" == typeof Symbol && e5 instanceof Symbol);
            }(e4, t4) ? "symbol" : e4;
          }
          function m(t4) {
            if (null == t4) return "" + t4;
            var e4 = f(t4);
            if ("object" === e4) {
              if (t4 instanceof Date) return "date";
              if (t4 instanceof RegExp) return "regexp";
            }
            return e4;
          }
          function g(t4) {
            var e4 = m(t4);
            switch (e4) {
              case "array":
              case "object":
                return "an " + e4;
              case "boolean":
              case "date":
              case "regexp":
                return "a " + e4;
              default:
                return e4;
            }
          }
          var v = "function" == typeof Symbol && Symbol.iterator, y = "@@iterator", x = "<<anonymous>>", b = { array: d("array"), bool: d("boolean"), func: d("function"), number: d("number"), object: d("object"), string: d("string"), symbol: d("symbol"), any: h(r2), arrayOf: function(t4) {
            return h(function(e4, n4, r3, i2, o2) {
              if ("function" != typeof t4) return new l("Property `" + o2 + "` of component `" + r3 + "` has invalid PropType notation inside arrayOf.");
              var a2 = e4[n4];
              if (!Array.isArray(a2)) return new l("Invalid " + i2 + " `" + o2 + "` of type `" + f(a2) + "` supplied to `" + r3 + "`, expected an array.");
              for (var c2 = 0; c2 < a2.length; c2++) {
                var u2 = t4(a2, c2, r3, i2, o2 + "[" + c2 + "]", s);
                if (u2 instanceof Error) return u2;
              }
              return null;
            });
          }, element: h(function(e4, n4, r3, i2, o2) {
            var a2 = e4[n4];
            return t3(a2) ? null : new l("Invalid " + i2 + " `" + o2 + "` of type `" + f(a2) + "` supplied to `" + r3 + "`, expected a single ReactElement.");
          }), elementType: h(function(t4, e4, n4, r3, i2) {
            var a2 = t4[e4];
            return o.isValidElementType(a2) ? null : new l("Invalid " + r3 + " `" + i2 + "` of type `" + f(a2) + "` supplied to `" + n4 + "`, expected a single ReactElement type.");
          }), instanceOf: function(t4) {
            return h(function(e4, n4, r3, i2, o2) {
              if (!(e4[n4] instanceof t4)) {
                var a2 = t4.name || x;
                return new l("Invalid " + i2 + " `" + o2 + "` of type `" + ((s2 = e4[n4]).constructor && s2.constructor.name ? s2.constructor.name : x) + "` supplied to `" + r3 + "`, expected instance of `" + a2 + "`.");
              }
              var s2;
              return null;
            });
          }, node: h(function(t4, e4, n4, r3, i2) {
            return p(t4[e4]) ? null : new l("Invalid " + r3 + " `" + i2 + "` supplied to `" + n4 + "`, expected a ReactNode.");
          }), objectOf: function(t4) {
            return h(function(e4, n4, r3, i2, o2) {
              if ("function" != typeof t4) return new l("Property `" + o2 + "` of component `" + r3 + "` has invalid PropType notation inside objectOf.");
              var a2 = e4[n4], c2 = f(a2);
              if ("object" !== c2) return new l("Invalid " + i2 + " `" + o2 + "` of type `" + c2 + "` supplied to `" + r3 + "`, expected an object.");
              for (var h2 in a2) if (u(a2, h2)) {
                var d2 = t4(a2, h2, r3, i2, o2 + "." + h2, s);
                if (d2 instanceof Error) return d2;
              }
              return null;
            });
          }, oneOf: function(t4) {
            function e4(e5, r3, i2, o2, a2) {
              for (var s2 = e5[r3], c2 = 0; c2 < t4.length; c2++) if (n3(s2, t4[c2])) return null;
              var u2 = JSON.stringify(t4, function(t5, e6) {
                return "symbol" === m(e6) ? String(e6) : e6;
              });
              return new l("Invalid " + o2 + " `" + a2 + "` of value `" + String(s2) + "` supplied to `" + i2 + "`, expected one of " + u2 + ".");
            }
            return Array.isArray(t4) ? h(e4) : (i(arguments.length > 1 ? "Invalid arguments supplied to oneOf, expected an array, got " + arguments.length + " arguments. A common mistake is to write oneOf(x, y, z) instead of oneOf([x, y, z])." : "Invalid argument supplied to oneOf, expected an array."), r2);
          }, oneOfType: function(t4) {
            if (!Array.isArray(t4)) return i("Invalid argument supplied to oneOfType, expected an instance of array."), r2;
            for (var e4 = 0; e4 < t4.length; e4++) {
              var n4 = t4[e4];
              if ("function" != typeof n4) return i("Invalid argument supplied to oneOfType. Expected an array of check functions, but received " + g(n4) + " at index " + e4 + "."), r2;
            }
            return h(function(e5, n5, r3, i2, o2) {
              for (var a2 = 0; a2 < t4.length; a2++) if (null == (0, t4[a2])(e5, n5, r3, i2, o2, s)) return null;
              return new l("Invalid " + i2 + " `" + o2 + "` supplied to `" + r3 + "`.");
            });
          }, shape: function(t4) {
            return h(function(e4, n4, r3, i2, o2) {
              var a2 = e4[n4], c2 = f(a2);
              if ("object" !== c2) return new l("Invalid " + i2 + " `" + o2 + "` of type `" + c2 + "` supplied to `" + r3 + "`, expected `object`.");
              for (var u2 in t4) {
                var h2 = t4[u2];
                if (h2) {
                  var d2 = h2(a2, u2, r3, i2, o2 + "." + u2, s);
                  if (d2) return d2;
                }
              }
              return null;
            });
          }, exact: function(t4) {
            return h(function(e4, n4, r3, i2, o2) {
              var c2 = e4[n4], u2 = f(c2);
              if ("object" !== u2) return new l("Invalid " + i2 + " `" + o2 + "` of type `" + u2 + "` supplied to `" + r3 + "`, expected `object`.");
              var h2 = a({}, e4[n4], t4);
              for (var d2 in h2) {
                var p2 = t4[d2];
                if (!p2) return new l("Invalid " + i2 + " `" + o2 + "` key `" + d2 + "` supplied to `" + r3 + "`.\nBad object: " + JSON.stringify(e4[n4], null, "  ") + "\nValid keys: " + JSON.stringify(Object.keys(t4), null, "  "));
                var m2 = p2(c2, d2, r3, i2, o2 + "." + d2, s);
                if (m2) return m2;
              }
              return null;
            });
          } };
          return l.prototype = Error.prototype, b.checkPropTypes = c, b.resetWarningCache = c.resetWarningCache, b.PropTypes = b, b;
        };
      }, function(t2, e2, n2) {
        "use strict";
        function r2(t3) {
          if (null == t3) throw new TypeError("Object.assign cannot be called with null or undefined");
          return Object(t3);
        }
        var i = Object.getOwnPropertySymbols, o = Object.prototype.hasOwnProperty, a = Object.prototype.propertyIsEnumerable;
        t2.exports = function() {
          try {
            if (!Object.assign) return false;
            var t3 = new String("abc");
            if (t3[5] = "de", "5" === Object.getOwnPropertyNames(t3)[0]) return false;
            for (var e3 = {}, n3 = 0; n3 < 10; n3++) e3["_" + String.fromCharCode(n3)] = n3;
            if ("0123456789" !== Object.getOwnPropertyNames(e3).map(function(t4) {
              return e3[t4];
            }).join("")) return false;
            var r3 = {};
            return "abcdefghijklmnopqrst".split("").forEach(function(t4) {
              r3[t4] = t4;
            }), "abcdefghijklmnopqrst" === Object.keys(Object.assign({}, r3)).join("");
          } catch (t4) {
            return false;
          }
        }() ? Object.assign : function(t3, e3) {
          for (var n3, s, c = r2(t3), u = 1; u < arguments.length; u++) {
            for (var l in n3 = Object(arguments[u])) o.call(n3, l) && (c[l] = n3[l]);
            if (i) {
              s = i(n3);
              for (var h = 0; h < s.length; h++) a.call(n3, s[h]) && (c[s[h]] = n3[s[h]]);
            }
          }
          return c;
        };
      }, function(t2, e2, n2) {
        "use strict";
        function r2(t3, e3, n3, r3, c) {
          for (var u in t3) if (s(t3, u)) {
            var l;
            try {
              if ("function" != typeof t3[u]) {
                var h = Error((r3 || "React class") + ": " + n3 + " type `" + u + "` is invalid; it must be a function, usually from the `prop-types` package, but received `" + typeof t3[u] + "`.");
                throw h.name = "Invariant Violation", h;
              }
              l = t3[u](e3, u, r3, n3, null, o);
            } catch (t4) {
              l = t4;
            }
            if (!l || l instanceof Error || i((r3 || "React class") + ": type specification of " + n3 + " `" + u + "` is invalid; the type checker function must return `null` or an `Error` but returned a " + typeof l + ". You may have forgotten to pass an argument to the type checker creator (arrayOf, instanceOf, objectOf, oneOf, oneOfType, and shape all require an argument)."), l instanceof Error && !(l.message in a)) {
              a[l.message] = true;
              var d = c ? c() : "";
              i("Failed " + n3 + " type: " + l.message + (null != d ? d : ""));
            }
          }
        }
        var i = function() {
        }, o = n2(5), a = {}, s = Function.call.bind(Object.prototype.hasOwnProperty);
        i = function(t3) {
          var e3 = "Warning: " + t3;
          "undefined" != typeof console && console.error(e3);
          try {
            throw new Error(e3);
          } catch (t4) {
          }
        }, r2.resetWarningCache = function() {
          a = {};
        }, t2.exports = r2;
      }, function(t2, e2, n2) {
        "use strict";
        function r2(t3, e3) {
          if (null == t3) return {};
          var n3, r3, i2 = function(t4, e4) {
            if (null == t4) return {};
            var n4, r4, i3 = {}, o2 = Object.keys(t4);
            for (r4 = 0; r4 < o2.length; r4++) n4 = o2[r4], e4.indexOf(n4) >= 0 || (i3[n4] = t4[n4]);
            return i3;
          }(t3, e3);
          if (Object.getOwnPropertySymbols) {
            var o = Object.getOwnPropertySymbols(t3);
            for (r3 = 0; r3 < o.length; r3++) n3 = o[r3], e3.indexOf(n3) >= 0 || Object.prototype.propertyIsEnumerable.call(t3, n3) && (i2[n3] = t3[n3]);
          }
          return i2;
        }
        e2.a = function(t3) {
          var e3 = t3.children, n3 = t3.device, o = t3.onChange, a = r2(t3, ["children", "device", "onChange"]), s = Object(i.a)(a, n3, o);
          return "function" == typeof e3 ? e3(s) : s ? e3 : null;
        };
        var i = n2(0);
      }]));
    }, function(t, e, n) {
      var r, i;
      r = this, i = function() {
        var t2 = {};
        t2.TAU = 2 * Math.PI, t2.extend = function(t3, e3) {
          for (var n2 in e3) t3[n2] = e3[n2];
          return t3;
        }, t2.lerp = function(t3, e3, n2) {
          return (e3 - t3) * n2 + t3;
        }, t2.modulo = function(t3, e3) {
          return (t3 % e3 + e3) % e3;
        };
        var e2 = { 2: function(t3) {
          return t3 * t3;
        }, 3: function(t3) {
          return t3 * t3 * t3;
        }, 4: function(t3) {
          return t3 * t3 * t3 * t3;
        }, 5: function(t3) {
          return t3 * t3 * t3 * t3 * t3;
        } };
        return t2.easeInOut = function(t3, n2) {
          if (1 == n2) return t3;
          var r2 = (t3 = Math.max(0, Math.min(1, t3))) < 0.5, i2 = r2 ? t3 : 1 - t3, o = (e2[n2] || e2[2])(i2 /= 0.5);
          return o /= 2, r2 ? o : 1 - o;
        }, t2;
      }, t.exports ? t.exports = i() : r.Zdog = i();
    }, function(t, e, n) {
      !function(e2, r) {
        if (t.exports) t.exports = r(n(3), n(6), n(15), n(16));
        else {
          var i = e2.Zdog;
          i.Anchor = r(i, i.Vector, i.CanvasRenderer, i.SvgRenderer);
        }
      }(this, function(t2, e2, n2, r) {
        var i = t2.TAU, o = { x: 1, y: 1, z: 1 };
        function a(t3) {
          this.create(t3 || {});
        }
        return a.prototype.create = function(n3) {
          this.children = [], t2.extend(this, this.constructor.defaults), this.setOptions(n3), this.translate = new e2(n3.translate), this.rotate = new e2(n3.rotate), this.scale = new e2(o).multiply(this.scale), this.origin = new e2(), this.renderOrigin = new e2(), this.addTo && this.addTo.addChild(this);
        }, a.defaults = {}, a.optionKeys = Object.keys(a.defaults).concat(["rotate", "translate", "scale", "addTo"]), a.prototype.setOptions = function(t3) {
          var e3 = this.constructor.optionKeys;
          for (var n3 in t3) -1 != e3.indexOf(n3) && (this[n3] = t3[n3]);
        }, a.prototype.addChild = function(t3) {
          -1 == this.children.indexOf(t3) && (t3.remove(), t3.addTo = this, this.children.push(t3));
        }, a.prototype.removeChild = function(t3) {
          var e3 = this.children.indexOf(t3);
          -1 != e3 && this.children.splice(e3, 1);
        }, a.prototype.remove = function() {
          this.addTo && this.addTo.removeChild(this);
        }, a.prototype.update = function() {
          this.reset(), this.children.forEach(function(t3) {
            t3.update();
          }), this.transform(this.translate, this.rotate, this.scale);
        }, a.prototype.reset = function() {
          this.renderOrigin.set(this.origin);
        }, a.prototype.transform = function(t3, e3, n3) {
          this.renderOrigin.transform(t3, e3, n3), this.children.forEach(function(r2) {
            r2.transform(t3, e3, n3);
          });
        }, a.prototype.updateGraph = function() {
          this.update(), this.updateFlatGraph(), this.flatGraph.forEach(function(t3) {
            t3.updateSortValue();
          }), this.flatGraph.sort(a.shapeSorter);
        }, a.shapeSorter = function(t3, e3) {
          return t3.sortValue - e3.sortValue;
        }, Object.defineProperty(a.prototype, "flatGraph", { get: function() {
          return this._flatGraph || this.updateFlatGraph(), this._flatGraph;
        }, set: function(t3) {
          this._flatGraph = t3;
        } }), a.prototype.updateFlatGraph = function() {
          this.flatGraph = this.getFlatGraph();
        }, a.prototype.getFlatGraph = function() {
          var t3 = [this];
          return this.addChildFlatGraph(t3);
        }, a.prototype.addChildFlatGraph = function(t3) {
          return this.children.forEach(function(e3) {
            var n3 = e3.getFlatGraph();
            Array.prototype.push.apply(t3, n3);
          }), t3;
        }, a.prototype.updateSortValue = function() {
          this.sortValue = this.renderOrigin.z;
        }, a.prototype.render = function() {
        }, a.prototype.renderGraphCanvas = function(t3) {
          if (!t3) throw new Error("ctx is " + t3 + ". Canvas context required for render. Check .renderGraphCanvas( ctx ).");
          this.flatGraph.forEach(function(e3) {
            e3.render(t3, n2);
          });
        }, a.prototype.renderGraphSvg = function(t3) {
          if (!t3) throw new Error("svg is " + t3 + ". SVG required for render. Check .renderGraphSvg( svg ).");
          this.flatGraph.forEach(function(e3) {
            e3.render(t3, r);
          });
        }, a.prototype.copy = function(e3) {
          var n3 = {};
          return this.constructor.optionKeys.forEach(function(t3) {
            n3[t3] = this[t3];
          }, this), t2.extend(n3, e3), new (0, this.constructor)(n3);
        }, a.prototype.copyGraph = function(t3) {
          var e3 = this.copy(t3);
          return this.children.forEach(function(t4) {
            t4.copyGraph({ addTo: e3 });
          }), e3;
        }, a.prototype.normalizeRotate = function() {
          this.rotate.x = t2.modulo(this.rotate.x, i), this.rotate.y = t2.modulo(this.rotate.y, i), this.rotate.z = t2.modulo(this.rotate.z, i);
        }, a.subclass = /* @__PURE__ */ function e3(n3) {
          return function(r2) {
            function i2(t3) {
              this.create(t3 || {});
            }
            return i2.prototype = Object.create(n3.prototype), i2.prototype.constructor = i2, i2.defaults = t2.extend({}, n3.defaults), t2.extend(i2.defaults, r2), i2.optionKeys = n3.optionKeys.slice(0), Object.keys(i2.defaults).forEach(function(t3) {
              1 != !i2.optionKeys.indexOf(t3) && i2.optionKeys.push(t3);
            }), i2.subclass = e3(i2), i2;
          };
        }(a), a;
      });
    }, function(t, e, n) {
      !function(e2, r) {
        if (t.exports) t.exports = r(n(3), n(6), n(8), n(4));
        else {
          var i = e2.Zdog;
          i.Shape = r(i, i.Vector, i.PathCommand, i.Anchor);
        }
      }(this, function(t2, e2, n2, r) {
        var i = r.subclass({ stroke: 1, fill: false, color: "#333", closed: true, visible: true, path: [{}], front: { z: 1 }, backface: true });
        i.prototype.create = function(t3) {
          r.prototype.create.call(this, t3), this.updatePath(), this.front = new e2(t3.front || this.front), this.renderFront = new e2(this.front), this.renderNormal = new e2();
        };
        var o = ["move", "line", "bezier", "arc"];
        i.prototype.updatePath = function() {
          this.setPath(), this.updatePathCommands();
        }, i.prototype.setPath = function() {
        }, i.prototype.updatePathCommands = function() {
          var t3;
          this.pathCommands = this.path.map(function(e3, r2) {
            var i2 = Object.keys(e3), a2 = i2[0], s = e3[a2];
            1 == i2.length && -1 != o.indexOf(a2) || (a2 = "line", s = e3);
            var c = "line" == a2 || "move" == a2, u = Array.isArray(s);
            c && !u && (s = [s]);
            var l = new n2(a2 = 0 === r2 ? "move" : a2, s, t3);
            return t3 = l.endRenderPoint, l;
          });
        }, i.prototype.reset = function() {
          this.renderOrigin.set(this.origin), this.renderFront.set(this.front), this.pathCommands.forEach(function(t3) {
            t3.reset();
          });
        }, i.prototype.transform = function(t3, e3, n3) {
          this.renderOrigin.transform(t3, e3, n3), this.renderFront.transform(t3, e3, n3), this.renderNormal.set(this.renderOrigin).subtract(this.renderFront), this.pathCommands.forEach(function(r2) {
            r2.transform(t3, e3, n3);
          }), this.children.forEach(function(r2) {
            r2.transform(t3, e3, n3);
          });
        }, i.prototype.updateSortValue = function() {
          var t3 = this.pathCommands.length, e3 = this.pathCommands[0].endRenderPoint, n3 = this.pathCommands[t3 - 1].endRenderPoint;
          t3 > 2 && e3.isSame(n3) && (t3 -= 1);
          for (var r2 = 0, i2 = 0; i2 < t3; i2++) r2 += this.pathCommands[i2].endRenderPoint.z;
          this.sortValue = r2 / t3;
        }, i.prototype.render = function(t3, e3) {
          var n3 = this.pathCommands.length;
          if (this.visible && n3 && (this.isFacingBack = this.renderNormal.z > 0, this.backface || !this.isFacingBack)) {
            if (!e3) throw new Error("Zdog renderer required. Set to " + e3);
            var r2 = 1 == n3;
            e3.isCanvas && r2 ? this.renderCanvasDot(t3, e3) : this.renderPath(t3, e3);
          }
        };
        var a = t2.TAU;
        i.prototype.renderCanvasDot = function(t3) {
          var e3 = this.getLineWidth();
          if (e3) {
            t3.fillStyle = this.getRenderColor();
            var n3 = this.pathCommands[0].endRenderPoint;
            t3.beginPath();
            var r2 = e3 / 2;
            t3.arc(n3.x, n3.y, r2, 0, a), t3.fill();
          }
        }, i.prototype.getLineWidth = function() {
          return this.stroke ? 1 == this.stroke ? 1 : this.stroke : 0;
        }, i.prototype.getRenderColor = function() {
          return "string" == typeof this.backface && this.isFacingBack ? this.backface : this.color;
        }, i.prototype.renderPath = function(t3, e3) {
          var n3 = this.getRenderElement(t3, e3), r2 = !(2 == this.pathCommands.length && "line" == this.pathCommands[1].method) && this.closed, i2 = this.getRenderColor();
          e3.renderPath(t3, n3, this.pathCommands, r2), e3.stroke(t3, n3, this.stroke, i2, this.getLineWidth()), e3.fill(t3, n3, this.fill, i2), e3.end(t3, n3);
        };
        return i.prototype.getRenderElement = function(t3, e3) {
          if (e3.isSvg) return this.svgElement || (this.svgElement = document.createElementNS("http://www.w3.org/2000/svg", "path"), this.svgElement.setAttribute("stroke-linecap", "round"), this.svgElement.setAttribute("stroke-linejoin", "round")), this.svgElement;
        }, i;
      });
    }, function(t, e, n) {
      !function(e2, r) {
        if (t.exports) t.exports = r(n(3));
        else {
          var i = e2.Zdog;
          i.Vector = r(i);
        }
      }(this, function(t2) {
        function e2(t3) {
          this.set(t3);
        }
        var n2 = t2.TAU;
        function r(t3, e3, r2, i2) {
          if (e3 && e3 % n2 != 0) {
            var o = Math.cos(e3), a = Math.sin(e3), s = t3[r2], c = t3[i2];
            t3[r2] = s * o - c * a, t3[i2] = c * o + s * a;
          }
        }
        function i(t3) {
          return Math.abs(t3 - 1) < 1e-8 ? 1 : Math.sqrt(t3);
        }
        return e2.prototype.set = function(t3) {
          return this.x = t3 && t3.x || 0, this.y = t3 && t3.y || 0, this.z = t3 && t3.z || 0, this;
        }, e2.prototype.write = function(t3) {
          return t3 ? (this.x = null != t3.x ? t3.x : this.x, this.y = null != t3.y ? t3.y : this.y, this.z = null != t3.z ? t3.z : this.z, this) : this;
        }, e2.prototype.rotate = function(t3) {
          if (t3) return this.rotateZ(t3.z), this.rotateY(t3.y), this.rotateX(t3.x), this;
        }, e2.prototype.rotateZ = function(t3) {
          r(this, t3, "x", "y");
        }, e2.prototype.rotateX = function(t3) {
          r(this, t3, "y", "z");
        }, e2.prototype.rotateY = function(t3) {
          r(this, t3, "x", "z");
        }, e2.prototype.isSame = function(t3) {
          return !!t3 && (this.x === t3.x && this.y === t3.y && this.z === t3.z);
        }, e2.prototype.add = function(t3) {
          return t3 ? (this.x += t3.x || 0, this.y += t3.y || 0, this.z += t3.z || 0, this) : this;
        }, e2.prototype.subtract = function(t3) {
          return t3 ? (this.x -= t3.x || 0, this.y -= t3.y || 0, this.z -= t3.z || 0, this) : this;
        }, e2.prototype.multiply = function(t3) {
          return null == t3 || ("number" == typeof t3 ? (this.x *= t3, this.y *= t3, this.z *= t3) : (this.x *= null != t3.x ? t3.x : 1, this.y *= null != t3.y ? t3.y : 1, this.z *= null != t3.z ? t3.z : 1)), this;
        }, e2.prototype.transform = function(t3, e3, n3) {
          return this.multiply(n3), this.rotate(e3), this.add(t3), this;
        }, e2.prototype.lerp = function(e3, n3) {
          return this.x = t2.lerp(this.x, e3.x || 0, n3), this.y = t2.lerp(this.y, e3.y || 0, n3), this.z = t2.lerp(this.z, e3.z || 0, n3), this;
        }, e2.prototype.magnitude = function() {
          return i(this.x * this.x + this.y * this.y + this.z * this.z);
        }, e2.prototype.magnitude2d = function() {
          return i(this.x * this.x + this.y * this.y);
        }, e2.prototype.copy = function() {
          return new e2(this);
        }, e2;
      });
    }, function(t, e, n) {
      "use strict";
      function r(t2) {
        if (void 0 === t2) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
        return t2;
      }
      function i(t2, e2) {
        t2.prototype = Object.create(e2.prototype), t2.prototype.constructor = t2, t2.__proto__ = e2;
      }
      n.r(e), n.d(e, "gsap", function() {
        return qr;
      }), n.d(e, "default", function() {
        return qr;
      }), n.d(e, "CSSPlugin", function() {
        return Wr;
      }), n.d(e, "TweenMax", function() {
        return Xr;
      }), n.d(e, "TweenLite", function() {
        return $e;
      }), n.d(e, "TimelineMax", function() {
        return Ue;
      }), n.d(e, "TimelineLite", function() {
        return Ue;
      }), n.d(e, "Power0", function() {
        return Tn;
      }), n.d(e, "Power1", function() {
        return En;
      }), n.d(e, "Power2", function() {
        return An;
      }), n.d(e, "Power3", function() {
        return Cn;
      }), n.d(e, "Power4", function() {
        return Ln;
      }), n.d(e, "Linear", function() {
        return Pn;
      }), n.d(e, "Quad", function() {
        return Rn;
      }), n.d(e, "Cubic", function() {
        return On;
      }), n.d(e, "Quart", function() {
        return Dn;
      }), n.d(e, "Quint", function() {
        return In;
      }), n.d(e, "Strong", function() {
        return Nn;
      }), n.d(e, "Elastic", function() {
        return zn;
      }), n.d(e, "Back", function() {
        return kn;
      }), n.d(e, "SteppedEase", function() {
        return Fn;
      }), n.d(e, "Bounce", function() {
        return Bn;
      }), n.d(e, "Sine", function() {
        return Hn;
      }), n.d(e, "Expo", function() {
        return Gn;
      }), n.d(e, "Circ", function() {
        return Un;
      });
      var o, a, s, c, u, l, h, d, p, f, m, g, v, y, x, b, w, _, M, S, T, E, A, C, L, P, R, O, D = { autoSleep: 120, force3D: "auto", nullTargetWarn: 1, units: { lineHeight: "" } }, I = { duration: 0.5, overwrite: false, delay: 0 }, N = 1e8, z = 2 * Math.PI, k = z / 4, F = 0, B = Math.sqrt, H = Math.cos, G = Math.sin, U = function(t2) {
        return "string" == typeof t2;
      }, j = function(t2) {
        return "function" == typeof t2;
      }, V = function(t2) {
        return "number" == typeof t2;
      }, W = function(t2) {
        return void 0 === t2;
      }, q = function(t2) {
        return "object" == typeof t2;
      }, X = function(t2) {
        return false !== t2;
      }, Y = function() {
        return "undefined" != typeof window;
      }, Z = function(t2) {
        return j(t2) || U(t2);
      }, J = "function" == typeof ArrayBuffer && ArrayBuffer.isView || function() {
      }, $ = Array.isArray, Q = /(?:-?\.?\d|\.)+/gi, K = /[-+=.]*\d+[.e\-+]*\d*[e\-+]*\d*/g, tt = /[-+=.]*\d+[.e-]*\d*[a-z%]*/g, et = /[-+=.]*\d+\.?\d*(?:e-|e\+)?\d*/gi, nt = /[+-]=-?[.\d]+/, rt = /[#\-+.]*\b[a-z\d-=+%.]+/gi, it = /[\d.+\-=]+(?:e[-+]\d*)*/i, ot = {}, at = {}, st = function(t2) {
        return (at = Dt(t2, ot)) && gn;
      }, ct = function(t2, e2) {
        return console.warn("Invalid property", t2, "set to", e2, "Missing plugin? gsap.registerPlugin()");
      }, ut = function(t2, e2) {
        return !e2 && console.warn(t2);
      }, lt = function(t2, e2) {
        return t2 && (ot[t2] = e2) && at && (at[t2] = e2) || ot;
      }, ht = function() {
        return 0;
      }, dt = {}, pt = [], ft = {}, mt = {}, gt = {}, vt = 30, yt = [], xt = "", bt = function(t2) {
        var e2, n2, r2 = t2[0];
        if (q(r2) || j(r2) || (t2 = [t2]), !(e2 = (r2._gsap || {}).harness)) {
          for (n2 = yt.length; n2-- && !yt[n2].targetTest(r2); ) ;
          e2 = yt[n2];
        }
        for (n2 = t2.length; n2--; ) t2[n2] && (t2[n2]._gsap || (t2[n2]._gsap = new He(t2[n2], e2))) || t2.splice(n2, 1);
        return t2;
      }, wt = function(t2) {
        return t2._gsap || bt(ae(t2))[0]._gsap;
      }, _t = function(t2, e2, n2) {
        return (n2 = t2[e2]) && j(n2) ? t2[e2]() : W(n2) && t2.getAttribute && t2.getAttribute(e2) || n2;
      }, Mt = function(t2, e2) {
        return (t2 = t2.split(",")).forEach(e2) || t2;
      }, St = function(t2) {
        return Math.round(1e5 * t2) / 1e5 || 0;
      }, Tt = function(t2, e2) {
        for (var n2 = e2.length, r2 = 0; t2.indexOf(e2[r2]) < 0 && ++r2 < n2; ) ;
        return r2 < n2;
      }, Et = function(t2, e2, n2) {
        var r2, i2 = V(t2[1]), o2 = (i2 ? 2 : 1) + (e2 < 2 ? 0 : 1), a2 = t2[o2];
        if (i2 && (a2.duration = t2[1]), a2.parent = n2, e2) {
          for (r2 = a2; n2 && !("immediateRender" in r2); ) r2 = n2.vars.defaults || {}, n2 = X(n2.vars.inherit) && n2.parent;
          a2.immediateRender = X(r2.immediateRender), e2 < 2 ? a2.runBackwards = 1 : a2.startAt = t2[o2 - 1];
        }
        return a2;
      }, At = function() {
        var t2, e2, n2 = pt.length, r2 = pt.slice(0);
        for (ft = {}, pt.length = 0, t2 = 0; t2 < n2; t2++) (e2 = r2[t2]) && e2._lazy && (e2.render(e2._lazy[0], e2._lazy[1], true)._lazy = 0);
      }, Ct = function(t2, e2, n2, r2) {
        pt.length && At(), t2.render(e2, n2, r2), pt.length && At();
      }, Lt = function(t2) {
        var e2 = parseFloat(t2);
        return (e2 || 0 === e2) && (t2 + "").match(rt).length < 2 ? e2 : U(t2) ? t2.trim() : t2;
      }, Pt = function(t2) {
        return t2;
      }, Rt = function(t2, e2) {
        for (var n2 in e2) n2 in t2 || (t2[n2] = e2[n2]);
        return t2;
      }, Ot = function(t2, e2) {
        for (var n2 in e2) n2 in t2 || "duration" === n2 || "ease" === n2 || (t2[n2] = e2[n2]);
      }, Dt = function(t2, e2) {
        for (var n2 in e2) t2[n2] = e2[n2];
        return t2;
      }, It = function t2(e2, n2) {
        for (var r2 in n2) "__proto__" !== r2 && "constructor" !== r2 && "prototype" !== r2 && (e2[r2] = q(n2[r2]) ? t2(e2[r2] || (e2[r2] = {}), n2[r2]) : n2[r2]);
        return e2;
      }, Nt = function(t2, e2) {
        var n2, r2 = {};
        for (n2 in t2) n2 in e2 || (r2[n2] = t2[n2]);
        return r2;
      }, zt = function(t2) {
        var e2 = t2.parent || a, n2 = t2.keyframes ? Ot : Rt;
        if (X(t2.inherit)) for (; e2; ) n2(t2, e2.vars.defaults), e2 = e2.parent || e2._dp;
        return t2;
      }, kt = function(t2, e2, n2, r2) {
        void 0 === n2 && (n2 = "_first"), void 0 === r2 && (r2 = "_last");
        var i2 = e2._prev, o2 = e2._next;
        i2 ? i2._next = o2 : t2[n2] === e2 && (t2[n2] = o2), o2 ? o2._prev = i2 : t2[r2] === e2 && (t2[r2] = i2), e2._next = e2._prev = e2.parent = null;
      }, Ft = function(t2, e2) {
        t2.parent && (!e2 || t2.parent.autoRemoveChildren) && t2.parent.remove(t2), t2._act = 0;
      }, Bt = function(t2, e2) {
        if (t2 && (!e2 || e2._end > t2._dur || e2._start < 0)) for (var n2 = t2; n2; ) n2._dirty = 1, n2 = n2.parent;
        return t2;
      }, Ht = function(t2) {
        for (var e2 = t2.parent; e2 && e2.parent; ) e2._dirty = 1, e2.totalDuration(), e2 = e2.parent;
        return t2;
      }, Gt = function(t2) {
        return t2._repeat ? Ut(t2._tTime, t2 = t2.duration() + t2._rDelay) * t2 : 0;
      }, Ut = function(t2, e2) {
        var n2 = Math.floor(t2 /= e2);
        return t2 && n2 === t2 ? n2 - 1 : n2;
      }, jt = function(t2, e2) {
        return (t2 - e2._start) * e2._ts + (e2._ts >= 0 ? 0 : e2._dirty ? e2.totalDuration() : e2._tDur);
      }, Vt = function(t2) {
        return t2._end = St(t2._start + (t2._tDur / Math.abs(t2._ts || t2._rts || 1e-8) || 0));
      }, Wt = function(t2, e2) {
        var n2 = t2._dp;
        return n2 && n2.smoothChildTiming && t2._ts && (t2._start = St(n2._time - (t2._ts > 0 ? e2 / t2._ts : ((t2._dirty ? t2.totalDuration() : t2._tDur) - e2) / -t2._ts)), Vt(t2), n2._dirty || Bt(n2, t2)), t2;
      }, qt = function(t2, e2) {
        var n2;
        if ((e2._time || e2._initted && !e2._dur) && (n2 = jt(t2.rawTime(), e2), (!e2._dur || ee(0, e2.totalDuration(), n2) - e2._tTime > 1e-8) && e2.render(n2, true)), Bt(t2, e2)._dp && t2._initted && t2._time >= t2._dur && t2._ts) {
          if (t2._dur < t2.duration()) for (n2 = t2; n2._dp; ) n2.rawTime() >= 0 && n2.totalTime(n2._tTime), n2 = n2._dp;
          t2._zTime = -1e-8;
        }
      }, Xt = function(t2, e2, n2, r2) {
        return e2.parent && Ft(e2), e2._start = St(n2 + e2._delay), e2._end = St(e2._start + (e2.totalDuration() / Math.abs(e2.timeScale()) || 0)), function(t3, e3, n3, r3, i2) {
          void 0 === n3 && (n3 = "_first"), void 0 === r3 && (r3 = "_last");
          var o2, a2 = t3[r3];
          if (i2) for (o2 = e3[i2]; a2 && a2[i2] > o2; ) a2 = a2._prev;
          a2 ? (e3._next = a2._next, a2._next = e3) : (e3._next = t3[n3], t3[n3] = e3), e3._next ? e3._next._prev = e3 : t3[r3] = e3, e3._prev = a2, e3.parent = e3._dp = t3;
        }(t2, e2, "_first", "_last", t2._sort ? "_start" : 0), t2._recent = e2, r2 || qt(t2, e2), t2;
      }, Yt = function(t2, e2) {
        return (ot.ScrollTrigger || ct("scrollTrigger", e2)) && ot.ScrollTrigger.create(e2, t2);
      }, Zt = function(t2, e2, n2, r2) {
        return Xe(t2, e2), t2._initted ? !n2 && t2._pt && (t2._dur && false !== t2.vars.lazy || !t2._dur && t2.vars.lazy) && h !== Ae.frame ? (pt.push(t2), t2._lazy = [e2, r2], 1) : void 0 : 1;
      }, Jt = function(t2, e2, n2, r2) {
        var i2 = t2._repeat, o2 = St(e2) || 0, a2 = t2._tTime / t2._tDur;
        return a2 && !r2 && (t2._time *= o2 / t2._dur), t2._dur = o2, t2._tDur = i2 ? i2 < 0 ? 1e10 : St(o2 * (i2 + 1) + t2._rDelay * i2) : o2, a2 && !r2 ? Wt(t2, t2._tTime = t2._tDur * a2) : t2.parent && Vt(t2), n2 || Bt(t2.parent, t2), t2;
      }, $t = function(t2) {
        return t2 instanceof Ue ? Bt(t2) : Jt(t2, t2._dur);
      }, Qt = { _start: 0, endTime: ht }, Kt = function t2(e2, n2) {
        var r2, i2, o2 = e2.labels, a2 = e2._recent || Qt, s2 = e2.duration() >= N ? a2.endTime(false) : e2._dur;
        return U(n2) && (isNaN(n2) || n2 in o2) ? "<" === (r2 = n2.charAt(0)) || ">" === r2 ? ("<" === r2 ? a2._start : a2.endTime(a2._repeat >= 0)) + (parseFloat(n2.substr(1)) || 0) : (r2 = n2.indexOf("=")) < 0 ? (n2 in o2 || (o2[n2] = s2), o2[n2]) : (i2 = +(n2.charAt(r2 - 1) + n2.substr(r2 + 1)), r2 > 1 ? t2(e2, n2.substr(0, r2 - 1)) + i2 : s2 + i2) : null == n2 ? s2 : +n2;
      }, te = function(t2, e2) {
        return t2 || 0 === t2 ? e2(t2) : e2;
      }, ee = function(t2, e2, n2) {
        return n2 < t2 ? t2 : n2 > e2 ? e2 : n2;
      }, ne = function(t2) {
        if ("string" != typeof t2) return "";
        var e2 = it.exec(t2);
        return e2 ? t2.substr(e2.index + e2[0].length) : "";
      }, re = [].slice, ie = function(t2, e2) {
        return t2 && q(t2) && "length" in t2 && (!e2 && !t2.length || t2.length - 1 in t2 && q(t2[0])) && !t2.nodeType && t2 !== s;
      }, oe = function(t2, e2, n2) {
        return void 0 === n2 && (n2 = []), t2.forEach(function(t3) {
          var r2;
          return U(t3) && !e2 || ie(t3, 1) ? (r2 = n2).push.apply(r2, ae(t3)) : n2.push(t3);
        }) || n2;
      }, ae = function(t2, e2) {
        return !U(t2) || e2 || !c && Ce() ? $(t2) ? oe(t2, e2) : ie(t2) ? re.call(t2, 0) : t2 ? [t2] : [] : re.call(u.querySelectorAll(t2), 0);
      }, se = function(t2) {
        return t2.sort(function() {
          return 0.5 - Math.random();
        });
      }, ce = function(t2) {
        if (j(t2)) return t2;
        var e2 = q(t2) ? t2 : { each: t2 }, n2 = Ne(e2.ease), r2 = e2.from || 0, i2 = parseFloat(e2.base) || 0, o2 = {}, a2 = r2 > 0 && r2 < 1, s2 = isNaN(r2) || a2, c2 = e2.axis, u2 = r2, l2 = r2;
        return U(r2) ? u2 = l2 = { center: 0.5, edges: 0.5, end: 1 }[r2] || 0 : !a2 && s2 && (u2 = r2[0], l2 = r2[1]), function(t3, a3, h2) {
          var d2, p2, f2, m2, g2, v2, y2, x2, b2, w2 = (h2 || e2).length, _2 = o2[w2];
          if (!_2) {
            if (!(b2 = "auto" === e2.grid ? 0 : (e2.grid || [1, N])[1])) {
              for (y2 = -N; y2 < (y2 = h2[b2++].getBoundingClientRect().left) && b2 < w2; ) ;
              b2--;
            }
            for (_2 = o2[w2] = [], d2 = s2 ? Math.min(b2, w2) * u2 - 0.5 : r2 % b2, p2 = s2 ? w2 * l2 / b2 - 0.5 : r2 / b2 | 0, y2 = 0, x2 = N, v2 = 0; v2 < w2; v2++) f2 = v2 % b2 - d2, m2 = p2 - (v2 / b2 | 0), _2[v2] = g2 = c2 ? Math.abs("y" === c2 ? m2 : f2) : B(f2 * f2 + m2 * m2), g2 > y2 && (y2 = g2), g2 < x2 && (x2 = g2);
            "random" === r2 && se(_2), _2.max = y2 - x2, _2.min = x2, _2.v = w2 = (parseFloat(e2.amount) || parseFloat(e2.each) * (b2 > w2 ? w2 - 1 : c2 ? "y" === c2 ? w2 / b2 : b2 : Math.max(b2, w2 / b2)) || 0) * ("edges" === r2 ? -1 : 1), _2.b = w2 < 0 ? i2 - w2 : i2, _2.u = ne(e2.amount || e2.each) || 0, n2 = n2 && w2 < 0 ? De(n2) : n2;
          }
          return w2 = (_2[t3] - _2.min) / _2.max || 0, St(_2.b + (n2 ? n2(w2) : w2) * _2.v) + _2.u;
        };
      }, ue = function(t2) {
        var e2 = t2 < 1 ? Math.pow(10, (t2 + "").length - 2) : 1;
        return function(n2) {
          var r2 = Math.round(parseFloat(n2) / t2) * t2 * e2;
          return (r2 - r2 % 1) / e2 + (V(n2) ? 0 : ne(n2));
        };
      }, le = function(t2, e2) {
        var n2, r2, i2 = $(t2);
        return !i2 && q(t2) && (n2 = i2 = t2.radius || N, t2.values ? (t2 = ae(t2.values), (r2 = !V(t2[0])) && (n2 *= n2)) : t2 = ue(t2.increment)), te(e2, i2 ? j(t2) ? function(e3) {
          return r2 = t2(e3), Math.abs(r2 - e3) <= n2 ? r2 : e3;
        } : function(e3) {
          for (var i3, o2, a2 = parseFloat(r2 ? e3.x : e3), s2 = parseFloat(r2 ? e3.y : 0), c2 = N, u2 = 0, l2 = t2.length; l2--; ) (i3 = r2 ? (i3 = t2[l2].x - a2) * i3 + (o2 = t2[l2].y - s2) * o2 : Math.abs(t2[l2] - a2)) < c2 && (c2 = i3, u2 = l2);
          return u2 = !n2 || c2 <= n2 ? t2[u2] : e3, r2 || u2 === e3 || V(e3) ? u2 : u2 + ne(e3);
        } : ue(t2));
      }, he = function(t2, e2, n2, r2) {
        return te($(t2) ? !e2 : true === n2 ? !!(n2 = 0) : !r2, function() {
          return $(t2) ? t2[~~(Math.random() * t2.length)] : (n2 = n2 || 1e-5) && (r2 = n2 < 1 ? Math.pow(10, (n2 + "").length - 2) : 1) && Math.floor(Math.round((t2 - n2 / 2 + Math.random() * (e2 - t2 + 0.99 * n2)) / n2) * n2 * r2) / r2;
        });
      }, de = function(t2, e2, n2) {
        return te(n2, function(n3) {
          return t2[~~e2(n3)];
        });
      }, pe = function(t2) {
        for (var e2, n2, r2, i2, o2 = 0, a2 = ""; ~(e2 = t2.indexOf("random(", o2)); ) r2 = t2.indexOf(")", e2), i2 = "[" === t2.charAt(e2 + 7), n2 = t2.substr(e2 + 7, r2 - e2 - 7).match(i2 ? rt : Q), a2 += t2.substr(o2, e2 - o2) + he(i2 ? n2 : +n2[0], i2 ? 0 : +n2[1], +n2[2] || 1e-5), o2 = r2 + 1;
        return a2 + t2.substr(o2, t2.length - o2);
      }, fe = function(t2, e2, n2, r2, i2) {
        var o2 = e2 - t2, a2 = r2 - n2;
        return te(i2, function(e3) {
          return n2 + ((e3 - t2) / o2 * a2 || 0);
        });
      }, me = function(t2, e2, n2) {
        var r2, i2, o2, a2 = t2.labels, s2 = N;
        for (r2 in a2) (i2 = a2[r2] - e2) < 0 == !!n2 && i2 && s2 > (i2 = Math.abs(i2)) && (o2 = r2, s2 = i2);
        return o2;
      }, ge = function(t2, e2, n2) {
        var r2, i2, o2 = t2.vars, a2 = o2[e2];
        if (a2) return r2 = o2[e2 + "Params"], i2 = o2.callbackScope || t2, n2 && pt.length && At(), r2 ? a2.apply(i2, r2) : a2.call(i2);
      }, ve = function(t2) {
        return Ft(t2), t2.progress() < 1 && ge(t2, "onInterrupt"), t2;
      }, ye = function(t2) {
        var e2 = (t2 = !t2.name && t2.default || t2).name, n2 = j(t2), r2 = e2 && !n2 && t2.init ? function() {
          this._props = [];
        } : t2, i2 = { init: ht, render: sn, add: We, kill: un, modifier: cn, rawVars: 0 }, o2 = { targetTest: 0, get: 0, getSetter: nn, aliases: {}, register: 0 };
        if (Ce(), t2 !== r2) {
          if (mt[e2]) return;
          Rt(r2, Rt(Nt(t2, i2), o2)), Dt(r2.prototype, Dt(i2, Nt(t2, o2))), mt[r2.prop = e2] = r2, t2.targetTest && (yt.push(r2), dt[e2] = 1), e2 = ("css" === e2 ? "CSS" : e2.charAt(0).toUpperCase() + e2.substr(1)) + "Plugin";
        }
        lt(e2, r2), t2.register && t2.register(gn, r2, dn);
      }, xe = { aqua: [0, 255, 255], lime: [0, 255, 0], silver: [192, 192, 192], black: [0, 0, 0], maroon: [128, 0, 0], teal: [0, 128, 128], blue: [0, 0, 255], navy: [0, 0, 128], white: [255, 255, 255], olive: [128, 128, 0], yellow: [255, 255, 0], orange: [255, 165, 0], gray: [128, 128, 128], purple: [128, 0, 128], green: [0, 128, 0], red: [255, 0, 0], pink: [255, 192, 203], cyan: [0, 255, 255], transparent: [255, 255, 255, 0] }, be = function(t2, e2, n2) {
        return 255 * (6 * (t2 = t2 < 0 ? t2 + 1 : t2 > 1 ? t2 - 1 : t2) < 1 ? e2 + (n2 - e2) * t2 * 6 : t2 < 0.5 ? n2 : 3 * t2 < 2 ? e2 + (n2 - e2) * (2 / 3 - t2) * 6 : e2) + 0.5 | 0;
      }, we = function(t2, e2, n2) {
        var r2, i2, o2, a2, s2, c2, u2, l2, h2, d2, p2 = t2 ? V(t2) ? [t2 >> 16, t2 >> 8 & 255, 255 & t2] : 0 : xe.black;
        if (!p2) {
          if ("," === t2.substr(-1) && (t2 = t2.substr(0, t2.length - 1)), xe[t2]) p2 = xe[t2];
          else if ("#" === t2.charAt(0)) {
            if (t2.length < 6 && (r2 = t2.charAt(1), i2 = t2.charAt(2), o2 = t2.charAt(3), t2 = "#" + r2 + r2 + i2 + i2 + o2 + o2 + (5 === t2.length ? t2.charAt(4) + t2.charAt(4) : "")), 9 === t2.length) return [(p2 = parseInt(t2.substr(1, 6), 16)) >> 16, p2 >> 8 & 255, 255 & p2, parseInt(t2.substr(7), 16) / 255];
            p2 = [(t2 = parseInt(t2.substr(1), 16)) >> 16, t2 >> 8 & 255, 255 & t2];
          } else if ("hsl" === t2.substr(0, 3)) if (p2 = d2 = t2.match(Q), e2) {
            if (~t2.indexOf("=")) return p2 = t2.match(K), n2 && p2.length < 4 && (p2[3] = 1), p2;
          } else a2 = +p2[0] % 360 / 360, s2 = +p2[1] / 100, r2 = 2 * (c2 = +p2[2] / 100) - (i2 = c2 <= 0.5 ? c2 * (s2 + 1) : c2 + s2 - c2 * s2), p2.length > 3 && (p2[3] *= 1), p2[0] = be(a2 + 1 / 3, r2, i2), p2[1] = be(a2, r2, i2), p2[2] = be(a2 - 1 / 3, r2, i2);
          else p2 = t2.match(Q) || xe.transparent;
          p2 = p2.map(Number);
        }
        return e2 && !d2 && (r2 = p2[0] / 255, i2 = p2[1] / 255, o2 = p2[2] / 255, c2 = ((u2 = Math.max(r2, i2, o2)) + (l2 = Math.min(r2, i2, o2))) / 2, u2 === l2 ? a2 = s2 = 0 : (h2 = u2 - l2, s2 = c2 > 0.5 ? h2 / (2 - u2 - l2) : h2 / (u2 + l2), a2 = u2 === r2 ? (i2 - o2) / h2 + (i2 < o2 ? 6 : 0) : u2 === i2 ? (o2 - r2) / h2 + 2 : (r2 - i2) / h2 + 4, a2 *= 60), p2[0] = ~~(a2 + 0.5), p2[1] = ~~(100 * s2 + 0.5), p2[2] = ~~(100 * c2 + 0.5)), n2 && p2.length < 4 && (p2[3] = 1), p2;
      }, _e = function(t2) {
        var e2 = [], n2 = [], r2 = -1;
        return t2.split(Se).forEach(function(t3) {
          var i2 = t3.match(tt) || [];
          e2.push.apply(e2, i2), n2.push(r2 += i2.length + 1);
        }), e2.c = n2, e2;
      }, Me = function(t2, e2, n2) {
        var r2, i2, o2, a2, s2 = "", c2 = (t2 + s2).match(Se), u2 = e2 ? "hsla(" : "rgba(", l2 = 0;
        if (!c2) return t2;
        if (c2 = c2.map(function(t3) {
          return (t3 = we(t3, e2, 1)) && u2 + (e2 ? t3[0] + "," + t3[1] + "%," + t3[2] + "%," + t3[3] : t3.join(",")) + ")";
        }), n2 && (o2 = _e(t2), (r2 = n2.c).join(s2) !== o2.c.join(s2))) for (a2 = (i2 = t2.replace(Se, "1").split(tt)).length - 1; l2 < a2; l2++) s2 += i2[l2] + (~r2.indexOf(l2) ? c2.shift() || u2 + "0,0,0,0)" : (o2.length ? o2 : c2.length ? c2 : n2).shift());
        if (!i2) for (a2 = (i2 = t2.split(Se)).length - 1; l2 < a2; l2++) s2 += i2[l2] + c2[l2];
        return s2 + i2[a2];
      }, Se = function() {
        var t2, e2 = "(?:\\b(?:(?:rgb|rgba|hsl|hsla)\\(.+?\\))|\\B#(?:[0-9a-f]{3,4}){1,2}\\b";
        for (t2 in xe) e2 += "|" + t2 + "\\b";
        return new RegExp(e2 + ")", "gi");
      }(), Te = /hsl[a]?\(/, Ee = function(t2) {
        var e2, n2 = t2.join(" ");
        if (Se.lastIndex = 0, Se.test(n2)) return e2 = Te.test(n2), t2[1] = Me(t2[1], e2), t2[0] = Me(t2[0], e2, _e(t2[1])), true;
      }, Ae = (b = Date.now, w = 500, _ = 33, M = b(), S = M, E = T = 1e3 / 240, C = function t2(e2) {
        var n2, r2, i2, o2, a2 = b() - S, s2 = true === e2;
        if (a2 > w && (M += a2 - _), ((n2 = (i2 = (S += a2) - M) - E) > 0 || s2) && (o2 = ++v.frame, y = i2 - 1e3 * v.time, v.time = i2 /= 1e3, E += n2 + (n2 >= T ? 4 : T - n2), r2 = 1), s2 || (f = m(t2)), r2) for (x = 0; x < A.length; x++) A[x](i2, y, o2, e2);
      }, v = { time: 0, frame: 0, tick: function() {
        C(true);
      }, deltaRatio: function(t2) {
        return y / (1e3 / (t2 || 60));
      }, wake: function() {
        l && (!c && Y() && (s = c = window, u = s.document || {}, ot.gsap = gn, (s.gsapVersions || (s.gsapVersions = [])).push(gn.version), st(at || s.GreenSockGlobals || !s.gsap && s || {}), g = s.requestAnimationFrame), f && v.sleep(), m = g || function(t2) {
          return setTimeout(t2, E - 1e3 * v.time + 1 | 0);
        }, p = 1, C(2));
      }, sleep: function() {
        (g ? s.cancelAnimationFrame : clearTimeout)(f), p = 0, m = ht;
      }, lagSmoothing: function(t2, e2) {
        w = t2 || 1 / 1e-8, _ = Math.min(e2, w, 0);
      }, fps: function(t2) {
        T = 1e3 / (t2 || 240), E = 1e3 * v.time + T;
      }, add: function(t2) {
        A.indexOf(t2) < 0 && A.push(t2), Ce();
      }, remove: function(t2) {
        var e2;
        ~(e2 = A.indexOf(t2)) && A.splice(e2, 1) && x >= e2 && x--;
      }, _listeners: A = [] }), Ce = function() {
        return !p && Ae.wake();
      }, Le = {}, Pe = /^[\d.\-M][\d.\-,\s]/, Re = /["']/g, Oe = function(t2) {
        for (var e2, n2, r2, i2 = {}, o2 = t2.substr(1, t2.length - 3).split(":"), a2 = o2[0], s2 = 1, c2 = o2.length; s2 < c2; s2++) n2 = o2[s2], e2 = s2 !== c2 - 1 ? n2.lastIndexOf(",") : n2.length, r2 = n2.substr(0, e2), i2[a2] = isNaN(r2) ? r2.replace(Re, "").trim() : +r2, a2 = n2.substr(e2 + 1).trim();
        return i2;
      }, De = function(t2) {
        return function(e2) {
          return 1 - t2(1 - e2);
        };
      }, Ie = function t2(e2, n2) {
        for (var r2, i2 = e2._first; i2; ) i2 instanceof Ue ? t2(i2, n2) : !i2.vars.yoyoEase || i2._yoyo && i2._repeat || i2._yoyo === n2 || (i2.timeline ? t2(i2.timeline, n2) : (r2 = i2._ease, i2._ease = i2._yEase, i2._yEase = r2, i2._yoyo = n2)), i2 = i2._next;
      }, Ne = function(t2, e2) {
        return t2 && (j(t2) ? t2 : Le[t2] || function(t3) {
          var e3, n2, r2, i2, o2 = (t3 + "").split("("), a2 = Le[o2[0]];
          return a2 && o2.length > 1 && a2.config ? a2.config.apply(null, ~t3.indexOf("{") ? [Oe(o2[1])] : (e3 = t3, n2 = e3.indexOf("(") + 1, r2 = e3.indexOf(")"), i2 = e3.indexOf("(", n2), e3.substring(n2, ~i2 && i2 < r2 ? e3.indexOf(")", r2 + 1) : r2)).split(",").map(Lt)) : Le._CE && Pe.test(t3) ? Le._CE("", t3) : a2;
        }(t2)) || e2;
      }, ze = function(t2, e2, n2, r2) {
        void 0 === n2 && (n2 = function(t3) {
          return 1 - e2(1 - t3);
        }), void 0 === r2 && (r2 = function(t3) {
          return t3 < 0.5 ? e2(2 * t3) / 2 : 1 - e2(2 * (1 - t3)) / 2;
        });
        var i2, o2 = { easeIn: e2, easeOut: n2, easeInOut: r2 };
        return Mt(t2, function(t3) {
          for (var e3 in Le[t3] = ot[t3] = o2, Le[i2 = t3.toLowerCase()] = n2, o2) Le[i2 + ("easeIn" === e3 ? ".in" : "easeOut" === e3 ? ".out" : ".inOut")] = Le[t3 + "." + e3] = o2[e3];
        }), o2;
      }, ke = function(t2) {
        return function(e2) {
          return e2 < 0.5 ? (1 - t2(1 - 2 * e2)) / 2 : 0.5 + t2(2 * (e2 - 0.5)) / 2;
        };
      }, Fe = function t2(e2, n2, r2) {
        var i2 = n2 >= 1 ? n2 : 1, o2 = (r2 || (e2 ? 0.3 : 0.45)) / (n2 < 1 ? n2 : 1), a2 = o2 / z * (Math.asin(1 / i2) || 0), s2 = function(t3) {
          return 1 === t3 ? 1 : i2 * Math.pow(2, -10 * t3) * G((t3 - a2) * o2) + 1;
        }, c2 = "out" === e2 ? s2 : "in" === e2 ? function(t3) {
          return 1 - s2(1 - t3);
        } : ke(s2);
        return o2 = z / o2, c2.config = function(n3, r3) {
          return t2(e2, n3, r3);
        }, c2;
      }, Be = function t2(e2, n2) {
        void 0 === n2 && (n2 = 1.70158);
        var r2 = function(t3) {
          return t3 ? --t3 * t3 * ((n2 + 1) * t3 + n2) + 1 : 0;
        }, i2 = "out" === e2 ? r2 : "in" === e2 ? function(t3) {
          return 1 - r2(1 - t3);
        } : ke(r2);
        return i2.config = function(n3) {
          return t2(e2, n3);
        }, i2;
      };
      Mt("Linear,Quad,Cubic,Quart,Quint,Strong", function(t2, e2) {
        var n2 = e2 < 5 ? e2 + 1 : e2;
        ze(t2 + ",Power" + (n2 - 1), e2 ? function(t3) {
          return Math.pow(t3, n2);
        } : function(t3) {
          return t3;
        }, function(t3) {
          return 1 - Math.pow(1 - t3, n2);
        }, function(t3) {
          return t3 < 0.5 ? Math.pow(2 * t3, n2) / 2 : 1 - Math.pow(2 * (1 - t3), n2) / 2;
        });
      }), Le.Linear.easeNone = Le.none = Le.Linear.easeIn, ze("Elastic", Fe("in"), Fe("out"), Fe()), L = 7.5625, R = 1 / (P = 2.75), ze("Bounce", function(t2) {
        return 1 - O(1 - t2);
      }, O = function(t2) {
        return t2 < R ? L * t2 * t2 : t2 < 0.7272727272727273 ? L * Math.pow(t2 - 1.5 / P, 2) + 0.75 : t2 < 0.9090909090909092 ? L * (t2 -= 2.25 / P) * t2 + 0.9375 : L * Math.pow(t2 - 2.625 / P, 2) + 0.984375;
      }), ze("Expo", function(t2) {
        return t2 ? Math.pow(2, 10 * (t2 - 1)) : 0;
      }), ze("Circ", function(t2) {
        return -(B(1 - t2 * t2) - 1);
      }), ze("Sine", function(t2) {
        return 1 === t2 ? 1 : 1 - H(t2 * k);
      }), ze("Back", Be("in"), Be("out"), Be()), Le.SteppedEase = Le.steps = ot.SteppedEase = { config: function(t2, e2) {
        void 0 === t2 && (t2 = 1);
        var n2 = 1 / t2, r2 = t2 + (e2 ? 0 : 1), i2 = e2 ? 1 : 0;
        return function(t3) {
          return ((r2 * ee(0, 1 - 1e-8, t3) | 0) + i2) * n2;
        };
      } }, I.ease = Le["quad.out"], Mt("onComplete,onUpdate,onStart,onRepeat,onReverseComplete,onInterrupt", function(t2) {
        return xt += t2 + "," + t2 + "Params,";
      });
      var He = function(t2, e2) {
        this.id = F++, t2._gsap = this, this.target = t2, this.harness = e2, this.get = e2 ? e2.get : _t, this.set = e2 ? e2.getSetter : nn;
      }, Ge = function() {
        function t2(t3, e3) {
          var n2 = t3.parent || a;
          this.vars = t3, this._delay = +t3.delay || 0, (this._repeat = t3.repeat === 1 / 0 ? -2 : t3.repeat || 0) && (this._rDelay = t3.repeatDelay || 0, this._yoyo = !!t3.yoyo || !!t3.yoyoEase), this._ts = 1, Jt(this, +t3.duration, 1, 1), this.data = t3.data, p || Ae.wake(), n2 && Xt(n2, this, e3 || 0 === e3 ? e3 : n2._time, 1), t3.reversed && this.reverse(), t3.paused && this.paused(true);
        }
        var e2 = t2.prototype;
        return e2.delay = function(t3) {
          return t3 || 0 === t3 ? (this.parent && this.parent.smoothChildTiming && this.startTime(this._start + t3 - this._delay), this._delay = t3, this) : this._delay;
        }, e2.duration = function(t3) {
          return arguments.length ? this.totalDuration(this._repeat > 0 ? t3 + (t3 + this._rDelay) * this._repeat : t3) : this.totalDuration() && this._dur;
        }, e2.totalDuration = function(t3) {
          return arguments.length ? (this._dirty = 0, Jt(this, this._repeat < 0 ? t3 : (t3 - this._repeat * this._rDelay) / (this._repeat + 1))) : this._tDur;
        }, e2.totalTime = function(t3, e3) {
          if (Ce(), !arguments.length) return this._tTime;
          var n2 = this._dp;
          if (n2 && n2.smoothChildTiming && this._ts) {
            for (Wt(this, t3), !n2._dp || n2.parent || qt(n2, this); n2.parent; ) n2.parent._time !== n2._start + (n2._ts >= 0 ? n2._tTime / n2._ts : (n2.totalDuration() - n2._tTime) / -n2._ts) && n2.totalTime(n2._tTime, true), n2 = n2.parent;
            !this.parent && this._dp.autoRemoveChildren && (this._ts > 0 && t3 < this._tDur || this._ts < 0 && t3 > 0 || !this._tDur && !t3) && Xt(this._dp, this, this._start - this._delay);
          }
          return (this._tTime !== t3 || !this._dur && !e3 || this._initted && 1e-8 === Math.abs(this._zTime) || !t3 && !this._initted && (this.add || this._ptLookup)) && (this._ts || (this._pTime = t3), Ct(this, t3, e3)), this;
        }, e2.time = function(t3, e3) {
          return arguments.length ? this.totalTime(Math.min(this.totalDuration(), t3 + Gt(this)) % this._dur || (t3 ? this._dur : 0), e3) : this._time;
        }, e2.totalProgress = function(t3, e3) {
          return arguments.length ? this.totalTime(this.totalDuration() * t3, e3) : this.totalDuration() ? Math.min(1, this._tTime / this._tDur) : this.ratio;
        }, e2.progress = function(t3, e3) {
          return arguments.length ? this.totalTime(this.duration() * (!this._yoyo || 1 & this.iteration() ? t3 : 1 - t3) + Gt(this), e3) : this.duration() ? Math.min(1, this._time / this._dur) : this.ratio;
        }, e2.iteration = function(t3, e3) {
          var n2 = this.duration() + this._rDelay;
          return arguments.length ? this.totalTime(this._time + (t3 - 1) * n2, e3) : this._repeat ? Ut(this._tTime, n2) + 1 : 1;
        }, e2.timeScale = function(t3) {
          if (!arguments.length) return -1e-8 === this._rts ? 0 : this._rts;
          if (this._rts === t3) return this;
          var e3 = this.parent && this._ts ? jt(this.parent._time, this) : this._tTime;
          return this._rts = +t3 || 0, this._ts = this._ps || -1e-8 === t3 ? 0 : this._rts, Ht(this.totalTime(ee(-this._delay, this._tDur, e3), true));
        }, e2.paused = function(t3) {
          return arguments.length ? (this._ps !== t3 && (this._ps = t3, t3 ? (this._pTime = this._tTime || Math.max(-this._delay, this.rawTime()), this._ts = this._act = 0) : (Ce(), this._ts = this._rts, this.totalTime(this.parent && !this.parent.smoothChildTiming ? this.rawTime() : this._tTime || this._pTime, 1 === this.progress() && (this._tTime -= 1e-8) && 1e-8 !== Math.abs(this._zTime)))), this) : this._ps;
        }, e2.startTime = function(t3) {
          if (arguments.length) {
            this._start = t3;
            var e3 = this.parent || this._dp;
            return e3 && (e3._sort || !this.parent) && Xt(e3, this, t3 - this._delay), this;
          }
          return this._start;
        }, e2.endTime = function(t3) {
          return this._start + (X(t3) ? this.totalDuration() : this.duration()) / Math.abs(this._ts);
        }, e2.rawTime = function(t3) {
          var e3 = this.parent || this._dp;
          return e3 ? t3 && (!this._ts || this._repeat && this._time && this.totalProgress() < 1) ? this._tTime % (this._dur + this._rDelay) : this._ts ? jt(e3.rawTime(t3), this) : this._tTime : this._tTime;
        }, e2.globalTime = function(t3) {
          for (var e3 = this, n2 = arguments.length ? t3 : e3.rawTime(); e3; ) n2 = e3._start + n2 / (e3._ts || 1), e3 = e3._dp;
          return n2;
        }, e2.repeat = function(t3) {
          return arguments.length ? (this._repeat = t3 === 1 / 0 ? -2 : t3, $t(this)) : -2 === this._repeat ? 1 / 0 : this._repeat;
        }, e2.repeatDelay = function(t3) {
          return arguments.length ? (this._rDelay = t3, $t(this)) : this._rDelay;
        }, e2.yoyo = function(t3) {
          return arguments.length ? (this._yoyo = t3, this) : this._yoyo;
        }, e2.seek = function(t3, e3) {
          return this.totalTime(Kt(this, t3), X(e3));
        }, e2.restart = function(t3, e3) {
          return this.play().totalTime(t3 ? -this._delay : 0, X(e3));
        }, e2.play = function(t3, e3) {
          return null != t3 && this.seek(t3, e3), this.reversed(false).paused(false);
        }, e2.reverse = function(t3, e3) {
          return null != t3 && this.seek(t3 || this.totalDuration(), e3), this.reversed(true).paused(false);
        }, e2.pause = function(t3, e3) {
          return null != t3 && this.seek(t3, e3), this.paused(true);
        }, e2.resume = function() {
          return this.paused(false);
        }, e2.reversed = function(t3) {
          return arguments.length ? (!!t3 !== this.reversed() && this.timeScale(-this._rts || (t3 ? -1e-8 : 0)), this) : this._rts < 0;
        }, e2.invalidate = function() {
          return this._initted = this._act = 0, this._zTime = -1e-8, this;
        }, e2.isActive = function() {
          var t3, e3 = this.parent || this._dp, n2 = this._start;
          return !(e3 && !(this._ts && this._initted && e3.isActive() && (t3 = e3.rawTime(true)) >= n2 && t3 < this.endTime(true) - 1e-8));
        }, e2.eventCallback = function(t3, e3, n2) {
          var r2 = this.vars;
          return arguments.length > 1 ? (e3 ? (r2[t3] = e3, n2 && (r2[t3 + "Params"] = n2), "onUpdate" === t3 && (this._onUpdate = e3)) : delete r2[t3], this) : r2[t3];
        }, e2.then = function(t3) {
          var e3 = this;
          return new Promise(function(n2) {
            var r2 = j(t3) ? t3 : Pt, i2 = function() {
              var t4 = e3.then;
              e3.then = null, j(r2) && (r2 = r2(e3)) && (r2.then || r2 === e3) && (e3.then = t4), n2(r2), e3.then = t4;
            };
            e3._initted && 1 === e3.totalProgress() && e3._ts >= 0 || !e3._tTime && e3._ts < 0 ? i2() : e3._prom = i2;
          });
        }, e2.kill = function() {
          ve(this);
        }, t2;
      }();
      Rt(Ge.prototype, { _time: 0, _start: 0, _end: 0, _tTime: 0, _tDur: 0, _dirty: 0, _repeat: 0, _yoyo: false, parent: null, _initted: false, _rDelay: 0, _ts: 1, _dp: 0, ratio: 0, _zTime: -1e-8, _prom: 0, _ps: false, _rts: 1 });
      var Ue = function(t2) {
        function e2(e3, n3) {
          var i2;
          return void 0 === e3 && (e3 = {}), (i2 = t2.call(this, e3, n3) || this).labels = {}, i2.smoothChildTiming = !!e3.smoothChildTiming, i2.autoRemoveChildren = !!e3.autoRemoveChildren, i2._sort = X(e3.sortChildren), i2.parent && qt(i2.parent, r(i2)), e3.scrollTrigger && Yt(r(i2), e3.scrollTrigger), i2;
        }
        i(e2, t2);
        var n2 = e2.prototype;
        return n2.to = function(t3, e3, n3) {
          return new $e(t3, Et(arguments, 0, this), Kt(this, V(e3) ? arguments[3] : n3)), this;
        }, n2.from = function(t3, e3, n3) {
          return new $e(t3, Et(arguments, 1, this), Kt(this, V(e3) ? arguments[3] : n3)), this;
        }, n2.fromTo = function(t3, e3, n3, r2) {
          return new $e(t3, Et(arguments, 2, this), Kt(this, V(e3) ? arguments[4] : r2)), this;
        }, n2.set = function(t3, e3, n3) {
          return e3.duration = 0, e3.parent = this, zt(e3).repeatDelay || (e3.repeat = 0), e3.immediateRender = !!e3.immediateRender, new $e(t3, e3, Kt(this, n3), 1), this;
        }, n2.call = function(t3, e3, n3) {
          return Xt(this, $e.delayedCall(0, t3, e3), Kt(this, n3));
        }, n2.staggerTo = function(t3, e3, n3, r2, i2, o2, a2) {
          return n3.duration = e3, n3.stagger = n3.stagger || r2, n3.onComplete = o2, n3.onCompleteParams = a2, n3.parent = this, new $e(t3, n3, Kt(this, i2)), this;
        }, n2.staggerFrom = function(t3, e3, n3, r2, i2, o2, a2) {
          return n3.runBackwards = 1, zt(n3).immediateRender = X(n3.immediateRender), this.staggerTo(t3, e3, n3, r2, i2, o2, a2);
        }, n2.staggerFromTo = function(t3, e3, n3, r2, i2, o2, a2, s2) {
          return r2.startAt = n3, zt(r2).immediateRender = X(r2.immediateRender), this.staggerTo(t3, e3, r2, i2, o2, a2, s2);
        }, n2.render = function(t3, e3, n3) {
          var r2, i2, o2, s2, c2, u2, l2, h2, d2, p2, f2, m2, g2 = this._time, v2 = this._dirty ? this.totalDuration() : this._tDur, y2 = this._dur, x2 = this !== a && t3 > v2 - 1e-8 && t3 >= 0 ? v2 : t3 < 1e-8 ? 0 : t3, b2 = this._zTime < 0 != t3 < 0 && (this._initted || !y2);
          if (x2 !== this._tTime || n3 || b2) {
            if (g2 !== this._time && y2 && (x2 += this._time - g2, t3 += this._time - g2), r2 = x2, d2 = this._start, u2 = !(h2 = this._ts), b2 && (y2 || (g2 = this._zTime), (t3 || !e3) && (this._zTime = t3)), this._repeat) {
              if (f2 = this._yoyo, c2 = y2 + this._rDelay, this._repeat < -1 && t3 < 0) return this.totalTime(100 * c2 + t3, e3, n3);
              if (r2 = St(x2 % c2), x2 === v2 ? (s2 = this._repeat, r2 = y2) : ((s2 = ~~(x2 / c2)) && s2 === x2 / c2 && (r2 = y2, s2--), r2 > y2 && (r2 = y2)), p2 = Ut(this._tTime, c2), !g2 && this._tTime && p2 !== s2 && (p2 = s2), f2 && 1 & s2 && (r2 = y2 - r2, m2 = 1), s2 !== p2 && !this._lock) {
                var w2 = f2 && 1 & p2, _2 = w2 === (f2 && 1 & s2);
                if (s2 < p2 && (w2 = !w2), g2 = w2 ? 0 : y2, this._lock = 1, this.render(g2 || (m2 ? 0 : St(s2 * c2)), e3, !y2)._lock = 0, !e3 && this.parent && ge(this, "onRepeat"), this.vars.repeatRefresh && !m2 && (this.invalidate()._lock = 1), g2 !== this._time || u2 !== !this._ts) return this;
                if (y2 = this._dur, v2 = this._tDur, _2 && (this._lock = 2, g2 = w2 ? y2 : -1e-4, this.render(g2, true), this.vars.repeatRefresh && !m2 && this.invalidate()), this._lock = 0, !this._ts && !u2) return this;
                Ie(this, m2);
              }
            }
            if (this._hasPause && !this._forcing && this._lock < 2 && (l2 = function(t4, e4, n4) {
              var r3;
              if (n4 > e4) for (r3 = t4._first; r3 && r3._start <= n4; ) {
                if (!r3._dur && "isPause" === r3.data && r3._start > e4) return r3;
                r3 = r3._next;
              }
              else for (r3 = t4._last; r3 && r3._start >= n4; ) {
                if (!r3._dur && "isPause" === r3.data && r3._start < e4) return r3;
                r3 = r3._prev;
              }
            }(this, St(g2), St(r2))) && (x2 -= r2 - (r2 = l2._start)), this._tTime = x2, this._time = r2, this._act = !h2, this._initted || (this._onUpdate = this.vars.onUpdate, this._initted = 1, this._zTime = t3, g2 = 0), !g2 && (r2 || !y2 && t3 >= 0) && !e3 && ge(this, "onStart"), r2 >= g2 && t3 >= 0) for (i2 = this._first; i2; ) {
              if (o2 = i2._next, (i2._act || r2 >= i2._start) && i2._ts && l2 !== i2) {
                if (i2.parent !== this) return this.render(t3, e3, n3);
                if (i2.render(i2._ts > 0 ? (r2 - i2._start) * i2._ts : (i2._dirty ? i2.totalDuration() : i2._tDur) + (r2 - i2._start) * i2._ts, e3, n3), r2 !== this._time || !this._ts && !u2) {
                  l2 = 0, o2 && (x2 += this._zTime = -1e-8);
                  break;
                }
              }
              i2 = o2;
            }
            else {
              i2 = this._last;
              for (var M2 = t3 < 0 ? t3 : r2; i2; ) {
                if (o2 = i2._prev, (i2._act || M2 <= i2._end) && i2._ts && l2 !== i2) {
                  if (i2.parent !== this) return this.render(t3, e3, n3);
                  if (i2.render(i2._ts > 0 ? (M2 - i2._start) * i2._ts : (i2._dirty ? i2.totalDuration() : i2._tDur) + (M2 - i2._start) * i2._ts, e3, n3), r2 !== this._time || !this._ts && !u2) {
                    l2 = 0, o2 && (x2 += this._zTime = M2 ? -1e-8 : 1e-8);
                    break;
                  }
                }
                i2 = o2;
              }
            }
            if (l2 && !e3 && (this.pause(), l2.render(r2 >= g2 ? 0 : -1e-8)._zTime = r2 >= g2 ? 1 : -1, this._ts)) return this._start = d2, Vt(this), this.render(t3, e3, n3);
            this._onUpdate && !e3 && ge(this, "onUpdate", true), (x2 === v2 && v2 >= this.totalDuration() || !x2 && g2) && (d2 !== this._start && Math.abs(h2) === Math.abs(this._ts) || this._lock || ((t3 || !y2) && (x2 === v2 && this._ts > 0 || !x2 && this._ts < 0) && Ft(this, 1), e3 || t3 < 0 && !g2 || !x2 && !g2 || (ge(this, x2 === v2 ? "onComplete" : "onReverseComplete", true), this._prom && !(x2 < v2 && this.timeScale() > 0) && this._prom())));
          }
          return this;
        }, n2.add = function(t3, e3) {
          var n3 = this;
          if (V(e3) || (e3 = Kt(this, e3)), !(t3 instanceof Ge)) {
            if ($(t3)) return t3.forEach(function(t4) {
              return n3.add(t4, e3);
            }), this;
            if (U(t3)) return this.addLabel(t3, e3);
            if (!j(t3)) return this;
            t3 = $e.delayedCall(0, t3);
          }
          return this !== t3 ? Xt(this, t3, e3) : this;
        }, n2.getChildren = function(t3, e3, n3, r2) {
          void 0 === t3 && (t3 = true), void 0 === e3 && (e3 = true), void 0 === n3 && (n3 = true), void 0 === r2 && (r2 = -N);
          for (var i2 = [], o2 = this._first; o2; ) o2._start >= r2 && (o2 instanceof $e ? e3 && i2.push(o2) : (n3 && i2.push(o2), t3 && i2.push.apply(i2, o2.getChildren(true, e3, n3)))), o2 = o2._next;
          return i2;
        }, n2.getById = function(t3) {
          for (var e3 = this.getChildren(1, 1, 1), n3 = e3.length; n3--; ) if (e3[n3].vars.id === t3) return e3[n3];
        }, n2.remove = function(t3) {
          return U(t3) ? this.removeLabel(t3) : j(t3) ? this.killTweensOf(t3) : (kt(this, t3), t3 === this._recent && (this._recent = this._last), Bt(this));
        }, n2.totalTime = function(e3, n3) {
          return arguments.length ? (this._forcing = 1, !this._dp && this._ts && (this._start = St(Ae.time - (this._ts > 0 ? e3 / this._ts : (this.totalDuration() - e3) / -this._ts))), t2.prototype.totalTime.call(this, e3, n3), this._forcing = 0, this) : this._tTime;
        }, n2.addLabel = function(t3, e3) {
          return this.labels[t3] = Kt(this, e3), this;
        }, n2.removeLabel = function(t3) {
          return delete this.labels[t3], this;
        }, n2.addPause = function(t3, e3, n3) {
          var r2 = $e.delayedCall(0, e3 || ht, n3);
          return r2.data = "isPause", this._hasPause = 1, Xt(this, r2, Kt(this, t3));
        }, n2.removePause = function(t3) {
          var e3 = this._first;
          for (t3 = Kt(this, t3); e3; ) e3._start === t3 && "isPause" === e3.data && Ft(e3), e3 = e3._next;
        }, n2.killTweensOf = function(t3, e3, n3) {
          for (var r2 = this.getTweensOf(t3, n3), i2 = r2.length; i2--; ) je !== r2[i2] && r2[i2].kill(t3, e3);
          return this;
        }, n2.getTweensOf = function(t3, e3) {
          for (var n3, r2 = [], i2 = ae(t3), o2 = this._first, a2 = V(e3); o2; ) o2 instanceof $e ? Tt(o2._targets, i2) && (a2 ? (!je || o2._initted && o2._ts) && o2.globalTime(0) <= e3 && o2.globalTime(o2.totalDuration()) > e3 : !e3 || o2.isActive()) && r2.push(o2) : (n3 = o2.getTweensOf(i2, e3)).length && r2.push.apply(r2, n3), o2 = o2._next;
          return r2;
        }, n2.tweenTo = function(t3, e3) {
          e3 = e3 || {};
          var n3 = this, r2 = Kt(n3, t3), i2 = e3, o2 = i2.startAt, a2 = i2.onStart, s2 = i2.onStartParams, c2 = i2.immediateRender, u2 = $e.to(n3, Rt({ ease: "none", lazy: false, immediateRender: false, time: r2, overwrite: "auto", duration: e3.duration || Math.abs((r2 - (o2 && "time" in o2 ? o2.time : n3._time)) / n3.timeScale()) || 1e-8, onStart: function() {
            n3.pause();
            var t4 = e3.duration || Math.abs((r2 - n3._time) / n3.timeScale());
            u2._dur !== t4 && Jt(u2, t4, 0, 1).render(u2._time, true, true), a2 && a2.apply(u2, s2 || []);
          } }, e3));
          return c2 ? u2.render(0) : u2;
        }, n2.tweenFromTo = function(t3, e3, n3) {
          return this.tweenTo(e3, Rt({ startAt: { time: Kt(this, t3) } }, n3));
        }, n2.recent = function() {
          return this._recent;
        }, n2.nextLabel = function(t3) {
          return void 0 === t3 && (t3 = this._time), me(this, Kt(this, t3));
        }, n2.previousLabel = function(t3) {
          return void 0 === t3 && (t3 = this._time), me(this, Kt(this, t3), 1);
        }, n2.currentLabel = function(t3) {
          return arguments.length ? this.seek(t3, true) : this.previousLabel(this._time + 1e-8);
        }, n2.shiftChildren = function(t3, e3, n3) {
          void 0 === n3 && (n3 = 0);
          for (var r2, i2 = this._first, o2 = this.labels; i2; ) i2._start >= n3 && (i2._start += t3, i2._end += t3), i2 = i2._next;
          if (e3) for (r2 in o2) o2[r2] >= n3 && (o2[r2] += t3);
          return Bt(this);
        }, n2.invalidate = function() {
          var e3 = this._first;
          for (this._lock = 0; e3; ) e3.invalidate(), e3 = e3._next;
          return t2.prototype.invalidate.call(this);
        }, n2.clear = function(t3) {
          void 0 === t3 && (t3 = true);
          for (var e3, n3 = this._first; n3; ) e3 = n3._next, this.remove(n3), n3 = e3;
          return this._dp && (this._time = this._tTime = this._pTime = 0), t3 && (this.labels = {}), Bt(this);
        }, n2.totalDuration = function(t3) {
          var e3, n3, r2, i2 = 0, o2 = this, s2 = o2._last, c2 = N;
          if (arguments.length) return o2.timeScale((o2._repeat < 0 ? o2.duration() : o2.totalDuration()) / (o2.reversed() ? -t3 : t3));
          if (o2._dirty) {
            for (r2 = o2.parent; s2; ) e3 = s2._prev, s2._dirty && s2.totalDuration(), (n3 = s2._start) > c2 && o2._sort && s2._ts && !o2._lock ? (o2._lock = 1, Xt(o2, s2, n3 - s2._delay, 1)._lock = 0) : c2 = n3, n3 < 0 && s2._ts && (i2 -= n3, (!r2 && !o2._dp || r2 && r2.smoothChildTiming) && (o2._start += n3 / o2._ts, o2._time -= n3, o2._tTime -= n3), o2.shiftChildren(-n3, false, -Infinity), c2 = 0), s2._end > i2 && s2._ts && (i2 = s2._end), s2 = e3;
            Jt(o2, o2 === a && o2._time > i2 ? o2._time : i2, 1, 1), o2._dirty = 0;
          }
          return o2._tDur;
        }, e2.updateRoot = function(t3) {
          if (a._ts && (Ct(a, jt(t3, a)), h = Ae.frame), Ae.frame >= vt) {
            vt += D.autoSleep || 120;
            var e3 = a._first;
            if ((!e3 || !e3._ts) && D.autoSleep && Ae._listeners.length < 2) {
              for (; e3 && !e3._ts; ) e3 = e3._next;
              e3 || Ae.sleep();
            }
          }
        }, e2;
      }(Ge);
      Rt(Ue.prototype, { _lock: 0, _hasPause: 0, _forcing: 0 });
      var je, Ve = function(t2, e2, n2, r2, i2, o2, a2) {
        var s2, c2, u2, l2, h2, d2, p2, f2, m2 = new dn(this._pt, t2, e2, 0, 1, an, null, i2), g2 = 0, v2 = 0;
        for (m2.b = n2, m2.e = r2, n2 += "", (p2 = ~(r2 += "").indexOf("random(")) && (r2 = pe(r2)), o2 && (o2(f2 = [n2, r2], t2, e2), n2 = f2[0], r2 = f2[1]), c2 = n2.match(et) || []; s2 = et.exec(r2); ) l2 = s2[0], h2 = r2.substring(g2, s2.index), u2 ? u2 = (u2 + 1) % 5 : "rgba(" === h2.substr(-5) && (u2 = 1), l2 !== c2[v2++] && (d2 = parseFloat(c2[v2 - 1]) || 0, m2._pt = { _next: m2._pt, p: h2 || 1 === v2 ? h2 : ",", s: d2, c: "=" === l2.charAt(1) ? parseFloat(l2.substr(2)) * ("-" === l2.charAt(0) ? -1 : 1) : parseFloat(l2) - d2, m: u2 && u2 < 4 ? Math.round : 0 }, g2 = et.lastIndex);
        return m2.c = g2 < r2.length ? r2.substring(g2, r2.length) : "", m2.fp = a2, (nt.test(r2) || p2) && (m2.e = 0), this._pt = m2, m2;
      }, We = function(t2, e2, n2, r2, i2, o2, a2, s2, c2) {
        j(r2) && (r2 = r2(i2 || 0, t2, o2));
        var u2, l2 = t2[e2], h2 = "get" !== n2 ? n2 : j(l2) ? c2 ? t2[e2.indexOf("set") || !j(t2["get" + e2.substr(3)]) ? e2 : "get" + e2.substr(3)](c2) : t2[e2]() : l2, d2 = j(l2) ? c2 ? tn : Ke : Qe;
        if (U(r2) && (~r2.indexOf("random(") && (r2 = pe(r2)), "=" === r2.charAt(1) && (r2 = parseFloat(h2) + parseFloat(r2.substr(2)) * ("-" === r2.charAt(0) ? -1 : 1) + (ne(h2) || 0))), h2 !== r2) return isNaN(h2 * r2) ? (!l2 && !(e2 in t2) && ct(e2, r2), Ve.call(this, t2, e2, h2, r2, d2, s2 || D.stringFilter, c2)) : (u2 = new dn(this._pt, t2, e2, +h2 || 0, r2 - (h2 || 0), "boolean" == typeof l2 ? on : rn, 0, d2), c2 && (u2.fp = c2), a2 && u2.modifier(a2, this, t2), this._pt = u2);
      }, qe = function(t2, e2, n2, r2, i2, o2) {
        var a2, s2, c2, u2;
        if (mt[t2] && false !== (a2 = new mt[t2]()).init(i2, a2.rawVars ? e2[t2] : function(t3, e3, n3, r3, i3) {
          if (j(t3) && (t3 = Ye(t3, i3, e3, n3, r3)), !q(t3) || t3.style && t3.nodeType || $(t3) || J(t3)) return U(t3) ? Ye(t3, i3, e3, n3, r3) : t3;
          var o3, a3 = {};
          for (o3 in t3) a3[o3] = Ye(t3[o3], i3, e3, n3, r3);
          return a3;
        }(e2[t2], r2, i2, o2, n2), n2, r2, o2) && (n2._pt = s2 = new dn(n2._pt, i2, t2, 0, 1, a2.render, a2, 0, a2.priority), n2 !== d)) for (c2 = n2._ptLookup[n2._targets.indexOf(i2)], u2 = a2._props.length; u2--; ) c2[a2._props[u2]] = s2;
        return a2;
      }, Xe = function t2(e2, n2) {
        var r2, i2, s2, c2, u2, l2, h2, d2, p2, f2, m2, g2, v2, y2 = e2.vars, x2 = y2.ease, b2 = y2.startAt, w2 = y2.immediateRender, _2 = y2.lazy, M2 = y2.onUpdate, S2 = y2.onUpdateParams, T2 = y2.callbackScope, E2 = y2.runBackwards, A2 = y2.yoyoEase, C2 = y2.keyframes, L2 = y2.autoRevert, P2 = e2._dur, R2 = e2._startAt, O2 = e2._targets, D2 = e2.parent, N2 = D2 && "nested" === D2.data ? D2.parent._targets : O2, z2 = "auto" === e2._overwrite && !o, k2 = e2.timeline;
        if (k2 && (!C2 || !x2) && (x2 = "none"), e2._ease = Ne(x2, I.ease), e2._yEase = A2 ? De(Ne(true === A2 ? x2 : A2, I.ease)) : 0, A2 && e2._yoyo && !e2._repeat && (A2 = e2._yEase, e2._yEase = e2._ease, e2._ease = A2), !k2) {
          if (g2 = (d2 = O2[0] ? wt(O2[0]).harness : 0) && y2[d2.prop], r2 = Nt(y2, dt), R2 && R2.render(-1, true).kill(), b2) {
            if (Ft(e2._startAt = $e.set(O2, Rt({ data: "isStart", overwrite: false, parent: D2, immediateRender: true, lazy: X(_2), startAt: null, delay: 0, onUpdate: M2, onUpdateParams: S2, callbackScope: T2, stagger: 0 }, b2))), w2) {
              if (n2 > 0) L2 || (e2._startAt = 0);
              else if (P2 && !(n2 < 0 && R2)) return void (n2 && (e2._zTime = n2));
            }
          } else if (E2 && P2) if (R2) !L2 && (e2._startAt = 0);
          else if (n2 && (w2 = false), s2 = Rt({ overwrite: false, data: "isFromStart", lazy: w2 && X(_2), immediateRender: w2, stagger: 0, parent: D2 }, r2), g2 && (s2[d2.prop] = g2), Ft(e2._startAt = $e.set(O2, s2)), w2) {
            if (!n2) return;
          } else t2(e2._startAt, 1e-8);
          for (e2._pt = 0, _2 = P2 && X(_2) || _2 && !P2, i2 = 0; i2 < O2.length; i2++) {
            if (h2 = (u2 = O2[i2])._gsap || bt(O2)[i2]._gsap, e2._ptLookup[i2] = f2 = {}, ft[h2.id] && pt.length && At(), m2 = N2 === O2 ? i2 : N2.indexOf(u2), d2 && false !== (p2 = new d2()).init(u2, g2 || r2, e2, m2, N2) && (e2._pt = c2 = new dn(e2._pt, u2, p2.name, 0, 1, p2.render, p2, 0, p2.priority), p2._props.forEach(function(t3) {
              f2[t3] = c2;
            }), p2.priority && (l2 = 1)), !d2 || g2) for (s2 in r2) mt[s2] && (p2 = qe(s2, r2, e2, m2, u2, N2)) ? p2.priority && (l2 = 1) : f2[s2] = c2 = We.call(e2, u2, s2, "get", r2[s2], m2, N2, 0, y2.stringFilter);
            e2._op && e2._op[i2] && e2.kill(u2, e2._op[i2]), z2 && e2._pt && (je = e2, a.killTweensOf(u2, f2, e2.globalTime(0)), v2 = !e2.parent, je = 0), e2._pt && _2 && (ft[h2.id] = 1);
          }
          l2 && hn(e2), e2._onInit && e2._onInit(e2);
        }
        e2._from = !k2 && !!y2.runBackwards, e2._onUpdate = M2, e2._initted = (!e2._op || e2._pt) && !v2;
      }, Ye = function(t2, e2, n2, r2, i2) {
        return j(t2) ? t2.call(e2, n2, r2, i2) : U(t2) && ~t2.indexOf("random(") ? pe(t2) : t2;
      }, Ze = xt + "repeat,repeatDelay,yoyo,repeatRefresh,yoyoEase", Je = (Ze + ",id,stagger,delay,duration,paused,scrollTrigger").split(","), $e = function(t2) {
        function e2(e3, n3, i2, s2) {
          var c2;
          "number" == typeof n3 && (i2.duration = n3, n3 = i2, i2 = null);
          var u2, l2, h2, d2, p2, f2, m2, g2, v2 = (c2 = t2.call(this, s2 ? n3 : zt(n3), i2) || this).vars, y2 = v2.duration, x2 = v2.delay, b2 = v2.immediateRender, w2 = v2.stagger, _2 = v2.overwrite, M2 = v2.keyframes, S2 = v2.defaults, T2 = v2.scrollTrigger, E2 = v2.yoyoEase, A2 = c2.parent, C2 = ($(e3) || J(e3) ? V(e3[0]) : "length" in n3) ? [e3] : ae(e3);
          if (c2._targets = C2.length ? bt(C2) : ut("GSAP target " + e3 + " not found. https://greensock.com", !D.nullTargetWarn) || [], c2._ptLookup = [], c2._overwrite = _2, M2 || w2 || Z(y2) || Z(x2)) {
            if (n3 = c2.vars, (u2 = c2.timeline = new Ue({ data: "nested", defaults: S2 || {} })).kill(), u2.parent = u2._dp = r(c2), u2._start = 0, M2) Rt(u2.vars.defaults, { ease: "none" }), M2.forEach(function(t3) {
              return u2.to(C2, t3, ">");
            });
            else {
              if (d2 = C2.length, m2 = w2 ? ce(w2) : ht, q(w2)) for (p2 in w2) ~Ze.indexOf(p2) && (g2 || (g2 = {}), g2[p2] = w2[p2]);
              for (l2 = 0; l2 < d2; l2++) {
                for (p2 in h2 = {}, n3) Je.indexOf(p2) < 0 && (h2[p2] = n3[p2]);
                h2.stagger = 0, E2 && (h2.yoyoEase = E2), g2 && Dt(h2, g2), f2 = C2[l2], h2.duration = +Ye(y2, r(c2), l2, f2, C2), h2.delay = (+Ye(x2, r(c2), l2, f2, C2) || 0) - c2._delay, !w2 && 1 === d2 && h2.delay && (c2._delay = x2 = h2.delay, c2._start += x2, h2.delay = 0), u2.to(f2, h2, m2(l2, f2, C2));
              }
              u2.duration() ? y2 = x2 = 0 : c2.timeline = 0;
            }
            y2 || c2.duration(y2 = u2.duration());
          } else c2.timeline = 0;
          return true !== _2 || o || (je = r(c2), a.killTweensOf(C2), je = 0), A2 && qt(A2, r(c2)), (b2 || !y2 && !M2 && c2._start === St(A2._time) && X(b2) && function t3(e4) {
            return !e4 || e4._ts && t3(e4.parent);
          }(r(c2)) && "nested" !== A2.data) && (c2._tTime = -1e-8, c2.render(Math.max(0, -x2))), T2 && Yt(r(c2), T2), c2;
        }
        i(e2, t2);
        var n2 = e2.prototype;
        return n2.render = function(t3, e3, n3) {
          var r2, i2, o2, a2, s2, c2, u2, l2, h2, d2 = this._time, p2 = this._tDur, f2 = this._dur, m2 = t3 > p2 - 1e-8 && t3 >= 0 ? p2 : t3 < 1e-8 ? 0 : t3;
          if (f2) {
            if (m2 !== this._tTime || !t3 || n3 || !this._initted && this._tTime || this._startAt && this._zTime < 0 != t3 < 0) {
              if (r2 = m2, l2 = this.timeline, this._repeat) {
                if (a2 = f2 + this._rDelay, this._repeat < -1 && t3 < 0) return this.totalTime(100 * a2 + t3, e3, n3);
                if (r2 = St(m2 % a2), m2 === p2 ? (o2 = this._repeat, r2 = f2) : ((o2 = ~~(m2 / a2)) && o2 === m2 / a2 && (r2 = f2, o2--), r2 > f2 && (r2 = f2)), (c2 = this._yoyo && 1 & o2) && (h2 = this._yEase, r2 = f2 - r2), s2 = Ut(this._tTime, a2), r2 === d2 && !n3 && this._initted) return this;
                o2 !== s2 && (l2 && this._yEase && Ie(l2, c2), !this.vars.repeatRefresh || c2 || this._lock || (this._lock = n3 = 1, this.render(St(a2 * o2), true).invalidate()._lock = 0));
              }
              if (!this._initted) {
                if (Zt(this, t3 < 0 ? t3 : r2, n3, e3)) return this._tTime = 0, this;
                if (f2 !== this._dur) return this.render(t3, e3, n3);
              }
              for (this._tTime = m2, this._time = r2, !this._act && this._ts && (this._act = 1, this._lazy = 0), this.ratio = u2 = (h2 || this._ease)(r2 / f2), this._from && (this.ratio = u2 = 1 - u2), r2 && !d2 && !e3 && ge(this, "onStart"), i2 = this._pt; i2; ) i2.r(u2, i2.d), i2 = i2._next;
              l2 && l2.render(t3 < 0 ? t3 : !r2 && c2 ? -1e-8 : l2._dur * u2, e3, n3) || this._startAt && (this._zTime = t3), this._onUpdate && !e3 && (t3 < 0 && this._startAt && this._startAt.render(t3, true, n3), ge(this, "onUpdate")), this._repeat && o2 !== s2 && this.vars.onRepeat && !e3 && this.parent && ge(this, "onRepeat"), m2 !== this._tDur && m2 || this._tTime !== m2 || (t3 < 0 && this._startAt && !this._onUpdate && this._startAt.render(t3, true, true), (t3 || !f2) && (m2 === this._tDur && this._ts > 0 || !m2 && this._ts < 0) && Ft(this, 1), e3 || t3 < 0 && !d2 || !m2 && !d2 || (ge(this, m2 === p2 ? "onComplete" : "onReverseComplete", true), this._prom && !(m2 < p2 && this.timeScale() > 0) && this._prom()));
            }
          } else !function(t4, e4, n4, r3) {
            var i3, o3, a3, s3 = t4.ratio, c3 = e4 < 0 || !e4 && (!t4._start && function t5(e5) {
              var n5 = e5.parent;
              return n5 && n5._ts && n5._initted && !n5._lock && (n5.rawTime() < 0 || t5(n5));
            }(t4) || (t4._ts < 0 || t4._dp._ts < 0) && "isFromStart" !== t4.data && "isStart" !== t4.data) ? 0 : 1, u3 = t4._rDelay, l3 = 0;
            if (u3 && t4._repeat && (l3 = ee(0, t4._tDur, e4), o3 = Ut(l3, u3), a3 = Ut(t4._tTime, u3), t4._yoyo && 1 & o3 && (c3 = 1 - c3), o3 !== a3 && (s3 = 1 - c3, t4.vars.repeatRefresh && t4._initted && t4.invalidate())), c3 !== s3 || r3 || 1e-8 === t4._zTime || !e4 && t4._zTime) {
              if (!t4._initted && Zt(t4, e4, r3, n4)) return;
              for (a3 = t4._zTime, t4._zTime = e4 || (n4 ? 1e-8 : 0), n4 || (n4 = e4 && !a3), t4.ratio = c3, t4._from && (c3 = 1 - c3), t4._time = 0, t4._tTime = l3, n4 || ge(t4, "onStart"), i3 = t4._pt; i3; ) i3.r(c3, i3.d), i3 = i3._next;
              t4._startAt && e4 < 0 && t4._startAt.render(e4, true, true), t4._onUpdate && !n4 && ge(t4, "onUpdate"), l3 && t4._repeat && !n4 && t4.parent && ge(t4, "onRepeat"), (e4 >= t4._tDur || e4 < 0) && t4.ratio === c3 && (c3 && Ft(t4, 1), n4 || (ge(t4, c3 ? "onComplete" : "onReverseComplete", true), t4._prom && t4._prom()));
            } else t4._zTime || (t4._zTime = e4);
          }(this, t3, e3, n3);
          return this;
        }, n2.targets = function() {
          return this._targets;
        }, n2.invalidate = function() {
          return this._pt = this._op = this._startAt = this._onUpdate = this._lazy = this.ratio = 0, this._ptLookup = [], this.timeline && this.timeline.invalidate(), t2.prototype.invalidate.call(this);
        }, n2.kill = function(t3, e3) {
          if (void 0 === e3 && (e3 = "all"), !(t3 || e3 && "all" !== e3)) return this._lazy = this._pt = 0, this.parent ? ve(this) : this;
          if (this.timeline) {
            var n3 = this.timeline.totalDuration();
            return this.timeline.killTweensOf(t3, e3, je && true !== je.vars.overwrite)._first || ve(this), this.parent && n3 !== this.timeline.totalDuration() && Jt(this, this._dur * this.timeline._tDur / n3, 0, 1), this;
          }
          var r2, i2, o2, a2, s2, c2, u2, l2 = this._targets, h2 = t3 ? ae(t3) : l2, d2 = this._ptLookup, p2 = this._pt;
          if ((!e3 || "all" === e3) && function(t4, e4) {
            for (var n4 = t4.length, r3 = n4 === e4.length; r3 && n4-- && t4[n4] === e4[n4]; ) ;
            return n4 < 0;
          }(l2, h2)) return "all" === e3 && (this._pt = 0), ve(this);
          for (r2 = this._op = this._op || [], "all" !== e3 && (U(e3) && (s2 = {}, Mt(e3, function(t4) {
            return s2[t4] = 1;
          }), e3 = s2), e3 = function(t4, e4) {
            var n4, r3, i3, o3, a3 = t4[0] ? wt(t4[0]).harness : 0, s3 = a3 && a3.aliases;
            if (!s3) return e4;
            for (r3 in n4 = Dt({}, e4), s3) if (r3 in n4) for (i3 = (o3 = s3[r3].split(",")).length; i3--; ) n4[o3[i3]] = n4[r3];
            return n4;
          }(l2, e3)), u2 = l2.length; u2--; ) if (~h2.indexOf(l2[u2])) for (s2 in i2 = d2[u2], "all" === e3 ? (r2[u2] = e3, a2 = i2, o2 = {}) : (o2 = r2[u2] = r2[u2] || {}, a2 = e3), a2) (c2 = i2 && i2[s2]) && ("kill" in c2.d && true !== c2.d.kill(s2) || kt(this, c2, "_pt"), delete i2[s2]), "all" !== o2 && (o2[s2] = 1);
          return this._initted && !this._pt && p2 && ve(this), this;
        }, e2.to = function(t3, n3) {
          return new e2(t3, n3, arguments[2]);
        }, e2.from = function(t3, n3) {
          return new e2(t3, Et(arguments, 1));
        }, e2.delayedCall = function(t3, n3, r2, i2) {
          return new e2(n3, 0, { immediateRender: false, lazy: false, overwrite: false, delay: t3, onComplete: n3, onReverseComplete: n3, onCompleteParams: r2, onReverseCompleteParams: r2, callbackScope: i2 });
        }, e2.fromTo = function(t3, n3, r2) {
          return new e2(t3, Et(arguments, 2));
        }, e2.set = function(t3, n3) {
          return n3.duration = 0, n3.repeatDelay || (n3.repeat = 0), new e2(t3, n3);
        }, e2.killTweensOf = function(t3, e3, n3) {
          return a.killTweensOf(t3, e3, n3);
        }, e2;
      }(Ge);
      Rt($e.prototype, { _targets: [], _lazy: 0, _startAt: 0, _op: 0, _onInit: 0 }), Mt("staggerTo,staggerFrom,staggerFromTo", function(t2) {
        $e[t2] = function() {
          var e2 = new Ue(), n2 = re.call(arguments, 0);
          return n2.splice("staggerFromTo" === t2 ? 5 : 4, 0, 0), e2[t2].apply(e2, n2);
        };
      });
      var Qe = function(t2, e2, n2) {
        return t2[e2] = n2;
      }, Ke = function(t2, e2, n2) {
        return t2[e2](n2);
      }, tn = function(t2, e2, n2, r2) {
        return t2[e2](r2.fp, n2);
      }, en = function(t2, e2, n2) {
        return t2.setAttribute(e2, n2);
      }, nn = function(t2, e2) {
        return j(t2[e2]) ? Ke : W(t2[e2]) && t2.setAttribute ? en : Qe;
      }, rn = function(t2, e2) {
        return e2.set(e2.t, e2.p, Math.round(1e4 * (e2.s + e2.c * t2)) / 1e4, e2);
      }, on = function(t2, e2) {
        return e2.set(e2.t, e2.p, !!(e2.s + e2.c * t2), e2);
      }, an = function(t2, e2) {
        var n2 = e2._pt, r2 = "";
        if (!t2 && e2.b) r2 = e2.b;
        else if (1 === t2 && e2.e) r2 = e2.e;
        else {
          for (; n2; ) r2 = n2.p + (n2.m ? n2.m(n2.s + n2.c * t2) : Math.round(1e4 * (n2.s + n2.c * t2)) / 1e4) + r2, n2 = n2._next;
          r2 += e2.c;
        }
        e2.set(e2.t, e2.p, r2, e2);
      }, sn = function(t2, e2) {
        for (var n2 = e2._pt; n2; ) n2.r(t2, n2.d), n2 = n2._next;
      }, cn = function(t2, e2, n2, r2) {
        for (var i2, o2 = this._pt; o2; ) i2 = o2._next, o2.p === r2 && o2.modifier(t2, e2, n2), o2 = i2;
      }, un = function(t2) {
        for (var e2, n2, r2 = this._pt; r2; ) n2 = r2._next, r2.p === t2 && !r2.op || r2.op === t2 ? kt(this, r2, "_pt") : r2.dep || (e2 = 1), r2 = n2;
        return !e2;
      }, ln = function(t2, e2, n2, r2) {
        r2.mSet(t2, e2, r2.m.call(r2.tween, n2, r2.mt), r2);
      }, hn = function(t2) {
        for (var e2, n2, r2, i2, o2 = t2._pt; o2; ) {
          for (e2 = o2._next, n2 = r2; n2 && n2.pr > o2.pr; ) n2 = n2._next;
          (o2._prev = n2 ? n2._prev : i2) ? o2._prev._next = o2 : r2 = o2, (o2._next = n2) ? n2._prev = o2 : i2 = o2, o2 = e2;
        }
        t2._pt = r2;
      }, dn = function() {
        function t2(t3, e2, n2, r2, i2, o2, a2, s2, c2) {
          this.t = e2, this.s = r2, this.c = i2, this.p = n2, this.r = o2 || rn, this.d = a2 || this, this.set = s2 || Qe, this.pr = c2 || 0, this._next = t3, t3 && (t3._prev = this);
        }
        return t2.prototype.modifier = function(t3, e2, n2) {
          this.mSet = this.mSet || this.set, this.set = ln, this.m = t3, this.mt = n2, this.tween = e2;
        }, t2;
      }();
      Mt(xt + "parent,duration,ease,delay,overwrite,runBackwards,startAt,yoyo,immediateRender,repeat,repeatDelay,data,paused,reversed,lazy,callbackScope,stringFilter,id,yoyoEase,stagger,inherit,repeatRefresh,keyframes,autoRevert,scrollTrigger", function(t2) {
        return dt[t2] = 1;
      }), ot.TweenMax = ot.TweenLite = $e, ot.TimelineLite = ot.TimelineMax = Ue, a = new Ue({ sortChildren: false, defaults: I, autoRemoveChildren: true, id: "root", smoothChildTiming: true }), D.stringFilter = Ee;
      var pn = { registerPlugin: function() {
        for (var t2 = arguments.length, e2 = new Array(t2), n2 = 0; n2 < t2; n2++) e2[n2] = arguments[n2];
        e2.forEach(function(t3) {
          return ye(t3);
        });
      }, timeline: function(t2) {
        return new Ue(t2);
      }, getTweensOf: function(t2, e2) {
        return a.getTweensOf(t2, e2);
      }, getProperty: function(t2, e2, n2, r2) {
        U(t2) && (t2 = ae(t2)[0]);
        var i2 = wt(t2 || {}).get, o2 = n2 ? Pt : Lt;
        return "native" === n2 && (n2 = ""), t2 ? e2 ? o2((mt[e2] && mt[e2].get || i2)(t2, e2, n2, r2)) : function(e3, n3, r3) {
          return o2((mt[e3] && mt[e3].get || i2)(t2, e3, n3, r3));
        } : t2;
      }, quickSetter: function(t2, e2, n2) {
        if ((t2 = ae(t2)).length > 1) {
          var r2 = t2.map(function(t3) {
            return gn.quickSetter(t3, e2, n2);
          }), i2 = r2.length;
          return function(t3) {
            for (var e3 = i2; e3--; ) r2[e3](t3);
          };
        }
        t2 = t2[0] || {};
        var o2 = mt[e2], a2 = wt(t2), s2 = a2.harness && (a2.harness.aliases || {})[e2] || e2, c2 = o2 ? function(e3) {
          var r3 = new o2();
          d._pt = 0, r3.init(t2, n2 ? e3 + n2 : e3, d, 0, [t2]), r3.render(1, r3), d._pt && sn(1, d);
        } : a2.set(t2, s2);
        return o2 ? c2 : function(e3) {
          return c2(t2, s2, n2 ? e3 + n2 : e3, a2, 1);
        };
      }, isTweening: function(t2) {
        return a.getTweensOf(t2, true).length > 0;
      }, defaults: function(t2) {
        return t2 && t2.ease && (t2.ease = Ne(t2.ease, I.ease)), It(I, t2 || {});
      }, config: function(t2) {
        return It(D, t2 || {});
      }, registerEffect: function(t2) {
        var e2 = t2.name, n2 = t2.effect, r2 = t2.plugins, i2 = t2.defaults, o2 = t2.extendTimeline;
        (r2 || "").split(",").forEach(function(t3) {
          return t3 && !mt[t3] && !ot[t3] && ut(e2 + " effect requires " + t3 + " plugin.");
        }), gt[e2] = function(t3, e3, r3) {
          return n2(ae(t3), Rt(e3 || {}, i2), r3);
        }, o2 && (Ue.prototype[e2] = function(t3, n3, r3) {
          return this.add(gt[e2](t3, q(n3) ? n3 : (r3 = n3) && {}, this), r3);
        });
      }, registerEase: function(t2, e2) {
        Le[t2] = Ne(e2);
      }, parseEase: function(t2, e2) {
        return arguments.length ? Ne(t2, e2) : Le;
      }, getById: function(t2) {
        return a.getById(t2);
      }, exportRoot: function(t2, e2) {
        void 0 === t2 && (t2 = {});
        var n2, r2, i2 = new Ue(t2);
        for (i2.smoothChildTiming = X(t2.smoothChildTiming), a.remove(i2), i2._dp = 0, i2._time = i2._tTime = a._time, n2 = a._first; n2; ) r2 = n2._next, !e2 && !n2._dur && n2 instanceof $e && n2.vars.onComplete === n2._targets[0] || Xt(i2, n2, n2._start - n2._delay), n2 = r2;
        return Xt(a, i2, 0), i2;
      }, utils: { wrap: function t2(e2, n2, r2) {
        var i2 = n2 - e2;
        return $(e2) ? de(e2, t2(0, e2.length), n2) : te(r2, function(t3) {
          return (i2 + (t3 - e2) % i2) % i2 + e2;
        });
      }, wrapYoyo: function t2(e2, n2, r2) {
        var i2 = n2 - e2, o2 = 2 * i2;
        return $(e2) ? de(e2, t2(0, e2.length - 1), n2) : te(r2, function(t3) {
          return e2 + ((t3 = (o2 + (t3 - e2) % o2) % o2 || 0) > i2 ? o2 - t3 : t3);
        });
      }, distribute: ce, random: he, snap: le, normalize: function(t2, e2, n2) {
        return fe(t2, e2, 0, 1, n2);
      }, getUnit: ne, clamp: function(t2, e2, n2) {
        return te(n2, function(n3) {
          return ee(t2, e2, n3);
        });
      }, splitColor: we, toArray: ae, mapRange: fe, pipe: function() {
        for (var t2 = arguments.length, e2 = new Array(t2), n2 = 0; n2 < t2; n2++) e2[n2] = arguments[n2];
        return function(t3) {
          return e2.reduce(function(t4, e3) {
            return e3(t4);
          }, t3);
        };
      }, unitize: function(t2, e2) {
        return function(n2) {
          return t2(parseFloat(n2)) + (e2 || ne(n2));
        };
      }, interpolate: function t2(e2, n2, r2, i2) {
        var o2 = isNaN(e2 + n2) ? 0 : function(t3) {
          return (1 - t3) * e2 + t3 * n2;
        };
        if (!o2) {
          var a2, s2, c2, u2, l2, h2 = U(e2), d2 = {};
          if (true === r2 && (i2 = 1) && (r2 = null), h2) e2 = { p: e2 }, n2 = { p: n2 };
          else if ($(e2) && !$(n2)) {
            for (c2 = [], u2 = e2.length, l2 = u2 - 2, s2 = 1; s2 < u2; s2++) c2.push(t2(e2[s2 - 1], e2[s2]));
            u2--, o2 = function(t3) {
              t3 *= u2;
              var e3 = Math.min(l2, ~~t3);
              return c2[e3](t3 - e3);
            }, r2 = n2;
          } else i2 || (e2 = Dt($(e2) ? [] : {}, e2));
          if (!c2) {
            for (a2 in n2) We.call(d2, e2, a2, "get", n2[a2]);
            o2 = function(t3) {
              return sn(t3, d2) || (h2 ? e2.p : e2);
            };
          }
        }
        return te(r2, o2);
      }, shuffle: se }, install: st, effects: gt, ticker: Ae, updateRoot: Ue.updateRoot, plugins: mt, globalTimeline: a, core: { PropTween: dn, globals: lt, Tween: $e, Timeline: Ue, Animation: Ge, getCache: wt, _removeLinkedListItem: kt, suppressOverwrites: function(t2) {
        return o = t2;
      } } };
      Mt("to,from,fromTo,delayedCall,set,killTweensOf", function(t2) {
        return pn[t2] = $e[t2];
      }), Ae.add(Ue.updateRoot), d = pn.to({}, { duration: 0 });
      var fn = function(t2, e2) {
        for (var n2 = t2._pt; n2 && n2.p !== e2 && n2.op !== e2 && n2.fp !== e2; ) n2 = n2._next;
        return n2;
      }, mn = function(t2, e2) {
        return { name: t2, rawVars: 1, init: function(t3, n2, r2) {
          r2._onInit = function(t4) {
            var r3, i2;
            if (U(n2) && (r3 = {}, Mt(n2, function(t5) {
              return r3[t5] = 1;
            }), n2 = r3), e2) {
              for (i2 in r3 = {}, n2) r3[i2] = e2(n2[i2]);
              n2 = r3;
            }
            !function(t5, e3) {
              var n3, r4, i3, o2 = t5._targets;
              for (n3 in e3) for (r4 = o2.length; r4--; ) (i3 = t5._ptLookup[r4][n3]) && (i3 = i3.d) && (i3._pt && (i3 = fn(i3, n3)), i3 && i3.modifier && i3.modifier(e3[n3], t5, o2[r4], n3));
            }(t4, n2);
          };
        } };
      }, gn = pn.registerPlugin({ name: "attr", init: function(t2, e2, n2, r2, i2) {
        var o2, a2;
        for (o2 in e2) (a2 = this.add(t2, "setAttribute", (t2.getAttribute(o2) || 0) + "", e2[o2], r2, i2, 0, 0, o2)) && (a2.op = o2), this._props.push(o2);
      } }, { name: "endArray", init: function(t2, e2) {
        for (var n2 = e2.length; n2--; ) this.add(t2, n2, t2[n2] || 0, e2[n2]);
      } }, mn("roundProps", ue), mn("modifiers"), mn("snap", le)) || pn;
      $e.version = Ue.version = gn.version = "3.6.0", l = 1, Y() && Ce();
      var vn, yn, xn, bn, wn, _n, Mn, Sn, Tn = Le.Power0, En = Le.Power1, An = Le.Power2, Cn = Le.Power3, Ln = Le.Power4, Pn = Le.Linear, Rn = Le.Quad, On = Le.Cubic, Dn = Le.Quart, In = Le.Quint, Nn = Le.Strong, zn = Le.Elastic, kn = Le.Back, Fn = Le.SteppedEase, Bn = Le.Bounce, Hn = Le.Sine, Gn = Le.Expo, Un = Le.Circ, jn = {}, Vn = 180 / Math.PI, Wn = Math.PI / 180, qn = Math.atan2, Xn = /([A-Z])/g, Yn = /(?:left|right|width|margin|padding|x)/i, Zn = /[\s,\(]\S/, Jn = { autoAlpha: "opacity,visibility", scale: "scaleX,scaleY", alpha: "opacity" }, $n = function(t2, e2) {
        return e2.set(e2.t, e2.p, Math.round(1e4 * (e2.s + e2.c * t2)) / 1e4 + e2.u, e2);
      }, Qn = function(t2, e2) {
        return e2.set(e2.t, e2.p, 1 === t2 ? e2.e : Math.round(1e4 * (e2.s + e2.c * t2)) / 1e4 + e2.u, e2);
      }, Kn = function(t2, e2) {
        return e2.set(e2.t, e2.p, t2 ? Math.round(1e4 * (e2.s + e2.c * t2)) / 1e4 + e2.u : e2.b, e2);
      }, tr = function(t2, e2) {
        var n2 = e2.s + e2.c * t2;
        e2.set(e2.t, e2.p, ~~(n2 + (n2 < 0 ? -0.5 : 0.5)) + e2.u, e2);
      }, er = function(t2, e2) {
        return e2.set(e2.t, e2.p, t2 ? e2.e : e2.b, e2);
      }, nr = function(t2, e2) {
        return e2.set(e2.t, e2.p, 1 !== t2 ? e2.b : e2.e, e2);
      }, rr = function(t2, e2, n2) {
        return t2.style[e2] = n2;
      }, ir = function(t2, e2, n2) {
        return t2.style.setProperty(e2, n2);
      }, or = function(t2, e2, n2) {
        return t2._gsap[e2] = n2;
      }, ar = function(t2, e2, n2) {
        return t2._gsap.scaleX = t2._gsap.scaleY = n2;
      }, sr = function(t2, e2, n2, r2, i2) {
        var o2 = t2._gsap;
        o2.scaleX = o2.scaleY = n2, o2.renderTransform(i2, o2);
      }, cr = function(t2, e2, n2, r2, i2) {
        var o2 = t2._gsap;
        o2[e2] = n2, o2.renderTransform(i2, o2);
      }, ur = "transform", lr = ur + "Origin", hr = function(t2, e2) {
        var n2 = yn.createElementNS ? yn.createElementNS((e2 || "http://www.w3.org/1999/xhtml").replace(/^https/, "http"), t2) : yn.createElement(t2);
        return n2.style ? n2 : yn.createElement(t2);
      }, dr = function t2(e2, n2, r2) {
        var i2 = getComputedStyle(e2);
        return i2[n2] || i2.getPropertyValue(n2.replace(Xn, "-$1").toLowerCase()) || i2.getPropertyValue(n2) || !r2 && t2(e2, fr(n2) || n2, 1) || "";
      }, pr = "O,Moz,ms,Ms,Webkit".split(","), fr = function(t2, e2, n2) {
        var r2 = (e2 || wn).style, i2 = 5;
        if (t2 in r2 && !n2) return t2;
        for (t2 = t2.charAt(0).toUpperCase() + t2.substr(1); i2-- && !(pr[i2] + t2 in r2); ) ;
        return i2 < 0 ? null : (3 === i2 ? "ms" : i2 >= 0 ? pr[i2] : "") + t2;
      }, mr = function() {
        "undefined" != typeof window && window.document && (vn = window, yn = vn.document, xn = yn.documentElement, wn = hr("div") || { style: {} }, _n = hr("div"), ur = fr(ur), lr = ur + "Origin", wn.style.cssText = "border-width:0;line-height:0;position:absolute;padding:0", Sn = !!fr("perspective"), bn = 1);
      }, gr = function t2(e2) {
        var n2, r2 = hr("svg", this.ownerSVGElement && this.ownerSVGElement.getAttribute("xmlns") || "http://www.w3.org/2000/svg"), i2 = this.parentNode, o2 = this.nextSibling, a2 = this.style.cssText;
        if (xn.appendChild(r2), r2.appendChild(this), this.style.display = "block", e2) try {
          n2 = this.getBBox(), this._gsapBBox = this.getBBox, this.getBBox = t2;
        } catch (t3) {
        }
        else this._gsapBBox && (n2 = this._gsapBBox());
        return i2 && (o2 ? i2.insertBefore(this, o2) : i2.appendChild(this)), xn.removeChild(r2), this.style.cssText = a2, n2;
      }, vr = function(t2, e2) {
        for (var n2 = e2.length; n2--; ) if (t2.hasAttribute(e2[n2])) return t2.getAttribute(e2[n2]);
      }, yr = function(t2) {
        var e2;
        try {
          e2 = t2.getBBox();
        } catch (n2) {
          e2 = gr.call(t2, true);
        }
        return e2 && (e2.width || e2.height) || t2.getBBox === gr || (e2 = gr.call(t2, true)), !e2 || e2.width || e2.x || e2.y ? e2 : { x: +vr(t2, ["x", "cx", "x1"]) || 0, y: +vr(t2, ["y", "cy", "y1"]) || 0, width: 0, height: 0 };
      }, xr = function(t2) {
        return !(!t2.getCTM || t2.parentNode && !t2.ownerSVGElement || !yr(t2));
      }, br = function(t2, e2) {
        if (e2) {
          var n2 = t2.style;
          e2 in jn && e2 !== lr && (e2 = ur), n2.removeProperty ? ("ms" !== e2.substr(0, 2) && "webkit" !== e2.substr(0, 6) || (e2 = "-" + e2), n2.removeProperty(e2.replace(Xn, "-$1").toLowerCase())) : n2.removeAttribute(e2);
        }
      }, wr = function(t2, e2, n2, r2, i2, o2) {
        var a2 = new dn(t2._pt, e2, n2, 0, 1, o2 ? nr : er);
        return t2._pt = a2, a2.b = r2, a2.e = i2, t2._props.push(n2), a2;
      }, _r = { deg: 1, rad: 1, turn: 1 }, Mr = function t2(e2, n2, r2, i2) {
        var o2, a2, s2, c2, u2 = parseFloat(r2) || 0, l2 = (r2 + "").trim().substr((u2 + "").length) || "px", h2 = wn.style, d2 = Yn.test(n2), p2 = "svg" === e2.tagName.toLowerCase(), f2 = (p2 ? "client" : "offset") + (d2 ? "Width" : "Height"), m2 = "px" === i2, g2 = "%" === i2;
        return i2 === l2 || !u2 || _r[i2] || _r[l2] ? u2 : ("px" !== l2 && !m2 && (u2 = t2(e2, n2, r2, "px")), c2 = e2.getCTM && xr(e2), !g2 && "%" !== l2 || !jn[n2] && !~n2.indexOf("adius") ? (h2[d2 ? "width" : "height"] = 100 + (m2 ? l2 : i2), a2 = ~n2.indexOf("adius") || "em" === i2 && e2.appendChild && !p2 ? e2 : e2.parentNode, c2 && (a2 = (e2.ownerSVGElement || {}).parentNode), a2 && a2 !== yn && a2.appendChild || (a2 = yn.body), (s2 = a2._gsap) && g2 && s2.width && d2 && s2.time === Ae.time ? St(u2 / s2.width * 100) : ((g2 || "%" === l2) && (h2.position = dr(e2, "position")), a2 === e2 && (h2.position = "static"), a2.appendChild(wn), o2 = wn[f2], a2.removeChild(wn), h2.position = "absolute", d2 && g2 && ((s2 = wt(a2)).time = Ae.time, s2.width = a2[f2]), St(m2 ? o2 * u2 / 100 : o2 && u2 ? 100 / o2 * u2 : 0))) : (o2 = c2 ? e2.getBBox()[d2 ? "width" : "height"] : e2[f2], St(g2 ? u2 / o2 * 100 : u2 / 100 * o2)));
      }, Sr = function(t2, e2, n2, r2) {
        var i2;
        return bn || mr(), e2 in Jn && "transform" !== e2 && ~(e2 = Jn[e2]).indexOf(",") && (e2 = e2.split(",")[0]), jn[e2] && "transform" !== e2 ? (i2 = Nr(t2, r2), i2 = "transformOrigin" !== e2 ? i2[e2] : zr(dr(t2, lr)) + " " + i2.zOrigin + "px") : (!(i2 = t2.style[e2]) || "auto" === i2 || r2 || ~(i2 + "").indexOf("calc(")) && (i2 = Cr[e2] && Cr[e2](t2, e2, n2) || dr(t2, e2) || _t(t2, e2) || ("opacity" === e2 ? 1 : 0)), n2 && !~(i2 + "").trim().indexOf(" ") ? Mr(t2, e2, i2, n2) + n2 : i2;
      }, Tr = function(t2, e2, n2, r2) {
        if (!n2 || "none" === n2) {
          var i2 = fr(e2, t2, 1), o2 = i2 && dr(t2, i2, 1);
          o2 && o2 !== n2 ? (e2 = i2, n2 = o2) : "borderColor" === e2 && (n2 = dr(t2, "borderTopColor"));
        }
        var a2, s2, c2, u2, l2, h2, d2, p2, f2, m2, g2, v2, y2 = new dn(this._pt, t2.style, e2, 0, 1, an), x2 = 0, b2 = 0;
        if (y2.b = n2, y2.e = r2, n2 += "", "auto" === (r2 += "") && (t2.style[e2] = r2, r2 = dr(t2, e2) || r2, t2.style[e2] = n2), Ee(a2 = [n2, r2]), r2 = a2[1], c2 = (n2 = a2[0]).match(tt) || [], (r2.match(tt) || []).length) {
          for (; s2 = tt.exec(r2); ) d2 = s2[0], f2 = r2.substring(x2, s2.index), l2 ? l2 = (l2 + 1) % 5 : "rgba(" !== f2.substr(-5) && "hsla(" !== f2.substr(-5) || (l2 = 1), d2 !== (h2 = c2[b2++] || "") && (u2 = parseFloat(h2) || 0, g2 = h2.substr((u2 + "").length), (v2 = "=" === d2.charAt(1) ? +(d2.charAt(0) + "1") : 0) && (d2 = d2.substr(2)), p2 = parseFloat(d2), m2 = d2.substr((p2 + "").length), x2 = tt.lastIndex - m2.length, m2 || (m2 = m2 || D.units[e2] || g2, x2 === r2.length && (r2 += m2, y2.e += m2)), g2 !== m2 && (u2 = Mr(t2, e2, h2, m2) || 0), y2._pt = { _next: y2._pt, p: f2 || 1 === b2 ? f2 : ",", s: u2, c: v2 ? v2 * p2 : p2 - u2, m: l2 && l2 < 4 || "zIndex" === e2 ? Math.round : 0 });
          y2.c = x2 < r2.length ? r2.substring(x2, r2.length) : "";
        } else y2.r = "display" === e2 && "none" === r2 ? nr : er;
        return nt.test(r2) && (y2.e = 0), this._pt = y2, y2;
      }, Er = { top: "0%", bottom: "100%", left: "0%", right: "100%", center: "50%" }, Ar = function(t2, e2) {
        if (e2.tween && e2.tween._time === e2.tween._dur) {
          var n2, r2, i2, o2 = e2.t, a2 = o2.style, s2 = e2.u, c2 = o2._gsap;
          if ("all" === s2 || true === s2) a2.cssText = "", r2 = 1;
          else for (i2 = (s2 = s2.split(",")).length; --i2 > -1; ) n2 = s2[i2], jn[n2] && (r2 = 1, n2 = "transformOrigin" === n2 ? lr : ur), br(o2, n2);
          r2 && (br(o2, ur), c2 && (c2.svg && o2.removeAttribute("transform"), Nr(o2, 1), c2.uncache = 1));
        }
      }, Cr = { clearProps: function(t2, e2, n2, r2, i2) {
        if ("isFromStart" !== i2.data) {
          var o2 = t2._pt = new dn(t2._pt, e2, n2, 0, 0, Ar);
          return o2.u = r2, o2.pr = -10, o2.tween = i2, t2._props.push(n2), 1;
        }
      } }, Lr = [1, 0, 0, 1, 0, 0], Pr = {}, Rr = function(t2) {
        return "matrix(1, 0, 0, 1, 0, 0)" === t2 || "none" === t2 || !t2;
      }, Or = function(t2) {
        var e2 = dr(t2, ur);
        return Rr(e2) ? Lr : e2.substr(7).match(K).map(St);
      }, Dr = function(t2, e2) {
        var n2, r2, i2, o2, a2 = t2._gsap || wt(t2), s2 = t2.style, c2 = Or(t2);
        return a2.svg && t2.getAttribute("transform") ? "1,0,0,1,0,0" === (c2 = [(i2 = t2.transform.baseVal.consolidate().matrix).a, i2.b, i2.c, i2.d, i2.e, i2.f]).join(",") ? Lr : c2 : (c2 !== Lr || t2.offsetParent || t2 === xn || a2.svg || (i2 = s2.display, s2.display = "block", (n2 = t2.parentNode) && t2.offsetParent || (o2 = 1, r2 = t2.nextSibling, xn.appendChild(t2)), c2 = Or(t2), i2 ? s2.display = i2 : br(t2, "display"), o2 && (r2 ? n2.insertBefore(t2, r2) : n2 ? n2.appendChild(t2) : xn.removeChild(t2))), e2 && c2.length > 6 ? [c2[0], c2[1], c2[4], c2[5], c2[12], c2[13]] : c2);
      }, Ir = function(t2, e2, n2, r2, i2, o2) {
        var a2, s2, c2, u2 = t2._gsap, l2 = i2 || Dr(t2, true), h2 = u2.xOrigin || 0, d2 = u2.yOrigin || 0, p2 = u2.xOffset || 0, f2 = u2.yOffset || 0, m2 = l2[0], g2 = l2[1], v2 = l2[2], y2 = l2[3], x2 = l2[4], b2 = l2[5], w2 = e2.split(" "), _2 = parseFloat(w2[0]) || 0, M2 = parseFloat(w2[1]) || 0;
        n2 ? l2 !== Lr && (s2 = m2 * y2 - g2 * v2) && (c2 = _2 * (-g2 / s2) + M2 * (m2 / s2) - (m2 * b2 - g2 * x2) / s2, _2 = _2 * (y2 / s2) + M2 * (-v2 / s2) + (v2 * b2 - y2 * x2) / s2, M2 = c2) : (_2 = (a2 = yr(t2)).x + (~w2[0].indexOf("%") ? _2 / 100 * a2.width : _2), M2 = a2.y + (~(w2[1] || w2[0]).indexOf("%") ? M2 / 100 * a2.height : M2)), r2 || false !== r2 && u2.smooth ? (x2 = _2 - h2, b2 = M2 - d2, u2.xOffset = p2 + (x2 * m2 + b2 * v2) - x2, u2.yOffset = f2 + (x2 * g2 + b2 * y2) - b2) : u2.xOffset = u2.yOffset = 0, u2.xOrigin = _2, u2.yOrigin = M2, u2.smooth = !!r2, u2.origin = e2, u2.originIsAbsolute = !!n2, t2.style[lr] = "0px 0px", o2 && (wr(o2, u2, "xOrigin", h2, _2), wr(o2, u2, "yOrigin", d2, M2), wr(o2, u2, "xOffset", p2, u2.xOffset), wr(o2, u2, "yOffset", f2, u2.yOffset)), t2.setAttribute("data-svg-origin", _2 + " " + M2);
      }, Nr = function(t2, e2) {
        var n2 = t2._gsap || new He(t2);
        if ("x" in n2 && !e2 && !n2.uncache) return n2;
        var r2, i2, o2, a2, s2, c2, u2, l2, h2, d2, p2, f2, m2, g2, v2, y2, x2, b2, w2, _2, M2, S2, T2, E2, A2, C2, L2, P2, R2, O2, I2, N2, z2 = t2.style, k2 = n2.scaleX < 0, F2 = dr(t2, lr) || "0";
        return r2 = i2 = o2 = c2 = u2 = l2 = h2 = d2 = p2 = 0, a2 = s2 = 1, n2.svg = !(!t2.getCTM || !xr(t2)), g2 = Dr(t2, n2.svg), n2.svg && (E2 = !n2.uncache && t2.getAttribute("data-svg-origin"), Ir(t2, E2 || F2, !!E2 || n2.originIsAbsolute, false !== n2.smooth, g2)), f2 = n2.xOrigin || 0, m2 = n2.yOrigin || 0, g2 !== Lr && (b2 = g2[0], w2 = g2[1], _2 = g2[2], M2 = g2[3], r2 = S2 = g2[4], i2 = T2 = g2[5], 6 === g2.length ? (a2 = Math.sqrt(b2 * b2 + w2 * w2), s2 = Math.sqrt(M2 * M2 + _2 * _2), c2 = b2 || w2 ? qn(w2, b2) * Vn : 0, (h2 = _2 || M2 ? qn(_2, M2) * Vn + c2 : 0) && (s2 *= Math.cos(h2 * Wn)), n2.svg && (r2 -= f2 - (f2 * b2 + m2 * _2), i2 -= m2 - (f2 * w2 + m2 * M2))) : (N2 = g2[6], O2 = g2[7], L2 = g2[8], P2 = g2[9], R2 = g2[10], I2 = g2[11], r2 = g2[12], i2 = g2[13], o2 = g2[14], u2 = (v2 = qn(N2, R2)) * Vn, v2 && (E2 = S2 * (y2 = Math.cos(-v2)) + L2 * (x2 = Math.sin(-v2)), A2 = T2 * y2 + P2 * x2, C2 = N2 * y2 + R2 * x2, L2 = S2 * -x2 + L2 * y2, P2 = T2 * -x2 + P2 * y2, R2 = N2 * -x2 + R2 * y2, I2 = O2 * -x2 + I2 * y2, S2 = E2, T2 = A2, N2 = C2), l2 = (v2 = qn(-_2, R2)) * Vn, v2 && (y2 = Math.cos(-v2), I2 = M2 * (x2 = Math.sin(-v2)) + I2 * y2, b2 = E2 = b2 * y2 - L2 * x2, w2 = A2 = w2 * y2 - P2 * x2, _2 = C2 = _2 * y2 - R2 * x2), c2 = (v2 = qn(w2, b2)) * Vn, v2 && (E2 = b2 * (y2 = Math.cos(v2)) + w2 * (x2 = Math.sin(v2)), A2 = S2 * y2 + T2 * x2, w2 = w2 * y2 - b2 * x2, T2 = T2 * y2 - S2 * x2, b2 = E2, S2 = A2), u2 && Math.abs(u2) + Math.abs(c2) > 359.9 && (u2 = c2 = 0, l2 = 180 - l2), a2 = St(Math.sqrt(b2 * b2 + w2 * w2 + _2 * _2)), s2 = St(Math.sqrt(T2 * T2 + N2 * N2)), v2 = qn(S2, T2), h2 = Math.abs(v2) > 2e-4 ? v2 * Vn : 0, p2 = I2 ? 1 / (I2 < 0 ? -I2 : I2) : 0), n2.svg && (E2 = t2.getAttribute("transform"), n2.forceCSS = t2.setAttribute("transform", "") || !Rr(dr(t2, ur)), E2 && t2.setAttribute("transform", E2))), Math.abs(h2) > 90 && Math.abs(h2) < 270 && (k2 ? (a2 *= -1, h2 += c2 <= 0 ? 180 : -180, c2 += c2 <= 0 ? 180 : -180) : (s2 *= -1, h2 += h2 <= 0 ? 180 : -180)), n2.x = r2 - ((n2.xPercent = r2 && (n2.xPercent || (Math.round(t2.offsetWidth / 2) === Math.round(-r2) ? -50 : 0))) ? t2.offsetWidth * n2.xPercent / 100 : 0) + "px", n2.y = i2 - ((n2.yPercent = i2 && (n2.yPercent || (Math.round(t2.offsetHeight / 2) === Math.round(-i2) ? -50 : 0))) ? t2.offsetHeight * n2.yPercent / 100 : 0) + "px", n2.z = o2 + "px", n2.scaleX = St(a2), n2.scaleY = St(s2), n2.rotation = St(c2) + "deg", n2.rotationX = St(u2) + "deg", n2.rotationY = St(l2) + "deg", n2.skewX = h2 + "deg", n2.skewY = d2 + "deg", n2.transformPerspective = p2 + "px", (n2.zOrigin = parseFloat(F2.split(" ")[2]) || 0) && (z2[lr] = zr(F2)), n2.xOffset = n2.yOffset = 0, n2.force3D = D.force3D, n2.renderTransform = n2.svg ? Hr : Sn ? Br : Fr, n2.uncache = 0, n2;
      }, zr = function(t2) {
        return (t2 = t2.split(" "))[0] + " " + t2[1];
      }, kr = function(t2, e2, n2) {
        var r2 = ne(e2);
        return St(parseFloat(e2) + parseFloat(Mr(t2, "x", n2 + "px", r2))) + r2;
      }, Fr = function(t2, e2) {
        e2.z = "0px", e2.rotationY = e2.rotationX = "0deg", e2.force3D = 0, Br(t2, e2);
      }, Br = function(t2, e2) {
        var n2 = e2 || this, r2 = n2.xPercent, i2 = n2.yPercent, o2 = n2.x, a2 = n2.y, s2 = n2.z, c2 = n2.rotation, u2 = n2.rotationY, l2 = n2.rotationX, h2 = n2.skewX, d2 = n2.skewY, p2 = n2.scaleX, f2 = n2.scaleY, m2 = n2.transformPerspective, g2 = n2.force3D, v2 = n2.target, y2 = n2.zOrigin, x2 = "", b2 = "auto" === g2 && t2 && 1 !== t2 || true === g2;
        if (y2 && ("0deg" !== l2 || "0deg" !== u2)) {
          var w2, _2 = parseFloat(u2) * Wn, M2 = Math.sin(_2), S2 = Math.cos(_2);
          _2 = parseFloat(l2) * Wn, w2 = Math.cos(_2), o2 = kr(v2, o2, M2 * w2 * -y2), a2 = kr(v2, a2, -Math.sin(_2) * -y2), s2 = kr(v2, s2, S2 * w2 * -y2 + y2);
        }
        "0px" !== m2 && (x2 += "perspective(" + m2 + ") "), (r2 || i2) && (x2 += "translate(" + r2 + "%, " + i2 + "%) "), (b2 || "0px" !== o2 || "0px" !== a2 || "0px" !== s2) && (x2 += "0px" !== s2 || b2 ? "translate3d(" + o2 + ", " + a2 + ", " + s2 + ") " : "translate(" + o2 + ", " + a2 + ") "), "0deg" !== c2 && (x2 += "rotate(" + c2 + ") "), "0deg" !== u2 && (x2 += "rotateY(" + u2 + ") "), "0deg" !== l2 && (x2 += "rotateX(" + l2 + ") "), "0deg" === h2 && "0deg" === d2 || (x2 += "skew(" + h2 + ", " + d2 + ") "), 1 === p2 && 1 === f2 || (x2 += "scale(" + p2 + ", " + f2 + ") "), v2.style[ur] = x2 || "translate(0, 0)";
      }, Hr = function(t2, e2) {
        var n2, r2, i2, o2, a2, s2 = e2 || this, c2 = s2.xPercent, u2 = s2.yPercent, l2 = s2.x, h2 = s2.y, d2 = s2.rotation, p2 = s2.skewX, f2 = s2.skewY, m2 = s2.scaleX, g2 = s2.scaleY, v2 = s2.target, y2 = s2.xOrigin, x2 = s2.yOrigin, b2 = s2.xOffset, w2 = s2.yOffset, _2 = s2.forceCSS, M2 = parseFloat(l2), S2 = parseFloat(h2);
        d2 = parseFloat(d2), p2 = parseFloat(p2), (f2 = parseFloat(f2)) && (p2 += f2 = parseFloat(f2), d2 += f2), d2 || p2 ? (d2 *= Wn, p2 *= Wn, n2 = Math.cos(d2) * m2, r2 = Math.sin(d2) * m2, i2 = Math.sin(d2 - p2) * -g2, o2 = Math.cos(d2 - p2) * g2, p2 && (f2 *= Wn, a2 = Math.tan(p2 - f2), i2 *= a2 = Math.sqrt(1 + a2 * a2), o2 *= a2, f2 && (a2 = Math.tan(f2), n2 *= a2 = Math.sqrt(1 + a2 * a2), r2 *= a2)), n2 = St(n2), r2 = St(r2), i2 = St(i2), o2 = St(o2)) : (n2 = m2, o2 = g2, r2 = i2 = 0), (M2 && !~(l2 + "").indexOf("px") || S2 && !~(h2 + "").indexOf("px")) && (M2 = Mr(v2, "x", l2, "px"), S2 = Mr(v2, "y", h2, "px")), (y2 || x2 || b2 || w2) && (M2 = St(M2 + y2 - (y2 * n2 + x2 * i2) + b2), S2 = St(S2 + x2 - (y2 * r2 + x2 * o2) + w2)), (c2 || u2) && (a2 = v2.getBBox(), M2 = St(M2 + c2 / 100 * a2.width), S2 = St(S2 + u2 / 100 * a2.height)), a2 = "matrix(" + n2 + "," + r2 + "," + i2 + "," + o2 + "," + M2 + "," + S2 + ")", v2.setAttribute("transform", a2), _2 && (v2.style[ur] = a2);
      }, Gr = function(t2, e2, n2, r2, i2, o2) {
        var a2, s2, c2 = U(i2), u2 = parseFloat(i2) * (c2 && ~i2.indexOf("rad") ? Vn : 1), l2 = o2 ? u2 * o2 : u2 - r2, h2 = r2 + l2 + "deg";
        return c2 && ("short" === (a2 = i2.split("_")[1]) && (l2 %= 360) !== l2 % 180 && (l2 += l2 < 0 ? 360 : -360), "cw" === a2 && l2 < 0 ? l2 = (l2 + 36e9) % 360 - 360 * ~~(l2 / 360) : "ccw" === a2 && l2 > 0 && (l2 = (l2 - 36e9) % 360 - 360 * ~~(l2 / 360))), t2._pt = s2 = new dn(t2._pt, e2, n2, r2, l2, Qn), s2.e = h2, s2.u = "deg", t2._props.push(n2), s2;
      }, Ur = function(t2, e2, n2) {
        var r2, i2, o2, a2, s2, c2, u2, l2 = _n.style, h2 = n2._gsap;
        for (i2 in l2.cssText = getComputedStyle(n2).cssText + ";position:absolute;display:block;", l2[ur] = e2, yn.body.appendChild(_n), r2 = Nr(_n, 1), jn) (o2 = h2[i2]) !== (a2 = r2[i2]) && "perspective,force3D,transformOrigin,svgOrigin".indexOf(i2) < 0 && (s2 = ne(o2) !== (u2 = ne(a2)) ? Mr(n2, i2, o2, u2) : parseFloat(o2), c2 = parseFloat(a2), t2._pt = new dn(t2._pt, h2, i2, s2, c2 - s2, $n), t2._pt.u = u2 || 0, t2._props.push(i2));
        yn.body.removeChild(_n);
      };
      Mt("padding,margin,Width,Radius", function(t2, e2) {
        var n2 = "Top", r2 = "Right", i2 = "Bottom", o2 = "Left", a2 = (e2 < 3 ? [n2, r2, i2, o2] : [n2 + o2, n2 + r2, i2 + r2, i2 + o2]).map(function(n3) {
          return e2 < 2 ? t2 + n3 : "border" + n3 + t2;
        });
        Cr[e2 > 1 ? "border" + t2 : t2] = function(t3, e3, n3, r3, i3) {
          var o3, s2;
          if (arguments.length < 4) return o3 = a2.map(function(e4) {
            return Sr(t3, e4, n3);
          }), 5 === (s2 = o3.join(" ")).split(o3[0]).length ? o3[0] : s2;
          o3 = (r3 + "").split(" "), s2 = {}, a2.forEach(function(t4, e4) {
            return s2[t4] = o3[e4] = o3[e4] || o3[(e4 - 1) / 2 | 0];
          }), t3.init(e3, s2, i3);
        };
      });
      var jr, Vr, Wr = { name: "css", register: mr, targetTest: function(t2) {
        return t2.style && t2.nodeType;
      }, init: function(t2, e2, n2, r2, i2) {
        var o2, a2, s2, c2, u2, l2, h2, d2, p2, f2, m2, g2, v2, y2, x2, b2, w2, _2, M2, S2 = this._props, T2 = t2.style, E2 = n2.vars.startAt;
        for (h2 in bn || mr(), e2) if ("autoRound" !== h2 && (a2 = e2[h2], !mt[h2] || !qe(h2, e2, n2, r2, t2, i2))) {
          if (u2 = typeof a2, l2 = Cr[h2], "function" === u2 && (u2 = typeof (a2 = a2.call(n2, r2, t2, i2))), "string" === u2 && ~a2.indexOf("random(") && (a2 = pe(a2)), l2) l2(this, t2, h2, a2, n2) && (x2 = 1);
          else if ("--" === h2.substr(0, 2)) o2 = (getComputedStyle(t2).getPropertyValue(h2) + "").trim(), a2 += "", d2 = ne(o2), (p2 = ne(a2)) ? d2 !== p2 && (o2 = Mr(t2, h2, o2, p2) + p2) : d2 && (a2 += d2), this.add(T2, "setProperty", o2, a2, r2, i2, 0, 0, h2);
          else if ("undefined" !== u2) {
            if (E2 && h2 in E2 ? (o2 = "function" == typeof E2[h2] ? E2[h2].call(n2, r2, t2, i2) : E2[h2], h2 in D.units && !ne(o2) && (o2 += D.units[h2]), "=" === (o2 + "").charAt(1) && (o2 = Sr(t2, h2))) : o2 = Sr(t2, h2), c2 = parseFloat(o2), (f2 = "string" === u2 && "=" === a2.charAt(1) ? +(a2.charAt(0) + "1") : 0) && (a2 = a2.substr(2)), s2 = parseFloat(a2), h2 in Jn && ("autoAlpha" === h2 && (1 === c2 && "hidden" === Sr(t2, "visibility") && s2 && (c2 = 0), wr(this, T2, "visibility", c2 ? "inherit" : "hidden", s2 ? "inherit" : "hidden", !s2)), "scale" !== h2 && "transform" !== h2 && ~(h2 = Jn[h2]).indexOf(",") && (h2 = h2.split(",")[0])), m2 = h2 in jn) if (g2 || ((v2 = t2._gsap).renderTransform && !e2.parseTransform || Nr(t2, e2.parseTransform), y2 = false !== e2.smoothOrigin && v2.smooth, (g2 = this._pt = new dn(this._pt, T2, ur, 0, 1, v2.renderTransform, v2, 0, -1)).dep = 1), "scale" === h2) this._pt = new dn(this._pt, v2, "scaleY", v2.scaleY, f2 ? f2 * s2 : s2 - v2.scaleY), S2.push("scaleY", h2), h2 += "X";
            else {
              if ("transformOrigin" === h2) {
                w2 = void 0, _2 = void 0, M2 = void 0, w2 = (b2 = a2).split(" "), _2 = w2[0], M2 = w2[1] || "50%", "top" !== _2 && "bottom" !== _2 && "left" !== M2 && "right" !== M2 || (b2 = _2, _2 = M2, M2 = b2), w2[0] = Er[_2] || _2, w2[1] = Er[M2] || M2, a2 = w2.join(" "), v2.svg ? Ir(t2, a2, 0, y2, 0, this) : ((p2 = parseFloat(a2.split(" ")[2]) || 0) !== v2.zOrigin && wr(this, v2, "zOrigin", v2.zOrigin, p2), wr(this, T2, h2, zr(o2), zr(a2)));
                continue;
              }
              if ("svgOrigin" === h2) {
                Ir(t2, a2, 1, y2, 0, this);
                continue;
              }
              if (h2 in Pr) {
                Gr(this, v2, h2, c2, a2, f2);
                continue;
              }
              if ("smoothOrigin" === h2) {
                wr(this, v2, "smooth", v2.smooth, a2);
                continue;
              }
              if ("force3D" === h2) {
                v2[h2] = a2;
                continue;
              }
              if ("transform" === h2) {
                Ur(this, a2, t2);
                continue;
              }
            }
            else h2 in T2 || (h2 = fr(h2) || h2);
            if (m2 || (s2 || 0 === s2) && (c2 || 0 === c2) && !Zn.test(a2) && h2 in T2) s2 || (s2 = 0), (d2 = (o2 + "").substr((c2 + "").length)) !== (p2 = ne(a2) || (h2 in D.units ? D.units[h2] : d2)) && (c2 = Mr(t2, h2, o2, p2)), this._pt = new dn(this._pt, m2 ? v2 : T2, h2, c2, f2 ? f2 * s2 : s2 - c2, m2 || "px" !== p2 && "zIndex" !== h2 || false === e2.autoRound ? $n : tr), this._pt.u = p2 || 0, d2 !== p2 && (this._pt.b = o2, this._pt.r = Kn);
            else if (h2 in T2) Tr.call(this, t2, h2, o2, a2);
            else {
              if (!(h2 in t2)) {
                ct(h2, a2);
                continue;
              }
              this.add(t2, h2, t2[h2], a2, r2, i2);
            }
            S2.push(h2);
          }
        }
        x2 && hn(this);
      }, get: Sr, aliases: Jn, getSetter: function(t2, e2, n2) {
        var r2 = Jn[e2];
        return r2 && r2.indexOf(",") < 0 && (e2 = r2), e2 in jn && e2 !== lr && (t2._gsap.x || Sr(t2, "x")) ? n2 && Mn === n2 ? "scale" === e2 ? ar : or : (Mn = n2 || {}) && ("scale" === e2 ? sr : cr) : t2.style && !W(t2.style[e2]) ? rr : ~e2.indexOf("-") ? ir : nn(t2, e2);
      }, core: { _removeProperty: br, _getMatrix: Dr } };
      gn.utils.checkPrefix = fr, Vr = Mt("x,y,z,scale,scaleX,scaleY,xPercent,yPercent," + (jr = "rotation,rotationX,rotationY,skewX,skewY") + ",transform,transformOrigin,svgOrigin,force3D,smoothOrigin,transformPerspective", function(t2) {
        jn[t2] = 1;
      }), Mt(jr, function(t2) {
        D.units[t2] = "deg", Pr[t2] = 1;
      }), Jn[Vr[13]] = "x,y,z,scale,scaleX,scaleY,xPercent,yPercent," + jr, Mt("0:translateX,1:translateY,2:translateZ,8:rotate,8:rotationZ,8:rotateZ,9:rotateX,10:rotateY", function(t2) {
        var e2 = t2.split(":");
        Jn[e2[1]] = Vr[e2[0]];
      }), Mt("x,y,z,top,right,bottom,left,width,height,fontSize,padding,margin,perspective", function(t2) {
        D.units[t2] = "px";
      }), gn.registerPlugin(Wr);
      var qr = gn.registerPlugin(Wr) || gn, Xr = qr.core.Tween;
    }, function(t, e, n) {
      !function(e2, r) {
        if (t.exports) t.exports = r(n(6));
        else {
          var i = e2.Zdog;
          i.PathCommand = r(i.Vector);
        }
      }(this, function(t2) {
        function e2(e3, i, o) {
          this.method = e3, this.points = i.map(n2), this.renderPoints = i.map(r), this.previousPoint = o, this.endRenderPoint = this.renderPoints[this.renderPoints.length - 1], "arc" == e3 && (this.controlPoints = [new t2(), new t2()]);
        }
        function n2(e3) {
          return e3 instanceof t2 ? e3 : new t2(e3);
        }
        function r(e3) {
          return new t2(e3);
        }
        e2.prototype.reset = function() {
          var t3 = this.points;
          this.renderPoints.forEach(function(e3, n3) {
            var r2 = t3[n3];
            e3.set(r2);
          });
        }, e2.prototype.transform = function(t3, e3, n3) {
          this.renderPoints.forEach(function(r2) {
            r2.transform(t3, e3, n3);
          });
        }, e2.prototype.render = function(t3, e3, n3) {
          return this[this.method](t3, e3, n3);
        }, e2.prototype.move = function(t3, e3, n3) {
          return n3.move(t3, e3, this.renderPoints[0]);
        }, e2.prototype.line = function(t3, e3, n3) {
          return n3.line(t3, e3, this.renderPoints[0]);
        }, e2.prototype.bezier = function(t3, e3, n3) {
          var r2 = this.renderPoints[0], i = this.renderPoints[1], o = this.renderPoints[2];
          return n3.bezier(t3, e3, r2, i, o);
        };
        return e2.prototype.arc = function(t3, e3, n3) {
          var r2 = this.previousPoint, i = this.renderPoints[0], o = this.renderPoints[1], a = this.controlPoints[0], s = this.controlPoints[1];
          return a.set(r2).lerp(i, 9 / 16), s.set(o).lerp(i, 9 / 16), n3.bezier(t3, e3, a, s, o);
        }, e2;
      });
    }, function(t, e, n) {
      !function(e2, r) {
        if (t.exports) t.exports = r(n(5));
        else {
          var i = e2.Zdog;
          i.Ellipse = r(i.Shape);
        }
      }(this, function(t2) {
        var e2 = t2.subclass({ diameter: 1, width: void 0, height: void 0, quarters: 4, closed: false });
        return e2.prototype.setPath = function() {
          var t3 = (null != this.width ? this.width : this.diameter) / 2, e3 = (null != this.height ? this.height : this.diameter) / 2;
          this.path = [{ x: 0, y: -e3 }, { arc: [{ x: t3, y: -e3 }, { x: t3, y: 0 }] }], this.quarters > 1 && this.path.push({ arc: [{ x: t3, y: e3 }, { x: 0, y: e3 }] }), this.quarters > 2 && this.path.push({ arc: [{ x: -t3, y: e3 }, { x: -t3, y: 0 }] }), this.quarters > 3 && this.path.push({ arc: [{ x: -t3, y: -e3 }, { x: 0, y: -e3 }] });
        }, e2;
      });
    }, function(t, e, n) {
      "use strict";
      n.r(e), n.d(e, "ACESFilmicToneMapping", function() {
        return nt;
      }), n.d(e, "AddEquation", function() {
        return T;
      }), n.d(e, "AddOperation", function() {
        return $;
      }), n.d(e, "AdditiveAnimationBlendMode", function() {
        return qe;
      }), n.d(e, "AdditiveBlending", function() {
        return w;
      }), n.d(e, "AlphaFormat", function() {
        return zt;
      }), n.d(e, "AlwaysDepth", function() {
        return U;
      }), n.d(e, "AlwaysStencilFunc", function() {
        return Sn;
      }), n.d(e, "AmbientLight", function() {
        return Dh;
      }), n.d(e, "AmbientLightProbe", function() {
        return ed;
      }), n.d(e, "AnimationClip", function() {
        return Hl;
      }), n.d(e, "AnimationLoader", function() {
        return Yl;
      }), n.d(e, "AnimationMixer", function() {
        return Od;
      }), n.d(e, "AnimationObjectGroup", function() {
        return Pd;
      }), n.d(e, "AnimationUtils", function() {
        return Al;
      }), n.d(e, "ArcCurve", function() {
        return nh;
      }), n.d(e, "ArrayCamera", function() {
        return Ps;
      }), n.d(e, "ArrowHelper", function() {
        return wp;
      }), n.d(e, "Audio", function() {
        return dd;
      }), n.d(e, "AudioAnalyser", function() {
        return yd;
      }), n.d(e, "AudioContext", function() {
        return Qh;
      }), n.d(e, "AudioListener", function() {
        return hd;
      }), n.d(e, "AudioLoader", function() {
        return Kh;
      }), n.d(e, "AxesHelper", function() {
        return _p;
      }), n.d(e, "AxisHelper", function() {
        return Mf;
      }), n.d(e, "BackSide", function() {
        return m;
      }), n.d(e, "BasicDepthPacking", function() {
        return on;
      }), n.d(e, "BasicShadowMap", function() {
        return l;
      }), n.d(e, "BinaryTextureLoader", function() {
        return Cf;
      }), n.d(e, "Bone", function() {
        return fc;
      }), n.d(e, "BooleanKeyframeTrack", function() {
        return Dl;
      }), n.d(e, "BoundingBoxHelper", function() {
        return Sf;
      }), n.d(e, "Box2", function() {
        return Ud;
      }), n.d(e, "Box3", function() {
        return tr;
      }), n.d(e, "Box3Helper", function() {
        return gp;
      }), n.d(e, "BoxBufferGeometry", function() {
        return mo;
      }), n.d(e, "BoxGeometry", function() {
        return Jc;
      }), n.d(e, "BoxHelper", function() {
        return mp;
      }), n.d(e, "BufferAttribute", function() {
        return Ti;
      }), n.d(e, "BufferGeometry", function() {
        return Xi;
      }), n.d(e, "BufferGeometryLoader", function() {
        return Gh;
      }), n.d(e, "ByteType", function() {
        return Tt;
      }), n.d(e, "Cache", function() {
        return Ul;
      }), n.d(e, "Camera", function() {
        return bo;
      }), n.d(e, "CameraHelper", function() {
        return dp;
      }), n.d(e, "CanvasRenderer", function() {
        return Rf;
      }), n.d(e, "CanvasTexture", function() {
        return jc;
      }), n.d(e, "CatmullRomCurve3", function() {
        return ch;
      }), n.d(e, "CineonToneMapping", function() {
        return et;
      }), n.d(e, "CircleBufferGeometry", function() {
        return $c;
      }), n.d(e, "CircleGeometry", function() {
        return Qc;
      }), n.d(e, "ClampToEdgeWrapping", function() {
        return dt;
      }), n.d(e, "Clock", function() {
        return od;
      }), n.d(e, "ClosedSplineCurve3", function() {
        return bf;
      }), n.d(e, "Color", function() {
        return yi;
      }), n.d(e, "ColorKeyframeTrack", function() {
        return Il;
      }), n.d(e, "CompressedTexture", function() {
        return Uc;
      }), n.d(e, "CompressedTextureLoader", function() {
        return Zl;
      }), n.d(e, "ConeBufferGeometry", function() {
        return nu;
      }), n.d(e, "ConeGeometry", function() {
        return eu;
      }), n.d(e, "CubeCamera", function() {
        return _o;
      }), n.d(e, "CubeGeometry", function() {
        return Jc;
      }), n.d(e, "CubeReflectionMapping", function() {
        return ot;
      }), n.d(e, "CubeRefractionMapping", function() {
        return at;
      }), n.d(e, "CubeTexture", function() {
        return Mo;
      }), n.d(e, "CubeTextureLoader", function() {
        return $l;
      }), n.d(e, "CubeUVReflectionMapping", function() {
        return ut;
      }), n.d(e, "CubeUVRefractionMapping", function() {
        return lt;
      }), n.d(e, "CubicBezierCurve", function() {
        return dh;
      }), n.d(e, "CubicBezierCurve3", function() {
        return ph;
      }), n.d(e, "CubicInterpolant", function() {
        return Ll;
      }), n.d(e, "CullFaceBack", function() {
        return s;
      }), n.d(e, "CullFaceFront", function() {
        return c;
      }), n.d(e, "CullFaceFrontBack", function() {
        return u;
      }), n.d(e, "CullFaceNone", function() {
        return a;
      }), n.d(e, "Curve", function() {
        return th;
      }), n.d(e, "CurvePath", function() {
        return bh;
      }), n.d(e, "CustomBlending", function() {
        return S;
      }), n.d(e, "CustomToneMapping", function() {
        return rt;
      }), n.d(e, "CylinderBufferGeometry", function() {
        return Kc;
      }), n.d(e, "CylinderGeometry", function() {
        return tu;
      }), n.d(e, "Cylindrical", function() {
        return Hd;
      }), n.d(e, "DataTexture", function() {
        return To;
      }), n.d(e, "DataTexture2DArray", function() {
        return Zo;
      }), n.d(e, "DataTexture3D", function() {
        return Jo;
      }), n.d(e, "DataTextureLoader", function() {
        return Ql;
      }), n.d(e, "DataUtils", function() {
        return Tp;
      }), n.d(e, "DecrementStencilOp", function() {
        return pn;
      }), n.d(e, "DecrementWrapStencilOp", function() {
        return mn;
      }), n.d(e, "DefaultLoadingManager", function() {
        return Vl;
      }), n.d(e, "DepthFormat", function() {
        return Ut;
      }), n.d(e, "DepthStencilFormat", function() {
        return jt;
      }), n.d(e, "DepthTexture", function() {
        return Vc;
      }), n.d(e, "DirectionalLight", function() {
        return Oh;
      }), n.d(e, "DirectionalLightHelper", function() {
        return up;
      }), n.d(e, "DiscreteInterpolant", function() {
        return Rl;
      }), n.d(e, "DodecahedronBufferGeometry", function() {
        return iu;
      }), n.d(e, "DodecahedronGeometry", function() {
        return ou;
      }), n.d(e, "DoubleSide", function() {
        return g;
      }), n.d(e, "DstAlphaFactor", function() {
        return z;
      }), n.d(e, "DstColorFactor", function() {
        return F;
      }), n.d(e, "DynamicBufferAttribute", function() {
        return lf;
      }), n.d(e, "DynamicCopyUsage", function() {
        return On;
      }), n.d(e, "DynamicDrawUsage", function() {
        return En;
      }), n.d(e, "DynamicReadUsage", function() {
        return Ln;
      }), n.d(e, "EdgesGeometry", function() {
        return lu;
      }), n.d(e, "EdgesHelper", function() {
        return Tf;
      }), n.d(e, "EllipseCurve", function() {
        return eh;
      }), n.d(e, "EqualDepth", function() {
        return W;
      }), n.d(e, "EqualStencilFunc", function() {
        return xn;
      }), n.d(e, "EquirectangularReflectionMapping", function() {
        return st;
      }), n.d(e, "EquirectangularRefractionMapping", function() {
        return ct;
      }), n.d(e, "Euler", function() {
        return Dr;
      }), n.d(e, "EventDispatcher", function() {
        return zn;
      }), n.d(e, "ExtrudeBufferGeometry", function() {
        return Bu;
      }), n.d(e, "ExtrudeGeometry", function() {
        return Gu;
      }), n.d(e, "Face3", function() {
        return xi;
      }), n.d(e, "Face4", function() {
        return Yp;
      }), n.d(e, "FaceColors", function() {
        return Qp;
      }), n.d(e, "FileLoader", function() {
        return Xl;
      }), n.d(e, "FlatShading", function() {
        return v;
      }), n.d(e, "Float16BufferAttribute", function() {
        return Di;
      }), n.d(e, "Float32Attribute", function() {
        return yf;
      }), n.d(e, "Float32BufferAttribute", function() {
        return Ii;
      }), n.d(e, "Float64Attribute", function() {
        return xf;
      }), n.d(e, "Float64BufferAttribute", function() {
        return Ni;
      }), n.d(e, "FloatType", function() {
        return Pt;
      }), n.d(e, "Fog", function() {
        return Fs;
      }), n.d(e, "FogExp2", function() {
        return ks;
      }), n.d(e, "Font", function() {
        return Yh;
      }), n.d(e, "FontLoader", function() {
        return Jh;
      }), n.d(e, "FrontSide", function() {
        return f;
      }), n.d(e, "Frustum", function() {
        return Co;
      }), n.d(e, "GLBufferAttribute", function() {
        return Nd;
      }), n.d(e, "GLSL1", function() {
        return In;
      }), n.d(e, "GLSL3", function() {
        return Nn;
      }), n.d(e, "GammaEncoding", function() {
        return Qe;
      }), n.d(e, "Geometry", function() {
        return Zc;
      }), n.d(e, "GeometryUtils", function() {
        return Pf;
      }), n.d(e, "GreaterDepth", function() {
        return X;
      }), n.d(e, "GreaterEqualDepth", function() {
        return q;
      }), n.d(e, "GreaterEqualStencilFunc", function() {
        return Mn;
      }), n.d(e, "GreaterStencilFunc", function() {
        return wn;
      }), n.d(e, "GridHelper", function() {
        return ip;
      }), n.d(e, "Group", function() {
        return Rs;
      }), n.d(e, "HalfFloatType", function() {
        return Rt;
      }), n.d(e, "HemisphereLight", function() {
        return Sh;
      }), n.d(e, "HemisphereLightHelper", function() {
        return rp;
      }), n.d(e, "HemisphereLightProbe", function() {
        return td;
      }), n.d(e, "IcosahedronBufferGeometry", function() {
        return Uu;
      }), n.d(e, "IcosahedronGeometry", function() {
        return ju;
      }), n.d(e, "ImageBitmapLoader", function() {
        return qh;
      }), n.d(e, "ImageLoader", function() {
        return Jl;
      }), n.d(e, "ImageUtils", function() {
        return jn;
      }), n.d(e, "ImmediateRenderObject", function() {
        return qd;
      }), n.d(e, "IncrementStencilOp", function() {
        return dn;
      }), n.d(e, "IncrementWrapStencilOp", function() {
        return fn;
      }), n.d(e, "InstancedBufferAttribute", function() {
        return Hh;
      }), n.d(e, "InstancedBufferGeometry", function() {
        return Bh;
      }), n.d(e, "InstancedInterleavedBuffer", function() {
        return Id;
      }), n.d(e, "InstancedMesh", function() {
        return _c;
      }), n.d(e, "Int16Attribute", function() {
        return ff;
      }), n.d(e, "Int16BufferAttribute", function() {
        return Li;
      }), n.d(e, "Int32Attribute", function() {
        return gf;
      }), n.d(e, "Int32BufferAttribute", function() {
        return Ri;
      }), n.d(e, "Int8Attribute", function() {
        return hf;
      }), n.d(e, "Int8BufferAttribute", function() {
        return Ei;
      }), n.d(e, "IntType", function() {
        return Ct;
      }), n.d(e, "InterleavedBuffer", function() {
        return Hs;
      }), n.d(e, "InterleavedBufferAttribute", function() {
        return Us;
      }), n.d(e, "Interpolant", function() {
        return Cl;
      }), n.d(e, "InterpolateDiscrete", function() {
        return Be;
      }), n.d(e, "InterpolateLinear", function() {
        return He;
      }), n.d(e, "InterpolateSmooth", function() {
        return Ge;
      }), n.d(e, "InvertStencilOp", function() {
        return gn;
      }), n.d(e, "JSONLoader", function() {
        return Of;
      }), n.d(e, "KeepStencilOp", function() {
        return ln;
      }), n.d(e, "KeyframeTrack", function() {
        return Ol;
      }), n.d(e, "LOD", function() {
        return sc;
      }), n.d(e, "LatheBufferGeometry", function() {
        return Vu;
      }), n.d(e, "LatheGeometry", function() {
        return Wu;
      }), n.d(e, "Layers", function() {
        return zr;
      }), n.d(e, "LensFlare", function() {
        return If;
      }), n.d(e, "LessDepth", function() {
        return j;
      }), n.d(e, "LessEqualDepth", function() {
        return V;
      }), n.d(e, "LessEqualStencilFunc", function() {
        return bn;
      }), n.d(e, "LessStencilFunc", function() {
        return yn;
      }), n.d(e, "Light", function() {
        return Mh;
      }), n.d(e, "LightProbe", function() {
        return zh;
      }), n.d(e, "Line", function() {
        return Lc;
      }), n.d(e, "Line3", function() {
        return Wd;
      }), n.d(e, "LineBasicMaterial", function() {
        return Mc;
      }), n.d(e, "LineCurve", function() {
        return fh;
      }), n.d(e, "LineCurve3", function() {
        return mh;
      }), n.d(e, "LineDashedMaterial", function() {
        return Tl;
      }), n.d(e, "LineLoop", function() {
        return Dc;
      }), n.d(e, "LinePieces", function() {
        return Jp;
      }), n.d(e, "LineSegments", function() {
        return Oc;
      }), n.d(e, "LineStrip", function() {
        return Zp;
      }), n.d(e, "LinearEncoding", function() {
        return Je;
      }), n.d(e, "LinearFilter", function() {
        return xt;
      }), n.d(e, "LinearInterpolant", function() {
        return Pl;
      }), n.d(e, "LinearMipMapLinearFilter", function() {
        return Mt;
      }), n.d(e, "LinearMipMapNearestFilter", function() {
        return wt;
      }), n.d(e, "LinearMipmapLinearFilter", function() {
        return _t;
      }), n.d(e, "LinearMipmapNearestFilter", function() {
        return bt;
      }), n.d(e, "LinearToneMapping", function() {
        return K;
      }), n.d(e, "Loader", function() {
        return Wl;
      }), n.d(e, "LoaderUtils", function() {
        return Fh;
      }), n.d(e, "LoadingManager", function() {
        return jl;
      }), n.d(e, "LogLuvEncoding", function() {
        return tn;
      }), n.d(e, "LoopOnce", function() {
        return ze;
      }), n.d(e, "LoopPingPong", function() {
        return Fe;
      }), n.d(e, "LoopRepeat", function() {
        return ke;
      }), n.d(e, "LuminanceAlphaFormat", function() {
        return Ht;
      }), n.d(e, "LuminanceFormat", function() {
        return Bt;
      }), n.d(e, "MOUSE", function() {
        return i;
      }), n.d(e, "Material", function() {
        return wi;
      }), n.d(e, "MaterialLoader", function() {
        return kh;
      }), n.d(e, "Math", function() {
        return Bn;
      }), n.d(e, "MathUtils", function() {
        return Bn;
      }), n.d(e, "Matrix3", function() {
        return Gn;
      }), n.d(e, "Matrix4", function() {
        return Tr;
      }), n.d(e, "MaxEquation", function() {
        return L;
      }), n.d(e, "Mesh", function() {
        return ho;
      }), n.d(e, "MeshBasicMaterial", function() {
        return _i;
      }), n.d(e, "MeshDepthMaterial", function() {
        return Ss;
      }), n.d(e, "MeshDistanceMaterial", function() {
        return Ts;
      }), n.d(e, "MeshFaceMaterial", function() {
        return tf;
      }), n.d(e, "MeshLambertMaterial", function() {
        return Ml;
      }), n.d(e, "MeshMatcapMaterial", function() {
        return Sl;
      }), n.d(e, "MeshNormalMaterial", function() {
        return _l;
      }), n.d(e, "MeshPhongMaterial", function() {
        return bl;
      }), n.d(e, "MeshPhysicalMaterial", function() {
        return xl;
      }), n.d(e, "MeshStandardMaterial", function() {
        return yl;
      }), n.d(e, "MeshToonMaterial", function() {
        return wl;
      }), n.d(e, "MinEquation", function() {
        return C;
      }), n.d(e, "MirroredRepeatWrapping", function() {
        return pt;
      }), n.d(e, "MixOperation", function() {
        return J;
      }), n.d(e, "MultiMaterial", function() {
        return ef;
      }), n.d(e, "MultiplyBlending", function() {
        return M;
      }), n.d(e, "MultiplyOperation", function() {
        return Z;
      }), n.d(e, "NearestFilter", function() {
        return ft;
      }), n.d(e, "NearestMipMapLinearFilter", function() {
        return yt;
      }), n.d(e, "NearestMipMapNearestFilter", function() {
        return gt;
      }), n.d(e, "NearestMipmapLinearFilter", function() {
        return vt;
      }), n.d(e, "NearestMipmapNearestFilter", function() {
        return mt;
      }), n.d(e, "NeverDepth", function() {
        return G;
      }), n.d(e, "NeverStencilFunc", function() {
        return vn;
      }), n.d(e, "NoBlending", function() {
        return x;
      }), n.d(e, "NoColors", function() {
        return $p;
      }), n.d(e, "NoToneMapping", function() {
        return Q;
      }), n.d(e, "NormalAnimationBlendMode", function() {
        return We;
      }), n.d(e, "NormalBlending", function() {
        return b;
      }), n.d(e, "NotEqualDepth", function() {
        return Y;
      }), n.d(e, "NotEqualStencilFunc", function() {
        return _n;
      }), n.d(e, "NumberKeyframeTrack", function() {
        return Nl;
      }), n.d(e, "Object3D", function() {
        return Jr;
      }), n.d(e, "ObjectLoader", function() {
        return Uh;
      }), n.d(e, "ObjectSpaceNormalMap", function() {
        return cn;
      }), n.d(e, "OctahedronBufferGeometry", function() {
        return qu;
      }), n.d(e, "OctahedronGeometry", function() {
        return Xu;
      }), n.d(e, "OneFactor", function() {
        return R;
      }), n.d(e, "OneMinusDstAlphaFactor", function() {
        return k;
      }), n.d(e, "OneMinusDstColorFactor", function() {
        return B;
      }), n.d(e, "OneMinusSrcAlphaFactor", function() {
        return N;
      }), n.d(e, "OneMinusSrcColorFactor", function() {
        return D;
      }), n.d(e, "OrthographicCamera", function() {
        return Ph;
      }), n.d(e, "PCFShadowMap", function() {
        return h;
      }), n.d(e, "PCFSoftShadowMap", function() {
        return d;
      }), n.d(e, "PMREMGenerator", function() {
        return Bp;
      }), n.d(e, "ParametricBufferGeometry", function() {
        return Yu;
      }), n.d(e, "ParametricGeometry", function() {
        return Zu;
      }), n.d(e, "Particle", function() {
        return rf;
      }), n.d(e, "ParticleBasicMaterial", function() {
        return sf;
      }), n.d(e, "ParticleSystem", function() {
        return of;
      }), n.d(e, "ParticleSystemMaterial", function() {
        return cf;
      }), n.d(e, "Path", function() {
        return wh;
      }), n.d(e, "PerspectiveCamera", function() {
        return wo;
      }), n.d(e, "Plane", function() {
        return ti;
      }), n.d(e, "PlaneBufferGeometry", function() {
        return Ro;
      }), n.d(e, "PlaneGeometry", function() {
        return Ju;
      }), n.d(e, "PlaneHelper", function() {
        return vp;
      }), n.d(e, "PointCloud", function() {
        return nf;
      }), n.d(e, "PointCloudMaterial", function() {
        return af;
      }), n.d(e, "PointLight", function() {
        return Lh;
      }), n.d(e, "PointLightHelper", function() {
        return Kd;
      }), n.d(e, "Points", function() {
        return Bc;
      }), n.d(e, "PointsMaterial", function() {
        return Ic;
      }), n.d(e, "PolarGridHelper", function() {
        return op;
      }), n.d(e, "PolyhedronBufferGeometry", function() {
        return ru;
      }), n.d(e, "PolyhedronGeometry", function() {
        return $u;
      }), n.d(e, "PositionalAudio", function() {
        return vd;
      }), n.d(e, "PropertyBinding", function() {
        return Ld;
      }), n.d(e, "PropertyMixer", function() {
        return xd;
      }), n.d(e, "QuadraticBezierCurve", function() {
        return gh;
      }), n.d(e, "QuadraticBezierCurve3", function() {
        return vh;
      }), n.d(e, "Quaternion", function() {
        return Jn;
      }), n.d(e, "QuaternionKeyframeTrack", function() {
        return kl;
      }), n.d(e, "QuaternionLinearInterpolant", function() {
        return zl;
      }), n.d(e, "REVISION", function() {
        return r;
      }), n.d(e, "RGBADepthPacking", function() {
        return an;
      }), n.d(e, "RGBAFormat", function() {
        return Ft;
      }), n.d(e, "RGBAIntegerFormat", function() {
        return Zt;
      }), n.d(e, "RGBA_ASTC_10x10_Format", function() {
        return ye;
      }), n.d(e, "RGBA_ASTC_10x5_Format", function() {
        return me;
      }), n.d(e, "RGBA_ASTC_10x6_Format", function() {
        return ge;
      }), n.d(e, "RGBA_ASTC_10x8_Format", function() {
        return ve;
      }), n.d(e, "RGBA_ASTC_12x10_Format", function() {
        return xe;
      }), n.d(e, "RGBA_ASTC_12x12_Format", function() {
        return be;
      }), n.d(e, "RGBA_ASTC_4x4_Format", function() {
        return se;
      }), n.d(e, "RGBA_ASTC_5x4_Format", function() {
        return ce;
      }), n.d(e, "RGBA_ASTC_5x5_Format", function() {
        return ue;
      }), n.d(e, "RGBA_ASTC_6x5_Format", function() {
        return le;
      }), n.d(e, "RGBA_ASTC_6x6_Format", function() {
        return he;
      }), n.d(e, "RGBA_ASTC_8x5_Format", function() {
        return de;
      }), n.d(e, "RGBA_ASTC_8x6_Format", function() {
        return pe;
      }), n.d(e, "RGBA_ASTC_8x8_Format", function() {
        return fe;
      }), n.d(e, "RGBA_BPTC_Format", function() {
        return we;
      }), n.d(e, "RGBA_ETC2_EAC_Format", function() {
        return ae;
      }), n.d(e, "RGBA_PVRTC_2BPPV1_Format", function() {
        return re;
      }), n.d(e, "RGBA_PVRTC_4BPPV1_Format", function() {
        return ne;
      }), n.d(e, "RGBA_S3TC_DXT1_Format", function() {
        return $t;
      }), n.d(e, "RGBA_S3TC_DXT3_Format", function() {
        return Qt;
      }), n.d(e, "RGBA_S3TC_DXT5_Format", function() {
        return Kt;
      }), n.d(e, "RGBDEncoding", function() {
        return rn;
      }), n.d(e, "RGBEEncoding", function() {
        return Ke;
      }), n.d(e, "RGBEFormat", function() {
        return Gt;
      }), n.d(e, "RGBFormat", function() {
        return kt;
      }), n.d(e, "RGBIntegerFormat", function() {
        return Yt;
      }), n.d(e, "RGBM16Encoding", function() {
        return nn;
      }), n.d(e, "RGBM7Encoding", function() {
        return en;
      }), n.d(e, "RGB_ETC1_Format", function() {
        return ie;
      }), n.d(e, "RGB_ETC2_Format", function() {
        return oe;
      }), n.d(e, "RGB_PVRTC_2BPPV1_Format", function() {
        return ee;
      }), n.d(e, "RGB_PVRTC_4BPPV1_Format", function() {
        return te;
      }), n.d(e, "RGB_S3TC_DXT1_Format", function() {
        return Jt;
      }), n.d(e, "RGFormat", function() {
        return qt;
      }), n.d(e, "RGIntegerFormat", function() {
        return Xt;
      }), n.d(e, "RawShaderMaterial", function() {
        return vl;
      }), n.d(e, "Ray", function() {
        return Sr;
      }), n.d(e, "Raycaster", function() {
        return zd;
      }), n.d(e, "RectAreaLight", function() {
        return Ih;
      }), n.d(e, "RedFormat", function() {
        return Vt;
      }), n.d(e, "RedIntegerFormat", function() {
        return Wt;
      }), n.d(e, "ReinhardToneMapping", function() {
        return tt;
      }), n.d(e, "RepeatWrapping", function() {
        return ht;
      }), n.d(e, "ReplaceStencilOp", function() {
        return hn;
      }), n.d(e, "ReverseSubtractEquation", function() {
        return A;
      }), n.d(e, "RingBufferGeometry", function() {
        return Qu;
      }), n.d(e, "RingGeometry", function() {
        return Ku;
      }), n.d(e, "SRGB8_ALPHA8_ASTC_10x10_Format", function() {
        return De;
      }), n.d(e, "SRGB8_ALPHA8_ASTC_10x5_Format", function() {
        return Pe;
      }), n.d(e, "SRGB8_ALPHA8_ASTC_10x6_Format", function() {
        return Re;
      }), n.d(e, "SRGB8_ALPHA8_ASTC_10x8_Format", function() {
        return Oe;
      }), n.d(e, "SRGB8_ALPHA8_ASTC_12x10_Format", function() {
        return Ie;
      }), n.d(e, "SRGB8_ALPHA8_ASTC_12x12_Format", function() {
        return Ne;
      }), n.d(e, "SRGB8_ALPHA8_ASTC_4x4_Format", function() {
        return _e;
      }), n.d(e, "SRGB8_ALPHA8_ASTC_5x4_Format", function() {
        return Me;
      }), n.d(e, "SRGB8_ALPHA8_ASTC_5x5_Format", function() {
        return Se;
      }), n.d(e, "SRGB8_ALPHA8_ASTC_6x5_Format", function() {
        return Te;
      }), n.d(e, "SRGB8_ALPHA8_ASTC_6x6_Format", function() {
        return Ee;
      }), n.d(e, "SRGB8_ALPHA8_ASTC_8x5_Format", function() {
        return Ae;
      }), n.d(e, "SRGB8_ALPHA8_ASTC_8x6_Format", function() {
        return Ce;
      }), n.d(e, "SRGB8_ALPHA8_ASTC_8x8_Format", function() {
        return Le;
      }), n.d(e, "Scene", function() {
        return Bs;
      }), n.d(e, "SceneUtils", function() {
        return Df;
      }), n.d(e, "ShaderChunk", function() {
        return Oo;
      }), n.d(e, "ShaderLib", function() {
        return Io;
      }), n.d(e, "ShaderMaterial", function() {
        return xo;
      }), n.d(e, "ShadowMaterial", function() {
        return gl;
      }), n.d(e, "Shape", function() {
        return _h;
      }), n.d(e, "ShapeBufferGeometry", function() {
        return tl;
      }), n.d(e, "ShapeGeometry", function() {
        return el;
      }), n.d(e, "ShapePath", function() {
        return Xh;
      }), n.d(e, "ShapeUtils", function() {
        return zu;
      }), n.d(e, "ShortType", function() {
        return Et;
      }), n.d(e, "Skeleton", function() {
        return vc;
      }), n.d(e, "SkeletonHelper", function() {
        return Qd;
      }), n.d(e, "SkinnedMesh", function() {
        return pc;
      }), n.d(e, "SmoothShading", function() {
        return y;
      }), n.d(e, "Sphere", function() {
        return gr;
      }), n.d(e, "SphereBufferGeometry", function() {
        return nl;
      }), n.d(e, "SphereGeometry", function() {
        return rl;
      }), n.d(e, "Spherical", function() {
        return Bd;
      }), n.d(e, "SphericalHarmonics3", function() {
        return Nh;
      }), n.d(e, "Spline", function() {
        return _f;
      }), n.d(e, "SplineCurve", function() {
        return yh;
      }), n.d(e, "SplineCurve3", function() {
        return wf;
      }), n.d(e, "SpotLight", function() {
        return Ah;
      }), n.d(e, "SpotLightHelper", function() {
        return Yd;
      }), n.d(e, "Sprite", function() {
        return rc;
      }), n.d(e, "SpriteMaterial", function() {
        return js;
      }), n.d(e, "SrcAlphaFactor", function() {
        return I;
      }), n.d(e, "SrcAlphaSaturateFactor", function() {
        return H;
      }), n.d(e, "SrcColorFactor", function() {
        return O;
      }), n.d(e, "StaticCopyUsage", function() {
        return Rn;
      }), n.d(e, "StaticDrawUsage", function() {
        return Tn;
      }), n.d(e, "StaticReadUsage", function() {
        return Cn;
      }), n.d(e, "StereoCamera", function() {
        return id;
      }), n.d(e, "StreamCopyUsage", function() {
        return Dn;
      }), n.d(e, "StreamDrawUsage", function() {
        return An;
      }), n.d(e, "StreamReadUsage", function() {
        return Pn;
      }), n.d(e, "StringKeyframeTrack", function() {
        return Fl;
      }), n.d(e, "SubtractEquation", function() {
        return E;
      }), n.d(e, "SubtractiveBlending", function() {
        return _;
      }), n.d(e, "TOUCH", function() {
        return o;
      }), n.d(e, "TangentSpaceNormalMap", function() {
        return sn;
      }), n.d(e, "TetrahedronBufferGeometry", function() {
        return il;
      }), n.d(e, "TetrahedronGeometry", function() {
        return ol;
      }), n.d(e, "TextBufferGeometry", function() {
        return al;
      }), n.d(e, "TextGeometry", function() {
        return sl;
      }), n.d(e, "Texture", function() {
        return Wn;
      }), n.d(e, "TextureLoader", function() {
        return Kl;
      }), n.d(e, "TorusBufferGeometry", function() {
        return cl;
      }), n.d(e, "TorusGeometry", function() {
        return ul;
      }), n.d(e, "TorusKnotBufferGeometry", function() {
        return ll;
      }), n.d(e, "TorusKnotGeometry", function() {
        return hl;
      }), n.d(e, "Triangle", function() {
        return hi;
      }), n.d(e, "TriangleFanDrawMode", function() {
        return Ze;
      }), n.d(e, "TriangleStripDrawMode", function() {
        return Ye;
      }), n.d(e, "TrianglesDrawMode", function() {
        return Xe;
      }), n.d(e, "TubeBufferGeometry", function() {
        return dl;
      }), n.d(e, "TubeGeometry", function() {
        return pl;
      }), n.d(e, "UVMapping", function() {
        return it;
      }), n.d(e, "Uint16Attribute", function() {
        return mf;
      }), n.d(e, "Uint16BufferAttribute", function() {
        return Pi;
      }), n.d(e, "Uint32Attribute", function() {
        return vf;
      }), n.d(e, "Uint32BufferAttribute", function() {
        return Oi;
      }), n.d(e, "Uint8Attribute", function() {
        return df;
      }), n.d(e, "Uint8BufferAttribute", function() {
        return Ai;
      }), n.d(e, "Uint8ClampedAttribute", function() {
        return pf;
      }), n.d(e, "Uint8ClampedBufferAttribute", function() {
        return Ci;
      }), n.d(e, "Uniform", function() {
        return Dd;
      }), n.d(e, "UniformsLib", function() {
        return Do;
      }), n.d(e, "UniformsUtils", function() {
        return yo;
      }), n.d(e, "UnsignedByteType", function() {
        return St;
      }), n.d(e, "UnsignedInt248Type", function() {
        return Nt;
      }), n.d(e, "UnsignedIntType", function() {
        return Lt;
      }), n.d(e, "UnsignedShort4444Type", function() {
        return Ot;
      }), n.d(e, "UnsignedShort5551Type", function() {
        return Dt;
      }), n.d(e, "UnsignedShort565Type", function() {
        return It;
      }), n.d(e, "UnsignedShortType", function() {
        return At;
      }), n.d(e, "VSMShadowMap", function() {
        return p;
      }), n.d(e, "Vector2", function() {
        return Hn;
      }), n.d(e, "Vector3", function() {
        return $n;
      }), n.d(e, "Vector4", function() {
        return Xn;
      }), n.d(e, "VectorKeyframeTrack", function() {
        return Bl;
      }), n.d(e, "Vertex", function() {
        return uf;
      }), n.d(e, "VertexColors", function() {
        return Kp;
      }), n.d(e, "VideoTexture", function() {
        return Gc;
      }), n.d(e, "WebGL1Renderer", function() {
        return zs;
      }), n.d(e, "WebGLCubeRenderTarget", function() {
        return So;
      }), n.d(e, "WebGLMultisampleRenderTarget", function() {
        return Zn;
      }), n.d(e, "WebGLRenderTarget", function() {
        return Yn;
      }), n.d(e, "WebGLRenderTargetCube", function() {
        return Lf;
      }), n.d(e, "WebGLRenderer", function() {
        return Ns;
      }), n.d(e, "WebGLUtils", function() {
        return Ls;
      }), n.d(e, "WireframeGeometry", function() {
        return fl;
      }), n.d(e, "WireframeHelper", function() {
        return Ef;
      }), n.d(e, "WrapAroundEnding", function() {
        return Ve;
      }), n.d(e, "XHRLoader", function() {
        return Af;
      }), n.d(e, "ZeroCurvatureEnding", function() {
        return Ue;
      }), n.d(e, "ZeroFactor", function() {
        return P;
      }), n.d(e, "ZeroSlopeEnding", function() {
        return je;
      }), n.d(e, "ZeroStencilOp", function() {
        return un;
      }), n.d(e, "sRGBEncoding", function() {
        return $e;
      });
      const r = "124", i = { LEFT: 0, MIDDLE: 1, RIGHT: 2, ROTATE: 0, DOLLY: 1, PAN: 2 }, o = { ROTATE: 0, PAN: 1, DOLLY_PAN: 2, DOLLY_ROTATE: 3 }, a = 0, s = 1, c = 2, u = 3, l = 0, h = 1, d = 2, p = 3, f = 0, m = 1, g = 2, v = 1, y = 2, x = 0, b = 1, w = 2, _ = 3, M = 4, S = 5, T = 100, E = 101, A = 102, C = 103, L = 104, P = 200, R = 201, O = 202, D = 203, I = 204, N = 205, z = 206, k = 207, F = 208, B = 209, H = 210, G = 0, U = 1, j = 2, V = 3, W = 4, q = 5, X = 6, Y = 7, Z = 0, J = 1, $ = 2, Q = 0, K = 1, tt = 2, et = 3, nt = 4, rt = 5, it = 300, ot = 301, at = 302, st = 303, ct = 304, ut = 306, lt = 307, ht = 1e3, dt = 1001, pt = 1002, ft = 1003, mt = 1004, gt = 1004, vt = 1005, yt = 1005, xt = 1006, bt = 1007, wt = 1007, _t = 1008, Mt = 1008, St = 1009, Tt = 1010, Et = 1011, At = 1012, Ct = 1013, Lt = 1014, Pt = 1015, Rt = 1016, Ot = 1017, Dt = 1018, It = 1019, Nt = 1020, zt = 1021, kt = 1022, Ft = 1023, Bt = 1024, Ht = 1025, Gt = Ft, Ut = 1026, jt = 1027, Vt = 1028, Wt = 1029, qt = 1030, Xt = 1031, Yt = 1032, Zt = 1033, Jt = 33776, $t = 33777, Qt = 33778, Kt = 33779, te = 35840, ee = 35841, ne = 35842, re = 35843, ie = 36196, oe = 37492, ae = 37496, se = 37808, ce = 37809, ue = 37810, le = 37811, he = 37812, de = 37813, pe = 37814, fe = 37815, me = 37816, ge = 37817, ve = 37818, ye = 37819, xe = 37820, be = 37821, we = 36492, _e = 37840, Me = 37841, Se = 37842, Te = 37843, Ee = 37844, Ae = 37845, Ce = 37846, Le = 37847, Pe = 37848, Re = 37849, Oe = 37850, De = 37851, Ie = 37852, Ne = 37853, ze = 2200, ke = 2201, Fe = 2202, Be = 2300, He = 2301, Ge = 2302, Ue = 2400, je = 2401, Ve = 2402, We = 2500, qe = 2501, Xe = 0, Ye = 1, Ze = 2, Je = 3e3, $e = 3001, Qe = 3007, Ke = 3002, tn = 3003, en = 3004, nn = 3005, rn = 3006, on = 3200, an = 3201, sn = 0, cn = 1, un = 0, ln = 7680, hn = 7681, dn = 7682, pn = 7683, fn = 34055, mn = 34056, gn = 5386, vn = 512, yn = 513, xn = 514, bn = 515, wn = 516, _n = 517, Mn = 518, Sn = 519, Tn = 35044, En = 35048, An = 35040, Cn = 35045, Ln = 35049, Pn = 35041, Rn = 35046, On = 35050, Dn = 35042, In = "100", Nn = "300 es";
      function zn() {
      }
      Object.assign(zn.prototype, { addEventListener: function(t2, e2) {
        void 0 === this._listeners && (this._listeners = {});
        const n2 = this._listeners;
        void 0 === n2[t2] && (n2[t2] = []), -1 === n2[t2].indexOf(e2) && n2[t2].push(e2);
      }, hasEventListener: function(t2, e2) {
        if (void 0 === this._listeners) return false;
        const n2 = this._listeners;
        return void 0 !== n2[t2] && -1 !== n2[t2].indexOf(e2);
      }, removeEventListener: function(t2, e2) {
        if (void 0 === this._listeners) return;
        const n2 = this._listeners[t2];
        if (void 0 !== n2) {
          const t3 = n2.indexOf(e2);
          -1 !== t3 && n2.splice(t3, 1);
        }
      }, dispatchEvent: function(t2) {
        if (void 0 === this._listeners) return;
        const e2 = this._listeners[t2.type];
        if (void 0 !== e2) {
          t2.target = this;
          const n2 = e2.slice(0);
          for (let e3 = 0, r2 = n2.length; e3 < r2; e3++) n2[e3].call(this, t2);
        }
      } });
      const kn = [];
      for (let t2 = 0; t2 < 256; t2++) kn[t2] = (t2 < 16 ? "0" : "") + t2.toString(16);
      let Fn = 1234567;
      const Bn = { DEG2RAD: Math.PI / 180, RAD2DEG: 180 / Math.PI, generateUUID: function() {
        const t2 = 4294967295 * Math.random() | 0, e2 = 4294967295 * Math.random() | 0, n2 = 4294967295 * Math.random() | 0, r2 = 4294967295 * Math.random() | 0;
        return (kn[255 & t2] + kn[t2 >> 8 & 255] + kn[t2 >> 16 & 255] + kn[t2 >> 24 & 255] + "-" + kn[255 & e2] + kn[e2 >> 8 & 255] + "-" + kn[e2 >> 16 & 15 | 64] + kn[e2 >> 24 & 255] + "-" + kn[63 & n2 | 128] + kn[n2 >> 8 & 255] + "-" + kn[n2 >> 16 & 255] + kn[n2 >> 24 & 255] + kn[255 & r2] + kn[r2 >> 8 & 255] + kn[r2 >> 16 & 255] + kn[r2 >> 24 & 255]).toUpperCase();
      }, clamp: function(t2, e2, n2) {
        return Math.max(e2, Math.min(n2, t2));
      }, euclideanModulo: function(t2, e2) {
        return (t2 % e2 + e2) % e2;
      }, mapLinear: function(t2, e2, n2, r2, i2) {
        return r2 + (t2 - e2) * (i2 - r2) / (n2 - e2);
      }, lerp: function(t2, e2, n2) {
        return (1 - n2) * t2 + n2 * e2;
      }, smoothstep: function(t2, e2, n2) {
        return t2 <= e2 ? 0 : t2 >= n2 ? 1 : (t2 = (t2 - e2) / (n2 - e2)) * t2 * (3 - 2 * t2);
      }, smootherstep: function(t2, e2, n2) {
        return t2 <= e2 ? 0 : t2 >= n2 ? 1 : (t2 = (t2 - e2) / (n2 - e2)) * t2 * t2 * (t2 * (6 * t2 - 15) + 10);
      }, randInt: function(t2, e2) {
        return t2 + Math.floor(Math.random() * (e2 - t2 + 1));
      }, randFloat: function(t2, e2) {
        return t2 + Math.random() * (e2 - t2);
      }, randFloatSpread: function(t2) {
        return t2 * (0.5 - Math.random());
      }, seededRandom: function(t2) {
        return void 0 !== t2 && (Fn = t2 % 2147483647), Fn = 16807 * Fn % 2147483647, (Fn - 1) / 2147483646;
      }, degToRad: function(t2) {
        return t2 * Bn.DEG2RAD;
      }, radToDeg: function(t2) {
        return t2 * Bn.RAD2DEG;
      }, isPowerOfTwo: function(t2) {
        return 0 == (t2 & t2 - 1) && 0 !== t2;
      }, ceilPowerOfTwo: function(t2) {
        return Math.pow(2, Math.ceil(Math.log(t2) / Math.LN2));
      }, floorPowerOfTwo: function(t2) {
        return Math.pow(2, Math.floor(Math.log(t2) / Math.LN2));
      }, setQuaternionFromProperEuler: function(t2, e2, n2, r2, i2) {
        const o2 = Math.cos, a2 = Math.sin, s2 = o2(n2 / 2), c2 = a2(n2 / 2), u2 = o2((e2 + r2) / 2), l2 = a2((e2 + r2) / 2), h2 = o2((e2 - r2) / 2), d2 = a2((e2 - r2) / 2), p2 = o2((r2 - e2) / 2), f2 = a2((r2 - e2) / 2);
        switch (i2) {
          case "XYX":
            t2.set(s2 * l2, c2 * h2, c2 * d2, s2 * u2);
            break;
          case "YZY":
            t2.set(c2 * d2, s2 * l2, c2 * h2, s2 * u2);
            break;
          case "ZXZ":
            t2.set(c2 * h2, c2 * d2, s2 * l2, s2 * u2);
            break;
          case "XZX":
            t2.set(s2 * l2, c2 * f2, c2 * p2, s2 * u2);
            break;
          case "YXY":
            t2.set(c2 * p2, s2 * l2, c2 * f2, s2 * u2);
            break;
          case "ZYZ":
            t2.set(c2 * f2, c2 * p2, s2 * l2, s2 * u2);
            break;
          default:
            console.warn("THREE.MathUtils: .setQuaternionFromProperEuler() encountered an unknown order: " + i2);
        }
      } };
      class Hn {
        constructor(t2 = 0, e2 = 0) {
          Object.defineProperty(this, "isVector2", { value: true }), this.x = t2, this.y = e2;
        }
        get width() {
          return this.x;
        }
        set width(t2) {
          this.x = t2;
        }
        get height() {
          return this.y;
        }
        set height(t2) {
          this.y = t2;
        }
        set(t2, e2) {
          return this.x = t2, this.y = e2, this;
        }
        setScalar(t2) {
          return this.x = t2, this.y = t2, this;
        }
        setX(t2) {
          return this.x = t2, this;
        }
        setY(t2) {
          return this.y = t2, this;
        }
        setComponent(t2, e2) {
          switch (t2) {
            case 0:
              this.x = e2;
              break;
            case 1:
              this.y = e2;
              break;
            default:
              throw new Error("index is out of range: " + t2);
          }
          return this;
        }
        getComponent(t2) {
          switch (t2) {
            case 0:
              return this.x;
            case 1:
              return this.y;
            default:
              throw new Error("index is out of range: " + t2);
          }
        }
        clone() {
          return new this.constructor(this.x, this.y);
        }
        copy(t2) {
          return this.x = t2.x, this.y = t2.y, this;
        }
        add(t2, e2) {
          return void 0 !== e2 ? (console.warn("THREE.Vector2: .add() now only accepts one argument. Use .addVectors( a, b ) instead."), this.addVectors(t2, e2)) : (this.x += t2.x, this.y += t2.y, this);
        }
        addScalar(t2) {
          return this.x += t2, this.y += t2, this;
        }
        addVectors(t2, e2) {
          return this.x = t2.x + e2.x, this.y = t2.y + e2.y, this;
        }
        addScaledVector(t2, e2) {
          return this.x += t2.x * e2, this.y += t2.y * e2, this;
        }
        sub(t2, e2) {
          return void 0 !== e2 ? (console.warn("THREE.Vector2: .sub() now only accepts one argument. Use .subVectors( a, b ) instead."), this.subVectors(t2, e2)) : (this.x -= t2.x, this.y -= t2.y, this);
        }
        subScalar(t2) {
          return this.x -= t2, this.y -= t2, this;
        }
        subVectors(t2, e2) {
          return this.x = t2.x - e2.x, this.y = t2.y - e2.y, this;
        }
        multiply(t2) {
          return this.x *= t2.x, this.y *= t2.y, this;
        }
        multiplyScalar(t2) {
          return this.x *= t2, this.y *= t2, this;
        }
        divide(t2) {
          return this.x /= t2.x, this.y /= t2.y, this;
        }
        divideScalar(t2) {
          return this.multiplyScalar(1 / t2);
        }
        applyMatrix3(t2) {
          const e2 = this.x, n2 = this.y, r2 = t2.elements;
          return this.x = r2[0] * e2 + r2[3] * n2 + r2[6], this.y = r2[1] * e2 + r2[4] * n2 + r2[7], this;
        }
        min(t2) {
          return this.x = Math.min(this.x, t2.x), this.y = Math.min(this.y, t2.y), this;
        }
        max(t2) {
          return this.x = Math.max(this.x, t2.x), this.y = Math.max(this.y, t2.y), this;
        }
        clamp(t2, e2) {
          return this.x = Math.max(t2.x, Math.min(e2.x, this.x)), this.y = Math.max(t2.y, Math.min(e2.y, this.y)), this;
        }
        clampScalar(t2, e2) {
          return this.x = Math.max(t2, Math.min(e2, this.x)), this.y = Math.max(t2, Math.min(e2, this.y)), this;
        }
        clampLength(t2, e2) {
          const n2 = this.length();
          return this.divideScalar(n2 || 1).multiplyScalar(Math.max(t2, Math.min(e2, n2)));
        }
        floor() {
          return this.x = Math.floor(this.x), this.y = Math.floor(this.y), this;
        }
        ceil() {
          return this.x = Math.ceil(this.x), this.y = Math.ceil(this.y), this;
        }
        round() {
          return this.x = Math.round(this.x), this.y = Math.round(this.y), this;
        }
        roundToZero() {
          return this.x = this.x < 0 ? Math.ceil(this.x) : Math.floor(this.x), this.y = this.y < 0 ? Math.ceil(this.y) : Math.floor(this.y), this;
        }
        negate() {
          return this.x = -this.x, this.y = -this.y, this;
        }
        dot(t2) {
          return this.x * t2.x + this.y * t2.y;
        }
        cross(t2) {
          return this.x * t2.y - this.y * t2.x;
        }
        lengthSq() {
          return this.x * this.x + this.y * this.y;
        }
        length() {
          return Math.sqrt(this.x * this.x + this.y * this.y);
        }
        manhattanLength() {
          return Math.abs(this.x) + Math.abs(this.y);
        }
        normalize() {
          return this.divideScalar(this.length() || 1);
        }
        angle() {
          return Math.atan2(-this.y, -this.x) + Math.PI;
        }
        distanceTo(t2) {
          return Math.sqrt(this.distanceToSquared(t2));
        }
        distanceToSquared(t2) {
          const e2 = this.x - t2.x, n2 = this.y - t2.y;
          return e2 * e2 + n2 * n2;
        }
        manhattanDistanceTo(t2) {
          return Math.abs(this.x - t2.x) + Math.abs(this.y - t2.y);
        }
        setLength(t2) {
          return this.normalize().multiplyScalar(t2);
        }
        lerp(t2, e2) {
          return this.x += (t2.x - this.x) * e2, this.y += (t2.y - this.y) * e2, this;
        }
        lerpVectors(t2, e2, n2) {
          return this.x = t2.x + (e2.x - t2.x) * n2, this.y = t2.y + (e2.y - t2.y) * n2, this;
        }
        equals(t2) {
          return t2.x === this.x && t2.y === this.y;
        }
        fromArray(t2, e2 = 0) {
          return this.x = t2[e2], this.y = t2[e2 + 1], this;
        }
        toArray(t2 = [], e2 = 0) {
          return t2[e2] = this.x, t2[e2 + 1] = this.y, t2;
        }
        fromBufferAttribute(t2, e2, n2) {
          return void 0 !== n2 && console.warn("THREE.Vector2: offset has been removed from .fromBufferAttribute()."), this.x = t2.getX(e2), this.y = t2.getY(e2), this;
        }
        rotateAround(t2, e2) {
          const n2 = Math.cos(e2), r2 = Math.sin(e2), i2 = this.x - t2.x, o2 = this.y - t2.y;
          return this.x = i2 * n2 - o2 * r2 + t2.x, this.y = i2 * r2 + o2 * n2 + t2.y, this;
        }
        random() {
          return this.x = Math.random(), this.y = Math.random(), this;
        }
      }
      class Gn {
        constructor() {
          Object.defineProperty(this, "isMatrix3", { value: true }), this.elements = [1, 0, 0, 0, 1, 0, 0, 0, 1], arguments.length > 0 && console.error("THREE.Matrix3: the constructor no longer reads arguments. use .set() instead.");
        }
        set(t2, e2, n2, r2, i2, o2, a2, s2, c2) {
          const u2 = this.elements;
          return u2[0] = t2, u2[1] = r2, u2[2] = a2, u2[3] = e2, u2[4] = i2, u2[5] = s2, u2[6] = n2, u2[7] = o2, u2[8] = c2, this;
        }
        identity() {
          return this.set(1, 0, 0, 0, 1, 0, 0, 0, 1), this;
        }
        clone() {
          return new this.constructor().fromArray(this.elements);
        }
        copy(t2) {
          const e2 = this.elements, n2 = t2.elements;
          return e2[0] = n2[0], e2[1] = n2[1], e2[2] = n2[2], e2[3] = n2[3], e2[4] = n2[4], e2[5] = n2[5], e2[6] = n2[6], e2[7] = n2[7], e2[8] = n2[8], this;
        }
        extractBasis(t2, e2, n2) {
          return t2.setFromMatrix3Column(this, 0), e2.setFromMatrix3Column(this, 1), n2.setFromMatrix3Column(this, 2), this;
        }
        setFromMatrix4(t2) {
          const e2 = t2.elements;
          return this.set(e2[0], e2[4], e2[8], e2[1], e2[5], e2[9], e2[2], e2[6], e2[10]), this;
        }
        multiply(t2) {
          return this.multiplyMatrices(this, t2);
        }
        premultiply(t2) {
          return this.multiplyMatrices(t2, this);
        }
        multiplyMatrices(t2, e2) {
          const n2 = t2.elements, r2 = e2.elements, i2 = this.elements, o2 = n2[0], a2 = n2[3], s2 = n2[6], c2 = n2[1], u2 = n2[4], l2 = n2[7], h2 = n2[2], d2 = n2[5], p2 = n2[8], f2 = r2[0], m2 = r2[3], g2 = r2[6], v2 = r2[1], y2 = r2[4], x2 = r2[7], b2 = r2[2], w2 = r2[5], _2 = r2[8];
          return i2[0] = o2 * f2 + a2 * v2 + s2 * b2, i2[3] = o2 * m2 + a2 * y2 + s2 * w2, i2[6] = o2 * g2 + a2 * x2 + s2 * _2, i2[1] = c2 * f2 + u2 * v2 + l2 * b2, i2[4] = c2 * m2 + u2 * y2 + l2 * w2, i2[7] = c2 * g2 + u2 * x2 + l2 * _2, i2[2] = h2 * f2 + d2 * v2 + p2 * b2, i2[5] = h2 * m2 + d2 * y2 + p2 * w2, i2[8] = h2 * g2 + d2 * x2 + p2 * _2, this;
        }
        multiplyScalar(t2) {
          const e2 = this.elements;
          return e2[0] *= t2, e2[3] *= t2, e2[6] *= t2, e2[1] *= t2, e2[4] *= t2, e2[7] *= t2, e2[2] *= t2, e2[5] *= t2, e2[8] *= t2, this;
        }
        determinant() {
          const t2 = this.elements, e2 = t2[0], n2 = t2[1], r2 = t2[2], i2 = t2[3], o2 = t2[4], a2 = t2[5], s2 = t2[6], c2 = t2[7], u2 = t2[8];
          return e2 * o2 * u2 - e2 * a2 * c2 - n2 * i2 * u2 + n2 * a2 * s2 + r2 * i2 * c2 - r2 * o2 * s2;
        }
        invert() {
          const t2 = this.elements, e2 = t2[0], n2 = t2[1], r2 = t2[2], i2 = t2[3], o2 = t2[4], a2 = t2[5], s2 = t2[6], c2 = t2[7], u2 = t2[8], l2 = u2 * o2 - a2 * c2, h2 = a2 * s2 - u2 * i2, d2 = c2 * i2 - o2 * s2, p2 = e2 * l2 + n2 * h2 + r2 * d2;
          if (0 === p2) return this.set(0, 0, 0, 0, 0, 0, 0, 0, 0);
          const f2 = 1 / p2;
          return t2[0] = l2 * f2, t2[1] = (r2 * c2 - u2 * n2) * f2, t2[2] = (a2 * n2 - r2 * o2) * f2, t2[3] = h2 * f2, t2[4] = (u2 * e2 - r2 * s2) * f2, t2[5] = (r2 * i2 - a2 * e2) * f2, t2[6] = d2 * f2, t2[7] = (n2 * s2 - c2 * e2) * f2, t2[8] = (o2 * e2 - n2 * i2) * f2, this;
        }
        transpose() {
          let t2;
          const e2 = this.elements;
          return t2 = e2[1], e2[1] = e2[3], e2[3] = t2, t2 = e2[2], e2[2] = e2[6], e2[6] = t2, t2 = e2[5], e2[5] = e2[7], e2[7] = t2, this;
        }
        getNormalMatrix(t2) {
          return this.setFromMatrix4(t2).copy(this).invert().transpose();
        }
        transposeIntoArray(t2) {
          const e2 = this.elements;
          return t2[0] = e2[0], t2[1] = e2[3], t2[2] = e2[6], t2[3] = e2[1], t2[4] = e2[4], t2[5] = e2[7], t2[6] = e2[2], t2[7] = e2[5], t2[8] = e2[8], this;
        }
        setUvTransform(t2, e2, n2, r2, i2, o2, a2) {
          const s2 = Math.cos(i2), c2 = Math.sin(i2);
          return this.set(n2 * s2, n2 * c2, -n2 * (s2 * o2 + c2 * a2) + o2 + t2, -r2 * c2, r2 * s2, -r2 * (-c2 * o2 + s2 * a2) + a2 + e2, 0, 0, 1), this;
        }
        scale(t2, e2) {
          const n2 = this.elements;
          return n2[0] *= t2, n2[3] *= t2, n2[6] *= t2, n2[1] *= e2, n2[4] *= e2, n2[7] *= e2, this;
        }
        rotate(t2) {
          const e2 = Math.cos(t2), n2 = Math.sin(t2), r2 = this.elements, i2 = r2[0], o2 = r2[3], a2 = r2[6], s2 = r2[1], c2 = r2[4], u2 = r2[7];
          return r2[0] = e2 * i2 + n2 * s2, r2[3] = e2 * o2 + n2 * c2, r2[6] = e2 * a2 + n2 * u2, r2[1] = -n2 * i2 + e2 * s2, r2[4] = -n2 * o2 + e2 * c2, r2[7] = -n2 * a2 + e2 * u2, this;
        }
        translate(t2, e2) {
          const n2 = this.elements;
          return n2[0] += t2 * n2[2], n2[3] += t2 * n2[5], n2[6] += t2 * n2[8], n2[1] += e2 * n2[2], n2[4] += e2 * n2[5], n2[7] += e2 * n2[8], this;
        }
        equals(t2) {
          const e2 = this.elements, n2 = t2.elements;
          for (let t3 = 0; t3 < 9; t3++) if (e2[t3] !== n2[t3]) return false;
          return true;
        }
        fromArray(t2, e2 = 0) {
          for (let n2 = 0; n2 < 9; n2++) this.elements[n2] = t2[n2 + e2];
          return this;
        }
        toArray(t2 = [], e2 = 0) {
          const n2 = this.elements;
          return t2[e2] = n2[0], t2[e2 + 1] = n2[1], t2[e2 + 2] = n2[2], t2[e2 + 3] = n2[3], t2[e2 + 4] = n2[4], t2[e2 + 5] = n2[5], t2[e2 + 6] = n2[6], t2[e2 + 7] = n2[7], t2[e2 + 8] = n2[8], t2;
        }
      }
      let Un;
      const jn = { getDataURL: function(t2) {
        if (/^data:/i.test(t2.src)) return t2.src;
        if ("undefined" == typeof HTMLCanvasElement) return t2.src;
        let e2;
        if (t2 instanceof HTMLCanvasElement) e2 = t2;
        else {
          void 0 === Un && (Un = document.createElementNS("http://www.w3.org/1999/xhtml", "canvas")), Un.width = t2.width, Un.height = t2.height;
          const n2 = Un.getContext("2d");
          t2 instanceof ImageData ? n2.putImageData(t2, 0, 0) : n2.drawImage(t2, 0, 0, t2.width, t2.height), e2 = Un;
        }
        return e2.width > 2048 || e2.height > 2048 ? e2.toDataURL("image/jpeg", 0.6) : e2.toDataURL("image/png");
      } };
      let Vn = 0;
      function Wn(t2 = Wn.DEFAULT_IMAGE, e2 = Wn.DEFAULT_MAPPING, n2 = dt, r2 = dt, i2 = xt, o2 = _t, a2 = Ft, s2 = St, c2 = 1, u2 = Je) {
        Object.defineProperty(this, "id", { value: Vn++ }), this.uuid = Bn.generateUUID(), this.name = "", this.image = t2, this.mipmaps = [], this.mapping = e2, this.wrapS = n2, this.wrapT = r2, this.magFilter = i2, this.minFilter = o2, this.anisotropy = c2, this.format = a2, this.internalFormat = null, this.type = s2, this.offset = new Hn(0, 0), this.repeat = new Hn(1, 1), this.center = new Hn(0, 0), this.rotation = 0, this.matrixAutoUpdate = true, this.matrix = new Gn(), this.generateMipmaps = true, this.premultiplyAlpha = false, this.flipY = true, this.unpackAlignment = 4, this.encoding = u2, this.version = 0, this.onUpdate = null;
      }
      function qn(t2) {
        return "undefined" != typeof HTMLImageElement && t2 instanceof HTMLImageElement || "undefined" != typeof HTMLCanvasElement && t2 instanceof HTMLCanvasElement || "undefined" != typeof ImageBitmap && t2 instanceof ImageBitmap ? jn.getDataURL(t2) : t2.data ? { data: Array.prototype.slice.call(t2.data), width: t2.width, height: t2.height, type: t2.data.constructor.name } : (console.warn("THREE.Texture: Unable to serialize Texture."), {});
      }
      Wn.DEFAULT_IMAGE = void 0, Wn.DEFAULT_MAPPING = it, Wn.prototype = Object.assign(Object.create(zn.prototype), { constructor: Wn, isTexture: true, updateMatrix: function() {
        this.matrix.setUvTransform(this.offset.x, this.offset.y, this.repeat.x, this.repeat.y, this.rotation, this.center.x, this.center.y);
      }, clone: function() {
        return new this.constructor().copy(this);
      }, copy: function(t2) {
        return this.name = t2.name, this.image = t2.image, this.mipmaps = t2.mipmaps.slice(0), this.mapping = t2.mapping, this.wrapS = t2.wrapS, this.wrapT = t2.wrapT, this.magFilter = t2.magFilter, this.minFilter = t2.minFilter, this.anisotropy = t2.anisotropy, this.format = t2.format, this.internalFormat = t2.internalFormat, this.type = t2.type, this.offset.copy(t2.offset), this.repeat.copy(t2.repeat), this.center.copy(t2.center), this.rotation = t2.rotation, this.matrixAutoUpdate = t2.matrixAutoUpdate, this.matrix.copy(t2.matrix), this.generateMipmaps = t2.generateMipmaps, this.premultiplyAlpha = t2.premultiplyAlpha, this.flipY = t2.flipY, this.unpackAlignment = t2.unpackAlignment, this.encoding = t2.encoding, this;
      }, toJSON: function(t2) {
        const e2 = void 0 === t2 || "string" == typeof t2;
        if (!e2 && void 0 !== t2.textures[this.uuid]) return t2.textures[this.uuid];
        const n2 = { metadata: { version: 4.5, type: "Texture", generator: "Texture.toJSON" }, uuid: this.uuid, name: this.name, mapping: this.mapping, repeat: [this.repeat.x, this.repeat.y], offset: [this.offset.x, this.offset.y], center: [this.center.x, this.center.y], rotation: this.rotation, wrap: [this.wrapS, this.wrapT], format: this.format, type: this.type, encoding: this.encoding, minFilter: this.minFilter, magFilter: this.magFilter, anisotropy: this.anisotropy, flipY: this.flipY, premultiplyAlpha: this.premultiplyAlpha, unpackAlignment: this.unpackAlignment };
        if (void 0 !== this.image) {
          const r2 = this.image;
          if (void 0 === r2.uuid && (r2.uuid = Bn.generateUUID()), !e2 && void 0 === t2.images[r2.uuid]) {
            let e3;
            if (Array.isArray(r2)) {
              e3 = [];
              for (let t3 = 0, n3 = r2.length; t3 < n3; t3++) r2[t3].isDataTexture ? e3.push(qn(r2[t3].image)) : e3.push(qn(r2[t3]));
            } else e3 = qn(r2);
            t2.images[r2.uuid] = { uuid: r2.uuid, url: e3 };
          }
          n2.image = r2.uuid;
        }
        return e2 || (t2.textures[this.uuid] = n2), n2;
      }, dispose: function() {
        this.dispatchEvent({ type: "dispose" });
      }, transformUv: function(t2) {
        if (this.mapping !== it) return t2;
        if (t2.applyMatrix3(this.matrix), t2.x < 0 || t2.x > 1) switch (this.wrapS) {
          case ht:
            t2.x = t2.x - Math.floor(t2.x);
            break;
          case dt:
            t2.x = t2.x < 0 ? 0 : 1;
            break;
          case pt:
            1 === Math.abs(Math.floor(t2.x) % 2) ? t2.x = Math.ceil(t2.x) - t2.x : t2.x = t2.x - Math.floor(t2.x);
        }
        if (t2.y < 0 || t2.y > 1) switch (this.wrapT) {
          case ht:
            t2.y = t2.y - Math.floor(t2.y);
            break;
          case dt:
            t2.y = t2.y < 0 ? 0 : 1;
            break;
          case pt:
            1 === Math.abs(Math.floor(t2.y) % 2) ? t2.y = Math.ceil(t2.y) - t2.y : t2.y = t2.y - Math.floor(t2.y);
        }
        return this.flipY && (t2.y = 1 - t2.y), t2;
      } }), Object.defineProperty(Wn.prototype, "needsUpdate", { set: function(t2) {
        true === t2 && this.version++;
      } });
      class Xn {
        constructor(t2 = 0, e2 = 0, n2 = 0, r2 = 1) {
          Object.defineProperty(this, "isVector4", { value: true }), this.x = t2, this.y = e2, this.z = n2, this.w = r2;
        }
        get width() {
          return this.z;
        }
        set width(t2) {
          this.z = t2;
        }
        get height() {
          return this.w;
        }
        set height(t2) {
          this.w = t2;
        }
        set(t2, e2, n2, r2) {
          return this.x = t2, this.y = e2, this.z = n2, this.w = r2, this;
        }
        setScalar(t2) {
          return this.x = t2, this.y = t2, this.z = t2, this.w = t2, this;
        }
        setX(t2) {
          return this.x = t2, this;
        }
        setY(t2) {
          return this.y = t2, this;
        }
        setZ(t2) {
          return this.z = t2, this;
        }
        setW(t2) {
          return this.w = t2, this;
        }
        setComponent(t2, e2) {
          switch (t2) {
            case 0:
              this.x = e2;
              break;
            case 1:
              this.y = e2;
              break;
            case 2:
              this.z = e2;
              break;
            case 3:
              this.w = e2;
              break;
            default:
              throw new Error("index is out of range: " + t2);
          }
          return this;
        }
        getComponent(t2) {
          switch (t2) {
            case 0:
              return this.x;
            case 1:
              return this.y;
            case 2:
              return this.z;
            case 3:
              return this.w;
            default:
              throw new Error("index is out of range: " + t2);
          }
        }
        clone() {
          return new this.constructor(this.x, this.y, this.z, this.w);
        }
        copy(t2) {
          return this.x = t2.x, this.y = t2.y, this.z = t2.z, this.w = void 0 !== t2.w ? t2.w : 1, this;
        }
        add(t2, e2) {
          return void 0 !== e2 ? (console.warn("THREE.Vector4: .add() now only accepts one argument. Use .addVectors( a, b ) instead."), this.addVectors(t2, e2)) : (this.x += t2.x, this.y += t2.y, this.z += t2.z, this.w += t2.w, this);
        }
        addScalar(t2) {
          return this.x += t2, this.y += t2, this.z += t2, this.w += t2, this;
        }
        addVectors(t2, e2) {
          return this.x = t2.x + e2.x, this.y = t2.y + e2.y, this.z = t2.z + e2.z, this.w = t2.w + e2.w, this;
        }
        addScaledVector(t2, e2) {
          return this.x += t2.x * e2, this.y += t2.y * e2, this.z += t2.z * e2, this.w += t2.w * e2, this;
        }
        sub(t2, e2) {
          return void 0 !== e2 ? (console.warn("THREE.Vector4: .sub() now only accepts one argument. Use .subVectors( a, b ) instead."), this.subVectors(t2, e2)) : (this.x -= t2.x, this.y -= t2.y, this.z -= t2.z, this.w -= t2.w, this);
        }
        subScalar(t2) {
          return this.x -= t2, this.y -= t2, this.z -= t2, this.w -= t2, this;
        }
        subVectors(t2, e2) {
          return this.x = t2.x - e2.x, this.y = t2.y - e2.y, this.z = t2.z - e2.z, this.w = t2.w - e2.w, this;
        }
        multiplyScalar(t2) {
          return this.x *= t2, this.y *= t2, this.z *= t2, this.w *= t2, this;
        }
        applyMatrix4(t2) {
          const e2 = this.x, n2 = this.y, r2 = this.z, i2 = this.w, o2 = t2.elements;
          return this.x = o2[0] * e2 + o2[4] * n2 + o2[8] * r2 + o2[12] * i2, this.y = o2[1] * e2 + o2[5] * n2 + o2[9] * r2 + o2[13] * i2, this.z = o2[2] * e2 + o2[6] * n2 + o2[10] * r2 + o2[14] * i2, this.w = o2[3] * e2 + o2[7] * n2 + o2[11] * r2 + o2[15] * i2, this;
        }
        divideScalar(t2) {
          return this.multiplyScalar(1 / t2);
        }
        setAxisAngleFromQuaternion(t2) {
          this.w = 2 * Math.acos(t2.w);
          const e2 = Math.sqrt(1 - t2.w * t2.w);
          return e2 < 1e-4 ? (this.x = 1, this.y = 0, this.z = 0) : (this.x = t2.x / e2, this.y = t2.y / e2, this.z = t2.z / e2), this;
        }
        setAxisAngleFromRotationMatrix(t2) {
          let e2, n2, r2, i2;
          const o2 = t2.elements, a2 = o2[0], s2 = o2[4], c2 = o2[8], u2 = o2[1], l2 = o2[5], h2 = o2[9], d2 = o2[2], p2 = o2[6], f2 = o2[10];
          if (Math.abs(s2 - u2) < 0.01 && Math.abs(c2 - d2) < 0.01 && Math.abs(h2 - p2) < 0.01) {
            if (Math.abs(s2 + u2) < 0.1 && Math.abs(c2 + d2) < 0.1 && Math.abs(h2 + p2) < 0.1 && Math.abs(a2 + l2 + f2 - 3) < 0.1) return this.set(1, 0, 0, 0), this;
            e2 = Math.PI;
            const t3 = (a2 + 1) / 2, o3 = (l2 + 1) / 2, m3 = (f2 + 1) / 2, g2 = (s2 + u2) / 4, v2 = (c2 + d2) / 4, y2 = (h2 + p2) / 4;
            return t3 > o3 && t3 > m3 ? t3 < 0.01 ? (n2 = 0, r2 = 0.707106781, i2 = 0.707106781) : (n2 = Math.sqrt(t3), r2 = g2 / n2, i2 = v2 / n2) : o3 > m3 ? o3 < 0.01 ? (n2 = 0.707106781, r2 = 0, i2 = 0.707106781) : (r2 = Math.sqrt(o3), n2 = g2 / r2, i2 = y2 / r2) : m3 < 0.01 ? (n2 = 0.707106781, r2 = 0.707106781, i2 = 0) : (i2 = Math.sqrt(m3), n2 = v2 / i2, r2 = y2 / i2), this.set(n2, r2, i2, e2), this;
          }
          let m2 = Math.sqrt((p2 - h2) * (p2 - h2) + (c2 - d2) * (c2 - d2) + (u2 - s2) * (u2 - s2));
          return Math.abs(m2) < 1e-3 && (m2 = 1), this.x = (p2 - h2) / m2, this.y = (c2 - d2) / m2, this.z = (u2 - s2) / m2, this.w = Math.acos((a2 + l2 + f2 - 1) / 2), this;
        }
        min(t2) {
          return this.x = Math.min(this.x, t2.x), this.y = Math.min(this.y, t2.y), this.z = Math.min(this.z, t2.z), this.w = Math.min(this.w, t2.w), this;
        }
        max(t2) {
          return this.x = Math.max(this.x, t2.x), this.y = Math.max(this.y, t2.y), this.z = Math.max(this.z, t2.z), this.w = Math.max(this.w, t2.w), this;
        }
        clamp(t2, e2) {
          return this.x = Math.max(t2.x, Math.min(e2.x, this.x)), this.y = Math.max(t2.y, Math.min(e2.y, this.y)), this.z = Math.max(t2.z, Math.min(e2.z, this.z)), this.w = Math.max(t2.w, Math.min(e2.w, this.w)), this;
        }
        clampScalar(t2, e2) {
          return this.x = Math.max(t2, Math.min(e2, this.x)), this.y = Math.max(t2, Math.min(e2, this.y)), this.z = Math.max(t2, Math.min(e2, this.z)), this.w = Math.max(t2, Math.min(e2, this.w)), this;
        }
        clampLength(t2, e2) {
          const n2 = this.length();
          return this.divideScalar(n2 || 1).multiplyScalar(Math.max(t2, Math.min(e2, n2)));
        }
        floor() {
          return this.x = Math.floor(this.x), this.y = Math.floor(this.y), this.z = Math.floor(this.z), this.w = Math.floor(this.w), this;
        }
        ceil() {
          return this.x = Math.ceil(this.x), this.y = Math.ceil(this.y), this.z = Math.ceil(this.z), this.w = Math.ceil(this.w), this;
        }
        round() {
          return this.x = Math.round(this.x), this.y = Math.round(this.y), this.z = Math.round(this.z), this.w = Math.round(this.w), this;
        }
        roundToZero() {
          return this.x = this.x < 0 ? Math.ceil(this.x) : Math.floor(this.x), this.y = this.y < 0 ? Math.ceil(this.y) : Math.floor(this.y), this.z = this.z < 0 ? Math.ceil(this.z) : Math.floor(this.z), this.w = this.w < 0 ? Math.ceil(this.w) : Math.floor(this.w), this;
        }
        negate() {
          return this.x = -this.x, this.y = -this.y, this.z = -this.z, this.w = -this.w, this;
        }
        dot(t2) {
          return this.x * t2.x + this.y * t2.y + this.z * t2.z + this.w * t2.w;
        }
        lengthSq() {
          return this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w;
        }
        length() {
          return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w);
        }
        manhattanLength() {
          return Math.abs(this.x) + Math.abs(this.y) + Math.abs(this.z) + Math.abs(this.w);
        }
        normalize() {
          return this.divideScalar(this.length() || 1);
        }
        setLength(t2) {
          return this.normalize().multiplyScalar(t2);
        }
        lerp(t2, e2) {
          return this.x += (t2.x - this.x) * e2, this.y += (t2.y - this.y) * e2, this.z += (t2.z - this.z) * e2, this.w += (t2.w - this.w) * e2, this;
        }
        lerpVectors(t2, e2, n2) {
          return this.x = t2.x + (e2.x - t2.x) * n2, this.y = t2.y + (e2.y - t2.y) * n2, this.z = t2.z + (e2.z - t2.z) * n2, this.w = t2.w + (e2.w - t2.w) * n2, this;
        }
        equals(t2) {
          return t2.x === this.x && t2.y === this.y && t2.z === this.z && t2.w === this.w;
        }
        fromArray(t2, e2 = 0) {
          return this.x = t2[e2], this.y = t2[e2 + 1], this.z = t2[e2 + 2], this.w = t2[e2 + 3], this;
        }
        toArray(t2 = [], e2 = 0) {
          return t2[e2] = this.x, t2[e2 + 1] = this.y, t2[e2 + 2] = this.z, t2[e2 + 3] = this.w, t2;
        }
        fromBufferAttribute(t2, e2, n2) {
          return void 0 !== n2 && console.warn("THREE.Vector4: offset has been removed from .fromBufferAttribute()."), this.x = t2.getX(e2), this.y = t2.getY(e2), this.z = t2.getZ(e2), this.w = t2.getW(e2), this;
        }
        random() {
          return this.x = Math.random(), this.y = Math.random(), this.z = Math.random(), this.w = Math.random(), this;
        }
      }
      function Yn(t2, e2, n2) {
        this.width = t2, this.height = e2, this.scissor = new Xn(0, 0, t2, e2), this.scissorTest = false, this.viewport = new Xn(0, 0, t2, e2), n2 = n2 || {}, this.texture = new Wn(void 0, n2.mapping, n2.wrapS, n2.wrapT, n2.magFilter, n2.minFilter, n2.format, n2.type, n2.anisotropy, n2.encoding), this.texture.image = {}, this.texture.image.width = t2, this.texture.image.height = e2, this.texture.generateMipmaps = void 0 !== n2.generateMipmaps && n2.generateMipmaps, this.texture.minFilter = void 0 !== n2.minFilter ? n2.minFilter : xt, this.depthBuffer = void 0 === n2.depthBuffer || n2.depthBuffer, this.stencilBuffer = void 0 !== n2.stencilBuffer && n2.stencilBuffer, this.depthTexture = void 0 !== n2.depthTexture ? n2.depthTexture : null;
      }
      function Zn(t2, e2, n2) {
        Yn.call(this, t2, e2, n2), this.samples = 4;
      }
      Yn.prototype = Object.assign(Object.create(zn.prototype), { constructor: Yn, isWebGLRenderTarget: true, setSize: function(t2, e2) {
        this.width === t2 && this.height === e2 || (this.width = t2, this.height = e2, this.texture.image.width = t2, this.texture.image.height = e2, this.dispose()), this.viewport.set(0, 0, t2, e2), this.scissor.set(0, 0, t2, e2);
      }, clone: function() {
        return new this.constructor().copy(this);
      }, copy: function(t2) {
        return this.width = t2.width, this.height = t2.height, this.viewport.copy(t2.viewport), this.texture = t2.texture.clone(), this.depthBuffer = t2.depthBuffer, this.stencilBuffer = t2.stencilBuffer, this.depthTexture = t2.depthTexture, this;
      }, dispose: function() {
        this.dispatchEvent({ type: "dispose" });
      } }), Zn.prototype = Object.assign(Object.create(Yn.prototype), { constructor: Zn, isWebGLMultisampleRenderTarget: true, copy: function(t2) {
        return Yn.prototype.copy.call(this, t2), this.samples = t2.samples, this;
      } });
      class Jn {
        constructor(t2 = 0, e2 = 0, n2 = 0, r2 = 1) {
          Object.defineProperty(this, "isQuaternion", { value: true }), this._x = t2, this._y = e2, this._z = n2, this._w = r2;
        }
        static slerp(t2, e2, n2, r2) {
          return n2.copy(t2).slerp(e2, r2);
        }
        static slerpFlat(t2, e2, n2, r2, i2, o2, a2) {
          let s2 = n2[r2 + 0], c2 = n2[r2 + 1], u2 = n2[r2 + 2], l2 = n2[r2 + 3];
          const h2 = i2[o2 + 0], d2 = i2[o2 + 1], p2 = i2[o2 + 2], f2 = i2[o2 + 3];
          if (l2 !== f2 || s2 !== h2 || c2 !== d2 || u2 !== p2) {
            let t3 = 1 - a2;
            const e3 = s2 * h2 + c2 * d2 + u2 * p2 + l2 * f2, n3 = e3 >= 0 ? 1 : -1, r3 = 1 - e3 * e3;
            if (r3 > Number.EPSILON) {
              const i4 = Math.sqrt(r3), o3 = Math.atan2(i4, e3 * n3);
              t3 = Math.sin(t3 * o3) / i4, a2 = Math.sin(a2 * o3) / i4;
            }
            const i3 = a2 * n3;
            if (s2 = s2 * t3 + h2 * i3, c2 = c2 * t3 + d2 * i3, u2 = u2 * t3 + p2 * i3, l2 = l2 * t3 + f2 * i3, t3 === 1 - a2) {
              const t4 = 1 / Math.sqrt(s2 * s2 + c2 * c2 + u2 * u2 + l2 * l2);
              s2 *= t4, c2 *= t4, u2 *= t4, l2 *= t4;
            }
          }
          t2[e2] = s2, t2[e2 + 1] = c2, t2[e2 + 2] = u2, t2[e2 + 3] = l2;
        }
        static multiplyQuaternionsFlat(t2, e2, n2, r2, i2, o2) {
          const a2 = n2[r2], s2 = n2[r2 + 1], c2 = n2[r2 + 2], u2 = n2[r2 + 3], l2 = i2[o2], h2 = i2[o2 + 1], d2 = i2[o2 + 2], p2 = i2[o2 + 3];
          return t2[e2] = a2 * p2 + u2 * l2 + s2 * d2 - c2 * h2, t2[e2 + 1] = s2 * p2 + u2 * h2 + c2 * l2 - a2 * d2, t2[e2 + 2] = c2 * p2 + u2 * d2 + a2 * h2 - s2 * l2, t2[e2 + 3] = u2 * p2 - a2 * l2 - s2 * h2 - c2 * d2, t2;
        }
        get x() {
          return this._x;
        }
        set x(t2) {
          this._x = t2, this._onChangeCallback();
        }
        get y() {
          return this._y;
        }
        set y(t2) {
          this._y = t2, this._onChangeCallback();
        }
        get z() {
          return this._z;
        }
        set z(t2) {
          this._z = t2, this._onChangeCallback();
        }
        get w() {
          return this._w;
        }
        set w(t2) {
          this._w = t2, this._onChangeCallback();
        }
        set(t2, e2, n2, r2) {
          return this._x = t2, this._y = e2, this._z = n2, this._w = r2, this._onChangeCallback(), this;
        }
        clone() {
          return new this.constructor(this._x, this._y, this._z, this._w);
        }
        copy(t2) {
          return this._x = t2.x, this._y = t2.y, this._z = t2.z, this._w = t2.w, this._onChangeCallback(), this;
        }
        setFromEuler(t2, e2) {
          if (!t2 || !t2.isEuler) throw new Error("THREE.Quaternion: .setFromEuler() now expects an Euler rotation rather than a Vector3 and order.");
          const n2 = t2._x, r2 = t2._y, i2 = t2._z, o2 = t2._order, a2 = Math.cos, s2 = Math.sin, c2 = a2(n2 / 2), u2 = a2(r2 / 2), l2 = a2(i2 / 2), h2 = s2(n2 / 2), d2 = s2(r2 / 2), p2 = s2(i2 / 2);
          switch (o2) {
            case "XYZ":
              this._x = h2 * u2 * l2 + c2 * d2 * p2, this._y = c2 * d2 * l2 - h2 * u2 * p2, this._z = c2 * u2 * p2 + h2 * d2 * l2, this._w = c2 * u2 * l2 - h2 * d2 * p2;
              break;
            case "YXZ":
              this._x = h2 * u2 * l2 + c2 * d2 * p2, this._y = c2 * d2 * l2 - h2 * u2 * p2, this._z = c2 * u2 * p2 - h2 * d2 * l2, this._w = c2 * u2 * l2 + h2 * d2 * p2;
              break;
            case "ZXY":
              this._x = h2 * u2 * l2 - c2 * d2 * p2, this._y = c2 * d2 * l2 + h2 * u2 * p2, this._z = c2 * u2 * p2 + h2 * d2 * l2, this._w = c2 * u2 * l2 - h2 * d2 * p2;
              break;
            case "ZYX":
              this._x = h2 * u2 * l2 - c2 * d2 * p2, this._y = c2 * d2 * l2 + h2 * u2 * p2, this._z = c2 * u2 * p2 - h2 * d2 * l2, this._w = c2 * u2 * l2 + h2 * d2 * p2;
              break;
            case "YZX":
              this._x = h2 * u2 * l2 + c2 * d2 * p2, this._y = c2 * d2 * l2 + h2 * u2 * p2, this._z = c2 * u2 * p2 - h2 * d2 * l2, this._w = c2 * u2 * l2 - h2 * d2 * p2;
              break;
            case "XZY":
              this._x = h2 * u2 * l2 - c2 * d2 * p2, this._y = c2 * d2 * l2 - h2 * u2 * p2, this._z = c2 * u2 * p2 + h2 * d2 * l2, this._w = c2 * u2 * l2 + h2 * d2 * p2;
              break;
            default:
              console.warn("THREE.Quaternion: .setFromEuler() encountered an unknown order: " + o2);
          }
          return false !== e2 && this._onChangeCallback(), this;
        }
        setFromAxisAngle(t2, e2) {
          const n2 = e2 / 2, r2 = Math.sin(n2);
          return this._x = t2.x * r2, this._y = t2.y * r2, this._z = t2.z * r2, this._w = Math.cos(n2), this._onChangeCallback(), this;
        }
        setFromRotationMatrix(t2) {
          const e2 = t2.elements, n2 = e2[0], r2 = e2[4], i2 = e2[8], o2 = e2[1], a2 = e2[5], s2 = e2[9], c2 = e2[2], u2 = e2[6], l2 = e2[10], h2 = n2 + a2 + l2;
          if (h2 > 0) {
            const t3 = 0.5 / Math.sqrt(h2 + 1);
            this._w = 0.25 / t3, this._x = (u2 - s2) * t3, this._y = (i2 - c2) * t3, this._z = (o2 - r2) * t3;
          } else if (n2 > a2 && n2 > l2) {
            const t3 = 2 * Math.sqrt(1 + n2 - a2 - l2);
            this._w = (u2 - s2) / t3, this._x = 0.25 * t3, this._y = (r2 + o2) / t3, this._z = (i2 + c2) / t3;
          } else if (a2 > l2) {
            const t3 = 2 * Math.sqrt(1 + a2 - n2 - l2);
            this._w = (i2 - c2) / t3, this._x = (r2 + o2) / t3, this._y = 0.25 * t3, this._z = (s2 + u2) / t3;
          } else {
            const t3 = 2 * Math.sqrt(1 + l2 - n2 - a2);
            this._w = (o2 - r2) / t3, this._x = (i2 + c2) / t3, this._y = (s2 + u2) / t3, this._z = 0.25 * t3;
          }
          return this._onChangeCallback(), this;
        }
        setFromUnitVectors(t2, e2) {
          let n2 = t2.dot(e2) + 1;
          return n2 < 1e-6 ? (n2 = 0, Math.abs(t2.x) > Math.abs(t2.z) ? (this._x = -t2.y, this._y = t2.x, this._z = 0, this._w = n2) : (this._x = 0, this._y = -t2.z, this._z = t2.y, this._w = n2)) : (this._x = t2.y * e2.z - t2.z * e2.y, this._y = t2.z * e2.x - t2.x * e2.z, this._z = t2.x * e2.y - t2.y * e2.x, this._w = n2), this.normalize();
        }
        angleTo(t2) {
          return 2 * Math.acos(Math.abs(Bn.clamp(this.dot(t2), -1, 1)));
        }
        rotateTowards(t2, e2) {
          const n2 = this.angleTo(t2);
          if (0 === n2) return this;
          const r2 = Math.min(1, e2 / n2);
          return this.slerp(t2, r2), this;
        }
        identity() {
          return this.set(0, 0, 0, 1);
        }
        invert() {
          return this.conjugate();
        }
        conjugate() {
          return this._x *= -1, this._y *= -1, this._z *= -1, this._onChangeCallback(), this;
        }
        dot(t2) {
          return this._x * t2._x + this._y * t2._y + this._z * t2._z + this._w * t2._w;
        }
        lengthSq() {
          return this._x * this._x + this._y * this._y + this._z * this._z + this._w * this._w;
        }
        length() {
          return Math.sqrt(this._x * this._x + this._y * this._y + this._z * this._z + this._w * this._w);
        }
        normalize() {
          let t2 = this.length();
          return 0 === t2 ? (this._x = 0, this._y = 0, this._z = 0, this._w = 1) : (t2 = 1 / t2, this._x = this._x * t2, this._y = this._y * t2, this._z = this._z * t2, this._w = this._w * t2), this._onChangeCallback(), this;
        }
        multiply(t2, e2) {
          return void 0 !== e2 ? (console.warn("THREE.Quaternion: .multiply() now only accepts one argument. Use .multiplyQuaternions( a, b ) instead."), this.multiplyQuaternions(t2, e2)) : this.multiplyQuaternions(this, t2);
        }
        premultiply(t2) {
          return this.multiplyQuaternions(t2, this);
        }
        multiplyQuaternions(t2, e2) {
          const n2 = t2._x, r2 = t2._y, i2 = t2._z, o2 = t2._w, a2 = e2._x, s2 = e2._y, c2 = e2._z, u2 = e2._w;
          return this._x = n2 * u2 + o2 * a2 + r2 * c2 - i2 * s2, this._y = r2 * u2 + o2 * s2 + i2 * a2 - n2 * c2, this._z = i2 * u2 + o2 * c2 + n2 * s2 - r2 * a2, this._w = o2 * u2 - n2 * a2 - r2 * s2 - i2 * c2, this._onChangeCallback(), this;
        }
        slerp(t2, e2) {
          if (0 === e2) return this;
          if (1 === e2) return this.copy(t2);
          const n2 = this._x, r2 = this._y, i2 = this._z, o2 = this._w;
          let a2 = o2 * t2._w + n2 * t2._x + r2 * t2._y + i2 * t2._z;
          if (a2 < 0 ? (this._w = -t2._w, this._x = -t2._x, this._y = -t2._y, this._z = -t2._z, a2 = -a2) : this.copy(t2), a2 >= 1) return this._w = o2, this._x = n2, this._y = r2, this._z = i2, this;
          const s2 = 1 - a2 * a2;
          if (s2 <= Number.EPSILON) {
            const t3 = 1 - e2;
            return this._w = t3 * o2 + e2 * this._w, this._x = t3 * n2 + e2 * this._x, this._y = t3 * r2 + e2 * this._y, this._z = t3 * i2 + e2 * this._z, this.normalize(), this._onChangeCallback(), this;
          }
          const c2 = Math.sqrt(s2), u2 = Math.atan2(c2, a2), l2 = Math.sin((1 - e2) * u2) / c2, h2 = Math.sin(e2 * u2) / c2;
          return this._w = o2 * l2 + this._w * h2, this._x = n2 * l2 + this._x * h2, this._y = r2 * l2 + this._y * h2, this._z = i2 * l2 + this._z * h2, this._onChangeCallback(), this;
        }
        equals(t2) {
          return t2._x === this._x && t2._y === this._y && t2._z === this._z && t2._w === this._w;
        }
        fromArray(t2, e2 = 0) {
          return this._x = t2[e2], this._y = t2[e2 + 1], this._z = t2[e2 + 2], this._w = t2[e2 + 3], this._onChangeCallback(), this;
        }
        toArray(t2 = [], e2 = 0) {
          return t2[e2] = this._x, t2[e2 + 1] = this._y, t2[e2 + 2] = this._z, t2[e2 + 3] = this._w, t2;
        }
        fromBufferAttribute(t2, e2) {
          return this._x = t2.getX(e2), this._y = t2.getY(e2), this._z = t2.getZ(e2), this._w = t2.getW(e2), this;
        }
        _onChange(t2) {
          return this._onChangeCallback = t2, this;
        }
        _onChangeCallback() {
        }
      }
      class $n {
        constructor(t2 = 0, e2 = 0, n2 = 0) {
          Object.defineProperty(this, "isVector3", { value: true }), this.x = t2, this.y = e2, this.z = n2;
        }
        set(t2, e2, n2) {
          return void 0 === n2 && (n2 = this.z), this.x = t2, this.y = e2, this.z = n2, this;
        }
        setScalar(t2) {
          return this.x = t2, this.y = t2, this.z = t2, this;
        }
        setX(t2) {
          return this.x = t2, this;
        }
        setY(t2) {
          return this.y = t2, this;
        }
        setZ(t2) {
          return this.z = t2, this;
        }
        setComponent(t2, e2) {
          switch (t2) {
            case 0:
              this.x = e2;
              break;
            case 1:
              this.y = e2;
              break;
            case 2:
              this.z = e2;
              break;
            default:
              throw new Error("index is out of range: " + t2);
          }
          return this;
        }
        getComponent(t2) {
          switch (t2) {
            case 0:
              return this.x;
            case 1:
              return this.y;
            case 2:
              return this.z;
            default:
              throw new Error("index is out of range: " + t2);
          }
        }
        clone() {
          return new this.constructor(this.x, this.y, this.z);
        }
        copy(t2) {
          return this.x = t2.x, this.y = t2.y, this.z = t2.z, this;
        }
        add(t2, e2) {
          return void 0 !== e2 ? (console.warn("THREE.Vector3: .add() now only accepts one argument. Use .addVectors( a, b ) instead."), this.addVectors(t2, e2)) : (this.x += t2.x, this.y += t2.y, this.z += t2.z, this);
        }
        addScalar(t2) {
          return this.x += t2, this.y += t2, this.z += t2, this;
        }
        addVectors(t2, e2) {
          return this.x = t2.x + e2.x, this.y = t2.y + e2.y, this.z = t2.z + e2.z, this;
        }
        addScaledVector(t2, e2) {
          return this.x += t2.x * e2, this.y += t2.y * e2, this.z += t2.z * e2, this;
        }
        sub(t2, e2) {
          return void 0 !== e2 ? (console.warn("THREE.Vector3: .sub() now only accepts one argument. Use .subVectors( a, b ) instead."), this.subVectors(t2, e2)) : (this.x -= t2.x, this.y -= t2.y, this.z -= t2.z, this);
        }
        subScalar(t2) {
          return this.x -= t2, this.y -= t2, this.z -= t2, this;
        }
        subVectors(t2, e2) {
          return this.x = t2.x - e2.x, this.y = t2.y - e2.y, this.z = t2.z - e2.z, this;
        }
        multiply(t2, e2) {
          return void 0 !== e2 ? (console.warn("THREE.Vector3: .multiply() now only accepts one argument. Use .multiplyVectors( a, b ) instead."), this.multiplyVectors(t2, e2)) : (this.x *= t2.x, this.y *= t2.y, this.z *= t2.z, this);
        }
        multiplyScalar(t2) {
          return this.x *= t2, this.y *= t2, this.z *= t2, this;
        }
        multiplyVectors(t2, e2) {
          return this.x = t2.x * e2.x, this.y = t2.y * e2.y, this.z = t2.z * e2.z, this;
        }
        applyEuler(t2) {
          return t2 && t2.isEuler || console.error("THREE.Vector3: .applyEuler() now expects an Euler rotation rather than a Vector3 and order."), this.applyQuaternion(Kn.setFromEuler(t2));
        }
        applyAxisAngle(t2, e2) {
          return this.applyQuaternion(Kn.setFromAxisAngle(t2, e2));
        }
        applyMatrix3(t2) {
          const e2 = this.x, n2 = this.y, r2 = this.z, i2 = t2.elements;
          return this.x = i2[0] * e2 + i2[3] * n2 + i2[6] * r2, this.y = i2[1] * e2 + i2[4] * n2 + i2[7] * r2, this.z = i2[2] * e2 + i2[5] * n2 + i2[8] * r2, this;
        }
        applyNormalMatrix(t2) {
          return this.applyMatrix3(t2).normalize();
        }
        applyMatrix4(t2) {
          const e2 = this.x, n2 = this.y, r2 = this.z, i2 = t2.elements, o2 = 1 / (i2[3] * e2 + i2[7] * n2 + i2[11] * r2 + i2[15]);
          return this.x = (i2[0] * e2 + i2[4] * n2 + i2[8] * r2 + i2[12]) * o2, this.y = (i2[1] * e2 + i2[5] * n2 + i2[9] * r2 + i2[13]) * o2, this.z = (i2[2] * e2 + i2[6] * n2 + i2[10] * r2 + i2[14]) * o2, this;
        }
        applyQuaternion(t2) {
          const e2 = this.x, n2 = this.y, r2 = this.z, i2 = t2.x, o2 = t2.y, a2 = t2.z, s2 = t2.w, c2 = s2 * e2 + o2 * r2 - a2 * n2, u2 = s2 * n2 + a2 * e2 - i2 * r2, l2 = s2 * r2 + i2 * n2 - o2 * e2, h2 = -i2 * e2 - o2 * n2 - a2 * r2;
          return this.x = c2 * s2 + h2 * -i2 + u2 * -a2 - l2 * -o2, this.y = u2 * s2 + h2 * -o2 + l2 * -i2 - c2 * -a2, this.z = l2 * s2 + h2 * -a2 + c2 * -o2 - u2 * -i2, this;
        }
        project(t2) {
          return this.applyMatrix4(t2.matrixWorldInverse).applyMatrix4(t2.projectionMatrix);
        }
        unproject(t2) {
          return this.applyMatrix4(t2.projectionMatrixInverse).applyMatrix4(t2.matrixWorld);
        }
        transformDirection(t2) {
          const e2 = this.x, n2 = this.y, r2 = this.z, i2 = t2.elements;
          return this.x = i2[0] * e2 + i2[4] * n2 + i2[8] * r2, this.y = i2[1] * e2 + i2[5] * n2 + i2[9] * r2, this.z = i2[2] * e2 + i2[6] * n2 + i2[10] * r2, this.normalize();
        }
        divide(t2) {
          return this.x /= t2.x, this.y /= t2.y, this.z /= t2.z, this;
        }
        divideScalar(t2) {
          return this.multiplyScalar(1 / t2);
        }
        min(t2) {
          return this.x = Math.min(this.x, t2.x), this.y = Math.min(this.y, t2.y), this.z = Math.min(this.z, t2.z), this;
        }
        max(t2) {
          return this.x = Math.max(this.x, t2.x), this.y = Math.max(this.y, t2.y), this.z = Math.max(this.z, t2.z), this;
        }
        clamp(t2, e2) {
          return this.x = Math.max(t2.x, Math.min(e2.x, this.x)), this.y = Math.max(t2.y, Math.min(e2.y, this.y)), this.z = Math.max(t2.z, Math.min(e2.z, this.z)), this;
        }
        clampScalar(t2, e2) {
          return this.x = Math.max(t2, Math.min(e2, this.x)), this.y = Math.max(t2, Math.min(e2, this.y)), this.z = Math.max(t2, Math.min(e2, this.z)), this;
        }
        clampLength(t2, e2) {
          const n2 = this.length();
          return this.divideScalar(n2 || 1).multiplyScalar(Math.max(t2, Math.min(e2, n2)));
        }
        floor() {
          return this.x = Math.floor(this.x), this.y = Math.floor(this.y), this.z = Math.floor(this.z), this;
        }
        ceil() {
          return this.x = Math.ceil(this.x), this.y = Math.ceil(this.y), this.z = Math.ceil(this.z), this;
        }
        round() {
          return this.x = Math.round(this.x), this.y = Math.round(this.y), this.z = Math.round(this.z), this;
        }
        roundToZero() {
          return this.x = this.x < 0 ? Math.ceil(this.x) : Math.floor(this.x), this.y = this.y < 0 ? Math.ceil(this.y) : Math.floor(this.y), this.z = this.z < 0 ? Math.ceil(this.z) : Math.floor(this.z), this;
        }
        negate() {
          return this.x = -this.x, this.y = -this.y, this.z = -this.z, this;
        }
        dot(t2) {
          return this.x * t2.x + this.y * t2.y + this.z * t2.z;
        }
        lengthSq() {
          return this.x * this.x + this.y * this.y + this.z * this.z;
        }
        length() {
          return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z);
        }
        manhattanLength() {
          return Math.abs(this.x) + Math.abs(this.y) + Math.abs(this.z);
        }
        normalize() {
          return this.divideScalar(this.length() || 1);
        }
        setLength(t2) {
          return this.normalize().multiplyScalar(t2);
        }
        lerp(t2, e2) {
          return this.x += (t2.x - this.x) * e2, this.y += (t2.y - this.y) * e2, this.z += (t2.z - this.z) * e2, this;
        }
        lerpVectors(t2, e2, n2) {
          return this.x = t2.x + (e2.x - t2.x) * n2, this.y = t2.y + (e2.y - t2.y) * n2, this.z = t2.z + (e2.z - t2.z) * n2, this;
        }
        cross(t2, e2) {
          return void 0 !== e2 ? (console.warn("THREE.Vector3: .cross() now only accepts one argument. Use .crossVectors( a, b ) instead."), this.crossVectors(t2, e2)) : this.crossVectors(this, t2);
        }
        crossVectors(t2, e2) {
          const n2 = t2.x, r2 = t2.y, i2 = t2.z, o2 = e2.x, a2 = e2.y, s2 = e2.z;
          return this.x = r2 * s2 - i2 * a2, this.y = i2 * o2 - n2 * s2, this.z = n2 * a2 - r2 * o2, this;
        }
        projectOnVector(t2) {
          const e2 = t2.lengthSq();
          if (0 === e2) return this.set(0, 0, 0);
          const n2 = t2.dot(this) / e2;
          return this.copy(t2).multiplyScalar(n2);
        }
        projectOnPlane(t2) {
          return Qn.copy(this).projectOnVector(t2), this.sub(Qn);
        }
        reflect(t2) {
          return this.sub(Qn.copy(t2).multiplyScalar(2 * this.dot(t2)));
        }
        angleTo(t2) {
          const e2 = Math.sqrt(this.lengthSq() * t2.lengthSq());
          if (0 === e2) return Math.PI / 2;
          const n2 = this.dot(t2) / e2;
          return Math.acos(Bn.clamp(n2, -1, 1));
        }
        distanceTo(t2) {
          return Math.sqrt(this.distanceToSquared(t2));
        }
        distanceToSquared(t2) {
          const e2 = this.x - t2.x, n2 = this.y - t2.y, r2 = this.z - t2.z;
          return e2 * e2 + n2 * n2 + r2 * r2;
        }
        manhattanDistanceTo(t2) {
          return Math.abs(this.x - t2.x) + Math.abs(this.y - t2.y) + Math.abs(this.z - t2.z);
        }
        setFromSpherical(t2) {
          return this.setFromSphericalCoords(t2.radius, t2.phi, t2.theta);
        }
        setFromSphericalCoords(t2, e2, n2) {
          const r2 = Math.sin(e2) * t2;
          return this.x = r2 * Math.sin(n2), this.y = Math.cos(e2) * t2, this.z = r2 * Math.cos(n2), this;
        }
        setFromCylindrical(t2) {
          return this.setFromCylindricalCoords(t2.radius, t2.theta, t2.y);
        }
        setFromCylindricalCoords(t2, e2, n2) {
          return this.x = t2 * Math.sin(e2), this.y = n2, this.z = t2 * Math.cos(e2), this;
        }
        setFromMatrixPosition(t2) {
          const e2 = t2.elements;
          return this.x = e2[12], this.y = e2[13], this.z = e2[14], this;
        }
        setFromMatrixScale(t2) {
          const e2 = this.setFromMatrixColumn(t2, 0).length(), n2 = this.setFromMatrixColumn(t2, 1).length(), r2 = this.setFromMatrixColumn(t2, 2).length();
          return this.x = e2, this.y = n2, this.z = r2, this;
        }
        setFromMatrixColumn(t2, e2) {
          return this.fromArray(t2.elements, 4 * e2);
        }
        setFromMatrix3Column(t2, e2) {
          return this.fromArray(t2.elements, 3 * e2);
        }
        equals(t2) {
          return t2.x === this.x && t2.y === this.y && t2.z === this.z;
        }
        fromArray(t2, e2 = 0) {
          return this.x = t2[e2], this.y = t2[e2 + 1], this.z = t2[e2 + 2], this;
        }
        toArray(t2 = [], e2 = 0) {
          return t2[e2] = this.x, t2[e2 + 1] = this.y, t2[e2 + 2] = this.z, t2;
        }
        fromBufferAttribute(t2, e2, n2) {
          return void 0 !== n2 && console.warn("THREE.Vector3: offset has been removed from .fromBufferAttribute()."), this.x = t2.getX(e2), this.y = t2.getY(e2), this.z = t2.getZ(e2), this;
        }
        random() {
          return this.x = Math.random(), this.y = Math.random(), this.z = Math.random(), this;
        }
      }
      const Qn = new $n(), Kn = new Jn();
      class tr {
        constructor(t2, e2) {
          Object.defineProperty(this, "isBox3", { value: true }), this.min = void 0 !== t2 ? t2 : new $n(1 / 0, 1 / 0, 1 / 0), this.max = void 0 !== e2 ? e2 : new $n(-1 / 0, -1 / 0, -1 / 0);
        }
        set(t2, e2) {
          return this.min.copy(t2), this.max.copy(e2), this;
        }
        setFromArray(t2) {
          let e2 = 1 / 0, n2 = 1 / 0, r2 = 1 / 0, i2 = -1 / 0, o2 = -1 / 0, a2 = -1 / 0;
          for (let s2 = 0, c2 = t2.length; s2 < c2; s2 += 3) {
            const c3 = t2[s2], u2 = t2[s2 + 1], l2 = t2[s2 + 2];
            c3 < e2 && (e2 = c3), u2 < n2 && (n2 = u2), l2 < r2 && (r2 = l2), c3 > i2 && (i2 = c3), u2 > o2 && (o2 = u2), l2 > a2 && (a2 = l2);
          }
          return this.min.set(e2, n2, r2), this.max.set(i2, o2, a2), this;
        }
        setFromBufferAttribute(t2) {
          let e2 = 1 / 0, n2 = 1 / 0, r2 = 1 / 0, i2 = -1 / 0, o2 = -1 / 0, a2 = -1 / 0;
          for (let s2 = 0, c2 = t2.count; s2 < c2; s2++) {
            const c3 = t2.getX(s2), u2 = t2.getY(s2), l2 = t2.getZ(s2);
            c3 < e2 && (e2 = c3), u2 < n2 && (n2 = u2), l2 < r2 && (r2 = l2), c3 > i2 && (i2 = c3), u2 > o2 && (o2 = u2), l2 > a2 && (a2 = l2);
          }
          return this.min.set(e2, n2, r2), this.max.set(i2, o2, a2), this;
        }
        setFromPoints(t2) {
          this.makeEmpty();
          for (let e2 = 0, n2 = t2.length; e2 < n2; e2++) this.expandByPoint(t2[e2]);
          return this;
        }
        setFromCenterAndSize(t2, e2) {
          const n2 = rr.copy(e2).multiplyScalar(0.5);
          return this.min.copy(t2).sub(n2), this.max.copy(t2).add(n2), this;
        }
        setFromObject(t2) {
          return this.makeEmpty(), this.expandByObject(t2);
        }
        clone() {
          return new this.constructor().copy(this);
        }
        copy(t2) {
          return this.min.copy(t2.min), this.max.copy(t2.max), this;
        }
        makeEmpty() {
          return this.min.x = this.min.y = this.min.z = 1 / 0, this.max.x = this.max.y = this.max.z = -1 / 0, this;
        }
        isEmpty() {
          return this.max.x < this.min.x || this.max.y < this.min.y || this.max.z < this.min.z;
        }
        getCenter(t2) {
          return void 0 === t2 && (console.warn("THREE.Box3: .getCenter() target is now required"), t2 = new $n()), this.isEmpty() ? t2.set(0, 0, 0) : t2.addVectors(this.min, this.max).multiplyScalar(0.5);
        }
        getSize(t2) {
          return void 0 === t2 && (console.warn("THREE.Box3: .getSize() target is now required"), t2 = new $n()), this.isEmpty() ? t2.set(0, 0, 0) : t2.subVectors(this.max, this.min);
        }
        expandByPoint(t2) {
          return this.min.min(t2), this.max.max(t2), this;
        }
        expandByVector(t2) {
          return this.min.sub(t2), this.max.add(t2), this;
        }
        expandByScalar(t2) {
          return this.min.addScalar(-t2), this.max.addScalar(t2), this;
        }
        expandByObject(t2) {
          t2.updateWorldMatrix(false, false);
          const e2 = t2.geometry;
          void 0 !== e2 && (null === e2.boundingBox && e2.computeBoundingBox(), ir.copy(e2.boundingBox), ir.applyMatrix4(t2.matrixWorld), this.union(ir));
          const n2 = t2.children;
          for (let t3 = 0, e3 = n2.length; t3 < e3; t3++) this.expandByObject(n2[t3]);
          return this;
        }
        containsPoint(t2) {
          return !(t2.x < this.min.x || t2.x > this.max.x || t2.y < this.min.y || t2.y > this.max.y || t2.z < this.min.z || t2.z > this.max.z);
        }
        containsBox(t2) {
          return this.min.x <= t2.min.x && t2.max.x <= this.max.x && this.min.y <= t2.min.y && t2.max.y <= this.max.y && this.min.z <= t2.min.z && t2.max.z <= this.max.z;
        }
        getParameter(t2, e2) {
          return void 0 === e2 && (console.warn("THREE.Box3: .getParameter() target is now required"), e2 = new $n()), e2.set((t2.x - this.min.x) / (this.max.x - this.min.x), (t2.y - this.min.y) / (this.max.y - this.min.y), (t2.z - this.min.z) / (this.max.z - this.min.z));
        }
        intersectsBox(t2) {
          return !(t2.max.x < this.min.x || t2.min.x > this.max.x || t2.max.y < this.min.y || t2.min.y > this.max.y || t2.max.z < this.min.z || t2.min.z > this.max.z);
        }
        intersectsSphere(t2) {
          return this.clampPoint(t2.center, rr), rr.distanceToSquared(t2.center) <= t2.radius * t2.radius;
        }
        intersectsPlane(t2) {
          let e2, n2;
          return t2.normal.x > 0 ? (e2 = t2.normal.x * this.min.x, n2 = t2.normal.x * this.max.x) : (e2 = t2.normal.x * this.max.x, n2 = t2.normal.x * this.min.x), t2.normal.y > 0 ? (e2 += t2.normal.y * this.min.y, n2 += t2.normal.y * this.max.y) : (e2 += t2.normal.y * this.max.y, n2 += t2.normal.y * this.min.y), t2.normal.z > 0 ? (e2 += t2.normal.z * this.min.z, n2 += t2.normal.z * this.max.z) : (e2 += t2.normal.z * this.max.z, n2 += t2.normal.z * this.min.z), e2 <= -t2.constant && n2 >= -t2.constant;
        }
        intersectsTriangle(t2) {
          if (this.isEmpty()) return false;
          this.getCenter(hr), dr.subVectors(this.max, hr), or.subVectors(t2.a, hr), ar.subVectors(t2.b, hr), sr.subVectors(t2.c, hr), cr.subVectors(ar, or), ur.subVectors(sr, ar), lr.subVectors(or, sr);
          let e2 = [0, -cr.z, cr.y, 0, -ur.z, ur.y, 0, -lr.z, lr.y, cr.z, 0, -cr.x, ur.z, 0, -ur.x, lr.z, 0, -lr.x, -cr.y, cr.x, 0, -ur.y, ur.x, 0, -lr.y, lr.x, 0];
          return !!er(e2, or, ar, sr, dr) && (e2 = [1, 0, 0, 0, 1, 0, 0, 0, 1], !!er(e2, or, ar, sr, dr) && (pr.crossVectors(cr, ur), e2 = [pr.x, pr.y, pr.z], er(e2, or, ar, sr, dr)));
        }
        clampPoint(t2, e2) {
          return void 0 === e2 && (console.warn("THREE.Box3: .clampPoint() target is now required"), e2 = new $n()), e2.copy(t2).clamp(this.min, this.max);
        }
        distanceToPoint(t2) {
          return rr.copy(t2).clamp(this.min, this.max).sub(t2).length();
        }
        getBoundingSphere(t2) {
          return void 0 === t2 && console.error("THREE.Box3: .getBoundingSphere() target is now required"), this.getCenter(t2.center), t2.radius = 0.5 * this.getSize(rr).length(), t2;
        }
        intersect(t2) {
          return this.min.max(t2.min), this.max.min(t2.max), this.isEmpty() && this.makeEmpty(), this;
        }
        union(t2) {
          return this.min.min(t2.min), this.max.max(t2.max), this;
        }
        applyMatrix4(t2) {
          return this.isEmpty() || (nr[0].set(this.min.x, this.min.y, this.min.z).applyMatrix4(t2), nr[1].set(this.min.x, this.min.y, this.max.z).applyMatrix4(t2), nr[2].set(this.min.x, this.max.y, this.min.z).applyMatrix4(t2), nr[3].set(this.min.x, this.max.y, this.max.z).applyMatrix4(t2), nr[4].set(this.max.x, this.min.y, this.min.z).applyMatrix4(t2), nr[5].set(this.max.x, this.min.y, this.max.z).applyMatrix4(t2), nr[6].set(this.max.x, this.max.y, this.min.z).applyMatrix4(t2), nr[7].set(this.max.x, this.max.y, this.max.z).applyMatrix4(t2), this.setFromPoints(nr)), this;
        }
        translate(t2) {
          return this.min.add(t2), this.max.add(t2), this;
        }
        equals(t2) {
          return t2.min.equals(this.min) && t2.max.equals(this.max);
        }
      }
      function er(t2, e2, n2, r2, i2) {
        for (let o2 = 0, a2 = t2.length - 3; o2 <= a2; o2 += 3) {
          fr.fromArray(t2, o2);
          const a3 = i2.x * Math.abs(fr.x) + i2.y * Math.abs(fr.y) + i2.z * Math.abs(fr.z), s2 = e2.dot(fr), c2 = n2.dot(fr), u2 = r2.dot(fr);
          if (Math.max(-Math.max(s2, c2, u2), Math.min(s2, c2, u2)) > a3) return false;
        }
        return true;
      }
      const nr = [new $n(), new $n(), new $n(), new $n(), new $n(), new $n(), new $n(), new $n()], rr = new $n(), ir = new tr(), or = new $n(), ar = new $n(), sr = new $n(), cr = new $n(), ur = new $n(), lr = new $n(), hr = new $n(), dr = new $n(), pr = new $n(), fr = new $n(), mr = new tr();
      class gr {
        constructor(t2, e2) {
          this.center = void 0 !== t2 ? t2 : new $n(), this.radius = void 0 !== e2 ? e2 : -1;
        }
        set(t2, e2) {
          return this.center.copy(t2), this.radius = e2, this;
        }
        setFromPoints(t2, e2) {
          const n2 = this.center;
          void 0 !== e2 ? n2.copy(e2) : mr.setFromPoints(t2).getCenter(n2);
          let r2 = 0;
          for (let e3 = 0, i2 = t2.length; e3 < i2; e3++) r2 = Math.max(r2, n2.distanceToSquared(t2[e3]));
          return this.radius = Math.sqrt(r2), this;
        }
        clone() {
          return new this.constructor().copy(this);
        }
        copy(t2) {
          return this.center.copy(t2.center), this.radius = t2.radius, this;
        }
        isEmpty() {
          return this.radius < 0;
        }
        makeEmpty() {
          return this.center.set(0, 0, 0), this.radius = -1, this;
        }
        containsPoint(t2) {
          return t2.distanceToSquared(this.center) <= this.radius * this.radius;
        }
        distanceToPoint(t2) {
          return t2.distanceTo(this.center) - this.radius;
        }
        intersectsSphere(t2) {
          const e2 = this.radius + t2.radius;
          return t2.center.distanceToSquared(this.center) <= e2 * e2;
        }
        intersectsBox(t2) {
          return t2.intersectsSphere(this);
        }
        intersectsPlane(t2) {
          return Math.abs(t2.distanceToPoint(this.center)) <= this.radius;
        }
        clampPoint(t2, e2) {
          const n2 = this.center.distanceToSquared(t2);
          return void 0 === e2 && (console.warn("THREE.Sphere: .clampPoint() target is now required"), e2 = new $n()), e2.copy(t2), n2 > this.radius * this.radius && (e2.sub(this.center).normalize(), e2.multiplyScalar(this.radius).add(this.center)), e2;
        }
        getBoundingBox(t2) {
          return void 0 === t2 && (console.warn("THREE.Sphere: .getBoundingBox() target is now required"), t2 = new tr()), this.isEmpty() ? (t2.makeEmpty(), t2) : (t2.set(this.center, this.center), t2.expandByScalar(this.radius), t2);
        }
        applyMatrix4(t2) {
          return this.center.applyMatrix4(t2), this.radius = this.radius * t2.getMaxScaleOnAxis(), this;
        }
        translate(t2) {
          return this.center.add(t2), this;
        }
        equals(t2) {
          return t2.center.equals(this.center) && t2.radius === this.radius;
        }
      }
      const vr = new $n(), yr = new $n(), xr = new $n(), br = new $n(), wr = new $n(), _r = new $n(), Mr = new $n();
      class Sr {
        constructor(t2, e2) {
          this.origin = void 0 !== t2 ? t2 : new $n(), this.direction = void 0 !== e2 ? e2 : new $n(0, 0, -1);
        }
        set(t2, e2) {
          return this.origin.copy(t2), this.direction.copy(e2), this;
        }
        clone() {
          return new this.constructor().copy(this);
        }
        copy(t2) {
          return this.origin.copy(t2.origin), this.direction.copy(t2.direction), this;
        }
        at(t2, e2) {
          return void 0 === e2 && (console.warn("THREE.Ray: .at() target is now required"), e2 = new $n()), e2.copy(this.direction).multiplyScalar(t2).add(this.origin);
        }
        lookAt(t2) {
          return this.direction.copy(t2).sub(this.origin).normalize(), this;
        }
        recast(t2) {
          return this.origin.copy(this.at(t2, vr)), this;
        }
        closestPointToPoint(t2, e2) {
          void 0 === e2 && (console.warn("THREE.Ray: .closestPointToPoint() target is now required"), e2 = new $n()), e2.subVectors(t2, this.origin);
          const n2 = e2.dot(this.direction);
          return n2 < 0 ? e2.copy(this.origin) : e2.copy(this.direction).multiplyScalar(n2).add(this.origin);
        }
        distanceToPoint(t2) {
          return Math.sqrt(this.distanceSqToPoint(t2));
        }
        distanceSqToPoint(t2) {
          const e2 = vr.subVectors(t2, this.origin).dot(this.direction);
          return e2 < 0 ? this.origin.distanceToSquared(t2) : (vr.copy(this.direction).multiplyScalar(e2).add(this.origin), vr.distanceToSquared(t2));
        }
        distanceSqToSegment(t2, e2, n2, r2) {
          yr.copy(t2).add(e2).multiplyScalar(0.5), xr.copy(e2).sub(t2).normalize(), br.copy(this.origin).sub(yr);
          const i2 = 0.5 * t2.distanceTo(e2), o2 = -this.direction.dot(xr), a2 = br.dot(this.direction), s2 = -br.dot(xr), c2 = br.lengthSq(), u2 = Math.abs(1 - o2 * o2);
          let l2, h2, d2, p2;
          if (u2 > 0) if (l2 = o2 * s2 - a2, h2 = o2 * a2 - s2, p2 = i2 * u2, l2 >= 0) if (h2 >= -p2) if (h2 <= p2) {
            const t3 = 1 / u2;
            l2 *= t3, h2 *= t3, d2 = l2 * (l2 + o2 * h2 + 2 * a2) + h2 * (o2 * l2 + h2 + 2 * s2) + c2;
          } else h2 = i2, l2 = Math.max(0, -(o2 * h2 + a2)), d2 = -l2 * l2 + h2 * (h2 + 2 * s2) + c2;
          else h2 = -i2, l2 = Math.max(0, -(o2 * h2 + a2)), d2 = -l2 * l2 + h2 * (h2 + 2 * s2) + c2;
          else h2 <= -p2 ? (l2 = Math.max(0, -(-o2 * i2 + a2)), h2 = l2 > 0 ? -i2 : Math.min(Math.max(-i2, -s2), i2), d2 = -l2 * l2 + h2 * (h2 + 2 * s2) + c2) : h2 <= p2 ? (l2 = 0, h2 = Math.min(Math.max(-i2, -s2), i2), d2 = h2 * (h2 + 2 * s2) + c2) : (l2 = Math.max(0, -(o2 * i2 + a2)), h2 = l2 > 0 ? i2 : Math.min(Math.max(-i2, -s2), i2), d2 = -l2 * l2 + h2 * (h2 + 2 * s2) + c2);
          else h2 = o2 > 0 ? -i2 : i2, l2 = Math.max(0, -(o2 * h2 + a2)), d2 = -l2 * l2 + h2 * (h2 + 2 * s2) + c2;
          return n2 && n2.copy(this.direction).multiplyScalar(l2).add(this.origin), r2 && r2.copy(xr).multiplyScalar(h2).add(yr), d2;
        }
        intersectSphere(t2, e2) {
          vr.subVectors(t2.center, this.origin);
          const n2 = vr.dot(this.direction), r2 = vr.dot(vr) - n2 * n2, i2 = t2.radius * t2.radius;
          if (r2 > i2) return null;
          const o2 = Math.sqrt(i2 - r2), a2 = n2 - o2, s2 = n2 + o2;
          return a2 < 0 && s2 < 0 ? null : a2 < 0 ? this.at(s2, e2) : this.at(a2, e2);
        }
        intersectsSphere(t2) {
          return this.distanceSqToPoint(t2.center) <= t2.radius * t2.radius;
        }
        distanceToPlane(t2) {
          const e2 = t2.normal.dot(this.direction);
          if (0 === e2) return 0 === t2.distanceToPoint(this.origin) ? 0 : null;
          const n2 = -(this.origin.dot(t2.normal) + t2.constant) / e2;
          return n2 >= 0 ? n2 : null;
        }
        intersectPlane(t2, e2) {
          const n2 = this.distanceToPlane(t2);
          return null === n2 ? null : this.at(n2, e2);
        }
        intersectsPlane(t2) {
          const e2 = t2.distanceToPoint(this.origin);
          if (0 === e2) return true;
          return t2.normal.dot(this.direction) * e2 < 0;
        }
        intersectBox(t2, e2) {
          let n2, r2, i2, o2, a2, s2;
          const c2 = 1 / this.direction.x, u2 = 1 / this.direction.y, l2 = 1 / this.direction.z, h2 = this.origin;
          return c2 >= 0 ? (n2 = (t2.min.x - h2.x) * c2, r2 = (t2.max.x - h2.x) * c2) : (n2 = (t2.max.x - h2.x) * c2, r2 = (t2.min.x - h2.x) * c2), u2 >= 0 ? (i2 = (t2.min.y - h2.y) * u2, o2 = (t2.max.y - h2.y) * u2) : (i2 = (t2.max.y - h2.y) * u2, o2 = (t2.min.y - h2.y) * u2), n2 > o2 || i2 > r2 ? null : ((i2 > n2 || n2 != n2) && (n2 = i2), (o2 < r2 || r2 != r2) && (r2 = o2), l2 >= 0 ? (a2 = (t2.min.z - h2.z) * l2, s2 = (t2.max.z - h2.z) * l2) : (a2 = (t2.max.z - h2.z) * l2, s2 = (t2.min.z - h2.z) * l2), n2 > s2 || a2 > r2 ? null : ((a2 > n2 || n2 != n2) && (n2 = a2), (s2 < r2 || r2 != r2) && (r2 = s2), r2 < 0 ? null : this.at(n2 >= 0 ? n2 : r2, e2)));
        }
        intersectsBox(t2) {
          return null !== this.intersectBox(t2, vr);
        }
        intersectTriangle(t2, e2, n2, r2, i2) {
          wr.subVectors(e2, t2), _r.subVectors(n2, t2), Mr.crossVectors(wr, _r);
          let o2, a2 = this.direction.dot(Mr);
          if (a2 > 0) {
            if (r2) return null;
            o2 = 1;
          } else {
            if (!(a2 < 0)) return null;
            o2 = -1, a2 = -a2;
          }
          br.subVectors(this.origin, t2);
          const s2 = o2 * this.direction.dot(_r.crossVectors(br, _r));
          if (s2 < 0) return null;
          const c2 = o2 * this.direction.dot(wr.cross(br));
          if (c2 < 0) return null;
          if (s2 + c2 > a2) return null;
          const u2 = -o2 * br.dot(Mr);
          return u2 < 0 ? null : this.at(u2 / a2, i2);
        }
        applyMatrix4(t2) {
          return this.origin.applyMatrix4(t2), this.direction.transformDirection(t2), this;
        }
        equals(t2) {
          return t2.origin.equals(this.origin) && t2.direction.equals(this.direction);
        }
      }
      class Tr {
        constructor() {
          Object.defineProperty(this, "isMatrix4", { value: true }), this.elements = [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1], arguments.length > 0 && console.error("THREE.Matrix4: the constructor no longer reads arguments. use .set() instead.");
        }
        set(t2, e2, n2, r2, i2, o2, a2, s2, c2, u2, l2, h2, d2, p2, f2, m2) {
          const g2 = this.elements;
          return g2[0] = t2, g2[4] = e2, g2[8] = n2, g2[12] = r2, g2[1] = i2, g2[5] = o2, g2[9] = a2, g2[13] = s2, g2[2] = c2, g2[6] = u2, g2[10] = l2, g2[14] = h2, g2[3] = d2, g2[7] = p2, g2[11] = f2, g2[15] = m2, this;
        }
        identity() {
          return this.set(1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1), this;
        }
        clone() {
          return new Tr().fromArray(this.elements);
        }
        copy(t2) {
          const e2 = this.elements, n2 = t2.elements;
          return e2[0] = n2[0], e2[1] = n2[1], e2[2] = n2[2], e2[3] = n2[3], e2[4] = n2[4], e2[5] = n2[5], e2[6] = n2[6], e2[7] = n2[7], e2[8] = n2[8], e2[9] = n2[9], e2[10] = n2[10], e2[11] = n2[11], e2[12] = n2[12], e2[13] = n2[13], e2[14] = n2[14], e2[15] = n2[15], this;
        }
        copyPosition(t2) {
          const e2 = this.elements, n2 = t2.elements;
          return e2[12] = n2[12], e2[13] = n2[13], e2[14] = n2[14], this;
        }
        extractBasis(t2, e2, n2) {
          return t2.setFromMatrixColumn(this, 0), e2.setFromMatrixColumn(this, 1), n2.setFromMatrixColumn(this, 2), this;
        }
        makeBasis(t2, e2, n2) {
          return this.set(t2.x, e2.x, n2.x, 0, t2.y, e2.y, n2.y, 0, t2.z, e2.z, n2.z, 0, 0, 0, 0, 1), this;
        }
        extractRotation(t2) {
          const e2 = this.elements, n2 = t2.elements, r2 = 1 / Er.setFromMatrixColumn(t2, 0).length(), i2 = 1 / Er.setFromMatrixColumn(t2, 1).length(), o2 = 1 / Er.setFromMatrixColumn(t2, 2).length();
          return e2[0] = n2[0] * r2, e2[1] = n2[1] * r2, e2[2] = n2[2] * r2, e2[3] = 0, e2[4] = n2[4] * i2, e2[5] = n2[5] * i2, e2[6] = n2[6] * i2, e2[7] = 0, e2[8] = n2[8] * o2, e2[9] = n2[9] * o2, e2[10] = n2[10] * o2, e2[11] = 0, e2[12] = 0, e2[13] = 0, e2[14] = 0, e2[15] = 1, this;
        }
        makeRotationFromEuler(t2) {
          t2 && t2.isEuler || console.error("THREE.Matrix4: .makeRotationFromEuler() now expects a Euler rotation rather than a Vector3 and order.");
          const e2 = this.elements, n2 = t2.x, r2 = t2.y, i2 = t2.z, o2 = Math.cos(n2), a2 = Math.sin(n2), s2 = Math.cos(r2), c2 = Math.sin(r2), u2 = Math.cos(i2), l2 = Math.sin(i2);
          if ("XYZ" === t2.order) {
            const t3 = o2 * u2, n3 = o2 * l2, r3 = a2 * u2, i3 = a2 * l2;
            e2[0] = s2 * u2, e2[4] = -s2 * l2, e2[8] = c2, e2[1] = n3 + r3 * c2, e2[5] = t3 - i3 * c2, e2[9] = -a2 * s2, e2[2] = i3 - t3 * c2, e2[6] = r3 + n3 * c2, e2[10] = o2 * s2;
          } else if ("YXZ" === t2.order) {
            const t3 = s2 * u2, n3 = s2 * l2, r3 = c2 * u2, i3 = c2 * l2;
            e2[0] = t3 + i3 * a2, e2[4] = r3 * a2 - n3, e2[8] = o2 * c2, e2[1] = o2 * l2, e2[5] = o2 * u2, e2[9] = -a2, e2[2] = n3 * a2 - r3, e2[6] = i3 + t3 * a2, e2[10] = o2 * s2;
          } else if ("ZXY" === t2.order) {
            const t3 = s2 * u2, n3 = s2 * l2, r3 = c2 * u2, i3 = c2 * l2;
            e2[0] = t3 - i3 * a2, e2[4] = -o2 * l2, e2[8] = r3 + n3 * a2, e2[1] = n3 + r3 * a2, e2[5] = o2 * u2, e2[9] = i3 - t3 * a2, e2[2] = -o2 * c2, e2[6] = a2, e2[10] = o2 * s2;
          } else if ("ZYX" === t2.order) {
            const t3 = o2 * u2, n3 = o2 * l2, r3 = a2 * u2, i3 = a2 * l2;
            e2[0] = s2 * u2, e2[4] = r3 * c2 - n3, e2[8] = t3 * c2 + i3, e2[1] = s2 * l2, e2[5] = i3 * c2 + t3, e2[9] = n3 * c2 - r3, e2[2] = -c2, e2[6] = a2 * s2, e2[10] = o2 * s2;
          } else if ("YZX" === t2.order) {
            const t3 = o2 * s2, n3 = o2 * c2, r3 = a2 * s2, i3 = a2 * c2;
            e2[0] = s2 * u2, e2[4] = i3 - t3 * l2, e2[8] = r3 * l2 + n3, e2[1] = l2, e2[5] = o2 * u2, e2[9] = -a2 * u2, e2[2] = -c2 * u2, e2[6] = n3 * l2 + r3, e2[10] = t3 - i3 * l2;
          } else if ("XZY" === t2.order) {
            const t3 = o2 * s2, n3 = o2 * c2, r3 = a2 * s2, i3 = a2 * c2;
            e2[0] = s2 * u2, e2[4] = -l2, e2[8] = c2 * u2, e2[1] = t3 * l2 + i3, e2[5] = o2 * u2, e2[9] = n3 * l2 - r3, e2[2] = r3 * l2 - n3, e2[6] = a2 * u2, e2[10] = i3 * l2 + t3;
          }
          return e2[3] = 0, e2[7] = 0, e2[11] = 0, e2[12] = 0, e2[13] = 0, e2[14] = 0, e2[15] = 1, this;
        }
        makeRotationFromQuaternion(t2) {
          return this.compose(Cr, t2, Lr);
        }
        lookAt(t2, e2, n2) {
          const r2 = this.elements;
          return Or.subVectors(t2, e2), 0 === Or.lengthSq() && (Or.z = 1), Or.normalize(), Pr.crossVectors(n2, Or), 0 === Pr.lengthSq() && (1 === Math.abs(n2.z) ? Or.x += 1e-4 : Or.z += 1e-4, Or.normalize(), Pr.crossVectors(n2, Or)), Pr.normalize(), Rr.crossVectors(Or, Pr), r2[0] = Pr.x, r2[4] = Rr.x, r2[8] = Or.x, r2[1] = Pr.y, r2[5] = Rr.y, r2[9] = Or.y, r2[2] = Pr.z, r2[6] = Rr.z, r2[10] = Or.z, this;
        }
        multiply(t2, e2) {
          return void 0 !== e2 ? (console.warn("THREE.Matrix4: .multiply() now only accepts one argument. Use .multiplyMatrices( a, b ) instead."), this.multiplyMatrices(t2, e2)) : this.multiplyMatrices(this, t2);
        }
        premultiply(t2) {
          return this.multiplyMatrices(t2, this);
        }
        multiplyMatrices(t2, e2) {
          const n2 = t2.elements, r2 = e2.elements, i2 = this.elements, o2 = n2[0], a2 = n2[4], s2 = n2[8], c2 = n2[12], u2 = n2[1], l2 = n2[5], h2 = n2[9], d2 = n2[13], p2 = n2[2], f2 = n2[6], m2 = n2[10], g2 = n2[14], v2 = n2[3], y2 = n2[7], x2 = n2[11], b2 = n2[15], w2 = r2[0], _2 = r2[4], M2 = r2[8], S2 = r2[12], T2 = r2[1], E2 = r2[5], A2 = r2[9], C2 = r2[13], L2 = r2[2], P2 = r2[6], R2 = r2[10], O2 = r2[14], D2 = r2[3], I2 = r2[7], N2 = r2[11], z2 = r2[15];
          return i2[0] = o2 * w2 + a2 * T2 + s2 * L2 + c2 * D2, i2[4] = o2 * _2 + a2 * E2 + s2 * P2 + c2 * I2, i2[8] = o2 * M2 + a2 * A2 + s2 * R2 + c2 * N2, i2[12] = o2 * S2 + a2 * C2 + s2 * O2 + c2 * z2, i2[1] = u2 * w2 + l2 * T2 + h2 * L2 + d2 * D2, i2[5] = u2 * _2 + l2 * E2 + h2 * P2 + d2 * I2, i2[9] = u2 * M2 + l2 * A2 + h2 * R2 + d2 * N2, i2[13] = u2 * S2 + l2 * C2 + h2 * O2 + d2 * z2, i2[2] = p2 * w2 + f2 * T2 + m2 * L2 + g2 * D2, i2[6] = p2 * _2 + f2 * E2 + m2 * P2 + g2 * I2, i2[10] = p2 * M2 + f2 * A2 + m2 * R2 + g2 * N2, i2[14] = p2 * S2 + f2 * C2 + m2 * O2 + g2 * z2, i2[3] = v2 * w2 + y2 * T2 + x2 * L2 + b2 * D2, i2[7] = v2 * _2 + y2 * E2 + x2 * P2 + b2 * I2, i2[11] = v2 * M2 + y2 * A2 + x2 * R2 + b2 * N2, i2[15] = v2 * S2 + y2 * C2 + x2 * O2 + b2 * z2, this;
        }
        multiplyScalar(t2) {
          const e2 = this.elements;
          return e2[0] *= t2, e2[4] *= t2, e2[8] *= t2, e2[12] *= t2, e2[1] *= t2, e2[5] *= t2, e2[9] *= t2, e2[13] *= t2, e2[2] *= t2, e2[6] *= t2, e2[10] *= t2, e2[14] *= t2, e2[3] *= t2, e2[7] *= t2, e2[11] *= t2, e2[15] *= t2, this;
        }
        determinant() {
          const t2 = this.elements, e2 = t2[0], n2 = t2[4], r2 = t2[8], i2 = t2[12], o2 = t2[1], a2 = t2[5], s2 = t2[9], c2 = t2[13], u2 = t2[2], l2 = t2[6], h2 = t2[10], d2 = t2[14];
          return t2[3] * (+i2 * s2 * l2 - r2 * c2 * l2 - i2 * a2 * h2 + n2 * c2 * h2 + r2 * a2 * d2 - n2 * s2 * d2) + t2[7] * (+e2 * s2 * d2 - e2 * c2 * h2 + i2 * o2 * h2 - r2 * o2 * d2 + r2 * c2 * u2 - i2 * s2 * u2) + t2[11] * (+e2 * c2 * l2 - e2 * a2 * d2 - i2 * o2 * l2 + n2 * o2 * d2 + i2 * a2 * u2 - n2 * c2 * u2) + t2[15] * (-r2 * a2 * u2 - e2 * s2 * l2 + e2 * a2 * h2 + r2 * o2 * l2 - n2 * o2 * h2 + n2 * s2 * u2);
        }
        transpose() {
          const t2 = this.elements;
          let e2;
          return e2 = t2[1], t2[1] = t2[4], t2[4] = e2, e2 = t2[2], t2[2] = t2[8], t2[8] = e2, e2 = t2[6], t2[6] = t2[9], t2[9] = e2, e2 = t2[3], t2[3] = t2[12], t2[12] = e2, e2 = t2[7], t2[7] = t2[13], t2[13] = e2, e2 = t2[11], t2[11] = t2[14], t2[14] = e2, this;
        }
        setPosition(t2, e2, n2) {
          const r2 = this.elements;
          return t2.isVector3 ? (r2[12] = t2.x, r2[13] = t2.y, r2[14] = t2.z) : (r2[12] = t2, r2[13] = e2, r2[14] = n2), this;
        }
        invert() {
          const t2 = this.elements, e2 = t2[0], n2 = t2[1], r2 = t2[2], i2 = t2[3], o2 = t2[4], a2 = t2[5], s2 = t2[6], c2 = t2[7], u2 = t2[8], l2 = t2[9], h2 = t2[10], d2 = t2[11], p2 = t2[12], f2 = t2[13], m2 = t2[14], g2 = t2[15], v2 = l2 * m2 * c2 - f2 * h2 * c2 + f2 * s2 * d2 - a2 * m2 * d2 - l2 * s2 * g2 + a2 * h2 * g2, y2 = p2 * h2 * c2 - u2 * m2 * c2 - p2 * s2 * d2 + o2 * m2 * d2 + u2 * s2 * g2 - o2 * h2 * g2, x2 = u2 * f2 * c2 - p2 * l2 * c2 + p2 * a2 * d2 - o2 * f2 * d2 - u2 * a2 * g2 + o2 * l2 * g2, b2 = p2 * l2 * s2 - u2 * f2 * s2 - p2 * a2 * h2 + o2 * f2 * h2 + u2 * a2 * m2 - o2 * l2 * m2, w2 = e2 * v2 + n2 * y2 + r2 * x2 + i2 * b2;
          if (0 === w2) return this.set(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0);
          const _2 = 1 / w2;
          return t2[0] = v2 * _2, t2[1] = (f2 * h2 * i2 - l2 * m2 * i2 - f2 * r2 * d2 + n2 * m2 * d2 + l2 * r2 * g2 - n2 * h2 * g2) * _2, t2[2] = (a2 * m2 * i2 - f2 * s2 * i2 + f2 * r2 * c2 - n2 * m2 * c2 - a2 * r2 * g2 + n2 * s2 * g2) * _2, t2[3] = (l2 * s2 * i2 - a2 * h2 * i2 - l2 * r2 * c2 + n2 * h2 * c2 + a2 * r2 * d2 - n2 * s2 * d2) * _2, t2[4] = y2 * _2, t2[5] = (u2 * m2 * i2 - p2 * h2 * i2 + p2 * r2 * d2 - e2 * m2 * d2 - u2 * r2 * g2 + e2 * h2 * g2) * _2, t2[6] = (p2 * s2 * i2 - o2 * m2 * i2 - p2 * r2 * c2 + e2 * m2 * c2 + o2 * r2 * g2 - e2 * s2 * g2) * _2, t2[7] = (o2 * h2 * i2 - u2 * s2 * i2 + u2 * r2 * c2 - e2 * h2 * c2 - o2 * r2 * d2 + e2 * s2 * d2) * _2, t2[8] = x2 * _2, t2[9] = (p2 * l2 * i2 - u2 * f2 * i2 - p2 * n2 * d2 + e2 * f2 * d2 + u2 * n2 * g2 - e2 * l2 * g2) * _2, t2[10] = (o2 * f2 * i2 - p2 * a2 * i2 + p2 * n2 * c2 - e2 * f2 * c2 - o2 * n2 * g2 + e2 * a2 * g2) * _2, t2[11] = (u2 * a2 * i2 - o2 * l2 * i2 - u2 * n2 * c2 + e2 * l2 * c2 + o2 * n2 * d2 - e2 * a2 * d2) * _2, t2[12] = b2 * _2, t2[13] = (u2 * f2 * r2 - p2 * l2 * r2 + p2 * n2 * h2 - e2 * f2 * h2 - u2 * n2 * m2 + e2 * l2 * m2) * _2, t2[14] = (p2 * a2 * r2 - o2 * f2 * r2 - p2 * n2 * s2 + e2 * f2 * s2 + o2 * n2 * m2 - e2 * a2 * m2) * _2, t2[15] = (o2 * l2 * r2 - u2 * a2 * r2 + u2 * n2 * s2 - e2 * l2 * s2 - o2 * n2 * h2 + e2 * a2 * h2) * _2, this;
        }
        scale(t2) {
          const e2 = this.elements, n2 = t2.x, r2 = t2.y, i2 = t2.z;
          return e2[0] *= n2, e2[4] *= r2, e2[8] *= i2, e2[1] *= n2, e2[5] *= r2, e2[9] *= i2, e2[2] *= n2, e2[6] *= r2, e2[10] *= i2, e2[3] *= n2, e2[7] *= r2, e2[11] *= i2, this;
        }
        getMaxScaleOnAxis() {
          const t2 = this.elements, e2 = t2[0] * t2[0] + t2[1] * t2[1] + t2[2] * t2[2], n2 = t2[4] * t2[4] + t2[5] * t2[5] + t2[6] * t2[6], r2 = t2[8] * t2[8] + t2[9] * t2[9] + t2[10] * t2[10];
          return Math.sqrt(Math.max(e2, n2, r2));
        }
        makeTranslation(t2, e2, n2) {
          return this.set(1, 0, 0, t2, 0, 1, 0, e2, 0, 0, 1, n2, 0, 0, 0, 1), this;
        }
        makeRotationX(t2) {
          const e2 = Math.cos(t2), n2 = Math.sin(t2);
          return this.set(1, 0, 0, 0, 0, e2, -n2, 0, 0, n2, e2, 0, 0, 0, 0, 1), this;
        }
        makeRotationY(t2) {
          const e2 = Math.cos(t2), n2 = Math.sin(t2);
          return this.set(e2, 0, n2, 0, 0, 1, 0, 0, -n2, 0, e2, 0, 0, 0, 0, 1), this;
        }
        makeRotationZ(t2) {
          const e2 = Math.cos(t2), n2 = Math.sin(t2);
          return this.set(e2, -n2, 0, 0, n2, e2, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1), this;
        }
        makeRotationAxis(t2, e2) {
          const n2 = Math.cos(e2), r2 = Math.sin(e2), i2 = 1 - n2, o2 = t2.x, a2 = t2.y, s2 = t2.z, c2 = i2 * o2, u2 = i2 * a2;
          return this.set(c2 * o2 + n2, c2 * a2 - r2 * s2, c2 * s2 + r2 * a2, 0, c2 * a2 + r2 * s2, u2 * a2 + n2, u2 * s2 - r2 * o2, 0, c2 * s2 - r2 * a2, u2 * s2 + r2 * o2, i2 * s2 * s2 + n2, 0, 0, 0, 0, 1), this;
        }
        makeScale(t2, e2, n2) {
          return this.set(t2, 0, 0, 0, 0, e2, 0, 0, 0, 0, n2, 0, 0, 0, 0, 1), this;
        }
        makeShear(t2, e2, n2) {
          return this.set(1, e2, n2, 0, t2, 1, n2, 0, t2, e2, 1, 0, 0, 0, 0, 1), this;
        }
        compose(t2, e2, n2) {
          const r2 = this.elements, i2 = e2._x, o2 = e2._y, a2 = e2._z, s2 = e2._w, c2 = i2 + i2, u2 = o2 + o2, l2 = a2 + a2, h2 = i2 * c2, d2 = i2 * u2, p2 = i2 * l2, f2 = o2 * u2, m2 = o2 * l2, g2 = a2 * l2, v2 = s2 * c2, y2 = s2 * u2, x2 = s2 * l2, b2 = n2.x, w2 = n2.y, _2 = n2.z;
          return r2[0] = (1 - (f2 + g2)) * b2, r2[1] = (d2 + x2) * b2, r2[2] = (p2 - y2) * b2, r2[3] = 0, r2[4] = (d2 - x2) * w2, r2[5] = (1 - (h2 + g2)) * w2, r2[6] = (m2 + v2) * w2, r2[7] = 0, r2[8] = (p2 + y2) * _2, r2[9] = (m2 - v2) * _2, r2[10] = (1 - (h2 + f2)) * _2, r2[11] = 0, r2[12] = t2.x, r2[13] = t2.y, r2[14] = t2.z, r2[15] = 1, this;
        }
        decompose(t2, e2, n2) {
          const r2 = this.elements;
          let i2 = Er.set(r2[0], r2[1], r2[2]).length();
          const o2 = Er.set(r2[4], r2[5], r2[6]).length(), a2 = Er.set(r2[8], r2[9], r2[10]).length();
          this.determinant() < 0 && (i2 = -i2), t2.x = r2[12], t2.y = r2[13], t2.z = r2[14], Ar.copy(this);
          const s2 = 1 / i2, c2 = 1 / o2, u2 = 1 / a2;
          return Ar.elements[0] *= s2, Ar.elements[1] *= s2, Ar.elements[2] *= s2, Ar.elements[4] *= c2, Ar.elements[5] *= c2, Ar.elements[6] *= c2, Ar.elements[8] *= u2, Ar.elements[9] *= u2, Ar.elements[10] *= u2, e2.setFromRotationMatrix(Ar), n2.x = i2, n2.y = o2, n2.z = a2, this;
        }
        makePerspective(t2, e2, n2, r2, i2, o2) {
          void 0 === o2 && console.warn("THREE.Matrix4: .makePerspective() has been redefined and has a new signature. Please check the docs.");
          const a2 = this.elements, s2 = 2 * i2 / (e2 - t2), c2 = 2 * i2 / (n2 - r2), u2 = (e2 + t2) / (e2 - t2), l2 = (n2 + r2) / (n2 - r2), h2 = -(o2 + i2) / (o2 - i2), d2 = -2 * o2 * i2 / (o2 - i2);
          return a2[0] = s2, a2[4] = 0, a2[8] = u2, a2[12] = 0, a2[1] = 0, a2[5] = c2, a2[9] = l2, a2[13] = 0, a2[2] = 0, a2[6] = 0, a2[10] = h2, a2[14] = d2, a2[3] = 0, a2[7] = 0, a2[11] = -1, a2[15] = 0, this;
        }
        makeOrthographic(t2, e2, n2, r2, i2, o2) {
          const a2 = this.elements, s2 = 1 / (e2 - t2), c2 = 1 / (n2 - r2), u2 = 1 / (o2 - i2), l2 = (e2 + t2) * s2, h2 = (n2 + r2) * c2, d2 = (o2 + i2) * u2;
          return a2[0] = 2 * s2, a2[4] = 0, a2[8] = 0, a2[12] = -l2, a2[1] = 0, a2[5] = 2 * c2, a2[9] = 0, a2[13] = -h2, a2[2] = 0, a2[6] = 0, a2[10] = -2 * u2, a2[14] = -d2, a2[3] = 0, a2[7] = 0, a2[11] = 0, a2[15] = 1, this;
        }
        equals(t2) {
          const e2 = this.elements, n2 = t2.elements;
          for (let t3 = 0; t3 < 16; t3++) if (e2[t3] !== n2[t3]) return false;
          return true;
        }
        fromArray(t2, e2 = 0) {
          for (let n2 = 0; n2 < 16; n2++) this.elements[n2] = t2[n2 + e2];
          return this;
        }
        toArray(t2 = [], e2 = 0) {
          const n2 = this.elements;
          return t2[e2] = n2[0], t2[e2 + 1] = n2[1], t2[e2 + 2] = n2[2], t2[e2 + 3] = n2[3], t2[e2 + 4] = n2[4], t2[e2 + 5] = n2[5], t2[e2 + 6] = n2[6], t2[e2 + 7] = n2[7], t2[e2 + 8] = n2[8], t2[e2 + 9] = n2[9], t2[e2 + 10] = n2[10], t2[e2 + 11] = n2[11], t2[e2 + 12] = n2[12], t2[e2 + 13] = n2[13], t2[e2 + 14] = n2[14], t2[e2 + 15] = n2[15], t2;
        }
      }
      const Er = new $n(), Ar = new Tr(), Cr = new $n(0, 0, 0), Lr = new $n(1, 1, 1), Pr = new $n(), Rr = new $n(), Or = new $n();
      class Dr {
        constructor(t2 = 0, e2 = 0, n2 = 0, r2 = Dr.DefaultOrder) {
          Object.defineProperty(this, "isEuler", { value: true }), this._x = t2, this._y = e2, this._z = n2, this._order = r2;
        }
        get x() {
          return this._x;
        }
        set x(t2) {
          this._x = t2, this._onChangeCallback();
        }
        get y() {
          return this._y;
        }
        set y(t2) {
          this._y = t2, this._onChangeCallback();
        }
        get z() {
          return this._z;
        }
        set z(t2) {
          this._z = t2, this._onChangeCallback();
        }
        get order() {
          return this._order;
        }
        set order(t2) {
          this._order = t2, this._onChangeCallback();
        }
        set(t2, e2, n2, r2) {
          return this._x = t2, this._y = e2, this._z = n2, this._order = r2 || this._order, this._onChangeCallback(), this;
        }
        clone() {
          return new this.constructor(this._x, this._y, this._z, this._order);
        }
        copy(t2) {
          return this._x = t2._x, this._y = t2._y, this._z = t2._z, this._order = t2._order, this._onChangeCallback(), this;
        }
        setFromRotationMatrix(t2, e2, n2) {
          const r2 = Bn.clamp, i2 = t2.elements, o2 = i2[0], a2 = i2[4], s2 = i2[8], c2 = i2[1], u2 = i2[5], l2 = i2[9], h2 = i2[2], d2 = i2[6], p2 = i2[10];
          switch (e2 = e2 || this._order) {
            case "XYZ":
              this._y = Math.asin(r2(s2, -1, 1)), Math.abs(s2) < 0.9999999 ? (this._x = Math.atan2(-l2, p2), this._z = Math.atan2(-a2, o2)) : (this._x = Math.atan2(d2, u2), this._z = 0);
              break;
            case "YXZ":
              this._x = Math.asin(-r2(l2, -1, 1)), Math.abs(l2) < 0.9999999 ? (this._y = Math.atan2(s2, p2), this._z = Math.atan2(c2, u2)) : (this._y = Math.atan2(-h2, o2), this._z = 0);
              break;
            case "ZXY":
              this._x = Math.asin(r2(d2, -1, 1)), Math.abs(d2) < 0.9999999 ? (this._y = Math.atan2(-h2, p2), this._z = Math.atan2(-a2, u2)) : (this._y = 0, this._z = Math.atan2(c2, o2));
              break;
            case "ZYX":
              this._y = Math.asin(-r2(h2, -1, 1)), Math.abs(h2) < 0.9999999 ? (this._x = Math.atan2(d2, p2), this._z = Math.atan2(c2, o2)) : (this._x = 0, this._z = Math.atan2(-a2, u2));
              break;
            case "YZX":
              this._z = Math.asin(r2(c2, -1, 1)), Math.abs(c2) < 0.9999999 ? (this._x = Math.atan2(-l2, u2), this._y = Math.atan2(-h2, o2)) : (this._x = 0, this._y = Math.atan2(s2, p2));
              break;
            case "XZY":
              this._z = Math.asin(-r2(a2, -1, 1)), Math.abs(a2) < 0.9999999 ? (this._x = Math.atan2(d2, u2), this._y = Math.atan2(s2, o2)) : (this._x = Math.atan2(-l2, p2), this._y = 0);
              break;
            default:
              console.warn("THREE.Euler: .setFromRotationMatrix() encountered an unknown order: " + e2);
          }
          return this._order = e2, false !== n2 && this._onChangeCallback(), this;
        }
        setFromQuaternion(t2, e2, n2) {
          return Ir.makeRotationFromQuaternion(t2), this.setFromRotationMatrix(Ir, e2, n2);
        }
        setFromVector3(t2, e2) {
          return this.set(t2.x, t2.y, t2.z, e2 || this._order);
        }
        reorder(t2) {
          return Nr.setFromEuler(this), this.setFromQuaternion(Nr, t2);
        }
        equals(t2) {
          return t2._x === this._x && t2._y === this._y && t2._z === this._z && t2._order === this._order;
        }
        fromArray(t2) {
          return this._x = t2[0], this._y = t2[1], this._z = t2[2], void 0 !== t2[3] && (this._order = t2[3]), this._onChangeCallback(), this;
        }
        toArray(t2 = [], e2 = 0) {
          return t2[e2] = this._x, t2[e2 + 1] = this._y, t2[e2 + 2] = this._z, t2[e2 + 3] = this._order, t2;
        }
        toVector3(t2) {
          return t2 ? t2.set(this._x, this._y, this._z) : new $n(this._x, this._y, this._z);
        }
        _onChange(t2) {
          return this._onChangeCallback = t2, this;
        }
        _onChangeCallback() {
        }
      }
      Dr.DefaultOrder = "XYZ", Dr.RotationOrders = ["XYZ", "YZX", "ZXY", "XZY", "YXZ", "ZYX"];
      const Ir = new Tr(), Nr = new Jn();
      class zr {
        constructor() {
          this.mask = 1;
        }
        set(t2) {
          this.mask = 1 << t2 | 0;
        }
        enable(t2) {
          this.mask |= 1 << t2 | 0;
        }
        enableAll() {
          this.mask = -1;
        }
        toggle(t2) {
          this.mask ^= 1 << t2 | 0;
        }
        disable(t2) {
          this.mask &= ~(1 << t2 | 0);
        }
        disableAll() {
          this.mask = 0;
        }
        test(t2) {
          return 0 != (this.mask & t2.mask);
        }
      }
      let kr = 0;
      const Fr = new $n(), Br = new Jn(), Hr = new Tr(), Gr = new $n(), Ur = new $n(), jr = new $n(), Vr = new Jn(), Wr = new $n(1, 0, 0), qr = new $n(0, 1, 0), Xr = new $n(0, 0, 1), Yr = { type: "added" }, Zr = { type: "removed" };
      function Jr() {
        Object.defineProperty(this, "id", { value: kr++ }), this.uuid = Bn.generateUUID(), this.name = "", this.type = "Object3D", this.parent = null, this.children = [], this.up = Jr.DefaultUp.clone();
        const t2 = new $n(), e2 = new Dr(), n2 = new Jn(), r2 = new $n(1, 1, 1);
        e2._onChange(function() {
          n2.setFromEuler(e2, false);
        }), n2._onChange(function() {
          e2.setFromQuaternion(n2, void 0, false);
        }), Object.defineProperties(this, { position: { configurable: true, enumerable: true, value: t2 }, rotation: { configurable: true, enumerable: true, value: e2 }, quaternion: { configurable: true, enumerable: true, value: n2 }, scale: { configurable: true, enumerable: true, value: r2 }, modelViewMatrix: { value: new Tr() }, normalMatrix: { value: new Gn() } }), this.matrix = new Tr(), this.matrixWorld = new Tr(), this.matrixAutoUpdate = Jr.DefaultMatrixAutoUpdate, this.matrixWorldNeedsUpdate = false, this.layers = new zr(), this.visible = true, this.castShadow = false, this.receiveShadow = false, this.frustumCulled = true, this.renderOrder = 0, this.animations = [], this.userData = {};
      }
      Jr.DefaultUp = new $n(0, 1, 0), Jr.DefaultMatrixAutoUpdate = true, Jr.prototype = Object.assign(Object.create(zn.prototype), { constructor: Jr, isObject3D: true, onBeforeRender: function() {
      }, onAfterRender: function() {
      }, applyMatrix4: function(t2) {
        this.matrixAutoUpdate && this.updateMatrix(), this.matrix.premultiply(t2), this.matrix.decompose(this.position, this.quaternion, this.scale);
      }, applyQuaternion: function(t2) {
        return this.quaternion.premultiply(t2), this;
      }, setRotationFromAxisAngle: function(t2, e2) {
        this.quaternion.setFromAxisAngle(t2, e2);
      }, setRotationFromEuler: function(t2) {
        this.quaternion.setFromEuler(t2, true);
      }, setRotationFromMatrix: function(t2) {
        this.quaternion.setFromRotationMatrix(t2);
      }, setRotationFromQuaternion: function(t2) {
        this.quaternion.copy(t2);
      }, rotateOnAxis: function(t2, e2) {
        return Br.setFromAxisAngle(t2, e2), this.quaternion.multiply(Br), this;
      }, rotateOnWorldAxis: function(t2, e2) {
        return Br.setFromAxisAngle(t2, e2), this.quaternion.premultiply(Br), this;
      }, rotateX: function(t2) {
        return this.rotateOnAxis(Wr, t2);
      }, rotateY: function(t2) {
        return this.rotateOnAxis(qr, t2);
      }, rotateZ: function(t2) {
        return this.rotateOnAxis(Xr, t2);
      }, translateOnAxis: function(t2, e2) {
        return Fr.copy(t2).applyQuaternion(this.quaternion), this.position.add(Fr.multiplyScalar(e2)), this;
      }, translateX: function(t2) {
        return this.translateOnAxis(Wr, t2);
      }, translateY: function(t2) {
        return this.translateOnAxis(qr, t2);
      }, translateZ: function(t2) {
        return this.translateOnAxis(Xr, t2);
      }, localToWorld: function(t2) {
        return t2.applyMatrix4(this.matrixWorld);
      }, worldToLocal: function(t2) {
        return t2.applyMatrix4(Hr.copy(this.matrixWorld).invert());
      }, lookAt: function(t2, e2, n2) {
        t2.isVector3 ? Gr.copy(t2) : Gr.set(t2, e2, n2);
        const r2 = this.parent;
        this.updateWorldMatrix(true, false), Ur.setFromMatrixPosition(this.matrixWorld), this.isCamera || this.isLight ? Hr.lookAt(Ur, Gr, this.up) : Hr.lookAt(Gr, Ur, this.up), this.quaternion.setFromRotationMatrix(Hr), r2 && (Hr.extractRotation(r2.matrixWorld), Br.setFromRotationMatrix(Hr), this.quaternion.premultiply(Br.invert()));
      }, add: function(t2) {
        if (arguments.length > 1) {
          for (let t3 = 0; t3 < arguments.length; t3++) this.add(arguments[t3]);
          return this;
        }
        return t2 === this ? (console.error("THREE.Object3D.add: object can't be added as a child of itself.", t2), this) : (t2 && t2.isObject3D ? (null !== t2.parent && t2.parent.remove(t2), t2.parent = this, this.children.push(t2), t2.dispatchEvent(Yr)) : console.error("THREE.Object3D.add: object not an instance of THREE.Object3D.", t2), this);
      }, remove: function(t2) {
        if (arguments.length > 1) {
          for (let t3 = 0; t3 < arguments.length; t3++) this.remove(arguments[t3]);
          return this;
        }
        const e2 = this.children.indexOf(t2);
        return -1 !== e2 && (t2.parent = null, this.children.splice(e2, 1), t2.dispatchEvent(Zr)), this;
      }, clear: function() {
        for (let t2 = 0; t2 < this.children.length; t2++) {
          const e2 = this.children[t2];
          e2.parent = null, e2.dispatchEvent(Zr);
        }
        return this.children.length = 0, this;
      }, attach: function(t2) {
        return this.updateWorldMatrix(true, false), Hr.copy(this.matrixWorld).invert(), null !== t2.parent && (t2.parent.updateWorldMatrix(true, false), Hr.multiply(t2.parent.matrixWorld)), t2.applyMatrix4(Hr), t2.updateWorldMatrix(false, false), this.add(t2), this;
      }, getObjectById: function(t2) {
        return this.getObjectByProperty("id", t2);
      }, getObjectByName: function(t2) {
        return this.getObjectByProperty("name", t2);
      }, getObjectByProperty: function(t2, e2) {
        if (this[t2] === e2) return this;
        for (let n2 = 0, r2 = this.children.length; n2 < r2; n2++) {
          const r3 = this.children[n2].getObjectByProperty(t2, e2);
          if (void 0 !== r3) return r3;
        }
      }, getWorldPosition: function(t2) {
        return void 0 === t2 && (console.warn("THREE.Object3D: .getWorldPosition() target is now required"), t2 = new $n()), this.updateWorldMatrix(true, false), t2.setFromMatrixPosition(this.matrixWorld);
      }, getWorldQuaternion: function(t2) {
        return void 0 === t2 && (console.warn("THREE.Object3D: .getWorldQuaternion() target is now required"), t2 = new Jn()), this.updateWorldMatrix(true, false), this.matrixWorld.decompose(Ur, t2, jr), t2;
      }, getWorldScale: function(t2) {
        return void 0 === t2 && (console.warn("THREE.Object3D: .getWorldScale() target is now required"), t2 = new $n()), this.updateWorldMatrix(true, false), this.matrixWorld.decompose(Ur, Vr, t2), t2;
      }, getWorldDirection: function(t2) {
        void 0 === t2 && (console.warn("THREE.Object3D: .getWorldDirection() target is now required"), t2 = new $n()), this.updateWorldMatrix(true, false);
        const e2 = this.matrixWorld.elements;
        return t2.set(e2[8], e2[9], e2[10]).normalize();
      }, raycast: function() {
      }, traverse: function(t2) {
        t2(this);
        const e2 = this.children;
        for (let n2 = 0, r2 = e2.length; n2 < r2; n2++) e2[n2].traverse(t2);
      }, traverseVisible: function(t2) {
        if (false === this.visible) return;
        t2(this);
        const e2 = this.children;
        for (let n2 = 0, r2 = e2.length; n2 < r2; n2++) e2[n2].traverseVisible(t2);
      }, traverseAncestors: function(t2) {
        const e2 = this.parent;
        null !== e2 && (t2(e2), e2.traverseAncestors(t2));
      }, updateMatrix: function() {
        this.matrix.compose(this.position, this.quaternion, this.scale), this.matrixWorldNeedsUpdate = true;
      }, updateMatrixWorld: function(t2) {
        this.matrixAutoUpdate && this.updateMatrix(), (this.matrixWorldNeedsUpdate || t2) && (null === this.parent ? this.matrixWorld.copy(this.matrix) : this.matrixWorld.multiplyMatrices(this.parent.matrixWorld, this.matrix), this.matrixWorldNeedsUpdate = false, t2 = true);
        const e2 = this.children;
        for (let n2 = 0, r2 = e2.length; n2 < r2; n2++) e2[n2].updateMatrixWorld(t2);
      }, updateWorldMatrix: function(t2, e2) {
        const n2 = this.parent;
        if (true === t2 && null !== n2 && n2.updateWorldMatrix(true, false), this.matrixAutoUpdate && this.updateMatrix(), null === this.parent ? this.matrixWorld.copy(this.matrix) : this.matrixWorld.multiplyMatrices(this.parent.matrixWorld, this.matrix), true === e2) {
          const t3 = this.children;
          for (let e3 = 0, n3 = t3.length; e3 < n3; e3++) t3[e3].updateWorldMatrix(false, true);
        }
      }, toJSON: function(t2) {
        const e2 = void 0 === t2 || "string" == typeof t2, n2 = {};
        e2 && (t2 = { geometries: {}, materials: {}, textures: {}, images: {}, shapes: {}, skeletons: {}, animations: {} }, n2.metadata = { version: 4.5, type: "Object", generator: "Object3D.toJSON" });
        const r2 = {};
        function i2(e3, n3) {
          return void 0 === e3[n3.uuid] && (e3[n3.uuid] = n3.toJSON(t2)), n3.uuid;
        }
        if (r2.uuid = this.uuid, r2.type = this.type, "" !== this.name && (r2.name = this.name), true === this.castShadow && (r2.castShadow = true), true === this.receiveShadow && (r2.receiveShadow = true), false === this.visible && (r2.visible = false), false === this.frustumCulled && (r2.frustumCulled = false), 0 !== this.renderOrder && (r2.renderOrder = this.renderOrder), "{}" !== JSON.stringify(this.userData) && (r2.userData = this.userData), r2.layers = this.layers.mask, r2.matrix = this.matrix.toArray(), false === this.matrixAutoUpdate && (r2.matrixAutoUpdate = false), this.isInstancedMesh && (r2.type = "InstancedMesh", r2.count = this.count, r2.instanceMatrix = this.instanceMatrix.toJSON()), this.isMesh || this.isLine || this.isPoints) {
          r2.geometry = i2(t2.geometries, this.geometry);
          const e3 = this.geometry.parameters;
          if (void 0 !== e3 && void 0 !== e3.shapes) {
            const n3 = e3.shapes;
            if (Array.isArray(n3)) for (let e4 = 0, r3 = n3.length; e4 < r3; e4++) {
              const r4 = n3[e4];
              i2(t2.shapes, r4);
            }
            else i2(t2.shapes, n3);
          }
        }
        if (this.isSkinnedMesh && (r2.bindMode = this.bindMode, r2.bindMatrix = this.bindMatrix.toArray(), void 0 !== this.skeleton && (i2(t2.skeletons, this.skeleton), r2.skeleton = this.skeleton.uuid)), void 0 !== this.material) if (Array.isArray(this.material)) {
          const e3 = [];
          for (let n3 = 0, r3 = this.material.length; n3 < r3; n3++) e3.push(i2(t2.materials, this.material[n3]));
          r2.material = e3;
        } else r2.material = i2(t2.materials, this.material);
        if (this.children.length > 0) {
          r2.children = [];
          for (let e3 = 0; e3 < this.children.length; e3++) r2.children.push(this.children[e3].toJSON(t2).object);
        }
        if (this.animations.length > 0) {
          r2.animations = [];
          for (let e3 = 0; e3 < this.animations.length; e3++) {
            const n3 = this.animations[e3];
            r2.animations.push(i2(t2.animations, n3));
          }
        }
        if (e2) {
          const e3 = o2(t2.geometries), r3 = o2(t2.materials), i3 = o2(t2.textures), a2 = o2(t2.images), s2 = o2(t2.shapes), c2 = o2(t2.skeletons), u2 = o2(t2.animations);
          e3.length > 0 && (n2.geometries = e3), r3.length > 0 && (n2.materials = r3), i3.length > 0 && (n2.textures = i3), a2.length > 0 && (n2.images = a2), s2.length > 0 && (n2.shapes = s2), c2.length > 0 && (n2.skeletons = c2), u2.length > 0 && (n2.animations = u2);
        }
        return n2.object = r2, n2;
        function o2(t3) {
          const e3 = [];
          for (const n3 in t3) {
            const r3 = t3[n3];
            delete r3.metadata, e3.push(r3);
          }
          return e3;
        }
      }, clone: function(t2) {
        return new this.constructor().copy(this, t2);
      }, copy: function(t2, e2 = true) {
        if (this.name = t2.name, this.up.copy(t2.up), this.position.copy(t2.position), this.rotation.order = t2.rotation.order, this.quaternion.copy(t2.quaternion), this.scale.copy(t2.scale), this.matrix.copy(t2.matrix), this.matrixWorld.copy(t2.matrixWorld), this.matrixAutoUpdate = t2.matrixAutoUpdate, this.matrixWorldNeedsUpdate = t2.matrixWorldNeedsUpdate, this.layers.mask = t2.layers.mask, this.visible = t2.visible, this.castShadow = t2.castShadow, this.receiveShadow = t2.receiveShadow, this.frustumCulled = t2.frustumCulled, this.renderOrder = t2.renderOrder, this.userData = JSON.parse(JSON.stringify(t2.userData)), true === e2) for (let e3 = 0; e3 < t2.children.length; e3++) {
          const n2 = t2.children[e3];
          this.add(n2.clone());
        }
        return this;
      } });
      const $r = new $n(), Qr = new $n(), Kr = new Gn();
      class ti {
        constructor(t2, e2) {
          Object.defineProperty(this, "isPlane", { value: true }), this.normal = void 0 !== t2 ? t2 : new $n(1, 0, 0), this.constant = void 0 !== e2 ? e2 : 0;
        }
        set(t2, e2) {
          return this.normal.copy(t2), this.constant = e2, this;
        }
        setComponents(t2, e2, n2, r2) {
          return this.normal.set(t2, e2, n2), this.constant = r2, this;
        }
        setFromNormalAndCoplanarPoint(t2, e2) {
          return this.normal.copy(t2), this.constant = -e2.dot(this.normal), this;
        }
        setFromCoplanarPoints(t2, e2, n2) {
          const r2 = $r.subVectors(n2, e2).cross(Qr.subVectors(t2, e2)).normalize();
          return this.setFromNormalAndCoplanarPoint(r2, t2), this;
        }
        clone() {
          return new this.constructor().copy(this);
        }
        copy(t2) {
          return this.normal.copy(t2.normal), this.constant = t2.constant, this;
        }
        normalize() {
          const t2 = 1 / this.normal.length();
          return this.normal.multiplyScalar(t2), this.constant *= t2, this;
        }
        negate() {
          return this.constant *= -1, this.normal.negate(), this;
        }
        distanceToPoint(t2) {
          return this.normal.dot(t2) + this.constant;
        }
        distanceToSphere(t2) {
          return this.distanceToPoint(t2.center) - t2.radius;
        }
        projectPoint(t2, e2) {
          return void 0 === e2 && (console.warn("THREE.Plane: .projectPoint() target is now required"), e2 = new $n()), e2.copy(this.normal).multiplyScalar(-this.distanceToPoint(t2)).add(t2);
        }
        intersectLine(t2, e2) {
          void 0 === e2 && (console.warn("THREE.Plane: .intersectLine() target is now required"), e2 = new $n());
          const n2 = t2.delta($r), r2 = this.normal.dot(n2);
          if (0 === r2) return 0 === this.distanceToPoint(t2.start) ? e2.copy(t2.start) : void 0;
          const i2 = -(t2.start.dot(this.normal) + this.constant) / r2;
          return i2 < 0 || i2 > 1 ? void 0 : e2.copy(n2).multiplyScalar(i2).add(t2.start);
        }
        intersectsLine(t2) {
          const e2 = this.distanceToPoint(t2.start), n2 = this.distanceToPoint(t2.end);
          return e2 < 0 && n2 > 0 || n2 < 0 && e2 > 0;
        }
        intersectsBox(t2) {
          return t2.intersectsPlane(this);
        }
        intersectsSphere(t2) {
          return t2.intersectsPlane(this);
        }
        coplanarPoint(t2) {
          return void 0 === t2 && (console.warn("THREE.Plane: .coplanarPoint() target is now required"), t2 = new $n()), t2.copy(this.normal).multiplyScalar(-this.constant);
        }
        applyMatrix4(t2, e2) {
          const n2 = e2 || Kr.getNormalMatrix(t2), r2 = this.coplanarPoint($r).applyMatrix4(t2), i2 = this.normal.applyMatrix3(n2).normalize();
          return this.constant = -r2.dot(i2), this;
        }
        translate(t2) {
          return this.constant -= t2.dot(this.normal), this;
        }
        equals(t2) {
          return t2.normal.equals(this.normal) && t2.constant === this.constant;
        }
      }
      const ei = new $n(), ni = new $n(), ri = new $n(), ii = new $n(), oi = new $n(), ai = new $n(), si = new $n(), ci = new $n(), ui = new $n(), li = new $n();
      class hi {
        constructor(t2, e2, n2) {
          this.a = void 0 !== t2 ? t2 : new $n(), this.b = void 0 !== e2 ? e2 : new $n(), this.c = void 0 !== n2 ? n2 : new $n();
        }
        static getNormal(t2, e2, n2, r2) {
          void 0 === r2 && (console.warn("THREE.Triangle: .getNormal() target is now required"), r2 = new $n()), r2.subVectors(n2, e2), ei.subVectors(t2, e2), r2.cross(ei);
          const i2 = r2.lengthSq();
          return i2 > 0 ? r2.multiplyScalar(1 / Math.sqrt(i2)) : r2.set(0, 0, 0);
        }
        static getBarycoord(t2, e2, n2, r2, i2) {
          ei.subVectors(r2, e2), ni.subVectors(n2, e2), ri.subVectors(t2, e2);
          const o2 = ei.dot(ei), a2 = ei.dot(ni), s2 = ei.dot(ri), c2 = ni.dot(ni), u2 = ni.dot(ri), l2 = o2 * c2 - a2 * a2;
          if (void 0 === i2 && (console.warn("THREE.Triangle: .getBarycoord() target is now required"), i2 = new $n()), 0 === l2) return i2.set(-2, -1, -1);
          const h2 = 1 / l2, d2 = (c2 * s2 - a2 * u2) * h2, p2 = (o2 * u2 - a2 * s2) * h2;
          return i2.set(1 - d2 - p2, p2, d2);
        }
        static containsPoint(t2, e2, n2, r2) {
          return this.getBarycoord(t2, e2, n2, r2, ii), ii.x >= 0 && ii.y >= 0 && ii.x + ii.y <= 1;
        }
        static getUV(t2, e2, n2, r2, i2, o2, a2, s2) {
          return this.getBarycoord(t2, e2, n2, r2, ii), s2.set(0, 0), s2.addScaledVector(i2, ii.x), s2.addScaledVector(o2, ii.y), s2.addScaledVector(a2, ii.z), s2;
        }
        static isFrontFacing(t2, e2, n2, r2) {
          return ei.subVectors(n2, e2), ni.subVectors(t2, e2), ei.cross(ni).dot(r2) < 0;
        }
        set(t2, e2, n2) {
          return this.a.copy(t2), this.b.copy(e2), this.c.copy(n2), this;
        }
        setFromPointsAndIndices(t2, e2, n2, r2) {
          return this.a.copy(t2[e2]), this.b.copy(t2[n2]), this.c.copy(t2[r2]), this;
        }
        clone() {
          return new this.constructor().copy(this);
        }
        copy(t2) {
          return this.a.copy(t2.a), this.b.copy(t2.b), this.c.copy(t2.c), this;
        }
        getArea() {
          return ei.subVectors(this.c, this.b), ni.subVectors(this.a, this.b), 0.5 * ei.cross(ni).length();
        }
        getMidpoint(t2) {
          return void 0 === t2 && (console.warn("THREE.Triangle: .getMidpoint() target is now required"), t2 = new $n()), t2.addVectors(this.a, this.b).add(this.c).multiplyScalar(1 / 3);
        }
        getNormal(t2) {
          return hi.getNormal(this.a, this.b, this.c, t2);
        }
        getPlane(t2) {
          return void 0 === t2 && (console.warn("THREE.Triangle: .getPlane() target is now required"), t2 = new ti()), t2.setFromCoplanarPoints(this.a, this.b, this.c);
        }
        getBarycoord(t2, e2) {
          return hi.getBarycoord(t2, this.a, this.b, this.c, e2);
        }
        getUV(t2, e2, n2, r2, i2) {
          return hi.getUV(t2, this.a, this.b, this.c, e2, n2, r2, i2);
        }
        containsPoint(t2) {
          return hi.containsPoint(t2, this.a, this.b, this.c);
        }
        isFrontFacing(t2) {
          return hi.isFrontFacing(this.a, this.b, this.c, t2);
        }
        intersectsBox(t2) {
          return t2.intersectsTriangle(this);
        }
        closestPointToPoint(t2, e2) {
          void 0 === e2 && (console.warn("THREE.Triangle: .closestPointToPoint() target is now required"), e2 = new $n());
          const n2 = this.a, r2 = this.b, i2 = this.c;
          let o2, a2;
          oi.subVectors(r2, n2), ai.subVectors(i2, n2), ci.subVectors(t2, n2);
          const s2 = oi.dot(ci), c2 = ai.dot(ci);
          if (s2 <= 0 && c2 <= 0) return e2.copy(n2);
          ui.subVectors(t2, r2);
          const u2 = oi.dot(ui), l2 = ai.dot(ui);
          if (u2 >= 0 && l2 <= u2) return e2.copy(r2);
          const h2 = s2 * l2 - u2 * c2;
          if (h2 <= 0 && s2 >= 0 && u2 <= 0) return o2 = s2 / (s2 - u2), e2.copy(n2).addScaledVector(oi, o2);
          li.subVectors(t2, i2);
          const d2 = oi.dot(li), p2 = ai.dot(li);
          if (p2 >= 0 && d2 <= p2) return e2.copy(i2);
          const f2 = d2 * c2 - s2 * p2;
          if (f2 <= 0 && c2 >= 0 && p2 <= 0) return a2 = c2 / (c2 - p2), e2.copy(n2).addScaledVector(ai, a2);
          const m2 = u2 * p2 - d2 * l2;
          if (m2 <= 0 && l2 - u2 >= 0 && d2 - p2 >= 0) return si.subVectors(i2, r2), a2 = (l2 - u2) / (l2 - u2 + (d2 - p2)), e2.copy(r2).addScaledVector(si, a2);
          const g2 = 1 / (m2 + f2 + h2);
          return o2 = f2 * g2, a2 = h2 * g2, e2.copy(n2).addScaledVector(oi, o2).addScaledVector(ai, a2);
        }
        equals(t2) {
          return t2.a.equals(this.a) && t2.b.equals(this.b) && t2.c.equals(this.c);
        }
      }
      const di = { aliceblue: 15792383, antiquewhite: 16444375, aqua: 65535, aquamarine: 8388564, azure: 15794175, beige: 16119260, bisque: 16770244, black: 0, blanchedalmond: 16772045, blue: 255, blueviolet: 9055202, brown: 10824234, burlywood: 14596231, cadetblue: 6266528, chartreuse: 8388352, chocolate: 13789470, coral: 16744272, cornflowerblue: 6591981, cornsilk: 16775388, crimson: 14423100, cyan: 65535, darkblue: 139, darkcyan: 35723, darkgoldenrod: 12092939, darkgray: 11119017, darkgreen: 25600, darkgrey: 11119017, darkkhaki: 12433259, darkmagenta: 9109643, darkolivegreen: 5597999, darkorange: 16747520, darkorchid: 10040012, darkred: 9109504, darksalmon: 15308410, darkseagreen: 9419919, darkslateblue: 4734347, darkslategray: 3100495, darkslategrey: 3100495, darkturquoise: 52945, darkviolet: 9699539, deeppink: 16716947, deepskyblue: 49151, dimgray: 6908265, dimgrey: 6908265, dodgerblue: 2003199, firebrick: 11674146, floralwhite: 16775920, forestgreen: 2263842, fuchsia: 16711935, gainsboro: 14474460, ghostwhite: 16316671, gold: 16766720, goldenrod: 14329120, gray: 8421504, green: 32768, greenyellow: 11403055, grey: 8421504, honeydew: 15794160, hotpink: 16738740, indianred: 13458524, indigo: 4915330, ivory: 16777200, khaki: 15787660, lavender: 15132410, lavenderblush: 16773365, lawngreen: 8190976, lemonchiffon: 16775885, lightblue: 11393254, lightcoral: 15761536, lightcyan: 14745599, lightgoldenrodyellow: 16448210, lightgray: 13882323, lightgreen: 9498256, lightgrey: 13882323, lightpink: 16758465, lightsalmon: 16752762, lightseagreen: 2142890, lightskyblue: 8900346, lightslategray: 7833753, lightslategrey: 7833753, lightsteelblue: 11584734, lightyellow: 16777184, lime: 65280, limegreen: 3329330, linen: 16445670, magenta: 16711935, maroon: 8388608, mediumaquamarine: 6737322, mediumblue: 205, mediumorchid: 12211667, mediumpurple: 9662683, mediumseagreen: 3978097, mediumslateblue: 8087790, mediumspringgreen: 64154, mediumturquoise: 4772300, mediumvioletred: 13047173, midnightblue: 1644912, mintcream: 16121850, mistyrose: 16770273, moccasin: 16770229, navajowhite: 16768685, navy: 128, oldlace: 16643558, olive: 8421376, olivedrab: 7048739, orange: 16753920, orangered: 16729344, orchid: 14315734, palegoldenrod: 15657130, palegreen: 10025880, paleturquoise: 11529966, palevioletred: 14381203, papayawhip: 16773077, peachpuff: 16767673, peru: 13468991, pink: 16761035, plum: 14524637, powderblue: 11591910, purple: 8388736, rebeccapurple: 6697881, red: 16711680, rosybrown: 12357519, royalblue: 4286945, saddlebrown: 9127187, salmon: 16416882, sandybrown: 16032864, seagreen: 3050327, seashell: 16774638, sienna: 10506797, silver: 12632256, skyblue: 8900331, slateblue: 6970061, slategray: 7372944, slategrey: 7372944, snow: 16775930, springgreen: 65407, steelblue: 4620980, tan: 13808780, teal: 32896, thistle: 14204888, tomato: 16737095, turquoise: 4251856, violet: 15631086, wheat: 16113331, white: 16777215, whitesmoke: 16119285, yellow: 16776960, yellowgreen: 10145074 }, pi = { h: 0, s: 0, l: 0 }, fi = { h: 0, s: 0, l: 0 };
      function mi(t2, e2, n2) {
        return n2 < 0 && (n2 += 1), n2 > 1 && (n2 -= 1), n2 < 1 / 6 ? t2 + 6 * (e2 - t2) * n2 : n2 < 0.5 ? e2 : n2 < 2 / 3 ? t2 + 6 * (e2 - t2) * (2 / 3 - n2) : t2;
      }
      function gi(t2) {
        return t2 < 0.04045 ? 0.0773993808 * t2 : Math.pow(0.9478672986 * t2 + 0.0521327014, 2.4);
      }
      function vi(t2) {
        return t2 < 31308e-7 ? 12.92 * t2 : 1.055 * Math.pow(t2, 0.41666) - 0.055;
      }
      class yi {
        constructor(t2, e2, n2) {
          return Object.defineProperty(this, "isColor", { value: true }), void 0 === e2 && void 0 === n2 ? this.set(t2) : this.setRGB(t2, e2, n2);
        }
        set(t2) {
          return t2 && t2.isColor ? this.copy(t2) : "number" == typeof t2 ? this.setHex(t2) : "string" == typeof t2 && this.setStyle(t2), this;
        }
        setScalar(t2) {
          return this.r = t2, this.g = t2, this.b = t2, this;
        }
        setHex(t2) {
          return t2 = Math.floor(t2), this.r = (t2 >> 16 & 255) / 255, this.g = (t2 >> 8 & 255) / 255, this.b = (255 & t2) / 255, this;
        }
        setRGB(t2, e2, n2) {
          return this.r = t2, this.g = e2, this.b = n2, this;
        }
        setHSL(t2, e2, n2) {
          if (t2 = Bn.euclideanModulo(t2, 1), e2 = Bn.clamp(e2, 0, 1), n2 = Bn.clamp(n2, 0, 1), 0 === e2) this.r = this.g = this.b = n2;
          else {
            const r2 = n2 <= 0.5 ? n2 * (1 + e2) : n2 + e2 - n2 * e2, i2 = 2 * n2 - r2;
            this.r = mi(i2, r2, t2 + 1 / 3), this.g = mi(i2, r2, t2), this.b = mi(i2, r2, t2 - 1 / 3);
          }
          return this;
        }
        setStyle(t2) {
          function e2(e3) {
            void 0 !== e3 && parseFloat(e3) < 1 && console.warn("THREE.Color: Alpha component of " + t2 + " will be ignored.");
          }
          let n2;
          if (n2 = /^((?:rgb|hsl)a?)\(\s*([^\)]*)\)/.exec(t2)) {
            let t3;
            const r2 = n2[1], i2 = n2[2];
            switch (r2) {
              case "rgb":
              case "rgba":
                if (t3 = /^(\d+)\s*,\s*(\d+)\s*,\s*(\d+)\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(i2)) return this.r = Math.min(255, parseInt(t3[1], 10)) / 255, this.g = Math.min(255, parseInt(t3[2], 10)) / 255, this.b = Math.min(255, parseInt(t3[3], 10)) / 255, e2(t3[4]), this;
                if (t3 = /^(\d+)\%\s*,\s*(\d+)\%\s*,\s*(\d+)\%\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(i2)) return this.r = Math.min(100, parseInt(t3[1], 10)) / 100, this.g = Math.min(100, parseInt(t3[2], 10)) / 100, this.b = Math.min(100, parseInt(t3[3], 10)) / 100, e2(t3[4]), this;
                break;
              case "hsl":
              case "hsla":
                if (t3 = /^(\d*\.?\d+)\s*,\s*(\d+)\%\s*,\s*(\d+)\%\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(i2)) {
                  const n3 = parseFloat(t3[1]) / 360, r3 = parseInt(t3[2], 10) / 100, i3 = parseInt(t3[3], 10) / 100;
                  return e2(t3[4]), this.setHSL(n3, r3, i3);
                }
            }
          } else if (n2 = /^\#([A-Fa-f\d]+)$/.exec(t2)) {
            const t3 = n2[1], e3 = t3.length;
            if (3 === e3) return this.r = parseInt(t3.charAt(0) + t3.charAt(0), 16) / 255, this.g = parseInt(t3.charAt(1) + t3.charAt(1), 16) / 255, this.b = parseInt(t3.charAt(2) + t3.charAt(2), 16) / 255, this;
            if (6 === e3) return this.r = parseInt(t3.charAt(0) + t3.charAt(1), 16) / 255, this.g = parseInt(t3.charAt(2) + t3.charAt(3), 16) / 255, this.b = parseInt(t3.charAt(4) + t3.charAt(5), 16) / 255, this;
          }
          return t2 && t2.length > 0 ? this.setColorName(t2) : this;
        }
        setColorName(t2) {
          const e2 = di[t2];
          return void 0 !== e2 ? this.setHex(e2) : console.warn("THREE.Color: Unknown color " + t2), this;
        }
        clone() {
          return new this.constructor(this.r, this.g, this.b);
        }
        copy(t2) {
          return this.r = t2.r, this.g = t2.g, this.b = t2.b, this;
        }
        copyGammaToLinear(t2, e2 = 2) {
          return this.r = Math.pow(t2.r, e2), this.g = Math.pow(t2.g, e2), this.b = Math.pow(t2.b, e2), this;
        }
        copyLinearToGamma(t2, e2 = 2) {
          const n2 = e2 > 0 ? 1 / e2 : 1;
          return this.r = Math.pow(t2.r, n2), this.g = Math.pow(t2.g, n2), this.b = Math.pow(t2.b, n2), this;
        }
        convertGammaToLinear(t2) {
          return this.copyGammaToLinear(this, t2), this;
        }
        convertLinearToGamma(t2) {
          return this.copyLinearToGamma(this, t2), this;
        }
        copySRGBToLinear(t2) {
          return this.r = gi(t2.r), this.g = gi(t2.g), this.b = gi(t2.b), this;
        }
        copyLinearToSRGB(t2) {
          return this.r = vi(t2.r), this.g = vi(t2.g), this.b = vi(t2.b), this;
        }
        convertSRGBToLinear() {
          return this.copySRGBToLinear(this), this;
        }
        convertLinearToSRGB() {
          return this.copyLinearToSRGB(this), this;
        }
        getHex() {
          return 255 * this.r << 16 ^ 255 * this.g << 8 ^ 255 * this.b << 0;
        }
        getHexString() {
          return ("000000" + this.getHex().toString(16)).slice(-6);
        }
        getHSL(t2) {
          void 0 === t2 && (console.warn("THREE.Color: .getHSL() target is now required"), t2 = { h: 0, s: 0, l: 0 });
          const e2 = this.r, n2 = this.g, r2 = this.b, i2 = Math.max(e2, n2, r2), o2 = Math.min(e2, n2, r2);
          let a2, s2;
          const c2 = (o2 + i2) / 2;
          if (o2 === i2) a2 = 0, s2 = 0;
          else {
            const t3 = i2 - o2;
            switch (s2 = c2 <= 0.5 ? t3 / (i2 + o2) : t3 / (2 - i2 - o2), i2) {
              case e2:
                a2 = (n2 - r2) / t3 + (n2 < r2 ? 6 : 0);
                break;
              case n2:
                a2 = (r2 - e2) / t3 + 2;
                break;
              case r2:
                a2 = (e2 - n2) / t3 + 4;
            }
            a2 /= 6;
          }
          return t2.h = a2, t2.s = s2, t2.l = c2, t2;
        }
        getStyle() {
          return "rgb(" + (255 * this.r | 0) + "," + (255 * this.g | 0) + "," + (255 * this.b | 0) + ")";
        }
        offsetHSL(t2, e2, n2) {
          return this.getHSL(pi), pi.h += t2, pi.s += e2, pi.l += n2, this.setHSL(pi.h, pi.s, pi.l), this;
        }
        add(t2) {
          return this.r += t2.r, this.g += t2.g, this.b += t2.b, this;
        }
        addColors(t2, e2) {
          return this.r = t2.r + e2.r, this.g = t2.g + e2.g, this.b = t2.b + e2.b, this;
        }
        addScalar(t2) {
          return this.r += t2, this.g += t2, this.b += t2, this;
        }
        sub(t2) {
          return this.r = Math.max(0, this.r - t2.r), this.g = Math.max(0, this.g - t2.g), this.b = Math.max(0, this.b - t2.b), this;
        }
        multiply(t2) {
          return this.r *= t2.r, this.g *= t2.g, this.b *= t2.b, this;
        }
        multiplyScalar(t2) {
          return this.r *= t2, this.g *= t2, this.b *= t2, this;
        }
        lerp(t2, e2) {
          return this.r += (t2.r - this.r) * e2, this.g += (t2.g - this.g) * e2, this.b += (t2.b - this.b) * e2, this;
        }
        lerpHSL(t2, e2) {
          this.getHSL(pi), t2.getHSL(fi);
          const n2 = Bn.lerp(pi.h, fi.h, e2), r2 = Bn.lerp(pi.s, fi.s, e2), i2 = Bn.lerp(pi.l, fi.l, e2);
          return this.setHSL(n2, r2, i2), this;
        }
        equals(t2) {
          return t2.r === this.r && t2.g === this.g && t2.b === this.b;
        }
        fromArray(t2, e2 = 0) {
          return this.r = t2[e2], this.g = t2[e2 + 1], this.b = t2[e2 + 2], this;
        }
        toArray(t2 = [], e2 = 0) {
          return t2[e2] = this.r, t2[e2 + 1] = this.g, t2[e2 + 2] = this.b, t2;
        }
        fromBufferAttribute(t2, e2) {
          return this.r = t2.getX(e2), this.g = t2.getY(e2), this.b = t2.getZ(e2), true === t2.normalized && (this.r /= 255, this.g /= 255, this.b /= 255), this;
        }
        toJSON() {
          return this.getHex();
        }
      }
      yi.NAMES = di, yi.prototype.r = 1, yi.prototype.g = 1, yi.prototype.b = 1;
      class xi {
        constructor(t2, e2, n2, r2, i2, o2 = 0) {
          this.a = t2, this.b = e2, this.c = n2, this.normal = r2 && r2.isVector3 ? r2 : new $n(), this.vertexNormals = Array.isArray(r2) ? r2 : [], this.color = i2 && i2.isColor ? i2 : new yi(), this.vertexColors = Array.isArray(i2) ? i2 : [], this.materialIndex = o2;
        }
        clone() {
          return new this.constructor().copy(this);
        }
        copy(t2) {
          this.a = t2.a, this.b = t2.b, this.c = t2.c, this.normal.copy(t2.normal), this.color.copy(t2.color), this.materialIndex = t2.materialIndex;
          for (let e2 = 0, n2 = t2.vertexNormals.length; e2 < n2; e2++) this.vertexNormals[e2] = t2.vertexNormals[e2].clone();
          for (let e2 = 0, n2 = t2.vertexColors.length; e2 < n2; e2++) this.vertexColors[e2] = t2.vertexColors[e2].clone();
          return this;
        }
      }
      let bi = 0;
      function wi() {
        Object.defineProperty(this, "id", { value: bi++ }), this.uuid = Bn.generateUUID(), this.name = "", this.type = "Material", this.fog = true, this.blending = b, this.side = f, this.flatShading = false, this.vertexColors = false, this.opacity = 1, this.transparent = false, this.blendSrc = I, this.blendDst = N, this.blendEquation = T, this.blendSrcAlpha = null, this.blendDstAlpha = null, this.blendEquationAlpha = null, this.depthFunc = V, this.depthTest = true, this.depthWrite = true, this.stencilWriteMask = 255, this.stencilFunc = Sn, this.stencilRef = 0, this.stencilFuncMask = 255, this.stencilFail = ln, this.stencilZFail = ln, this.stencilZPass = ln, this.stencilWrite = false, this.clippingPlanes = null, this.clipIntersection = false, this.clipShadows = false, this.shadowSide = null, this.colorWrite = true, this.precision = null, this.polygonOffset = false, this.polygonOffsetFactor = 0, this.polygonOffsetUnits = 0, this.dithering = false, this.alphaTest = 0, this.premultipliedAlpha = false, this.visible = true, this.toneMapped = true, this.userData = {}, this.version = 0;
      }
      function _i(t2) {
        wi.call(this), this.type = "MeshBasicMaterial", this.color = new yi(16777215), this.map = null, this.lightMap = null, this.lightMapIntensity = 1, this.aoMap = null, this.aoMapIntensity = 1, this.specularMap = null, this.alphaMap = null, this.envMap = null, this.combine = Z, this.reflectivity = 1, this.refractionRatio = 0.98, this.wireframe = false, this.wireframeLinewidth = 1, this.wireframeLinecap = "round", this.wireframeLinejoin = "round", this.skinning = false, this.morphTargets = false, this.setValues(t2);
      }
      wi.prototype = Object.assign(Object.create(zn.prototype), { constructor: wi, isMaterial: true, onBeforeCompile: function() {
      }, customProgramCacheKey: function() {
        return this.onBeforeCompile.toString();
      }, setValues: function(t2) {
        if (void 0 !== t2) for (const e2 in t2) {
          const n2 = t2[e2];
          if (void 0 === n2) {
            console.warn("THREE.Material: '" + e2 + "' parameter is undefined.");
            continue;
          }
          if ("shading" === e2) {
            console.warn("THREE." + this.type + ": .shading has been removed. Use the boolean .flatShading instead."), this.flatShading = n2 === v;
            continue;
          }
          const r2 = this[e2];
          void 0 !== r2 ? r2 && r2.isColor ? r2.set(n2) : r2 && r2.isVector3 && n2 && n2.isVector3 ? r2.copy(n2) : this[e2] = n2 : console.warn("THREE." + this.type + ": '" + e2 + "' is not a property of this material.");
        }
      }, toJSON: function(t2) {
        const e2 = void 0 === t2 || "string" == typeof t2;
        e2 && (t2 = { textures: {}, images: {} });
        const n2 = { metadata: { version: 4.5, type: "Material", generator: "Material.toJSON" } };
        function r2(t3) {
          const e3 = [];
          for (const n3 in t3) {
            const r3 = t3[n3];
            delete r3.metadata, e3.push(r3);
          }
          return e3;
        }
        if (n2.uuid = this.uuid, n2.type = this.type, "" !== this.name && (n2.name = this.name), this.color && this.color.isColor && (n2.color = this.color.getHex()), void 0 !== this.roughness && (n2.roughness = this.roughness), void 0 !== this.metalness && (n2.metalness = this.metalness), this.sheen && this.sheen.isColor && (n2.sheen = this.sheen.getHex()), this.emissive && this.emissive.isColor && (n2.emissive = this.emissive.getHex()), this.emissiveIntensity && 1 !== this.emissiveIntensity && (n2.emissiveIntensity = this.emissiveIntensity), this.specular && this.specular.isColor && (n2.specular = this.specular.getHex()), void 0 !== this.shininess && (n2.shininess = this.shininess), void 0 !== this.clearcoat && (n2.clearcoat = this.clearcoat), void 0 !== this.clearcoatRoughness && (n2.clearcoatRoughness = this.clearcoatRoughness), this.clearcoatMap && this.clearcoatMap.isTexture && (n2.clearcoatMap = this.clearcoatMap.toJSON(t2).uuid), this.clearcoatRoughnessMap && this.clearcoatRoughnessMap.isTexture && (n2.clearcoatRoughnessMap = this.clearcoatRoughnessMap.toJSON(t2).uuid), this.clearcoatNormalMap && this.clearcoatNormalMap.isTexture && (n2.clearcoatNormalMap = this.clearcoatNormalMap.toJSON(t2).uuid, n2.clearcoatNormalScale = this.clearcoatNormalScale.toArray()), this.map && this.map.isTexture && (n2.map = this.map.toJSON(t2).uuid), this.matcap && this.matcap.isTexture && (n2.matcap = this.matcap.toJSON(t2).uuid), this.alphaMap && this.alphaMap.isTexture && (n2.alphaMap = this.alphaMap.toJSON(t2).uuid), this.lightMap && this.lightMap.isTexture && (n2.lightMap = this.lightMap.toJSON(t2).uuid), this.aoMap && this.aoMap.isTexture && (n2.aoMap = this.aoMap.toJSON(t2).uuid, n2.aoMapIntensity = this.aoMapIntensity), this.bumpMap && this.bumpMap.isTexture && (n2.bumpMap = this.bumpMap.toJSON(t2).uuid, n2.bumpScale = this.bumpScale), this.normalMap && this.normalMap.isTexture && (n2.normalMap = this.normalMap.toJSON(t2).uuid, n2.normalMapType = this.normalMapType, n2.normalScale = this.normalScale.toArray()), this.displacementMap && this.displacementMap.isTexture && (n2.displacementMap = this.displacementMap.toJSON(t2).uuid, n2.displacementScale = this.displacementScale, n2.displacementBias = this.displacementBias), this.roughnessMap && this.roughnessMap.isTexture && (n2.roughnessMap = this.roughnessMap.toJSON(t2).uuid), this.metalnessMap && this.metalnessMap.isTexture && (n2.metalnessMap = this.metalnessMap.toJSON(t2).uuid), this.emissiveMap && this.emissiveMap.isTexture && (n2.emissiveMap = this.emissiveMap.toJSON(t2).uuid), this.specularMap && this.specularMap.isTexture && (n2.specularMap = this.specularMap.toJSON(t2).uuid), this.envMap && this.envMap.isTexture && (n2.envMap = this.envMap.toJSON(t2).uuid, n2.reflectivity = this.reflectivity, n2.refractionRatio = this.refractionRatio, void 0 !== this.combine && (n2.combine = this.combine), void 0 !== this.envMapIntensity && (n2.envMapIntensity = this.envMapIntensity)), this.gradientMap && this.gradientMap.isTexture && (n2.gradientMap = this.gradientMap.toJSON(t2).uuid), void 0 !== this.size && (n2.size = this.size), void 0 !== this.sizeAttenuation && (n2.sizeAttenuation = this.sizeAttenuation), this.blending !== b && (n2.blending = this.blending), true === this.flatShading && (n2.flatShading = this.flatShading), this.side !== f && (n2.side = this.side), this.vertexColors && (n2.vertexColors = true), this.opacity < 1 && (n2.opacity = this.opacity), true === this.transparent && (n2.transparent = this.transparent), n2.depthFunc = this.depthFunc, n2.depthTest = this.depthTest, n2.depthWrite = this.depthWrite, n2.stencilWrite = this.stencilWrite, n2.stencilWriteMask = this.stencilWriteMask, n2.stencilFunc = this.stencilFunc, n2.stencilRef = this.stencilRef, n2.stencilFuncMask = this.stencilFuncMask, n2.stencilFail = this.stencilFail, n2.stencilZFail = this.stencilZFail, n2.stencilZPass = this.stencilZPass, this.rotation && 0 !== this.rotation && (n2.rotation = this.rotation), true === this.polygonOffset && (n2.polygonOffset = true), 0 !== this.polygonOffsetFactor && (n2.polygonOffsetFactor = this.polygonOffsetFactor), 0 !== this.polygonOffsetUnits && (n2.polygonOffsetUnits = this.polygonOffsetUnits), this.linewidth && 1 !== this.linewidth && (n2.linewidth = this.linewidth), void 0 !== this.dashSize && (n2.dashSize = this.dashSize), void 0 !== this.gapSize && (n2.gapSize = this.gapSize), void 0 !== this.scale && (n2.scale = this.scale), true === this.dithering && (n2.dithering = true), this.alphaTest > 0 && (n2.alphaTest = this.alphaTest), true === this.premultipliedAlpha && (n2.premultipliedAlpha = this.premultipliedAlpha), true === this.wireframe && (n2.wireframe = this.wireframe), this.wireframeLinewidth > 1 && (n2.wireframeLinewidth = this.wireframeLinewidth), "round" !== this.wireframeLinecap && (n2.wireframeLinecap = this.wireframeLinecap), "round" !== this.wireframeLinejoin && (n2.wireframeLinejoin = this.wireframeLinejoin), true === this.morphTargets && (n2.morphTargets = true), true === this.morphNormals && (n2.morphNormals = true), true === this.skinning && (n2.skinning = true), false === this.visible && (n2.visible = false), false === this.toneMapped && (n2.toneMapped = false), "{}" !== JSON.stringify(this.userData) && (n2.userData = this.userData), e2) {
          const e3 = r2(t2.textures), i2 = r2(t2.images);
          e3.length > 0 && (n2.textures = e3), i2.length > 0 && (n2.images = i2);
        }
        return n2;
      }, clone: function() {
        return new this.constructor().copy(this);
      }, copy: function(t2) {
        this.name = t2.name, this.fog = t2.fog, this.blending = t2.blending, this.side = t2.side, this.flatShading = t2.flatShading, this.vertexColors = t2.vertexColors, this.opacity = t2.opacity, this.transparent = t2.transparent, this.blendSrc = t2.blendSrc, this.blendDst = t2.blendDst, this.blendEquation = t2.blendEquation, this.blendSrcAlpha = t2.blendSrcAlpha, this.blendDstAlpha = t2.blendDstAlpha, this.blendEquationAlpha = t2.blendEquationAlpha, this.depthFunc = t2.depthFunc, this.depthTest = t2.depthTest, this.depthWrite = t2.depthWrite, this.stencilWriteMask = t2.stencilWriteMask, this.stencilFunc = t2.stencilFunc, this.stencilRef = t2.stencilRef, this.stencilFuncMask = t2.stencilFuncMask, this.stencilFail = t2.stencilFail, this.stencilZFail = t2.stencilZFail, this.stencilZPass = t2.stencilZPass, this.stencilWrite = t2.stencilWrite;
        const e2 = t2.clippingPlanes;
        let n2 = null;
        if (null !== e2) {
          const t3 = e2.length;
          n2 = new Array(t3);
          for (let r2 = 0; r2 !== t3; ++r2) n2[r2] = e2[r2].clone();
        }
        return this.clippingPlanes = n2, this.clipIntersection = t2.clipIntersection, this.clipShadows = t2.clipShadows, this.shadowSide = t2.shadowSide, this.colorWrite = t2.colorWrite, this.precision = t2.precision, this.polygonOffset = t2.polygonOffset, this.polygonOffsetFactor = t2.polygonOffsetFactor, this.polygonOffsetUnits = t2.polygonOffsetUnits, this.dithering = t2.dithering, this.alphaTest = t2.alphaTest, this.premultipliedAlpha = t2.premultipliedAlpha, this.visible = t2.visible, this.toneMapped = t2.toneMapped, this.userData = JSON.parse(JSON.stringify(t2.userData)), this;
      }, dispose: function() {
        this.dispatchEvent({ type: "dispose" });
      } }), Object.defineProperty(wi.prototype, "needsUpdate", { set: function(t2) {
        true === t2 && this.version++;
      } }), _i.prototype = Object.create(wi.prototype), _i.prototype.constructor = _i, _i.prototype.isMeshBasicMaterial = true, _i.prototype.copy = function(t2) {
        return wi.prototype.copy.call(this, t2), this.color.copy(t2.color), this.map = t2.map, this.lightMap = t2.lightMap, this.lightMapIntensity = t2.lightMapIntensity, this.aoMap = t2.aoMap, this.aoMapIntensity = t2.aoMapIntensity, this.specularMap = t2.specularMap, this.alphaMap = t2.alphaMap, this.envMap = t2.envMap, this.combine = t2.combine, this.reflectivity = t2.reflectivity, this.refractionRatio = t2.refractionRatio, this.wireframe = t2.wireframe, this.wireframeLinewidth = t2.wireframeLinewidth, this.wireframeLinecap = t2.wireframeLinecap, this.wireframeLinejoin = t2.wireframeLinejoin, this.skinning = t2.skinning, this.morphTargets = t2.morphTargets, this;
      };
      const Mi = new $n(), Si = new Hn();
      function Ti(t2, e2, n2) {
        if (Array.isArray(t2)) throw new TypeError("THREE.BufferAttribute: array should be a Typed Array.");
        this.name = "", this.array = t2, this.itemSize = e2, this.count = void 0 !== t2 ? t2.length / e2 : 0, this.normalized = true === n2, this.usage = Tn, this.updateRange = { offset: 0, count: -1 }, this.version = 0;
      }
      function Ei(t2, e2, n2) {
        Ti.call(this, new Int8Array(t2), e2, n2);
      }
      function Ai(t2, e2, n2) {
        Ti.call(this, new Uint8Array(t2), e2, n2);
      }
      function Ci(t2, e2, n2) {
        Ti.call(this, new Uint8ClampedArray(t2), e2, n2);
      }
      function Li(t2, e2, n2) {
        Ti.call(this, new Int16Array(t2), e2, n2);
      }
      function Pi(t2, e2, n2) {
        Ti.call(this, new Uint16Array(t2), e2, n2);
      }
      function Ri(t2, e2, n2) {
        Ti.call(this, new Int32Array(t2), e2, n2);
      }
      function Oi(t2, e2, n2) {
        Ti.call(this, new Uint32Array(t2), e2, n2);
      }
      function Di(t2, e2, n2) {
        Ti.call(this, new Uint16Array(t2), e2, n2);
      }
      function Ii(t2, e2, n2) {
        Ti.call(this, new Float32Array(t2), e2, n2);
      }
      function Ni(t2, e2, n2) {
        Ti.call(this, new Float64Array(t2), e2, n2);
      }
      Object.defineProperty(Ti.prototype, "needsUpdate", { set: function(t2) {
        true === t2 && this.version++;
      } }), Object.assign(Ti.prototype, { isBufferAttribute: true, onUploadCallback: function() {
      }, setUsage: function(t2) {
        return this.usage = t2, this;
      }, copy: function(t2) {
        return this.name = t2.name, this.array = new t2.array.constructor(t2.array), this.itemSize = t2.itemSize, this.count = t2.count, this.normalized = t2.normalized, this.usage = t2.usage, this;
      }, copyAt: function(t2, e2, n2) {
        t2 *= this.itemSize, n2 *= e2.itemSize;
        for (let r2 = 0, i2 = this.itemSize; r2 < i2; r2++) this.array[t2 + r2] = e2.array[n2 + r2];
        return this;
      }, copyArray: function(t2) {
        return this.array.set(t2), this;
      }, copyColorsArray: function(t2) {
        const e2 = this.array;
        let n2 = 0;
        for (let r2 = 0, i2 = t2.length; r2 < i2; r2++) {
          let i3 = t2[r2];
          void 0 === i3 && (console.warn("THREE.BufferAttribute.copyColorsArray(): color is undefined", r2), i3 = new yi()), e2[n2++] = i3.r, e2[n2++] = i3.g, e2[n2++] = i3.b;
        }
        return this;
      }, copyVector2sArray: function(t2) {
        const e2 = this.array;
        let n2 = 0;
        for (let r2 = 0, i2 = t2.length; r2 < i2; r2++) {
          let i3 = t2[r2];
          void 0 === i3 && (console.warn("THREE.BufferAttribute.copyVector2sArray(): vector is undefined", r2), i3 = new Hn()), e2[n2++] = i3.x, e2[n2++] = i3.y;
        }
        return this;
      }, copyVector3sArray: function(t2) {
        const e2 = this.array;
        let n2 = 0;
        for (let r2 = 0, i2 = t2.length; r2 < i2; r2++) {
          let i3 = t2[r2];
          void 0 === i3 && (console.warn("THREE.BufferAttribute.copyVector3sArray(): vector is undefined", r2), i3 = new $n()), e2[n2++] = i3.x, e2[n2++] = i3.y, e2[n2++] = i3.z;
        }
        return this;
      }, copyVector4sArray: function(t2) {
        const e2 = this.array;
        let n2 = 0;
        for (let r2 = 0, i2 = t2.length; r2 < i2; r2++) {
          let i3 = t2[r2];
          void 0 === i3 && (console.warn("THREE.BufferAttribute.copyVector4sArray(): vector is undefined", r2), i3 = new Xn()), e2[n2++] = i3.x, e2[n2++] = i3.y, e2[n2++] = i3.z, e2[n2++] = i3.w;
        }
        return this;
      }, applyMatrix3: function(t2) {
        if (2 === this.itemSize) for (let e2 = 0, n2 = this.count; e2 < n2; e2++) Si.fromBufferAttribute(this, e2), Si.applyMatrix3(t2), this.setXY(e2, Si.x, Si.y);
        else if (3 === this.itemSize) for (let e2 = 0, n2 = this.count; e2 < n2; e2++) Mi.fromBufferAttribute(this, e2), Mi.applyMatrix3(t2), this.setXYZ(e2, Mi.x, Mi.y, Mi.z);
        return this;
      }, applyMatrix4: function(t2) {
        for (let e2 = 0, n2 = this.count; e2 < n2; e2++) Mi.x = this.getX(e2), Mi.y = this.getY(e2), Mi.z = this.getZ(e2), Mi.applyMatrix4(t2), this.setXYZ(e2, Mi.x, Mi.y, Mi.z);
        return this;
      }, applyNormalMatrix: function(t2) {
        for (let e2 = 0, n2 = this.count; e2 < n2; e2++) Mi.x = this.getX(e2), Mi.y = this.getY(e2), Mi.z = this.getZ(e2), Mi.applyNormalMatrix(t2), this.setXYZ(e2, Mi.x, Mi.y, Mi.z);
        return this;
      }, transformDirection: function(t2) {
        for (let e2 = 0, n2 = this.count; e2 < n2; e2++) Mi.x = this.getX(e2), Mi.y = this.getY(e2), Mi.z = this.getZ(e2), Mi.transformDirection(t2), this.setXYZ(e2, Mi.x, Mi.y, Mi.z);
        return this;
      }, set: function(t2, e2 = 0) {
        return this.array.set(t2, e2), this;
      }, getX: function(t2) {
        return this.array[t2 * this.itemSize];
      }, setX: function(t2, e2) {
        return this.array[t2 * this.itemSize] = e2, this;
      }, getY: function(t2) {
        return this.array[t2 * this.itemSize + 1];
      }, setY: function(t2, e2) {
        return this.array[t2 * this.itemSize + 1] = e2, this;
      }, getZ: function(t2) {
        return this.array[t2 * this.itemSize + 2];
      }, setZ: function(t2, e2) {
        return this.array[t2 * this.itemSize + 2] = e2, this;
      }, getW: function(t2) {
        return this.array[t2 * this.itemSize + 3];
      }, setW: function(t2, e2) {
        return this.array[t2 * this.itemSize + 3] = e2, this;
      }, setXY: function(t2, e2, n2) {
        return t2 *= this.itemSize, this.array[t2 + 0] = e2, this.array[t2 + 1] = n2, this;
      }, setXYZ: function(t2, e2, n2, r2) {
        return t2 *= this.itemSize, this.array[t2 + 0] = e2, this.array[t2 + 1] = n2, this.array[t2 + 2] = r2, this;
      }, setXYZW: function(t2, e2, n2, r2, i2) {
        return t2 *= this.itemSize, this.array[t2 + 0] = e2, this.array[t2 + 1] = n2, this.array[t2 + 2] = r2, this.array[t2 + 3] = i2, this;
      }, onUpload: function(t2) {
        return this.onUploadCallback = t2, this;
      }, clone: function() {
        return new this.constructor(this.array, this.itemSize).copy(this);
      }, toJSON: function() {
        return { itemSize: this.itemSize, type: this.array.constructor.name, array: Array.prototype.slice.call(this.array), normalized: this.normalized };
      } }), Ei.prototype = Object.create(Ti.prototype), Ei.prototype.constructor = Ei, Ai.prototype = Object.create(Ti.prototype), Ai.prototype.constructor = Ai, Ci.prototype = Object.create(Ti.prototype), Ci.prototype.constructor = Ci, Li.prototype = Object.create(Ti.prototype), Li.prototype.constructor = Li, Pi.prototype = Object.create(Ti.prototype), Pi.prototype.constructor = Pi, Ri.prototype = Object.create(Ti.prototype), Ri.prototype.constructor = Ri, Oi.prototype = Object.create(Ti.prototype), Oi.prototype.constructor = Oi, Di.prototype = Object.create(Ti.prototype), Di.prototype.constructor = Di, Di.prototype.isFloat16BufferAttribute = true, Ii.prototype = Object.create(Ti.prototype), Ii.prototype.constructor = Ii, Ni.prototype = Object.create(Ti.prototype), Ni.prototype.constructor = Ni;
      class zi {
        constructor() {
          this.vertices = [], this.normals = [], this.colors = [], this.uvs = [], this.uvs2 = [], this.groups = [], this.morphTargets = {}, this.skinWeights = [], this.skinIndices = [], this.boundingBox = null, this.boundingSphere = null, this.verticesNeedUpdate = false, this.normalsNeedUpdate = false, this.colorsNeedUpdate = false, this.uvsNeedUpdate = false, this.groupsNeedUpdate = false;
        }
        computeGroups(t2) {
          const e2 = [];
          let n2, r2, i2 = void 0;
          const o2 = t2.faces;
          for (r2 = 0; r2 < o2.length; r2++) {
            const t3 = o2[r2];
            t3.materialIndex !== i2 && (i2 = t3.materialIndex, void 0 !== n2 && (n2.count = 3 * r2 - n2.start, e2.push(n2)), n2 = { start: 3 * r2, materialIndex: i2 });
          }
          void 0 !== n2 && (n2.count = 3 * r2 - n2.start, e2.push(n2)), this.groups = e2;
        }
        fromGeometry(t2) {
          const e2 = t2.faces, n2 = t2.vertices, r2 = t2.faceVertexUvs, i2 = r2[0] && r2[0].length > 0, o2 = r2[1] && r2[1].length > 0, a2 = t2.morphTargets, s2 = a2.length;
          let c2;
          if (s2 > 0) {
            c2 = [];
            for (let t3 = 0; t3 < s2; t3++) c2[t3] = { name: a2[t3].name, data: [] };
            this.morphTargets.position = c2;
          }
          const u2 = t2.morphNormals, l2 = u2.length;
          let h2;
          if (l2 > 0) {
            h2 = [];
            for (let t3 = 0; t3 < l2; t3++) h2[t3] = { name: u2[t3].name, data: [] };
            this.morphTargets.normal = h2;
          }
          const d2 = t2.skinIndices, p2 = t2.skinWeights, f2 = d2.length === n2.length, m2 = p2.length === n2.length;
          n2.length > 0 && 0 === e2.length && console.error("THREE.DirectGeometry: Faceless geometries are not supported.");
          for (let t3 = 0; t3 < e2.length; t3++) {
            const g2 = e2[t3];
            this.vertices.push(n2[g2.a], n2[g2.b], n2[g2.c]);
            const v2 = g2.vertexNormals;
            if (3 === v2.length) this.normals.push(v2[0], v2[1], v2[2]);
            else {
              const t4 = g2.normal;
              this.normals.push(t4, t4, t4);
            }
            const y2 = g2.vertexColors;
            if (3 === y2.length) this.colors.push(y2[0], y2[1], y2[2]);
            else {
              const t4 = g2.color;
              this.colors.push(t4, t4, t4);
            }
            if (true === i2) {
              const e3 = r2[0][t3];
              void 0 !== e3 ? this.uvs.push(e3[0], e3[1], e3[2]) : (console.warn("THREE.DirectGeometry.fromGeometry(): Undefined vertexUv ", t3), this.uvs.push(new Hn(), new Hn(), new Hn()));
            }
            if (true === o2) {
              const e3 = r2[1][t3];
              void 0 !== e3 ? this.uvs2.push(e3[0], e3[1], e3[2]) : (console.warn("THREE.DirectGeometry.fromGeometry(): Undefined vertexUv2 ", t3), this.uvs2.push(new Hn(), new Hn(), new Hn()));
            }
            for (let t4 = 0; t4 < s2; t4++) {
              const e3 = a2[t4].vertices;
              c2[t4].data.push(e3[g2.a], e3[g2.b], e3[g2.c]);
            }
            for (let e3 = 0; e3 < l2; e3++) {
              const n3 = u2[e3].vertexNormals[t3];
              h2[e3].data.push(n3.a, n3.b, n3.c);
            }
            f2 && this.skinIndices.push(d2[g2.a], d2[g2.b], d2[g2.c]), m2 && this.skinWeights.push(p2[g2.a], p2[g2.b], p2[g2.c]);
          }
          return this.computeGroups(t2), this.verticesNeedUpdate = t2.verticesNeedUpdate, this.normalsNeedUpdate = t2.normalsNeedUpdate, this.colorsNeedUpdate = t2.colorsNeedUpdate, this.uvsNeedUpdate = t2.uvsNeedUpdate, this.groupsNeedUpdate = t2.groupsNeedUpdate, null !== t2.boundingSphere && (this.boundingSphere = t2.boundingSphere.clone()), null !== t2.boundingBox && (this.boundingBox = t2.boundingBox.clone()), this;
        }
      }
      function ki(t2) {
        if (0 === t2.length) return -1 / 0;
        let e2 = t2[0];
        for (let n2 = 1, r2 = t2.length; n2 < r2; ++n2) t2[n2] > e2 && (e2 = t2[n2]);
        return e2;
      }
      const Fi = { Int8Array, Uint8Array, Uint8ClampedArray: "undefined" != typeof Uint8ClampedArray ? Uint8ClampedArray : Uint8Array, Int16Array, Uint16Array, Int32Array, Uint32Array, Float32Array, Float64Array };
      function Bi(t2, e2) {
        return new Fi[t2](e2);
      }
      let Hi = 1;
      const Gi = new Tr(), Ui = new Jr(), ji = new $n(), Vi = new tr(), Wi = new tr(), qi = new $n();
      function Xi() {
        Object.defineProperty(this, "id", { value: Hi += 2 }), this.uuid = Bn.generateUUID(), this.name = "", this.type = "BufferGeometry", this.index = null, this.attributes = {}, this.morphAttributes = {}, this.morphTargetsRelative = false, this.groups = [], this.boundingBox = null, this.boundingSphere = null, this.drawRange = { start: 0, count: 1 / 0 }, this.userData = {};
      }
      Xi.prototype = Object.assign(Object.create(zn.prototype), { constructor: Xi, isBufferGeometry: true, getIndex: function() {
        return this.index;
      }, setIndex: function(t2) {
        return Array.isArray(t2) ? this.index = new (ki(t2) > 65535 ? Oi : Pi)(t2, 1) : this.index = t2, this;
      }, getAttribute: function(t2) {
        return this.attributes[t2];
      }, setAttribute: function(t2, e2) {
        return this.attributes[t2] = e2, this;
      }, deleteAttribute: function(t2) {
        return delete this.attributes[t2], this;
      }, hasAttribute: function(t2) {
        return void 0 !== this.attributes[t2];
      }, addGroup: function(t2, e2, n2 = 0) {
        this.groups.push({ start: t2, count: e2, materialIndex: n2 });
      }, clearGroups: function() {
        this.groups = [];
      }, setDrawRange: function(t2, e2) {
        this.drawRange.start = t2, this.drawRange.count = e2;
      }, applyMatrix4: function(t2) {
        const e2 = this.attributes.position;
        void 0 !== e2 && (e2.applyMatrix4(t2), e2.needsUpdate = true);
        const n2 = this.attributes.normal;
        if (void 0 !== n2) {
          const e3 = new Gn().getNormalMatrix(t2);
          n2.applyNormalMatrix(e3), n2.needsUpdate = true;
        }
        const r2 = this.attributes.tangent;
        return void 0 !== r2 && (r2.transformDirection(t2), r2.needsUpdate = true), null !== this.boundingBox && this.computeBoundingBox(), null !== this.boundingSphere && this.computeBoundingSphere(), this;
      }, rotateX: function(t2) {
        return Gi.makeRotationX(t2), this.applyMatrix4(Gi), this;
      }, rotateY: function(t2) {
        return Gi.makeRotationY(t2), this.applyMatrix4(Gi), this;
      }, rotateZ: function(t2) {
        return Gi.makeRotationZ(t2), this.applyMatrix4(Gi), this;
      }, translate: function(t2, e2, n2) {
        return Gi.makeTranslation(t2, e2, n2), this.applyMatrix4(Gi), this;
      }, scale: function(t2, e2, n2) {
        return Gi.makeScale(t2, e2, n2), this.applyMatrix4(Gi), this;
      }, lookAt: function(t2) {
        return Ui.lookAt(t2), Ui.updateMatrix(), this.applyMatrix4(Ui.matrix), this;
      }, center: function() {
        return this.computeBoundingBox(), this.boundingBox.getCenter(ji).negate(), this.translate(ji.x, ji.y, ji.z), this;
      }, setFromObject: function(t2) {
        const e2 = t2.geometry;
        if (t2.isPoints || t2.isLine) {
          const t3 = new Ii(3 * e2.vertices.length, 3), n2 = new Ii(3 * e2.colors.length, 3);
          if (this.setAttribute("position", t3.copyVector3sArray(e2.vertices)), this.setAttribute("color", n2.copyColorsArray(e2.colors)), e2.lineDistances && e2.lineDistances.length === e2.vertices.length) {
            const t4 = new Ii(e2.lineDistances.length, 1);
            this.setAttribute("lineDistance", t4.copyArray(e2.lineDistances));
          }
          null !== e2.boundingSphere && (this.boundingSphere = e2.boundingSphere.clone()), null !== e2.boundingBox && (this.boundingBox = e2.boundingBox.clone());
        } else t2.isMesh && e2 && e2.isGeometry && this.fromGeometry(e2);
        return this;
      }, setFromPoints: function(t2) {
        const e2 = [];
        for (let n2 = 0, r2 = t2.length; n2 < r2; n2++) {
          const r3 = t2[n2];
          e2.push(r3.x, r3.y, r3.z || 0);
        }
        return this.setAttribute("position", new Ii(e2, 3)), this;
      }, updateFromObject: function(t2) {
        let e2 = t2.geometry;
        if (t2.isMesh) {
          let t3 = e2.__directGeometry;
          if (true === e2.elementsNeedUpdate && (t3 = void 0, e2.elementsNeedUpdate = false), void 0 === t3) return this.fromGeometry(e2);
          t3.verticesNeedUpdate = e2.verticesNeedUpdate, t3.normalsNeedUpdate = e2.normalsNeedUpdate, t3.colorsNeedUpdate = e2.colorsNeedUpdate, t3.uvsNeedUpdate = e2.uvsNeedUpdate, t3.groupsNeedUpdate = e2.groupsNeedUpdate, e2.verticesNeedUpdate = false, e2.normalsNeedUpdate = false, e2.colorsNeedUpdate = false, e2.uvsNeedUpdate = false, e2.groupsNeedUpdate = false, e2 = t3;
        }
        if (true === e2.verticesNeedUpdate) {
          const t3 = this.attributes.position;
          void 0 !== t3 && (t3.copyVector3sArray(e2.vertices), t3.needsUpdate = true), e2.verticesNeedUpdate = false;
        }
        if (true === e2.normalsNeedUpdate) {
          const t3 = this.attributes.normal;
          void 0 !== t3 && (t3.copyVector3sArray(e2.normals), t3.needsUpdate = true), e2.normalsNeedUpdate = false;
        }
        if (true === e2.colorsNeedUpdate) {
          const t3 = this.attributes.color;
          void 0 !== t3 && (t3.copyColorsArray(e2.colors), t3.needsUpdate = true), e2.colorsNeedUpdate = false;
        }
        if (e2.uvsNeedUpdate) {
          const t3 = this.attributes.uv;
          void 0 !== t3 && (t3.copyVector2sArray(e2.uvs), t3.needsUpdate = true), e2.uvsNeedUpdate = false;
        }
        if (e2.lineDistancesNeedUpdate) {
          const t3 = this.attributes.lineDistance;
          void 0 !== t3 && (t3.copyArray(e2.lineDistances), t3.needsUpdate = true), e2.lineDistancesNeedUpdate = false;
        }
        return e2.groupsNeedUpdate && (e2.computeGroups(t2.geometry), this.groups = e2.groups, e2.groupsNeedUpdate = false), this;
      }, fromGeometry: function(t2) {
        return t2.__directGeometry = new zi().fromGeometry(t2), this.fromDirectGeometry(t2.__directGeometry);
      }, fromDirectGeometry: function(t2) {
        const e2 = new Float32Array(3 * t2.vertices.length);
        if (this.setAttribute("position", new Ti(e2, 3).copyVector3sArray(t2.vertices)), t2.normals.length > 0) {
          const e3 = new Float32Array(3 * t2.normals.length);
          this.setAttribute("normal", new Ti(e3, 3).copyVector3sArray(t2.normals));
        }
        if (t2.colors.length > 0) {
          const e3 = new Float32Array(3 * t2.colors.length);
          this.setAttribute("color", new Ti(e3, 3).copyColorsArray(t2.colors));
        }
        if (t2.uvs.length > 0) {
          const e3 = new Float32Array(2 * t2.uvs.length);
          this.setAttribute("uv", new Ti(e3, 2).copyVector2sArray(t2.uvs));
        }
        if (t2.uvs2.length > 0) {
          const e3 = new Float32Array(2 * t2.uvs2.length);
          this.setAttribute("uv2", new Ti(e3, 2).copyVector2sArray(t2.uvs2));
        }
        this.groups = t2.groups;
        for (const e3 in t2.morphTargets) {
          const n2 = [], r2 = t2.morphTargets[e3];
          for (let t3 = 0, e4 = r2.length; t3 < e4; t3++) {
            const e5 = r2[t3], i2 = new Ii(3 * e5.data.length, 3);
            i2.name = e5.name, n2.push(i2.copyVector3sArray(e5.data));
          }
          this.morphAttributes[e3] = n2;
        }
        if (t2.skinIndices.length > 0) {
          const e3 = new Ii(4 * t2.skinIndices.length, 4);
          this.setAttribute("skinIndex", e3.copyVector4sArray(t2.skinIndices));
        }
        if (t2.skinWeights.length > 0) {
          const e3 = new Ii(4 * t2.skinWeights.length, 4);
          this.setAttribute("skinWeight", e3.copyVector4sArray(t2.skinWeights));
        }
        return null !== t2.boundingSphere && (this.boundingSphere = t2.boundingSphere.clone()), null !== t2.boundingBox && (this.boundingBox = t2.boundingBox.clone()), this;
      }, computeBoundingBox: function() {
        null === this.boundingBox && (this.boundingBox = new tr());
        const t2 = this.attributes.position, e2 = this.morphAttributes.position;
        if (t2 && t2.isGLBufferAttribute) return console.error('THREE.BufferGeometry.computeBoundingBox(): GLBufferAttribute requires a manual bounding box. Alternatively set "mesh.frustumCulled" to "false".', this), void this.boundingBox.set(new $n(-1 / 0, -1 / 0, -1 / 0), new $n(1 / 0, 1 / 0, 1 / 0));
        if (void 0 !== t2) {
          if (this.boundingBox.setFromBufferAttribute(t2), e2) for (let t3 = 0, n2 = e2.length; t3 < n2; t3++) {
            const n3 = e2[t3];
            Vi.setFromBufferAttribute(n3), this.morphTargetsRelative ? (qi.addVectors(this.boundingBox.min, Vi.min), this.boundingBox.expandByPoint(qi), qi.addVectors(this.boundingBox.max, Vi.max), this.boundingBox.expandByPoint(qi)) : (this.boundingBox.expandByPoint(Vi.min), this.boundingBox.expandByPoint(Vi.max));
          }
        } else this.boundingBox.makeEmpty();
        (isNaN(this.boundingBox.min.x) || isNaN(this.boundingBox.min.y) || isNaN(this.boundingBox.min.z)) && console.error('THREE.BufferGeometry.computeBoundingBox(): Computed min/max have NaN values. The "position" attribute is likely to have NaN values.', this);
      }, computeBoundingSphere: function() {
        null === this.boundingSphere && (this.boundingSphere = new gr());
        const t2 = this.attributes.position, e2 = this.morphAttributes.position;
        if (t2 && t2.isGLBufferAttribute) return console.error('THREE.BufferGeometry.computeBoundingSphere(): GLBufferAttribute requires a manual bounding sphere. Alternatively set "mesh.frustumCulled" to "false".', this), void this.boundingSphere.set(new $n(), 1 / 0);
        if (t2) {
          const n2 = this.boundingSphere.center;
          if (Vi.setFromBufferAttribute(t2), e2) for (let t3 = 0, n3 = e2.length; t3 < n3; t3++) {
            const n4 = e2[t3];
            Wi.setFromBufferAttribute(n4), this.morphTargetsRelative ? (qi.addVectors(Vi.min, Wi.min), Vi.expandByPoint(qi), qi.addVectors(Vi.max, Wi.max), Vi.expandByPoint(qi)) : (Vi.expandByPoint(Wi.min), Vi.expandByPoint(Wi.max));
          }
          Vi.getCenter(n2);
          let r2 = 0;
          for (let e3 = 0, i2 = t2.count; e3 < i2; e3++) qi.fromBufferAttribute(t2, e3), r2 = Math.max(r2, n2.distanceToSquared(qi));
          if (e2) for (let i2 = 0, o2 = e2.length; i2 < o2; i2++) {
            const o3 = e2[i2], a2 = this.morphTargetsRelative;
            for (let e3 = 0, i3 = o3.count; e3 < i3; e3++) qi.fromBufferAttribute(o3, e3), a2 && (ji.fromBufferAttribute(t2, e3), qi.add(ji)), r2 = Math.max(r2, n2.distanceToSquared(qi));
          }
          this.boundingSphere.radius = Math.sqrt(r2), isNaN(this.boundingSphere.radius) && console.error('THREE.BufferGeometry.computeBoundingSphere(): Computed radius is NaN. The "position" attribute is likely to have NaN values.', this);
        }
      }, computeFaceNormals: function() {
      }, computeVertexNormals: function() {
        const t2 = this.index, e2 = this.getAttribute("position");
        if (void 0 !== e2) {
          let n2 = this.getAttribute("normal");
          if (void 0 === n2) n2 = new Ti(new Float32Array(3 * e2.count), 3), this.setAttribute("normal", n2);
          else for (let t3 = 0, e3 = n2.count; t3 < e3; t3++) n2.setXYZ(t3, 0, 0, 0);
          const r2 = new $n(), i2 = new $n(), o2 = new $n(), a2 = new $n(), s2 = new $n(), c2 = new $n(), u2 = new $n(), l2 = new $n();
          if (t2) for (let h2 = 0, d2 = t2.count; h2 < d2; h2 += 3) {
            const d3 = t2.getX(h2 + 0), p2 = t2.getX(h2 + 1), f2 = t2.getX(h2 + 2);
            r2.fromBufferAttribute(e2, d3), i2.fromBufferAttribute(e2, p2), o2.fromBufferAttribute(e2, f2), u2.subVectors(o2, i2), l2.subVectors(r2, i2), u2.cross(l2), a2.fromBufferAttribute(n2, d3), s2.fromBufferAttribute(n2, p2), c2.fromBufferAttribute(n2, f2), a2.add(u2), s2.add(u2), c2.add(u2), n2.setXYZ(d3, a2.x, a2.y, a2.z), n2.setXYZ(p2, s2.x, s2.y, s2.z), n2.setXYZ(f2, c2.x, c2.y, c2.z);
          }
          else for (let t3 = 0, a3 = e2.count; t3 < a3; t3 += 3) r2.fromBufferAttribute(e2, t3 + 0), i2.fromBufferAttribute(e2, t3 + 1), o2.fromBufferAttribute(e2, t3 + 2), u2.subVectors(o2, i2), l2.subVectors(r2, i2), u2.cross(l2), n2.setXYZ(t3 + 0, u2.x, u2.y, u2.z), n2.setXYZ(t3 + 1, u2.x, u2.y, u2.z), n2.setXYZ(t3 + 2, u2.x, u2.y, u2.z);
          this.normalizeNormals(), n2.needsUpdate = true;
        }
      }, merge: function(t2, e2) {
        if (!t2 || !t2.isBufferGeometry) return void console.error("THREE.BufferGeometry.merge(): geometry not an instance of THREE.BufferGeometry.", t2);
        void 0 === e2 && (e2 = 0, console.warn("THREE.BufferGeometry.merge(): Overwriting original geometry, starting at offset=0. Use BufferGeometryUtils.mergeBufferGeometries() for lossless merge."));
        const n2 = this.attributes;
        for (const r2 in n2) {
          if (void 0 === t2.attributes[r2]) continue;
          const i2 = n2[r2].array, o2 = t2.attributes[r2], a2 = o2.array, s2 = o2.itemSize * e2, c2 = Math.min(a2.length, i2.length - s2);
          for (let t3 = 0, e3 = s2; t3 < c2; t3++, e3++) i2[e3] = a2[t3];
        }
        return this;
      }, normalizeNormals: function() {
        const t2 = this.attributes.normal;
        for (let e2 = 0, n2 = t2.count; e2 < n2; e2++) qi.fromBufferAttribute(t2, e2), qi.normalize(), t2.setXYZ(e2, qi.x, qi.y, qi.z);
      }, toNonIndexed: function() {
        function t2(t3, e3) {
          const n3 = t3.array, r3 = t3.itemSize, i3 = t3.normalized, o3 = new n3.constructor(e3.length * r3);
          let a2 = 0, s2 = 0;
          for (let t4 = 0, i4 = e3.length; t4 < i4; t4++) {
            a2 = e3[t4] * r3;
            for (let t5 = 0; t5 < r3; t5++) o3[s2++] = n3[a2++];
          }
          return new Ti(o3, r3, i3);
        }
        if (null === this.index) return console.warn("THREE.BufferGeometry.toNonIndexed(): Geometry is already non-indexed."), this;
        const e2 = new Xi(), n2 = this.index.array, r2 = this.attributes;
        for (const i3 in r2) {
          const o3 = t2(r2[i3], n2);
          e2.setAttribute(i3, o3);
        }
        const i2 = this.morphAttributes;
        for (const r3 in i2) {
          const o3 = [], a2 = i2[r3];
          for (let e3 = 0, r4 = a2.length; e3 < r4; e3++) {
            const r5 = t2(a2[e3], n2);
            o3.push(r5);
          }
          e2.morphAttributes[r3] = o3;
        }
        e2.morphTargetsRelative = this.morphTargetsRelative;
        const o2 = this.groups;
        for (let t3 = 0, n3 = o2.length; t3 < n3; t3++) {
          const n4 = o2[t3];
          e2.addGroup(n4.start, n4.count, n4.materialIndex);
        }
        return e2;
      }, toJSON: function() {
        const t2 = { metadata: { version: 4.5, type: "BufferGeometry", generator: "BufferGeometry.toJSON" } };
        if (t2.uuid = this.uuid, t2.type = this.type, "" !== this.name && (t2.name = this.name), Object.keys(this.userData).length > 0 && (t2.userData = this.userData), void 0 !== this.parameters) {
          const e3 = this.parameters;
          for (const n3 in e3) void 0 !== e3[n3] && (t2[n3] = e3[n3]);
          return t2;
        }
        t2.data = { attributes: {} };
        const e2 = this.index;
        null !== e2 && (t2.data.index = { type: e2.array.constructor.name, array: Array.prototype.slice.call(e2.array) });
        const n2 = this.attributes;
        for (const e3 in n2) {
          const r3 = n2[e3], i3 = r3.toJSON(t2.data);
          "" !== r3.name && (i3.name = r3.name), t2.data.attributes[e3] = i3;
        }
        const r2 = {};
        let i2 = false;
        for (const e3 in this.morphAttributes) {
          const n3 = this.morphAttributes[e3], o3 = [];
          for (let e4 = 0, r3 = n3.length; e4 < r3; e4++) {
            const r4 = n3[e4], i3 = r4.toJSON(t2.data);
            "" !== r4.name && (i3.name = r4.name), o3.push(i3);
          }
          o3.length > 0 && (r2[e3] = o3, i2 = true);
        }
        i2 && (t2.data.morphAttributes = r2, t2.data.morphTargetsRelative = this.morphTargetsRelative);
        const o2 = this.groups;
        o2.length > 0 && (t2.data.groups = JSON.parse(JSON.stringify(o2)));
        const a2 = this.boundingSphere;
        return null !== a2 && (t2.data.boundingSphere = { center: a2.center.toArray(), radius: a2.radius }), t2;
      }, clone: function() {
        return new Xi().copy(this);
      }, copy: function(t2) {
        this.index = null, this.attributes = {}, this.morphAttributes = {}, this.groups = [], this.boundingBox = null, this.boundingSphere = null;
        const e2 = {};
        this.name = t2.name;
        const n2 = t2.index;
        null !== n2 && this.setIndex(n2.clone(e2));
        const r2 = t2.attributes;
        for (const t3 in r2) {
          const n3 = r2[t3];
          this.setAttribute(t3, n3.clone(e2));
        }
        const i2 = t2.morphAttributes;
        for (const t3 in i2) {
          const n3 = [], r3 = i2[t3];
          for (let t4 = 0, i3 = r3.length; t4 < i3; t4++) n3.push(r3[t4].clone(e2));
          this.morphAttributes[t3] = n3;
        }
        this.morphTargetsRelative = t2.morphTargetsRelative;
        const o2 = t2.groups;
        for (let t3 = 0, e3 = o2.length; t3 < e3; t3++) {
          const e4 = o2[t3];
          this.addGroup(e4.start, e4.count, e4.materialIndex);
        }
        const a2 = t2.boundingBox;
        null !== a2 && (this.boundingBox = a2.clone());
        const s2 = t2.boundingSphere;
        return null !== s2 && (this.boundingSphere = s2.clone()), this.drawRange.start = t2.drawRange.start, this.drawRange.count = t2.drawRange.count, this.userData = t2.userData, this;
      }, dispose: function() {
        this.dispatchEvent({ type: "dispose" });
      } });
      const Yi = new Tr(), Zi = new Sr(), Ji = new gr(), $i = new $n(), Qi = new $n(), Ki = new $n(), to = new $n(), eo = new $n(), no = new $n(), ro = new $n(), io = new $n(), oo = new $n(), ao = new Hn(), so = new Hn(), co = new Hn(), uo = new $n(), lo = new $n();
      function ho(t2 = new Xi(), e2 = new _i()) {
        Jr.call(this), this.type = "Mesh", this.geometry = t2, this.material = e2, this.updateMorphTargets();
      }
      function po(t2, e2, n2, r2, i2, o2, a2, s2) {
        let c2;
        if (c2 = e2.side === m ? r2.intersectTriangle(a2, o2, i2, true, s2) : r2.intersectTriangle(i2, o2, a2, e2.side !== g, s2), null === c2) return null;
        lo.copy(s2), lo.applyMatrix4(t2.matrixWorld);
        const u2 = n2.ray.origin.distanceTo(lo);
        return u2 < n2.near || u2 > n2.far ? null : { distance: u2, point: lo.clone(), object: t2 };
      }
      function fo(t2, e2, n2, r2, i2, o2, a2, s2, c2, u2, l2, h2) {
        $i.fromBufferAttribute(i2, u2), Qi.fromBufferAttribute(i2, l2), Ki.fromBufferAttribute(i2, h2);
        const d2 = t2.morphTargetInfluences;
        if (e2.morphTargets && o2 && d2) {
          ro.set(0, 0, 0), io.set(0, 0, 0), oo.set(0, 0, 0);
          for (let t3 = 0, e3 = o2.length; t3 < e3; t3++) {
            const e4 = d2[t3], n3 = o2[t3];
            0 !== e4 && (to.fromBufferAttribute(n3, u2), eo.fromBufferAttribute(n3, l2), no.fromBufferAttribute(n3, h2), a2 ? (ro.addScaledVector(to, e4), io.addScaledVector(eo, e4), oo.addScaledVector(no, e4)) : (ro.addScaledVector(to.sub($i), e4), io.addScaledVector(eo.sub(Qi), e4), oo.addScaledVector(no.sub(Ki), e4)));
          }
          $i.add(ro), Qi.add(io), Ki.add(oo);
        }
        t2.isSkinnedMesh && (t2.boneTransform(u2, $i), t2.boneTransform(l2, Qi), t2.boneTransform(h2, Ki));
        const p2 = po(t2, e2, n2, r2, $i, Qi, Ki, uo);
        if (p2) {
          s2 && (ao.fromBufferAttribute(s2, u2), so.fromBufferAttribute(s2, l2), co.fromBufferAttribute(s2, h2), p2.uv = hi.getUV(uo, $i, Qi, Ki, ao, so, co, new Hn())), c2 && (ao.fromBufferAttribute(c2, u2), so.fromBufferAttribute(c2, l2), co.fromBufferAttribute(c2, h2), p2.uv2 = hi.getUV(uo, $i, Qi, Ki, ao, so, co, new Hn()));
          const t3 = new xi(u2, l2, h2);
          hi.getNormal($i, Qi, Ki, t3.normal), p2.face = t3;
        }
        return p2;
      }
      ho.prototype = Object.assign(Object.create(Jr.prototype), { constructor: ho, isMesh: true, copy: function(t2) {
        return Jr.prototype.copy.call(this, t2), void 0 !== t2.morphTargetInfluences && (this.morphTargetInfluences = t2.morphTargetInfluences.slice()), void 0 !== t2.morphTargetDictionary && (this.morphTargetDictionary = Object.assign({}, t2.morphTargetDictionary)), this.material = t2.material, this.geometry = t2.geometry, this;
      }, updateMorphTargets: function() {
        const t2 = this.geometry;
        if (t2.isBufferGeometry) {
          const e2 = t2.morphAttributes, n2 = Object.keys(e2);
          if (n2.length > 0) {
            const t3 = e2[n2[0]];
            if (void 0 !== t3) {
              this.morphTargetInfluences = [], this.morphTargetDictionary = {};
              for (let e3 = 0, n3 = t3.length; e3 < n3; e3++) {
                const n4 = t3[e3].name || String(e3);
                this.morphTargetInfluences.push(0), this.morphTargetDictionary[n4] = e3;
              }
            }
          }
        } else {
          const e2 = t2.morphTargets;
          void 0 !== e2 && e2.length > 0 && console.error("THREE.Mesh.updateMorphTargets() no longer supports THREE.Geometry. Use THREE.BufferGeometry instead.");
        }
      }, raycast: function(t2, e2) {
        const n2 = this.geometry, r2 = this.material, i2 = this.matrixWorld;
        if (void 0 === r2) return;
        if (null === n2.boundingSphere && n2.computeBoundingSphere(), Ji.copy(n2.boundingSphere), Ji.applyMatrix4(i2), false === t2.ray.intersectsSphere(Ji)) return;
        if (Yi.copy(i2).invert(), Zi.copy(t2.ray).applyMatrix4(Yi), null !== n2.boundingBox && false === Zi.intersectsBox(n2.boundingBox)) return;
        let o2;
        if (n2.isBufferGeometry) {
          const i3 = n2.index, a2 = n2.attributes.position, s2 = n2.morphAttributes.position, c2 = n2.morphTargetsRelative, u2 = n2.attributes.uv, l2 = n2.attributes.uv2, h2 = n2.groups, d2 = n2.drawRange;
          if (null !== i3) if (Array.isArray(r2)) for (let n3 = 0, p2 = h2.length; n3 < p2; n3++) {
            const p3 = h2[n3], f2 = r2[p3.materialIndex];
            for (let n4 = Math.max(p3.start, d2.start), r3 = Math.min(p3.start + p3.count, d2.start + d2.count); n4 < r3; n4 += 3) {
              const r4 = i3.getX(n4), h3 = i3.getX(n4 + 1), d3 = i3.getX(n4 + 2);
              o2 = fo(this, f2, t2, Zi, a2, s2, c2, u2, l2, r4, h3, d3), o2 && (o2.faceIndex = Math.floor(n4 / 3), o2.face.materialIndex = p3.materialIndex, e2.push(o2));
            }
          }
          else {
            for (let n3 = Math.max(0, d2.start), h3 = Math.min(i3.count, d2.start + d2.count); n3 < h3; n3 += 3) {
              const h4 = i3.getX(n3), d3 = i3.getX(n3 + 1), p2 = i3.getX(n3 + 2);
              o2 = fo(this, r2, t2, Zi, a2, s2, c2, u2, l2, h4, d3, p2), o2 && (o2.faceIndex = Math.floor(n3 / 3), e2.push(o2));
            }
          }
          else if (void 0 !== a2) if (Array.isArray(r2)) for (let n3 = 0, i4 = h2.length; n3 < i4; n3++) {
            const i5 = h2[n3], p2 = r2[i5.materialIndex];
            for (let n4 = Math.max(i5.start, d2.start), r3 = Math.min(i5.start + i5.count, d2.start + d2.count); n4 < r3; n4 += 3) {
              o2 = fo(this, p2, t2, Zi, a2, s2, c2, u2, l2, n4, n4 + 1, n4 + 2), o2 && (o2.faceIndex = Math.floor(n4 / 3), o2.face.materialIndex = i5.materialIndex, e2.push(o2));
            }
          }
          else {
            for (let n3 = Math.max(0, d2.start), i4 = Math.min(a2.count, d2.start + d2.count); n3 < i4; n3 += 3) {
              o2 = fo(this, r2, t2, Zi, a2, s2, c2, u2, l2, n3, n3 + 1, n3 + 2), o2 && (o2.faceIndex = Math.floor(n3 / 3), e2.push(o2));
            }
          }
        } else if (n2.isGeometry) {
          const i3 = Array.isArray(r2), a2 = n2.vertices, s2 = n2.faces;
          let c2;
          const u2 = n2.faceVertexUvs[0];
          u2.length > 0 && (c2 = u2);
          for (let n3 = 0, u3 = s2.length; n3 < u3; n3++) {
            const u4 = s2[n3], l2 = i3 ? r2[u4.materialIndex] : r2;
            if (void 0 === l2) continue;
            const h2 = a2[u4.a], d2 = a2[u4.b], p2 = a2[u4.c];
            if (o2 = po(this, l2, t2, Zi, h2, d2, p2, uo), o2) {
              if (c2 && c2[n3]) {
                const t3 = c2[n3];
                ao.copy(t3[0]), so.copy(t3[1]), co.copy(t3[2]), o2.uv = hi.getUV(uo, h2, d2, p2, ao, so, co, new Hn());
              }
              o2.face = u4, o2.faceIndex = n3, e2.push(o2);
            }
          }
        }
      } });
      class mo extends Xi {
        constructor(t2 = 1, e2 = 1, n2 = 1, r2 = 1, i2 = 1, o2 = 1) {
          super(), this.type = "BoxBufferGeometry", this.parameters = { width: t2, height: e2, depth: n2, widthSegments: r2, heightSegments: i2, depthSegments: o2 };
          const a2 = this;
          r2 = Math.floor(r2), i2 = Math.floor(i2), o2 = Math.floor(o2);
          const s2 = [], c2 = [], u2 = [], l2 = [];
          let h2 = 0, d2 = 0;
          function p2(t3, e3, n3, r3, i3, o3, p3, f2, m2, g2, v2) {
            const y2 = o3 / m2, x2 = p3 / g2, b2 = o3 / 2, w2 = p3 / 2, _2 = f2 / 2, M2 = m2 + 1, S2 = g2 + 1;
            let T2 = 0, E2 = 0;
            const A2 = new $n();
            for (let o4 = 0; o4 < S2; o4++) {
              const a3 = o4 * x2 - w2;
              for (let s3 = 0; s3 < M2; s3++) {
                const h3 = s3 * y2 - b2;
                A2[t3] = h3 * r3, A2[e3] = a3 * i3, A2[n3] = _2, c2.push(A2.x, A2.y, A2.z), A2[t3] = 0, A2[e3] = 0, A2[n3] = f2 > 0 ? 1 : -1, u2.push(A2.x, A2.y, A2.z), l2.push(s3 / m2), l2.push(1 - o4 / g2), T2 += 1;
              }
            }
            for (let t4 = 0; t4 < g2; t4++) for (let e4 = 0; e4 < m2; e4++) {
              const n4 = h2 + e4 + M2 * t4, r4 = h2 + e4 + M2 * (t4 + 1), i4 = h2 + (e4 + 1) + M2 * (t4 + 1), o4 = h2 + (e4 + 1) + M2 * t4;
              s2.push(n4, r4, o4), s2.push(r4, i4, o4), E2 += 6;
            }
            a2.addGroup(d2, E2, v2), d2 += E2, h2 += T2;
          }
          p2("z", "y", "x", -1, -1, n2, e2, t2, o2, i2, 0), p2("z", "y", "x", 1, -1, n2, e2, -t2, o2, i2, 1), p2("x", "z", "y", 1, 1, t2, n2, e2, r2, o2, 2), p2("x", "z", "y", 1, -1, t2, n2, -e2, r2, o2, 3), p2("x", "y", "z", 1, -1, t2, e2, n2, r2, i2, 4), p2("x", "y", "z", -1, -1, t2, e2, -n2, r2, i2, 5), this.setIndex(s2), this.setAttribute("position", new Ii(c2, 3)), this.setAttribute("normal", new Ii(u2, 3)), this.setAttribute("uv", new Ii(l2, 2));
        }
      }
      function go(t2) {
        const e2 = {};
        for (const n2 in t2) {
          e2[n2] = {};
          for (const r2 in t2[n2]) {
            const i2 = t2[n2][r2];
            i2 && (i2.isColor || i2.isMatrix3 || i2.isMatrix4 || i2.isVector2 || i2.isVector3 || i2.isVector4 || i2.isTexture) ? e2[n2][r2] = i2.clone() : Array.isArray(i2) ? e2[n2][r2] = i2.slice() : e2[n2][r2] = i2;
          }
        }
        return e2;
      }
      function vo(t2) {
        const e2 = {};
        for (let n2 = 0; n2 < t2.length; n2++) {
          const r2 = go(t2[n2]);
          for (const t3 in r2) e2[t3] = r2[t3];
        }
        return e2;
      }
      const yo = { clone: go, merge: vo };
      function xo(t2) {
        wi.call(this), this.type = "ShaderMaterial", this.defines = {}, this.uniforms = {}, this.vertexShader = "void main() {\n	gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n}", this.fragmentShader = "void main() {\n	gl_FragColor = vec4( 1.0, 0.0, 0.0, 1.0 );\n}", this.linewidth = 1, this.wireframe = false, this.wireframeLinewidth = 1, this.fog = false, this.lights = false, this.clipping = false, this.skinning = false, this.morphTargets = false, this.morphNormals = false, this.extensions = { derivatives: false, fragDepth: false, drawBuffers: false, shaderTextureLOD: false }, this.defaultAttributeValues = { color: [1, 1, 1], uv: [0, 0], uv2: [0, 0] }, this.index0AttributeName = void 0, this.uniformsNeedUpdate = false, this.glslVersion = null, void 0 !== t2 && (void 0 !== t2.attributes && console.error("THREE.ShaderMaterial: attributes should now be defined in THREE.BufferGeometry instead."), this.setValues(t2));
      }
      function bo() {
        Jr.call(this), this.type = "Camera", this.matrixWorldInverse = new Tr(), this.projectionMatrix = new Tr(), this.projectionMatrixInverse = new Tr();
      }
      function wo(t2 = 50, e2 = 1, n2 = 0.1, r2 = 2e3) {
        bo.call(this), this.type = "PerspectiveCamera", this.fov = t2, this.zoom = 1, this.near = n2, this.far = r2, this.focus = 10, this.aspect = e2, this.view = null, this.filmGauge = 35, this.filmOffset = 0, this.updateProjectionMatrix();
      }
      xo.prototype = Object.create(wi.prototype), xo.prototype.constructor = xo, xo.prototype.isShaderMaterial = true, xo.prototype.copy = function(t2) {
        return wi.prototype.copy.call(this, t2), this.fragmentShader = t2.fragmentShader, this.vertexShader = t2.vertexShader, this.uniforms = go(t2.uniforms), this.defines = Object.assign({}, t2.defines), this.wireframe = t2.wireframe, this.wireframeLinewidth = t2.wireframeLinewidth, this.lights = t2.lights, this.clipping = t2.clipping, this.skinning = t2.skinning, this.morphTargets = t2.morphTargets, this.morphNormals = t2.morphNormals, this.extensions = Object.assign({}, t2.extensions), this.glslVersion = t2.glslVersion, this;
      }, xo.prototype.toJSON = function(t2) {
        const e2 = wi.prototype.toJSON.call(this, t2);
        e2.glslVersion = this.glslVersion, e2.uniforms = {};
        for (const n3 in this.uniforms) {
          const r2 = this.uniforms[n3].value;
          r2 && r2.isTexture ? e2.uniforms[n3] = { type: "t", value: r2.toJSON(t2).uuid } : r2 && r2.isColor ? e2.uniforms[n3] = { type: "c", value: r2.getHex() } : r2 && r2.isVector2 ? e2.uniforms[n3] = { type: "v2", value: r2.toArray() } : r2 && r2.isVector3 ? e2.uniforms[n3] = { type: "v3", value: r2.toArray() } : r2 && r2.isVector4 ? e2.uniforms[n3] = { type: "v4", value: r2.toArray() } : r2 && r2.isMatrix3 ? e2.uniforms[n3] = { type: "m3", value: r2.toArray() } : r2 && r2.isMatrix4 ? e2.uniforms[n3] = { type: "m4", value: r2.toArray() } : e2.uniforms[n3] = { value: r2 };
        }
        Object.keys(this.defines).length > 0 && (e2.defines = this.defines), e2.vertexShader = this.vertexShader, e2.fragmentShader = this.fragmentShader;
        const n2 = {};
        for (const t3 in this.extensions) true === this.extensions[t3] && (n2[t3] = true);
        return Object.keys(n2).length > 0 && (e2.extensions = n2), e2;
      }, bo.prototype = Object.assign(Object.create(Jr.prototype), { constructor: bo, isCamera: true, copy: function(t2, e2) {
        return Jr.prototype.copy.call(this, t2, e2), this.matrixWorldInverse.copy(t2.matrixWorldInverse), this.projectionMatrix.copy(t2.projectionMatrix), this.projectionMatrixInverse.copy(t2.projectionMatrixInverse), this;
      }, getWorldDirection: function(t2) {
        void 0 === t2 && (console.warn("THREE.Camera: .getWorldDirection() target is now required"), t2 = new $n()), this.updateWorldMatrix(true, false);
        const e2 = this.matrixWorld.elements;
        return t2.set(-e2[8], -e2[9], -e2[10]).normalize();
      }, updateMatrixWorld: function(t2) {
        Jr.prototype.updateMatrixWorld.call(this, t2), this.matrixWorldInverse.copy(this.matrixWorld).invert();
      }, updateWorldMatrix: function(t2, e2) {
        Jr.prototype.updateWorldMatrix.call(this, t2, e2), this.matrixWorldInverse.copy(this.matrixWorld).invert();
      }, clone: function() {
        return new this.constructor().copy(this);
      } }), wo.prototype = Object.assign(Object.create(bo.prototype), { constructor: wo, isPerspectiveCamera: true, copy: function(t2, e2) {
        return bo.prototype.copy.call(this, t2, e2), this.fov = t2.fov, this.zoom = t2.zoom, this.near = t2.near, this.far = t2.far, this.focus = t2.focus, this.aspect = t2.aspect, this.view = null === t2.view ? null : Object.assign({}, t2.view), this.filmGauge = t2.filmGauge, this.filmOffset = t2.filmOffset, this;
      }, setFocalLength: function(t2) {
        const e2 = 0.5 * this.getFilmHeight() / t2;
        this.fov = 2 * Bn.RAD2DEG * Math.atan(e2), this.updateProjectionMatrix();
      }, getFocalLength: function() {
        const t2 = Math.tan(0.5 * Bn.DEG2RAD * this.fov);
        return 0.5 * this.getFilmHeight() / t2;
      }, getEffectiveFOV: function() {
        return 2 * Bn.RAD2DEG * Math.atan(Math.tan(0.5 * Bn.DEG2RAD * this.fov) / this.zoom);
      }, getFilmWidth: function() {
        return this.filmGauge * Math.min(this.aspect, 1);
      }, getFilmHeight: function() {
        return this.filmGauge / Math.max(this.aspect, 1);
      }, setViewOffset: function(t2, e2, n2, r2, i2, o2) {
        this.aspect = t2 / e2, null === this.view && (this.view = { enabled: true, fullWidth: 1, fullHeight: 1, offsetX: 0, offsetY: 0, width: 1, height: 1 }), this.view.enabled = true, this.view.fullWidth = t2, this.view.fullHeight = e2, this.view.offsetX = n2, this.view.offsetY = r2, this.view.width = i2, this.view.height = o2, this.updateProjectionMatrix();
      }, clearViewOffset: function() {
        null !== this.view && (this.view.enabled = false), this.updateProjectionMatrix();
      }, updateProjectionMatrix: function() {
        const t2 = this.near;
        let e2 = t2 * Math.tan(0.5 * Bn.DEG2RAD * this.fov) / this.zoom, n2 = 2 * e2, r2 = this.aspect * n2, i2 = -0.5 * r2;
        const o2 = this.view;
        if (null !== this.view && this.view.enabled) {
          const t3 = o2.fullWidth, a3 = o2.fullHeight;
          i2 += o2.offsetX * r2 / t3, e2 -= o2.offsetY * n2 / a3, r2 *= o2.width / t3, n2 *= o2.height / a3;
        }
        const a2 = this.filmOffset;
        0 !== a2 && (i2 += t2 * a2 / this.getFilmWidth()), this.projectionMatrix.makePerspective(i2, i2 + r2, e2, e2 - n2, t2, this.far), this.projectionMatrixInverse.copy(this.projectionMatrix).invert();
      }, toJSON: function(t2) {
        const e2 = Jr.prototype.toJSON.call(this, t2);
        return e2.object.fov = this.fov, e2.object.zoom = this.zoom, e2.object.near = this.near, e2.object.far = this.far, e2.object.focus = this.focus, e2.object.aspect = this.aspect, null !== this.view && (e2.object.view = Object.assign({}, this.view)), e2.object.filmGauge = this.filmGauge, e2.object.filmOffset = this.filmOffset, e2;
      } });
      function _o(t2, e2, n2) {
        if (Jr.call(this), this.type = "CubeCamera", true !== n2.isWebGLCubeRenderTarget) return void console.error("THREE.CubeCamera: The constructor now expects an instance of WebGLCubeRenderTarget as third parameter.");
        this.renderTarget = n2;
        const r2 = new wo(90, 1, t2, e2);
        r2.layers = this.layers, r2.up.set(0, -1, 0), r2.lookAt(new $n(1, 0, 0)), this.add(r2);
        const i2 = new wo(90, 1, t2, e2);
        i2.layers = this.layers, i2.up.set(0, -1, 0), i2.lookAt(new $n(-1, 0, 0)), this.add(i2);
        const o2 = new wo(90, 1, t2, e2);
        o2.layers = this.layers, o2.up.set(0, 0, 1), o2.lookAt(new $n(0, 1, 0)), this.add(o2);
        const a2 = new wo(90, 1, t2, e2);
        a2.layers = this.layers, a2.up.set(0, 0, -1), a2.lookAt(new $n(0, -1, 0)), this.add(a2);
        const s2 = new wo(90, 1, t2, e2);
        s2.layers = this.layers, s2.up.set(0, -1, 0), s2.lookAt(new $n(0, 0, 1)), this.add(s2);
        const c2 = new wo(90, 1, t2, e2);
        c2.layers = this.layers, c2.up.set(0, -1, 0), c2.lookAt(new $n(0, 0, -1)), this.add(c2), this.update = function(t3, e3) {
          null === this.parent && this.updateMatrixWorld();
          const u2 = t3.xr.enabled, l2 = t3.getRenderTarget();
          t3.xr.enabled = false;
          const h2 = n2.texture.generateMipmaps;
          n2.texture.generateMipmaps = false, t3.setRenderTarget(n2, 0), t3.render(e3, r2), t3.setRenderTarget(n2, 1), t3.render(e3, i2), t3.setRenderTarget(n2, 2), t3.render(e3, o2), t3.setRenderTarget(n2, 3), t3.render(e3, a2), t3.setRenderTarget(n2, 4), t3.render(e3, s2), n2.texture.generateMipmaps = h2, t3.setRenderTarget(n2, 5), t3.render(e3, c2), t3.setRenderTarget(l2), t3.xr.enabled = u2;
        };
      }
      function Mo(t2, e2, n2, r2, i2, o2, a2, s2, c2, u2) {
        t2 = void 0 !== t2 ? t2 : [], e2 = void 0 !== e2 ? e2 : ot, a2 = void 0 !== a2 ? a2 : kt, Wn.call(this, t2, e2, n2, r2, i2, o2, a2, s2, c2, u2), this.flipY = false, this._needsFlipEnvMap = true;
      }
      function So(t2, e2, n2) {
        Number.isInteger(e2) && (console.warn("THREE.WebGLCubeRenderTarget: constructor signature is now WebGLCubeRenderTarget( size, options )"), e2 = n2), Yn.call(this, t2, t2, e2), e2 = e2 || {}, this.texture = new Mo(void 0, e2.mapping, e2.wrapS, e2.wrapT, e2.magFilter, e2.minFilter, e2.format, e2.type, e2.anisotropy, e2.encoding), this.texture._needsFlipEnvMap = false;
      }
      function To(t2, e2, n2, r2, i2, o2, a2, s2, c2, u2, l2, h2) {
        Wn.call(this, null, o2, a2, s2, c2, u2, r2, i2, l2, h2), this.image = { data: t2 || null, width: e2 || 1, height: n2 || 1 }, this.magFilter = void 0 !== c2 ? c2 : ft, this.minFilter = void 0 !== u2 ? u2 : ft, this.generateMipmaps = false, this.flipY = false, this.unpackAlignment = 1, this.needsUpdate = true;
      }
      _o.prototype = Object.create(Jr.prototype), _o.prototype.constructor = _o, Mo.prototype = Object.create(Wn.prototype), Mo.prototype.constructor = Mo, Mo.prototype.isCubeTexture = true, Object.defineProperty(Mo.prototype, "images", { get: function() {
        return this.image;
      }, set: function(t2) {
        this.image = t2;
      } }), So.prototype = Object.create(Yn.prototype), So.prototype.constructor = So, So.prototype.isWebGLCubeRenderTarget = true, So.prototype.fromEquirectangularTexture = function(t2, e2) {
        this.texture.type = e2.type, this.texture.format = Ft, this.texture.encoding = e2.encoding, this.texture.generateMipmaps = e2.generateMipmaps, this.texture.minFilter = e2.minFilter, this.texture.magFilter = e2.magFilter;
        const n2 = { uniforms: { tEquirect: { value: null } }, vertexShader: "\n\n			varying vec3 vWorldDirection;\n\n			vec3 transformDirection( in vec3 dir, in mat4 matrix ) {\n\n				return normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );\n\n			}\n\n			void main() {\n\n				vWorldDirection = transformDirection( position, modelMatrix );\n\n				#include <begin_vertex>\n				#include <project_vertex>\n\n			}\n		", fragmentShader: "\n\n			uniform sampler2D tEquirect;\n\n			varying vec3 vWorldDirection;\n\n			#include <common>\n\n			void main() {\n\n				vec3 direction = normalize( vWorldDirection );\n\n				vec2 sampleUV = equirectUv( direction );\n\n				gl_FragColor = texture2D( tEquirect, sampleUV );\n\n			}\n		" }, r2 = new mo(5, 5, 5), i2 = new xo({ name: "CubemapFromEquirect", uniforms: go(n2.uniforms), vertexShader: n2.vertexShader, fragmentShader: n2.fragmentShader, side: m, blending: x });
        i2.uniforms.tEquirect.value = e2;
        const o2 = new ho(r2, i2), a2 = e2.minFilter;
        e2.minFilter === _t && (e2.minFilter = xt);
        return new _o(1, 10, this).update(t2, o2), e2.minFilter = a2, o2.geometry.dispose(), o2.material.dispose(), this;
      }, So.prototype.clear = function(t2, e2, n2, r2) {
        const i2 = t2.getRenderTarget();
        for (let i3 = 0; i3 < 6; i3++) t2.setRenderTarget(this, i3), t2.clear(e2, n2, r2);
        t2.setRenderTarget(i2);
      }, To.prototype = Object.create(Wn.prototype), To.prototype.constructor = To, To.prototype.isDataTexture = true;
      const Eo = new gr(), Ao = new $n();
      class Co {
        constructor(t2, e2, n2, r2, i2, o2) {
          this.planes = [void 0 !== t2 ? t2 : new ti(), void 0 !== e2 ? e2 : new ti(), void 0 !== n2 ? n2 : new ti(), void 0 !== r2 ? r2 : new ti(), void 0 !== i2 ? i2 : new ti(), void 0 !== o2 ? o2 : new ti()];
        }
        set(t2, e2, n2, r2, i2, o2) {
          const a2 = this.planes;
          return a2[0].copy(t2), a2[1].copy(e2), a2[2].copy(n2), a2[3].copy(r2), a2[4].copy(i2), a2[5].copy(o2), this;
        }
        clone() {
          return new this.constructor().copy(this);
        }
        copy(t2) {
          const e2 = this.planes;
          for (let n2 = 0; n2 < 6; n2++) e2[n2].copy(t2.planes[n2]);
          return this;
        }
        setFromProjectionMatrix(t2) {
          const e2 = this.planes, n2 = t2.elements, r2 = n2[0], i2 = n2[1], o2 = n2[2], a2 = n2[3], s2 = n2[4], c2 = n2[5], u2 = n2[6], l2 = n2[7], h2 = n2[8], d2 = n2[9], p2 = n2[10], f2 = n2[11], m2 = n2[12], g2 = n2[13], v2 = n2[14], y2 = n2[15];
          return e2[0].setComponents(a2 - r2, l2 - s2, f2 - h2, y2 - m2).normalize(), e2[1].setComponents(a2 + r2, l2 + s2, f2 + h2, y2 + m2).normalize(), e2[2].setComponents(a2 + i2, l2 + c2, f2 + d2, y2 + g2).normalize(), e2[3].setComponents(a2 - i2, l2 - c2, f2 - d2, y2 - g2).normalize(), e2[4].setComponents(a2 - o2, l2 - u2, f2 - p2, y2 - v2).normalize(), e2[5].setComponents(a2 + o2, l2 + u2, f2 + p2, y2 + v2).normalize(), this;
        }
        intersectsObject(t2) {
          const e2 = t2.geometry;
          return null === e2.boundingSphere && e2.computeBoundingSphere(), Eo.copy(e2.boundingSphere).applyMatrix4(t2.matrixWorld), this.intersectsSphere(Eo);
        }
        intersectsSprite(t2) {
          return Eo.center.set(0, 0, 0), Eo.radius = 0.7071067811865476, Eo.applyMatrix4(t2.matrixWorld), this.intersectsSphere(Eo);
        }
        intersectsSphere(t2) {
          const e2 = this.planes, n2 = t2.center, r2 = -t2.radius;
          for (let t3 = 0; t3 < 6; t3++) {
            if (e2[t3].distanceToPoint(n2) < r2) return false;
          }
          return true;
        }
        intersectsBox(t2) {
          const e2 = this.planes;
          for (let n2 = 0; n2 < 6; n2++) {
            const r2 = e2[n2];
            if (Ao.x = r2.normal.x > 0 ? t2.max.x : t2.min.x, Ao.y = r2.normal.y > 0 ? t2.max.y : t2.min.y, Ao.z = r2.normal.z > 0 ? t2.max.z : t2.min.z, r2.distanceToPoint(Ao) < 0) return false;
          }
          return true;
        }
        containsPoint(t2) {
          const e2 = this.planes;
          for (let n2 = 0; n2 < 6; n2++) if (e2[n2].distanceToPoint(t2) < 0) return false;
          return true;
        }
      }
      function Lo() {
        let t2 = null, e2 = false, n2 = null, r2 = null;
        function i2(e3, o2) {
          n2(e3, o2), r2 = t2.requestAnimationFrame(i2);
        }
        return { start: function() {
          true !== e2 && null !== n2 && (r2 = t2.requestAnimationFrame(i2), e2 = true);
        }, stop: function() {
          t2.cancelAnimationFrame(r2), e2 = false;
        }, setAnimationLoop: function(t3) {
          n2 = t3;
        }, setContext: function(e3) {
          t2 = e3;
        } };
      }
      function Po(t2, e2) {
        const n2 = e2.isWebGL2, r2 = /* @__PURE__ */ new WeakMap();
        return { get: function(t3) {
          return t3.isInterleavedBufferAttribute && (t3 = t3.data), r2.get(t3);
        }, remove: function(e3) {
          e3.isInterleavedBufferAttribute && (e3 = e3.data);
          const n3 = r2.get(e3);
          n3 && (t2.deleteBuffer(n3.buffer), r2.delete(e3));
        }, update: function(e3, i2) {
          if (e3.isGLBufferAttribute) {
            const t3 = r2.get(e3);
            return void ((!t3 || t3.version < e3.version) && r2.set(e3, { buffer: e3.buffer, type: e3.type, bytesPerElement: e3.elementSize, version: e3.version }));
          }
          e3.isInterleavedBufferAttribute && (e3 = e3.data);
          const o2 = r2.get(e3);
          void 0 === o2 ? r2.set(e3, function(e4, r3) {
            const i3 = e4.array, o3 = e4.usage, a2 = t2.createBuffer();
            t2.bindBuffer(r3, a2), t2.bufferData(r3, i3, o3), e4.onUploadCallback();
            let s2 = 5126;
            return i3 instanceof Float32Array ? s2 = 5126 : i3 instanceof Float64Array ? console.warn("THREE.WebGLAttributes: Unsupported data buffer format: Float64Array.") : i3 instanceof Uint16Array ? e4.isFloat16BufferAttribute ? n2 ? s2 = 5131 : console.warn("THREE.WebGLAttributes: Usage of Float16BufferAttribute requires WebGL2.") : s2 = 5123 : i3 instanceof Int16Array ? s2 = 5122 : i3 instanceof Uint32Array ? s2 = 5125 : i3 instanceof Int32Array ? s2 = 5124 : i3 instanceof Int8Array ? s2 = 5120 : i3 instanceof Uint8Array && (s2 = 5121), { buffer: a2, type: s2, bytesPerElement: i3.BYTES_PER_ELEMENT, version: e4.version };
          }(e3, i2)) : o2.version < e3.version && (!function(e4, r3, i3) {
            const o3 = r3.array, a2 = r3.updateRange;
            t2.bindBuffer(i3, e4), -1 === a2.count ? t2.bufferSubData(i3, 0, o3) : (n2 ? t2.bufferSubData(i3, a2.offset * o3.BYTES_PER_ELEMENT, o3, a2.offset, a2.count) : t2.bufferSubData(i3, a2.offset * o3.BYTES_PER_ELEMENT, o3.subarray(a2.offset, a2.offset + a2.count)), a2.count = -1);
          }(o2.buffer, e3, i2), o2.version = e3.version);
        } };
      }
      class Ro extends Xi {
        constructor(t2 = 1, e2 = 1, n2 = 1, r2 = 1) {
          super(), this.type = "PlaneBufferGeometry", this.parameters = { width: t2, height: e2, widthSegments: n2, heightSegments: r2 };
          const i2 = t2 / 2, o2 = e2 / 2, a2 = Math.floor(n2), s2 = Math.floor(r2), c2 = a2 + 1, u2 = s2 + 1, l2 = t2 / a2, h2 = e2 / s2, d2 = [], p2 = [], f2 = [], m2 = [];
          for (let t3 = 0; t3 < u2; t3++) {
            const e3 = t3 * h2 - o2;
            for (let n3 = 0; n3 < c2; n3++) {
              const r3 = n3 * l2 - i2;
              p2.push(r3, -e3, 0), f2.push(0, 0, 1), m2.push(n3 / a2), m2.push(1 - t3 / s2);
            }
          }
          for (let t3 = 0; t3 < s2; t3++) for (let e3 = 0; e3 < a2; e3++) {
            const n3 = e3 + c2 * t3, r3 = e3 + c2 * (t3 + 1), i3 = e3 + 1 + c2 * (t3 + 1), o3 = e3 + 1 + c2 * t3;
            d2.push(n3, r3, o3), d2.push(r3, i3, o3);
          }
          this.setIndex(d2), this.setAttribute("position", new Ii(p2, 3)), this.setAttribute("normal", new Ii(f2, 3)), this.setAttribute("uv", new Ii(m2, 2));
        }
      }
      const Oo = { alphamap_fragment: "#ifdef USE_ALPHAMAP\n	diffuseColor.a *= texture2D( alphaMap, vUv ).g;\n#endif", alphamap_pars_fragment: "#ifdef USE_ALPHAMAP\n	uniform sampler2D alphaMap;\n#endif", alphatest_fragment: "#ifdef ALPHATEST\n	if ( diffuseColor.a < ALPHATEST ) discard;\n#endif", aomap_fragment: "#ifdef USE_AOMAP\n	float ambientOcclusion = ( texture2D( aoMap, vUv2 ).r - 1.0 ) * aoMapIntensity + 1.0;\n	reflectedLight.indirectDiffuse *= ambientOcclusion;\n	#if defined( USE_ENVMAP ) && defined( STANDARD )\n		float dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );\n		reflectedLight.indirectSpecular *= computeSpecularOcclusion( dotNV, ambientOcclusion, material.specularRoughness );\n	#endif\n#endif", aomap_pars_fragment: "#ifdef USE_AOMAP\n	uniform sampler2D aoMap;\n	uniform float aoMapIntensity;\n#endif", begin_vertex: "vec3 transformed = vec3( position );", beginnormal_vertex: "vec3 objectNormal = vec3( normal );\n#ifdef USE_TANGENT\n	vec3 objectTangent = vec3( tangent.xyz );\n#endif", bsdfs: "vec2 integrateSpecularBRDF( const in float dotNV, const in float roughness ) {\n	const vec4 c0 = vec4( - 1, - 0.0275, - 0.572, 0.022 );\n	const vec4 c1 = vec4( 1, 0.0425, 1.04, - 0.04 );\n	vec4 r = roughness * c0 + c1;\n	float a004 = min( r.x * r.x, exp2( - 9.28 * dotNV ) ) * r.x + r.y;\n	return vec2( -1.04, 1.04 ) * a004 + r.zw;\n}\nfloat punctualLightIntensityToIrradianceFactor( const in float lightDistance, const in float cutoffDistance, const in float decayExponent ) {\n#if defined ( PHYSICALLY_CORRECT_LIGHTS )\n	float distanceFalloff = 1.0 / max( pow( lightDistance, decayExponent ), 0.01 );\n	if( cutoffDistance > 0.0 ) {\n		distanceFalloff *= pow2( saturate( 1.0 - pow4( lightDistance / cutoffDistance ) ) );\n	}\n	return distanceFalloff;\n#else\n	if( cutoffDistance > 0.0 && decayExponent > 0.0 ) {\n		return pow( saturate( -lightDistance / cutoffDistance + 1.0 ), decayExponent );\n	}\n	return 1.0;\n#endif\n}\nvec3 BRDF_Diffuse_Lambert( const in vec3 diffuseColor ) {\n	return RECIPROCAL_PI * diffuseColor;\n}\nvec3 F_Schlick( const in vec3 specularColor, const in float dotLH ) {\n	float fresnel = exp2( ( -5.55473 * dotLH - 6.98316 ) * dotLH );\n	return ( 1.0 - specularColor ) * fresnel + specularColor;\n}\nvec3 F_Schlick_RoughnessDependent( const in vec3 F0, const in float dotNV, const in float roughness ) {\n	float fresnel = exp2( ( -5.55473 * dotNV - 6.98316 ) * dotNV );\n	vec3 Fr = max( vec3( 1.0 - roughness ), F0 ) - F0;\n	return Fr * fresnel + F0;\n}\nfloat G_GGX_Smith( const in float alpha, const in float dotNL, const in float dotNV ) {\n	float a2 = pow2( alpha );\n	float gl = dotNL + sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNL ) );\n	float gv = dotNV + sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNV ) );\n	return 1.0 / ( gl * gv );\n}\nfloat G_GGX_SmithCorrelated( const in float alpha, const in float dotNL, const in float dotNV ) {\n	float a2 = pow2( alpha );\n	float gv = dotNL * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNV ) );\n	float gl = dotNV * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNL ) );\n	return 0.5 / max( gv + gl, EPSILON );\n}\nfloat D_GGX( const in float alpha, const in float dotNH ) {\n	float a2 = pow2( alpha );\n	float denom = pow2( dotNH ) * ( a2 - 1.0 ) + 1.0;\n	return RECIPROCAL_PI * a2 / pow2( denom );\n}\nvec3 BRDF_Specular_GGX( const in IncidentLight incidentLight, const in vec3 viewDir, const in vec3 normal, const in vec3 specularColor, const in float roughness ) {\n	float alpha = pow2( roughness );\n	vec3 halfDir = normalize( incidentLight.direction + viewDir );\n	float dotNL = saturate( dot( normal, incidentLight.direction ) );\n	float dotNV = saturate( dot( normal, viewDir ) );\n	float dotNH = saturate( dot( normal, halfDir ) );\n	float dotLH = saturate( dot( incidentLight.direction, halfDir ) );\n	vec3 F = F_Schlick( specularColor, dotLH );\n	float G = G_GGX_SmithCorrelated( alpha, dotNL, dotNV );\n	float D = D_GGX( alpha, dotNH );\n	return F * ( G * D );\n}\nvec2 LTC_Uv( const in vec3 N, const in vec3 V, const in float roughness ) {\n	const float LUT_SIZE = 64.0;\n	const float LUT_SCALE = ( LUT_SIZE - 1.0 ) / LUT_SIZE;\n	const float LUT_BIAS = 0.5 / LUT_SIZE;\n	float dotNV = saturate( dot( N, V ) );\n	vec2 uv = vec2( roughness, sqrt( 1.0 - dotNV ) );\n	uv = uv * LUT_SCALE + LUT_BIAS;\n	return uv;\n}\nfloat LTC_ClippedSphereFormFactor( const in vec3 f ) {\n	float l = length( f );\n	return max( ( l * l + f.z ) / ( l + 1.0 ), 0.0 );\n}\nvec3 LTC_EdgeVectorFormFactor( const in vec3 v1, const in vec3 v2 ) {\n	float x = dot( v1, v2 );\n	float y = abs( x );\n	float a = 0.8543985 + ( 0.4965155 + 0.0145206 * y ) * y;\n	float b = 3.4175940 + ( 4.1616724 + y ) * y;\n	float v = a / b;\n	float theta_sintheta = ( x > 0.0 ) ? v : 0.5 * inversesqrt( max( 1.0 - x * x, 1e-7 ) ) - v;\n	return cross( v1, v2 ) * theta_sintheta;\n}\nvec3 LTC_Evaluate( const in vec3 N, const in vec3 V, const in vec3 P, const in mat3 mInv, const in vec3 rectCoords[ 4 ] ) {\n	vec3 v1 = rectCoords[ 1 ] - rectCoords[ 0 ];\n	vec3 v2 = rectCoords[ 3 ] - rectCoords[ 0 ];\n	vec3 lightNormal = cross( v1, v2 );\n	if( dot( lightNormal, P - rectCoords[ 0 ] ) < 0.0 ) return vec3( 0.0 );\n	vec3 T1, T2;\n	T1 = normalize( V - N * dot( V, N ) );\n	T2 = - cross( N, T1 );\n	mat3 mat = mInv * transposeMat3( mat3( T1, T2, N ) );\n	vec3 coords[ 4 ];\n	coords[ 0 ] = mat * ( rectCoords[ 0 ] - P );\n	coords[ 1 ] = mat * ( rectCoords[ 1 ] - P );\n	coords[ 2 ] = mat * ( rectCoords[ 2 ] - P );\n	coords[ 3 ] = mat * ( rectCoords[ 3 ] - P );\n	coords[ 0 ] = normalize( coords[ 0 ] );\n	coords[ 1 ] = normalize( coords[ 1 ] );\n	coords[ 2 ] = normalize( coords[ 2 ] );\n	coords[ 3 ] = normalize( coords[ 3 ] );\n	vec3 vectorFormFactor = vec3( 0.0 );\n	vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 0 ], coords[ 1 ] );\n	vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 1 ], coords[ 2 ] );\n	vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 2 ], coords[ 3 ] );\n	vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 3 ], coords[ 0 ] );\n	float result = LTC_ClippedSphereFormFactor( vectorFormFactor );\n	return vec3( result );\n}\nvec3 BRDF_Specular_GGX_Environment( const in vec3 viewDir, const in vec3 normal, const in vec3 specularColor, const in float roughness ) {\n	float dotNV = saturate( dot( normal, viewDir ) );\n	vec2 brdf = integrateSpecularBRDF( dotNV, roughness );\n	return specularColor * brdf.x + brdf.y;\n}\nvoid BRDF_Specular_Multiscattering_Environment( const in GeometricContext geometry, const in vec3 specularColor, const in float roughness, inout vec3 singleScatter, inout vec3 multiScatter ) {\n	float dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );\n	vec3 F = F_Schlick_RoughnessDependent( specularColor, dotNV, roughness );\n	vec2 brdf = integrateSpecularBRDF( dotNV, roughness );\n	vec3 FssEss = F * brdf.x + brdf.y;\n	float Ess = brdf.x + brdf.y;\n	float Ems = 1.0 - Ess;\n	vec3 Favg = specularColor + ( 1.0 - specularColor ) * 0.047619;	vec3 Fms = FssEss * Favg / ( 1.0 - Ems * Favg );\n	singleScatter += FssEss;\n	multiScatter += Fms * Ems;\n}\nfloat G_BlinnPhong_Implicit( ) {\n	return 0.25;\n}\nfloat D_BlinnPhong( const in float shininess, const in float dotNH ) {\n	return RECIPROCAL_PI * ( shininess * 0.5 + 1.0 ) * pow( dotNH, shininess );\n}\nvec3 BRDF_Specular_BlinnPhong( const in IncidentLight incidentLight, const in GeometricContext geometry, const in vec3 specularColor, const in float shininess ) {\n	vec3 halfDir = normalize( incidentLight.direction + geometry.viewDir );\n	float dotNH = saturate( dot( geometry.normal, halfDir ) );\n	float dotLH = saturate( dot( incidentLight.direction, halfDir ) );\n	vec3 F = F_Schlick( specularColor, dotLH );\n	float G = G_BlinnPhong_Implicit( );\n	float D = D_BlinnPhong( shininess, dotNH );\n	return F * ( G * D );\n}\nfloat GGXRoughnessToBlinnExponent( const in float ggxRoughness ) {\n	return ( 2.0 / pow2( ggxRoughness + 0.0001 ) - 2.0 );\n}\nfloat BlinnExponentToGGXRoughness( const in float blinnExponent ) {\n	return sqrt( 2.0 / ( blinnExponent + 2.0 ) );\n}\n#if defined( USE_SHEEN )\nfloat D_Charlie(float roughness, float NoH) {\n	float invAlpha = 1.0 / roughness;\n	float cos2h = NoH * NoH;\n	float sin2h = max(1.0 - cos2h, 0.0078125);	return (2.0 + invAlpha) * pow(sin2h, invAlpha * 0.5) / (2.0 * PI);\n}\nfloat V_Neubelt(float NoV, float NoL) {\n	return saturate(1.0 / (4.0 * (NoL + NoV - NoL * NoV)));\n}\nvec3 BRDF_Specular_Sheen( const in float roughness, const in vec3 L, const in GeometricContext geometry, vec3 specularColor ) {\n	vec3 N = geometry.normal;\n	vec3 V = geometry.viewDir;\n	vec3 H = normalize( V + L );\n	float dotNH = saturate( dot( N, H ) );\n	return specularColor * D_Charlie( roughness, dotNH ) * V_Neubelt( dot(N, V), dot(N, L) );\n}\n#endif", bumpmap_pars_fragment: "#ifdef USE_BUMPMAP\n	uniform sampler2D bumpMap;\n	uniform float bumpScale;\n	vec2 dHdxy_fwd() {\n		vec2 dSTdx = dFdx( vUv );\n		vec2 dSTdy = dFdy( vUv );\n		float Hll = bumpScale * texture2D( bumpMap, vUv ).x;\n		float dBx = bumpScale * texture2D( bumpMap, vUv + dSTdx ).x - Hll;\n		float dBy = bumpScale * texture2D( bumpMap, vUv + dSTdy ).x - Hll;\n		return vec2( dBx, dBy );\n	}\n	vec3 perturbNormalArb( vec3 surf_pos, vec3 surf_norm, vec2 dHdxy ) {\n		vec3 vSigmaX = vec3( dFdx( surf_pos.x ), dFdx( surf_pos.y ), dFdx( surf_pos.z ) );\n		vec3 vSigmaY = vec3( dFdy( surf_pos.x ), dFdy( surf_pos.y ), dFdy( surf_pos.z ) );\n		vec3 vN = surf_norm;\n		vec3 R1 = cross( vSigmaY, vN );\n		vec3 R2 = cross( vN, vSigmaX );\n		float fDet = dot( vSigmaX, R1 );\n		fDet *= ( float( gl_FrontFacing ) * 2.0 - 1.0 );\n		vec3 vGrad = sign( fDet ) * ( dHdxy.x * R1 + dHdxy.y * R2 );\n		return normalize( abs( fDet ) * surf_norm - vGrad );\n	}\n#endif", clipping_planes_fragment: "#if NUM_CLIPPING_PLANES > 0\n	vec4 plane;\n	#pragma unroll_loop_start\n	for ( int i = 0; i < UNION_CLIPPING_PLANES; i ++ ) {\n		plane = clippingPlanes[ i ];\n		if ( dot( vClipPosition, plane.xyz ) > plane.w ) discard;\n	}\n	#pragma unroll_loop_end\n	#if UNION_CLIPPING_PLANES < NUM_CLIPPING_PLANES\n		bool clipped = true;\n		#pragma unroll_loop_start\n		for ( int i = UNION_CLIPPING_PLANES; i < NUM_CLIPPING_PLANES; i ++ ) {\n			plane = clippingPlanes[ i ];\n			clipped = ( dot( vClipPosition, plane.xyz ) > plane.w ) && clipped;\n		}\n		#pragma unroll_loop_end\n		if ( clipped ) discard;\n	#endif\n#endif", clipping_planes_pars_fragment: "#if NUM_CLIPPING_PLANES > 0\n	varying vec3 vClipPosition;\n	uniform vec4 clippingPlanes[ NUM_CLIPPING_PLANES ];\n#endif", clipping_planes_pars_vertex: "#if NUM_CLIPPING_PLANES > 0\n	varying vec3 vClipPosition;\n#endif", clipping_planes_vertex: "#if NUM_CLIPPING_PLANES > 0\n	vClipPosition = - mvPosition.xyz;\n#endif", color_fragment: "#ifdef USE_COLOR\n	diffuseColor.rgb *= vColor;\n#endif", color_pars_fragment: "#ifdef USE_COLOR\n	varying vec3 vColor;\n#endif", color_pars_vertex: "#if defined( USE_COLOR ) || defined( USE_INSTANCING_COLOR )\n	varying vec3 vColor;\n#endif", color_vertex: "#if defined( USE_COLOR ) || defined( USE_INSTANCING_COLOR )\n	vColor = vec3( 1.0 );\n#endif\n#ifdef USE_COLOR\n	vColor.xyz *= color.xyz;\n#endif\n#ifdef USE_INSTANCING_COLOR\n	vColor.xyz *= instanceColor.xyz;\n#endif", common: "#define PI 3.141592653589793\n#define PI2 6.283185307179586\n#define PI_HALF 1.5707963267948966\n#define RECIPROCAL_PI 0.3183098861837907\n#define RECIPROCAL_PI2 0.15915494309189535\n#define EPSILON 1e-6\n#ifndef saturate\n#define saturate(a) clamp( a, 0.0, 1.0 )\n#endif\n#define whiteComplement(a) ( 1.0 - saturate( a ) )\nfloat pow2( const in float x ) { return x*x; }\nfloat pow3( const in float x ) { return x*x*x; }\nfloat pow4( const in float x ) { float x2 = x*x; return x2*x2; }\nfloat average( const in vec3 color ) { return dot( color, vec3( 0.3333 ) ); }\nhighp float rand( const in vec2 uv ) {\n	const highp float a = 12.9898, b = 78.233, c = 43758.5453;\n	highp float dt = dot( uv.xy, vec2( a,b ) ), sn = mod( dt, PI );\n	return fract(sin(sn) * c);\n}\n#ifdef HIGH_PRECISION\n	float precisionSafeLength( vec3 v ) { return length( v ); }\n#else\n	float max3( vec3 v ) { return max( max( v.x, v.y ), v.z ); }\n	float precisionSafeLength( vec3 v ) {\n		float maxComponent = max3( abs( v ) );\n		return length( v / maxComponent ) * maxComponent;\n	}\n#endif\nstruct IncidentLight {\n	vec3 color;\n	vec3 direction;\n	bool visible;\n};\nstruct ReflectedLight {\n	vec3 directDiffuse;\n	vec3 directSpecular;\n	vec3 indirectDiffuse;\n	vec3 indirectSpecular;\n};\nstruct GeometricContext {\n	vec3 position;\n	vec3 normal;\n	vec3 viewDir;\n#ifdef CLEARCOAT\n	vec3 clearcoatNormal;\n#endif\n};\nvec3 transformDirection( in vec3 dir, in mat4 matrix ) {\n	return normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );\n}\nvec3 inverseTransformDirection( in vec3 dir, in mat4 matrix ) {\n	return normalize( ( vec4( dir, 0.0 ) * matrix ).xyz );\n}\nvec3 projectOnPlane(in vec3 point, in vec3 pointOnPlane, in vec3 planeNormal ) {\n	float distance = dot( planeNormal, point - pointOnPlane );\n	return - distance * planeNormal + point;\n}\nfloat sideOfPlane( in vec3 point, in vec3 pointOnPlane, in vec3 planeNormal ) {\n	return sign( dot( point - pointOnPlane, planeNormal ) );\n}\nvec3 linePlaneIntersect( in vec3 pointOnLine, in vec3 lineDirection, in vec3 pointOnPlane, in vec3 planeNormal ) {\n	return lineDirection * ( dot( planeNormal, pointOnPlane - pointOnLine ) / dot( planeNormal, lineDirection ) ) + pointOnLine;\n}\nmat3 transposeMat3( const in mat3 m ) {\n	mat3 tmp;\n	tmp[ 0 ] = vec3( m[ 0 ].x, m[ 1 ].x, m[ 2 ].x );\n	tmp[ 1 ] = vec3( m[ 0 ].y, m[ 1 ].y, m[ 2 ].y );\n	tmp[ 2 ] = vec3( m[ 0 ].z, m[ 1 ].z, m[ 2 ].z );\n	return tmp;\n}\nfloat linearToRelativeLuminance( const in vec3 color ) {\n	vec3 weights = vec3( 0.2126, 0.7152, 0.0722 );\n	return dot( weights, color.rgb );\n}\nbool isPerspectiveMatrix( mat4 m ) {\n	return m[ 2 ][ 3 ] == - 1.0;\n}\nvec2 equirectUv( in vec3 dir ) {\n	float u = atan( dir.z, dir.x ) * RECIPROCAL_PI2 + 0.5;\n	float v = asin( clamp( dir.y, - 1.0, 1.0 ) ) * RECIPROCAL_PI + 0.5;\n	return vec2( u, v );\n}", cube_uv_reflection_fragment: "#ifdef ENVMAP_TYPE_CUBE_UV\n	#define cubeUV_maxMipLevel 8.0\n	#define cubeUV_minMipLevel 4.0\n	#define cubeUV_maxTileSize 256.0\n	#define cubeUV_minTileSize 16.0\n	float getFace( vec3 direction ) {\n		vec3 absDirection = abs( direction );\n		float face = - 1.0;\n		if ( absDirection.x > absDirection.z ) {\n			if ( absDirection.x > absDirection.y )\n				face = direction.x > 0.0 ? 0.0 : 3.0;\n			else\n				face = direction.y > 0.0 ? 1.0 : 4.0;\n		} else {\n			if ( absDirection.z > absDirection.y )\n				face = direction.z > 0.0 ? 2.0 : 5.0;\n			else\n				face = direction.y > 0.0 ? 1.0 : 4.0;\n		}\n		return face;\n	}\n	vec2 getUV( vec3 direction, float face ) {\n		vec2 uv;\n		if ( face == 0.0 ) {\n			uv = vec2( direction.z, direction.y ) / abs( direction.x );\n		} else if ( face == 1.0 ) {\n			uv = vec2( - direction.x, - direction.z ) / abs( direction.y );\n		} else if ( face == 2.0 ) {\n			uv = vec2( - direction.x, direction.y ) / abs( direction.z );\n		} else if ( face == 3.0 ) {\n			uv = vec2( - direction.z, direction.y ) / abs( direction.x );\n		} else if ( face == 4.0 ) {\n			uv = vec2( - direction.x, direction.z ) / abs( direction.y );\n		} else {\n			uv = vec2( direction.x, direction.y ) / abs( direction.z );\n		}\n		return 0.5 * ( uv + 1.0 );\n	}\n	vec3 bilinearCubeUV( sampler2D envMap, vec3 direction, float mipInt ) {\n		float face = getFace( direction );\n		float filterInt = max( cubeUV_minMipLevel - mipInt, 0.0 );\n		mipInt = max( mipInt, cubeUV_minMipLevel );\n		float faceSize = exp2( mipInt );\n		float texelSize = 1.0 / ( 3.0 * cubeUV_maxTileSize );\n		vec2 uv = getUV( direction, face ) * ( faceSize - 1.0 );\n		vec2 f = fract( uv );\n		uv += 0.5 - f;\n		if ( face > 2.0 ) {\n			uv.y += faceSize;\n			face -= 3.0;\n		}\n		uv.x += face * faceSize;\n		if ( mipInt < cubeUV_maxMipLevel ) {\n			uv.y += 2.0 * cubeUV_maxTileSize;\n		}\n		uv.y += filterInt * 2.0 * cubeUV_minTileSize;\n		uv.x += 3.0 * max( 0.0, cubeUV_maxTileSize - 2.0 * faceSize );\n		uv *= texelSize;\n		vec3 tl = envMapTexelToLinear( texture2D( envMap, uv ) ).rgb;\n		uv.x += texelSize;\n		vec3 tr = envMapTexelToLinear( texture2D( envMap, uv ) ).rgb;\n		uv.y += texelSize;\n		vec3 br = envMapTexelToLinear( texture2D( envMap, uv ) ).rgb;\n		uv.x -= texelSize;\n		vec3 bl = envMapTexelToLinear( texture2D( envMap, uv ) ).rgb;\n		vec3 tm = mix( tl, tr, f.x );\n		vec3 bm = mix( bl, br, f.x );\n		return mix( tm, bm, f.y );\n	}\n	#define r0 1.0\n	#define v0 0.339\n	#define m0 - 2.0\n	#define r1 0.8\n	#define v1 0.276\n	#define m1 - 1.0\n	#define r4 0.4\n	#define v4 0.046\n	#define m4 2.0\n	#define r5 0.305\n	#define v5 0.016\n	#define m5 3.0\n	#define r6 0.21\n	#define v6 0.0038\n	#define m6 4.0\n	float roughnessToMip( float roughness ) {\n		float mip = 0.0;\n		if ( roughness >= r1 ) {\n			mip = ( r0 - roughness ) * ( m1 - m0 ) / ( r0 - r1 ) + m0;\n		} else if ( roughness >= r4 ) {\n			mip = ( r1 - roughness ) * ( m4 - m1 ) / ( r1 - r4 ) + m1;\n		} else if ( roughness >= r5 ) {\n			mip = ( r4 - roughness ) * ( m5 - m4 ) / ( r4 - r5 ) + m4;\n		} else if ( roughness >= r6 ) {\n			mip = ( r5 - roughness ) * ( m6 - m5 ) / ( r5 - r6 ) + m5;\n		} else {\n			mip = - 2.0 * log2( 1.16 * roughness );		}\n		return mip;\n	}\n	vec4 textureCubeUV( sampler2D envMap, vec3 sampleDir, float roughness ) {\n		float mip = clamp( roughnessToMip( roughness ), m0, cubeUV_maxMipLevel );\n		float mipF = fract( mip );\n		float mipInt = floor( mip );\n		vec3 color0 = bilinearCubeUV( envMap, sampleDir, mipInt );\n		if ( mipF == 0.0 ) {\n			return vec4( color0, 1.0 );\n		} else {\n			vec3 color1 = bilinearCubeUV( envMap, sampleDir, mipInt + 1.0 );\n			return vec4( mix( color0, color1, mipF ), 1.0 );\n		}\n	}\n#endif", defaultnormal_vertex: "vec3 transformedNormal = objectNormal;\n#ifdef USE_INSTANCING\n	mat3 m = mat3( instanceMatrix );\n	transformedNormal /= vec3( dot( m[ 0 ], m[ 0 ] ), dot( m[ 1 ], m[ 1 ] ), dot( m[ 2 ], m[ 2 ] ) );\n	transformedNormal = m * transformedNormal;\n#endif\ntransformedNormal = normalMatrix * transformedNormal;\n#ifdef FLIP_SIDED\n	transformedNormal = - transformedNormal;\n#endif\n#ifdef USE_TANGENT\n	vec3 transformedTangent = ( modelViewMatrix * vec4( objectTangent, 0.0 ) ).xyz;\n	#ifdef FLIP_SIDED\n		transformedTangent = - transformedTangent;\n	#endif\n#endif", displacementmap_pars_vertex: "#ifdef USE_DISPLACEMENTMAP\n	uniform sampler2D displacementMap;\n	uniform float displacementScale;\n	uniform float displacementBias;\n#endif", displacementmap_vertex: "#ifdef USE_DISPLACEMENTMAP\n	transformed += normalize( objectNormal ) * ( texture2D( displacementMap, vUv ).x * displacementScale + displacementBias );\n#endif", emissivemap_fragment: "#ifdef USE_EMISSIVEMAP\n	vec4 emissiveColor = texture2D( emissiveMap, vUv );\n	emissiveColor.rgb = emissiveMapTexelToLinear( emissiveColor ).rgb;\n	totalEmissiveRadiance *= emissiveColor.rgb;\n#endif", emissivemap_pars_fragment: "#ifdef USE_EMISSIVEMAP\n	uniform sampler2D emissiveMap;\n#endif", encodings_fragment: "gl_FragColor = linearToOutputTexel( gl_FragColor );", encodings_pars_fragment: "\nvec4 LinearToLinear( in vec4 value ) {\n	return value;\n}\nvec4 GammaToLinear( in vec4 value, in float gammaFactor ) {\n	return vec4( pow( value.rgb, vec3( gammaFactor ) ), value.a );\n}\nvec4 LinearToGamma( in vec4 value, in float gammaFactor ) {\n	return vec4( pow( value.rgb, vec3( 1.0 / gammaFactor ) ), value.a );\n}\nvec4 sRGBToLinear( in vec4 value ) {\n	return vec4( mix( pow( value.rgb * 0.9478672986 + vec3( 0.0521327014 ), vec3( 2.4 ) ), value.rgb * 0.0773993808, vec3( lessThanEqual( value.rgb, vec3( 0.04045 ) ) ) ), value.a );\n}\nvec4 LinearTosRGB( in vec4 value ) {\n	return vec4( mix( pow( value.rgb, vec3( 0.41666 ) ) * 1.055 - vec3( 0.055 ), value.rgb * 12.92, vec3( lessThanEqual( value.rgb, vec3( 0.0031308 ) ) ) ), value.a );\n}\nvec4 RGBEToLinear( in vec4 value ) {\n	return vec4( value.rgb * exp2( value.a * 255.0 - 128.0 ), 1.0 );\n}\nvec4 LinearToRGBE( in vec4 value ) {\n	float maxComponent = max( max( value.r, value.g ), value.b );\n	float fExp = clamp( ceil( log2( maxComponent ) ), -128.0, 127.0 );\n	return vec4( value.rgb / exp2( fExp ), ( fExp + 128.0 ) / 255.0 );\n}\nvec4 RGBMToLinear( in vec4 value, in float maxRange ) {\n	return vec4( value.rgb * value.a * maxRange, 1.0 );\n}\nvec4 LinearToRGBM( in vec4 value, in float maxRange ) {\n	float maxRGB = max( value.r, max( value.g, value.b ) );\n	float M = clamp( maxRGB / maxRange, 0.0, 1.0 );\n	M = ceil( M * 255.0 ) / 255.0;\n	return vec4( value.rgb / ( M * maxRange ), M );\n}\nvec4 RGBDToLinear( in vec4 value, in float maxRange ) {\n	return vec4( value.rgb * ( ( maxRange / 255.0 ) / value.a ), 1.0 );\n}\nvec4 LinearToRGBD( in vec4 value, in float maxRange ) {\n	float maxRGB = max( value.r, max( value.g, value.b ) );\n	float D = max( maxRange / maxRGB, 1.0 );\n	D = clamp( floor( D ) / 255.0, 0.0, 1.0 );\n	return vec4( value.rgb * ( D * ( 255.0 / maxRange ) ), D );\n}\nconst mat3 cLogLuvM = mat3( 0.2209, 0.3390, 0.4184, 0.1138, 0.6780, 0.7319, 0.0102, 0.1130, 0.2969 );\nvec4 LinearToLogLuv( in vec4 value ) {\n	vec3 Xp_Y_XYZp = cLogLuvM * value.rgb;\n	Xp_Y_XYZp = max( Xp_Y_XYZp, vec3( 1e-6, 1e-6, 1e-6 ) );\n	vec4 vResult;\n	vResult.xy = Xp_Y_XYZp.xy / Xp_Y_XYZp.z;\n	float Le = 2.0 * log2(Xp_Y_XYZp.y) + 127.0;\n	vResult.w = fract( Le );\n	vResult.z = ( Le - ( floor( vResult.w * 255.0 ) ) / 255.0 ) / 255.0;\n	return vResult;\n}\nconst mat3 cLogLuvInverseM = mat3( 6.0014, -2.7008, -1.7996, -1.3320, 3.1029, -5.7721, 0.3008, -1.0882, 5.6268 );\nvec4 LogLuvToLinear( in vec4 value ) {\n	float Le = value.z * 255.0 + value.w;\n	vec3 Xp_Y_XYZp;\n	Xp_Y_XYZp.y = exp2( ( Le - 127.0 ) / 2.0 );\n	Xp_Y_XYZp.z = Xp_Y_XYZp.y / value.y;\n	Xp_Y_XYZp.x = value.x * Xp_Y_XYZp.z;\n	vec3 vRGB = cLogLuvInverseM * Xp_Y_XYZp.rgb;\n	return vec4( max( vRGB, 0.0 ), 1.0 );\n}", envmap_fragment: "#ifdef USE_ENVMAP\n	#ifdef ENV_WORLDPOS\n		vec3 cameraToFrag;\n		if ( isOrthographic ) {\n			cameraToFrag = normalize( vec3( - viewMatrix[ 0 ][ 2 ], - viewMatrix[ 1 ][ 2 ], - viewMatrix[ 2 ][ 2 ] ) );\n		} else {\n			cameraToFrag = normalize( vWorldPosition - cameraPosition );\n		}\n		vec3 worldNormal = inverseTransformDirection( normal, viewMatrix );\n		#ifdef ENVMAP_MODE_REFLECTION\n			vec3 reflectVec = reflect( cameraToFrag, worldNormal );\n		#else\n			vec3 reflectVec = refract( cameraToFrag, worldNormal, refractionRatio );\n		#endif\n	#else\n		vec3 reflectVec = vReflect;\n	#endif\n	#ifdef ENVMAP_TYPE_CUBE\n		vec4 envColor = textureCube( envMap, vec3( flipEnvMap * reflectVec.x, reflectVec.yz ) );\n	#elif defined( ENVMAP_TYPE_CUBE_UV )\n		vec4 envColor = textureCubeUV( envMap, reflectVec, 0.0 );\n	#else\n		vec4 envColor = vec4( 0.0 );\n	#endif\n	#ifndef ENVMAP_TYPE_CUBE_UV\n		envColor = envMapTexelToLinear( envColor );\n	#endif\n	#ifdef ENVMAP_BLENDING_MULTIPLY\n		outgoingLight = mix( outgoingLight, outgoingLight * envColor.xyz, specularStrength * reflectivity );\n	#elif defined( ENVMAP_BLENDING_MIX )\n		outgoingLight = mix( outgoingLight, envColor.xyz, specularStrength * reflectivity );\n	#elif defined( ENVMAP_BLENDING_ADD )\n		outgoingLight += envColor.xyz * specularStrength * reflectivity;\n	#endif\n#endif", envmap_common_pars_fragment: "#ifdef USE_ENVMAP\n	uniform float envMapIntensity;\n	uniform float flipEnvMap;\n	uniform int maxMipLevel;\n	#ifdef ENVMAP_TYPE_CUBE\n		uniform samplerCube envMap;\n	#else\n		uniform sampler2D envMap;\n	#endif\n	\n#endif", envmap_pars_fragment: "#ifdef USE_ENVMAP\n	uniform float reflectivity;\n	#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG )\n		#define ENV_WORLDPOS\n	#endif\n	#ifdef ENV_WORLDPOS\n		varying vec3 vWorldPosition;\n		uniform float refractionRatio;\n	#else\n		varying vec3 vReflect;\n	#endif\n#endif", envmap_pars_vertex: "#ifdef USE_ENVMAP\n	#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) ||defined( PHONG )\n		#define ENV_WORLDPOS\n	#endif\n	#ifdef ENV_WORLDPOS\n		\n		varying vec3 vWorldPosition;\n	#else\n		varying vec3 vReflect;\n		uniform float refractionRatio;\n	#endif\n#endif", envmap_physical_pars_fragment: "#if defined( USE_ENVMAP )\n	#ifdef ENVMAP_MODE_REFRACTION\n		uniform float refractionRatio;\n	#endif\n	vec3 getLightProbeIndirectIrradiance( const in GeometricContext geometry, const in int maxMIPLevel ) {\n		vec3 worldNormal = inverseTransformDirection( geometry.normal, viewMatrix );\n		#ifdef ENVMAP_TYPE_CUBE\n			vec3 queryVec = vec3( flipEnvMap * worldNormal.x, worldNormal.yz );\n			#ifdef TEXTURE_LOD_EXT\n				vec4 envMapColor = textureCubeLodEXT( envMap, queryVec, float( maxMIPLevel ) );\n			#else\n				vec4 envMapColor = textureCube( envMap, queryVec, float( maxMIPLevel ) );\n			#endif\n			envMapColor.rgb = envMapTexelToLinear( envMapColor ).rgb;\n		#elif defined( ENVMAP_TYPE_CUBE_UV )\n			vec4 envMapColor = textureCubeUV( envMap, worldNormal, 1.0 );\n		#else\n			vec4 envMapColor = vec4( 0.0 );\n		#endif\n		return PI * envMapColor.rgb * envMapIntensity;\n	}\n	float getSpecularMIPLevel( const in float roughness, const in int maxMIPLevel ) {\n		float maxMIPLevelScalar = float( maxMIPLevel );\n		float sigma = PI * roughness * roughness / ( 1.0 + roughness );\n		float desiredMIPLevel = maxMIPLevelScalar + log2( sigma );\n		return clamp( desiredMIPLevel, 0.0, maxMIPLevelScalar );\n	}\n	vec3 getLightProbeIndirectRadiance( const in vec3 viewDir, const in vec3 normal, const in float roughness, const in int maxMIPLevel ) {\n		#ifdef ENVMAP_MODE_REFLECTION\n			vec3 reflectVec = reflect( -viewDir, normal );\n			reflectVec = normalize( mix( reflectVec, normal, roughness * roughness) );\n		#else\n			vec3 reflectVec = refract( -viewDir, normal, refractionRatio );\n		#endif\n		reflectVec = inverseTransformDirection( reflectVec, viewMatrix );\n		float specularMIPLevel = getSpecularMIPLevel( roughness, maxMIPLevel );\n		#ifdef ENVMAP_TYPE_CUBE\n			vec3 queryReflectVec = vec3( flipEnvMap * reflectVec.x, reflectVec.yz );\n			#ifdef TEXTURE_LOD_EXT\n				vec4 envMapColor = textureCubeLodEXT( envMap, queryReflectVec, specularMIPLevel );\n			#else\n				vec4 envMapColor = textureCube( envMap, queryReflectVec, specularMIPLevel );\n			#endif\n			envMapColor.rgb = envMapTexelToLinear( envMapColor ).rgb;\n		#elif defined( ENVMAP_TYPE_CUBE_UV )\n			vec4 envMapColor = textureCubeUV( envMap, reflectVec, roughness );\n		#endif\n		return envMapColor.rgb * envMapIntensity;\n	}\n#endif", envmap_vertex: "#ifdef USE_ENVMAP\n	#ifdef ENV_WORLDPOS\n		vWorldPosition = worldPosition.xyz;\n	#else\n		vec3 cameraToVertex;\n		if ( isOrthographic ) {\n			cameraToVertex = normalize( vec3( - viewMatrix[ 0 ][ 2 ], - viewMatrix[ 1 ][ 2 ], - viewMatrix[ 2 ][ 2 ] ) );\n		} else {\n			cameraToVertex = normalize( worldPosition.xyz - cameraPosition );\n		}\n		vec3 worldNormal = inverseTransformDirection( transformedNormal, viewMatrix );\n		#ifdef ENVMAP_MODE_REFLECTION\n			vReflect = reflect( cameraToVertex, worldNormal );\n		#else\n			vReflect = refract( cameraToVertex, worldNormal, refractionRatio );\n		#endif\n	#endif\n#endif", fog_vertex: "#ifdef USE_FOG\n	fogDepth = - mvPosition.z;\n#endif", fog_pars_vertex: "#ifdef USE_FOG\n	varying float fogDepth;\n#endif", fog_fragment: "#ifdef USE_FOG\n	#ifdef FOG_EXP2\n		float fogFactor = 1.0 - exp( - fogDensity * fogDensity * fogDepth * fogDepth );\n	#else\n		float fogFactor = smoothstep( fogNear, fogFar, fogDepth );\n	#endif\n	gl_FragColor.rgb = mix( gl_FragColor.rgb, fogColor, fogFactor );\n#endif", fog_pars_fragment: "#ifdef USE_FOG\n	uniform vec3 fogColor;\n	varying float fogDepth;\n	#ifdef FOG_EXP2\n		uniform float fogDensity;\n	#else\n		uniform float fogNear;\n		uniform float fogFar;\n	#endif\n#endif", gradientmap_pars_fragment: "#ifdef USE_GRADIENTMAP\n	uniform sampler2D gradientMap;\n#endif\nvec3 getGradientIrradiance( vec3 normal, vec3 lightDirection ) {\n	float dotNL = dot( normal, lightDirection );\n	vec2 coord = vec2( dotNL * 0.5 + 0.5, 0.0 );\n	#ifdef USE_GRADIENTMAP\n		return texture2D( gradientMap, coord ).rgb;\n	#else\n		return ( coord.x < 0.7 ) ? vec3( 0.7 ) : vec3( 1.0 );\n	#endif\n}", lightmap_fragment: "#ifdef USE_LIGHTMAP\n	vec4 lightMapTexel= texture2D( lightMap, vUv2 );\n	reflectedLight.indirectDiffuse += PI * lightMapTexelToLinear( lightMapTexel ).rgb * lightMapIntensity;\n#endif", lightmap_pars_fragment: "#ifdef USE_LIGHTMAP\n	uniform sampler2D lightMap;\n	uniform float lightMapIntensity;\n#endif", lights_lambert_vertex: "vec3 diffuse = vec3( 1.0 );\nGeometricContext geometry;\ngeometry.position = mvPosition.xyz;\ngeometry.normal = normalize( transformedNormal );\ngeometry.viewDir = ( isOrthographic ) ? vec3( 0, 0, 1 ) : normalize( -mvPosition.xyz );\nGeometricContext backGeometry;\nbackGeometry.position = geometry.position;\nbackGeometry.normal = -geometry.normal;\nbackGeometry.viewDir = geometry.viewDir;\nvLightFront = vec3( 0.0 );\nvIndirectFront = vec3( 0.0 );\n#ifdef DOUBLE_SIDED\n	vLightBack = vec3( 0.0 );\n	vIndirectBack = vec3( 0.0 );\n#endif\nIncidentLight directLight;\nfloat dotNL;\nvec3 directLightColor_Diffuse;\nvIndirectFront += getAmbientLightIrradiance( ambientLightColor );\nvIndirectFront += getLightProbeIrradiance( lightProbe, geometry );\n#ifdef DOUBLE_SIDED\n	vIndirectBack += getAmbientLightIrradiance( ambientLightColor );\n	vIndirectBack += getLightProbeIrradiance( lightProbe, backGeometry );\n#endif\n#if NUM_POINT_LIGHTS > 0\n	#pragma unroll_loop_start\n	for ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {\n		getPointDirectLightIrradiance( pointLights[ i ], geometry, directLight );\n		dotNL = dot( geometry.normal, directLight.direction );\n		directLightColor_Diffuse = PI * directLight.color;\n		vLightFront += saturate( dotNL ) * directLightColor_Diffuse;\n		#ifdef DOUBLE_SIDED\n			vLightBack += saturate( -dotNL ) * directLightColor_Diffuse;\n		#endif\n	}\n	#pragma unroll_loop_end\n#endif\n#if NUM_SPOT_LIGHTS > 0\n	#pragma unroll_loop_start\n	for ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {\n		getSpotDirectLightIrradiance( spotLights[ i ], geometry, directLight );\n		dotNL = dot( geometry.normal, directLight.direction );\n		directLightColor_Diffuse = PI * directLight.color;\n		vLightFront += saturate( dotNL ) * directLightColor_Diffuse;\n		#ifdef DOUBLE_SIDED\n			vLightBack += saturate( -dotNL ) * directLightColor_Diffuse;\n		#endif\n	}\n	#pragma unroll_loop_end\n#endif\n#if NUM_DIR_LIGHTS > 0\n	#pragma unroll_loop_start\n	for ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\n		getDirectionalDirectLightIrradiance( directionalLights[ i ], geometry, directLight );\n		dotNL = dot( geometry.normal, directLight.direction );\n		directLightColor_Diffuse = PI * directLight.color;\n		vLightFront += saturate( dotNL ) * directLightColor_Diffuse;\n		#ifdef DOUBLE_SIDED\n			vLightBack += saturate( -dotNL ) * directLightColor_Diffuse;\n		#endif\n	}\n	#pragma unroll_loop_end\n#endif\n#if NUM_HEMI_LIGHTS > 0\n	#pragma unroll_loop_start\n	for ( int i = 0; i < NUM_HEMI_LIGHTS; i ++ ) {\n		vIndirectFront += getHemisphereLightIrradiance( hemisphereLights[ i ], geometry );\n		#ifdef DOUBLE_SIDED\n			vIndirectBack += getHemisphereLightIrradiance( hemisphereLights[ i ], backGeometry );\n		#endif\n	}\n	#pragma unroll_loop_end\n#endif", lights_pars_begin: "uniform bool receiveShadow;\nuniform vec3 ambientLightColor;\nuniform vec3 lightProbe[ 9 ];\nvec3 shGetIrradianceAt( in vec3 normal, in vec3 shCoefficients[ 9 ] ) {\n	float x = normal.x, y = normal.y, z = normal.z;\n	vec3 result = shCoefficients[ 0 ] * 0.886227;\n	result += shCoefficients[ 1 ] * 2.0 * 0.511664 * y;\n	result += shCoefficients[ 2 ] * 2.0 * 0.511664 * z;\n	result += shCoefficients[ 3 ] * 2.0 * 0.511664 * x;\n	result += shCoefficients[ 4 ] * 2.0 * 0.429043 * x * y;\n	result += shCoefficients[ 5 ] * 2.0 * 0.429043 * y * z;\n	result += shCoefficients[ 6 ] * ( 0.743125 * z * z - 0.247708 );\n	result += shCoefficients[ 7 ] * 2.0 * 0.429043 * x * z;\n	result += shCoefficients[ 8 ] * 0.429043 * ( x * x - y * y );\n	return result;\n}\nvec3 getLightProbeIrradiance( const in vec3 lightProbe[ 9 ], const in GeometricContext geometry ) {\n	vec3 worldNormal = inverseTransformDirection( geometry.normal, viewMatrix );\n	vec3 irradiance = shGetIrradianceAt( worldNormal, lightProbe );\n	return irradiance;\n}\nvec3 getAmbientLightIrradiance( const in vec3 ambientLightColor ) {\n	vec3 irradiance = ambientLightColor;\n	#ifndef PHYSICALLY_CORRECT_LIGHTS\n		irradiance *= PI;\n	#endif\n	return irradiance;\n}\n#if NUM_DIR_LIGHTS > 0\n	struct DirectionalLight {\n		vec3 direction;\n		vec3 color;\n	};\n	uniform DirectionalLight directionalLights[ NUM_DIR_LIGHTS ];\n	void getDirectionalDirectLightIrradiance( const in DirectionalLight directionalLight, const in GeometricContext geometry, out IncidentLight directLight ) {\n		directLight.color = directionalLight.color;\n		directLight.direction = directionalLight.direction;\n		directLight.visible = true;\n	}\n#endif\n#if NUM_POINT_LIGHTS > 0\n	struct PointLight {\n		vec3 position;\n		vec3 color;\n		float distance;\n		float decay;\n	};\n	uniform PointLight pointLights[ NUM_POINT_LIGHTS ];\n	void getPointDirectLightIrradiance( const in PointLight pointLight, const in GeometricContext geometry, out IncidentLight directLight ) {\n		vec3 lVector = pointLight.position - geometry.position;\n		directLight.direction = normalize( lVector );\n		float lightDistance = length( lVector );\n		directLight.color = pointLight.color;\n		directLight.color *= punctualLightIntensityToIrradianceFactor( lightDistance, pointLight.distance, pointLight.decay );\n		directLight.visible = ( directLight.color != vec3( 0.0 ) );\n	}\n#endif\n#if NUM_SPOT_LIGHTS > 0\n	struct SpotLight {\n		vec3 position;\n		vec3 direction;\n		vec3 color;\n		float distance;\n		float decay;\n		float coneCos;\n		float penumbraCos;\n	};\n	uniform SpotLight spotLights[ NUM_SPOT_LIGHTS ];\n	void getSpotDirectLightIrradiance( const in SpotLight spotLight, const in GeometricContext geometry, out IncidentLight directLight ) {\n		vec3 lVector = spotLight.position - geometry.position;\n		directLight.direction = normalize( lVector );\n		float lightDistance = length( lVector );\n		float angleCos = dot( directLight.direction, spotLight.direction );\n		if ( angleCos > spotLight.coneCos ) {\n			float spotEffect = smoothstep( spotLight.coneCos, spotLight.penumbraCos, angleCos );\n			directLight.color = spotLight.color;\n			directLight.color *= spotEffect * punctualLightIntensityToIrradianceFactor( lightDistance, spotLight.distance, spotLight.decay );\n			directLight.visible = true;\n		} else {\n			directLight.color = vec3( 0.0 );\n			directLight.visible = false;\n		}\n	}\n#endif\n#if NUM_RECT_AREA_LIGHTS > 0\n	struct RectAreaLight {\n		vec3 color;\n		vec3 position;\n		vec3 halfWidth;\n		vec3 halfHeight;\n	};\n	uniform sampler2D ltc_1;	uniform sampler2D ltc_2;\n	uniform RectAreaLight rectAreaLights[ NUM_RECT_AREA_LIGHTS ];\n#endif\n#if NUM_HEMI_LIGHTS > 0\n	struct HemisphereLight {\n		vec3 direction;\n		vec3 skyColor;\n		vec3 groundColor;\n	};\n	uniform HemisphereLight hemisphereLights[ NUM_HEMI_LIGHTS ];\n	vec3 getHemisphereLightIrradiance( const in HemisphereLight hemiLight, const in GeometricContext geometry ) {\n		float dotNL = dot( geometry.normal, hemiLight.direction );\n		float hemiDiffuseWeight = 0.5 * dotNL + 0.5;\n		vec3 irradiance = mix( hemiLight.groundColor, hemiLight.skyColor, hemiDiffuseWeight );\n		#ifndef PHYSICALLY_CORRECT_LIGHTS\n			irradiance *= PI;\n		#endif\n		return irradiance;\n	}\n#endif", lights_toon_fragment: "ToonMaterial material;\nmaterial.diffuseColor = diffuseColor.rgb;", lights_toon_pars_fragment: "varying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n	varying vec3 vNormal;\n#endif\nstruct ToonMaterial {\n	vec3 diffuseColor;\n};\nvoid RE_Direct_Toon( const in IncidentLight directLight, const in GeometricContext geometry, const in ToonMaterial material, inout ReflectedLight reflectedLight ) {\n	vec3 irradiance = getGradientIrradiance( geometry.normal, directLight.direction ) * directLight.color;\n	#ifndef PHYSICALLY_CORRECT_LIGHTS\n		irradiance *= PI;\n	#endif\n	reflectedLight.directDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\n}\nvoid RE_IndirectDiffuse_Toon( const in vec3 irradiance, const in GeometricContext geometry, const in ToonMaterial material, inout ReflectedLight reflectedLight ) {\n	reflectedLight.indirectDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\n}\n#define RE_Direct				RE_Direct_Toon\n#define RE_IndirectDiffuse		RE_IndirectDiffuse_Toon\n#define Material_LightProbeLOD( material )	(0)", lights_phong_fragment: "BlinnPhongMaterial material;\nmaterial.diffuseColor = diffuseColor.rgb;\nmaterial.specularColor = specular;\nmaterial.specularShininess = shininess;\nmaterial.specularStrength = specularStrength;", lights_phong_pars_fragment: "varying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n	varying vec3 vNormal;\n#endif\nstruct BlinnPhongMaterial {\n	vec3 diffuseColor;\n	vec3 specularColor;\n	float specularShininess;\n	float specularStrength;\n};\nvoid RE_Direct_BlinnPhong( const in IncidentLight directLight, const in GeometricContext geometry, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {\n	float dotNL = saturate( dot( geometry.normal, directLight.direction ) );\n	vec3 irradiance = dotNL * directLight.color;\n	#ifndef PHYSICALLY_CORRECT_LIGHTS\n		irradiance *= PI;\n	#endif\n	reflectedLight.directDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\n	reflectedLight.directSpecular += irradiance * BRDF_Specular_BlinnPhong( directLight, geometry, material.specularColor, material.specularShininess ) * material.specularStrength;\n}\nvoid RE_IndirectDiffuse_BlinnPhong( const in vec3 irradiance, const in GeometricContext geometry, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {\n	reflectedLight.indirectDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\n}\n#define RE_Direct				RE_Direct_BlinnPhong\n#define RE_IndirectDiffuse		RE_IndirectDiffuse_BlinnPhong\n#define Material_LightProbeLOD( material )	(0)", lights_physical_fragment: "PhysicalMaterial material;\nmaterial.diffuseColor = diffuseColor.rgb * ( 1.0 - metalnessFactor );\nvec3 dxy = max( abs( dFdx( geometryNormal ) ), abs( dFdy( geometryNormal ) ) );\nfloat geometryRoughness = max( max( dxy.x, dxy.y ), dxy.z );\nmaterial.specularRoughness = max( roughnessFactor, 0.0525 );material.specularRoughness += geometryRoughness;\nmaterial.specularRoughness = min( material.specularRoughness, 1.0 );\n#ifdef REFLECTIVITY\n	material.specularColor = mix( vec3( MAXIMUM_SPECULAR_COEFFICIENT * pow2( reflectivity ) ), diffuseColor.rgb, metalnessFactor );\n#else\n	material.specularColor = mix( vec3( DEFAULT_SPECULAR_COEFFICIENT ), diffuseColor.rgb, metalnessFactor );\n#endif\n#ifdef CLEARCOAT\n	material.clearcoat = clearcoat;\n	material.clearcoatRoughness = clearcoatRoughness;\n	#ifdef USE_CLEARCOATMAP\n		material.clearcoat *= texture2D( clearcoatMap, vUv ).x;\n	#endif\n	#ifdef USE_CLEARCOAT_ROUGHNESSMAP\n		material.clearcoatRoughness *= texture2D( clearcoatRoughnessMap, vUv ).y;\n	#endif\n	material.clearcoat = saturate( material.clearcoat );	material.clearcoatRoughness = max( material.clearcoatRoughness, 0.0525 );\n	material.clearcoatRoughness += geometryRoughness;\n	material.clearcoatRoughness = min( material.clearcoatRoughness, 1.0 );\n#endif\n#ifdef USE_SHEEN\n	material.sheenColor = sheen;\n#endif", lights_physical_pars_fragment: "struct PhysicalMaterial {\n	vec3 diffuseColor;\n	float specularRoughness;\n	vec3 specularColor;\n#ifdef CLEARCOAT\n	float clearcoat;\n	float clearcoatRoughness;\n#endif\n#ifdef USE_SHEEN\n	vec3 sheenColor;\n#endif\n};\n#define MAXIMUM_SPECULAR_COEFFICIENT 0.16\n#define DEFAULT_SPECULAR_COEFFICIENT 0.04\nfloat clearcoatDHRApprox( const in float roughness, const in float dotNL ) {\n	return DEFAULT_SPECULAR_COEFFICIENT + ( 1.0 - DEFAULT_SPECULAR_COEFFICIENT ) * ( pow( 1.0 - dotNL, 5.0 ) * pow( 1.0 - roughness, 2.0 ) );\n}\n#if NUM_RECT_AREA_LIGHTS > 0\n	void RE_Direct_RectArea_Physical( const in RectAreaLight rectAreaLight, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n		vec3 normal = geometry.normal;\n		vec3 viewDir = geometry.viewDir;\n		vec3 position = geometry.position;\n		vec3 lightPos = rectAreaLight.position;\n		vec3 halfWidth = rectAreaLight.halfWidth;\n		vec3 halfHeight = rectAreaLight.halfHeight;\n		vec3 lightColor = rectAreaLight.color;\n		float roughness = material.specularRoughness;\n		vec3 rectCoords[ 4 ];\n		rectCoords[ 0 ] = lightPos + halfWidth - halfHeight;		rectCoords[ 1 ] = lightPos - halfWidth - halfHeight;\n		rectCoords[ 2 ] = lightPos - halfWidth + halfHeight;\n		rectCoords[ 3 ] = lightPos + halfWidth + halfHeight;\n		vec2 uv = LTC_Uv( normal, viewDir, roughness );\n		vec4 t1 = texture2D( ltc_1, uv );\n		vec4 t2 = texture2D( ltc_2, uv );\n		mat3 mInv = mat3(\n			vec3( t1.x, 0, t1.y ),\n			vec3(    0, 1,    0 ),\n			vec3( t1.z, 0, t1.w )\n		);\n		vec3 fresnel = ( material.specularColor * t2.x + ( vec3( 1.0 ) - material.specularColor ) * t2.y );\n		reflectedLight.directSpecular += lightColor * fresnel * LTC_Evaluate( normal, viewDir, position, mInv, rectCoords );\n		reflectedLight.directDiffuse += lightColor * material.diffuseColor * LTC_Evaluate( normal, viewDir, position, mat3( 1.0 ), rectCoords );\n	}\n#endif\nvoid RE_Direct_Physical( const in IncidentLight directLight, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n	float dotNL = saturate( dot( geometry.normal, directLight.direction ) );\n	vec3 irradiance = dotNL * directLight.color;\n	#ifndef PHYSICALLY_CORRECT_LIGHTS\n		irradiance *= PI;\n	#endif\n	#ifdef CLEARCOAT\n		float ccDotNL = saturate( dot( geometry.clearcoatNormal, directLight.direction ) );\n		vec3 ccIrradiance = ccDotNL * directLight.color;\n		#ifndef PHYSICALLY_CORRECT_LIGHTS\n			ccIrradiance *= PI;\n		#endif\n		float clearcoatDHR = material.clearcoat * clearcoatDHRApprox( material.clearcoatRoughness, ccDotNL );\n		reflectedLight.directSpecular += ccIrradiance * material.clearcoat * BRDF_Specular_GGX( directLight, geometry.viewDir, geometry.clearcoatNormal, vec3( DEFAULT_SPECULAR_COEFFICIENT ), material.clearcoatRoughness );\n	#else\n		float clearcoatDHR = 0.0;\n	#endif\n	#ifdef USE_SHEEN\n		reflectedLight.directSpecular += ( 1.0 - clearcoatDHR ) * irradiance * BRDF_Specular_Sheen(\n			material.specularRoughness,\n			directLight.direction,\n			geometry,\n			material.sheenColor\n		);\n	#else\n		reflectedLight.directSpecular += ( 1.0 - clearcoatDHR ) * irradiance * BRDF_Specular_GGX( directLight, geometry.viewDir, geometry.normal, material.specularColor, material.specularRoughness);\n	#endif\n	reflectedLight.directDiffuse += ( 1.0 - clearcoatDHR ) * irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\n}\nvoid RE_IndirectDiffuse_Physical( const in vec3 irradiance, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n	reflectedLight.indirectDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\n}\nvoid RE_IndirectSpecular_Physical( const in vec3 radiance, const in vec3 irradiance, const in vec3 clearcoatRadiance, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight) {\n	#ifdef CLEARCOAT\n		float ccDotNV = saturate( dot( geometry.clearcoatNormal, geometry.viewDir ) );\n		reflectedLight.indirectSpecular += clearcoatRadiance * material.clearcoat * BRDF_Specular_GGX_Environment( geometry.viewDir, geometry.clearcoatNormal, vec3( DEFAULT_SPECULAR_COEFFICIENT ), material.clearcoatRoughness );\n		float ccDotNL = ccDotNV;\n		float clearcoatDHR = material.clearcoat * clearcoatDHRApprox( material.clearcoatRoughness, ccDotNL );\n	#else\n		float clearcoatDHR = 0.0;\n	#endif\n	float clearcoatInv = 1.0 - clearcoatDHR;\n	vec3 singleScattering = vec3( 0.0 );\n	vec3 multiScattering = vec3( 0.0 );\n	vec3 cosineWeightedIrradiance = irradiance * RECIPROCAL_PI;\n	BRDF_Specular_Multiscattering_Environment( geometry, material.specularColor, material.specularRoughness, singleScattering, multiScattering );\n	vec3 diffuse = material.diffuseColor * ( 1.0 - ( singleScattering + multiScattering ) );\n	reflectedLight.indirectSpecular += clearcoatInv * radiance * singleScattering;\n	reflectedLight.indirectSpecular += multiScattering * cosineWeightedIrradiance;\n	reflectedLight.indirectDiffuse += diffuse * cosineWeightedIrradiance;\n}\n#define RE_Direct				RE_Direct_Physical\n#define RE_Direct_RectArea		RE_Direct_RectArea_Physical\n#define RE_IndirectDiffuse		RE_IndirectDiffuse_Physical\n#define RE_IndirectSpecular		RE_IndirectSpecular_Physical\nfloat computeSpecularOcclusion( const in float dotNV, const in float ambientOcclusion, const in float roughness ) {\n	return saturate( pow( dotNV + ambientOcclusion, exp2( - 16.0 * roughness - 1.0 ) ) - 1.0 + ambientOcclusion );\n}", lights_fragment_begin: "\nGeometricContext geometry;\ngeometry.position = - vViewPosition;\ngeometry.normal = normal;\ngeometry.viewDir = ( isOrthographic ) ? vec3( 0, 0, 1 ) : normalize( vViewPosition );\n#ifdef CLEARCOAT\n	geometry.clearcoatNormal = clearcoatNormal;\n#endif\nIncidentLight directLight;\n#if ( NUM_POINT_LIGHTS > 0 ) && defined( RE_Direct )\n	PointLight pointLight;\n	#if defined( USE_SHADOWMAP ) && NUM_POINT_LIGHT_SHADOWS > 0\n	PointLightShadow pointLightShadow;\n	#endif\n	#pragma unroll_loop_start\n	for ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {\n		pointLight = pointLights[ i ];\n		getPointDirectLightIrradiance( pointLight, geometry, directLight );\n		#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_POINT_LIGHT_SHADOWS )\n		pointLightShadow = pointLightShadows[ i ];\n		directLight.color *= all( bvec2( directLight.visible, receiveShadow ) ) ? getPointShadow( pointShadowMap[ i ], pointLightShadow.shadowMapSize, pointLightShadow.shadowBias, pointLightShadow.shadowRadius, vPointShadowCoord[ i ], pointLightShadow.shadowCameraNear, pointLightShadow.shadowCameraFar ) : 1.0;\n		#endif\n		RE_Direct( directLight, geometry, material, reflectedLight );\n	}\n	#pragma unroll_loop_end\n#endif\n#if ( NUM_SPOT_LIGHTS > 0 ) && defined( RE_Direct )\n	SpotLight spotLight;\n	#if defined( USE_SHADOWMAP ) && NUM_SPOT_LIGHT_SHADOWS > 0\n	SpotLightShadow spotLightShadow;\n	#endif\n	#pragma unroll_loop_start\n	for ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {\n		spotLight = spotLights[ i ];\n		getSpotDirectLightIrradiance( spotLight, geometry, directLight );\n		#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS )\n		spotLightShadow = spotLightShadows[ i ];\n		directLight.color *= all( bvec2( directLight.visible, receiveShadow ) ) ? getShadow( spotShadowMap[ i ], spotLightShadow.shadowMapSize, spotLightShadow.shadowBias, spotLightShadow.shadowRadius, vSpotShadowCoord[ i ] ) : 1.0;\n		#endif\n		RE_Direct( directLight, geometry, material, reflectedLight );\n	}\n	#pragma unroll_loop_end\n#endif\n#if ( NUM_DIR_LIGHTS > 0 ) && defined( RE_Direct )\n	DirectionalLight directionalLight;\n	#if defined( USE_SHADOWMAP ) && NUM_DIR_LIGHT_SHADOWS > 0\n	DirectionalLightShadow directionalLightShadow;\n	#endif\n	#pragma unroll_loop_start\n	for ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\n		directionalLight = directionalLights[ i ];\n		getDirectionalDirectLightIrradiance( directionalLight, geometry, directLight );\n		#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_DIR_LIGHT_SHADOWS )\n		directionalLightShadow = directionalLightShadows[ i ];\n		directLight.color *= all( bvec2( directLight.visible, receiveShadow ) ) ? getShadow( directionalShadowMap[ i ], directionalLightShadow.shadowMapSize, directionalLightShadow.shadowBias, directionalLightShadow.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;\n		#endif\n		RE_Direct( directLight, geometry, material, reflectedLight );\n	}\n	#pragma unroll_loop_end\n#endif\n#if ( NUM_RECT_AREA_LIGHTS > 0 ) && defined( RE_Direct_RectArea )\n	RectAreaLight rectAreaLight;\n	#pragma unroll_loop_start\n	for ( int i = 0; i < NUM_RECT_AREA_LIGHTS; i ++ ) {\n		rectAreaLight = rectAreaLights[ i ];\n		RE_Direct_RectArea( rectAreaLight, geometry, material, reflectedLight );\n	}\n	#pragma unroll_loop_end\n#endif\n#if defined( RE_IndirectDiffuse )\n	vec3 iblIrradiance = vec3( 0.0 );\n	vec3 irradiance = getAmbientLightIrradiance( ambientLightColor );\n	irradiance += getLightProbeIrradiance( lightProbe, geometry );\n	#if ( NUM_HEMI_LIGHTS > 0 )\n		#pragma unroll_loop_start\n		for ( int i = 0; i < NUM_HEMI_LIGHTS; i ++ ) {\n			irradiance += getHemisphereLightIrradiance( hemisphereLights[ i ], geometry );\n		}\n		#pragma unroll_loop_end\n	#endif\n#endif\n#if defined( RE_IndirectSpecular )\n	vec3 radiance = vec3( 0.0 );\n	vec3 clearcoatRadiance = vec3( 0.0 );\n#endif", lights_fragment_maps: "#if defined( RE_IndirectDiffuse )\n	#ifdef USE_LIGHTMAP\n		vec4 lightMapTexel= texture2D( lightMap, vUv2 );\n		vec3 lightMapIrradiance = lightMapTexelToLinear( lightMapTexel ).rgb * lightMapIntensity;\n		#ifndef PHYSICALLY_CORRECT_LIGHTS\n			lightMapIrradiance *= PI;\n		#endif\n		irradiance += lightMapIrradiance;\n	#endif\n	#if defined( USE_ENVMAP ) && defined( STANDARD ) && defined( ENVMAP_TYPE_CUBE_UV )\n		iblIrradiance += getLightProbeIndirectIrradiance( geometry, maxMipLevel );\n	#endif\n#endif\n#if defined( USE_ENVMAP ) && defined( RE_IndirectSpecular )\n	radiance += getLightProbeIndirectRadiance( geometry.viewDir, geometry.normal, material.specularRoughness, maxMipLevel );\n	#ifdef CLEARCOAT\n		clearcoatRadiance += getLightProbeIndirectRadiance( geometry.viewDir, geometry.clearcoatNormal, material.clearcoatRoughness, maxMipLevel );\n	#endif\n#endif", lights_fragment_end: "#if defined( RE_IndirectDiffuse )\n	RE_IndirectDiffuse( irradiance, geometry, material, reflectedLight );\n#endif\n#if defined( RE_IndirectSpecular )\n	RE_IndirectSpecular( radiance, iblIrradiance, clearcoatRadiance, geometry, material, reflectedLight );\n#endif", logdepthbuf_fragment: "#if defined( USE_LOGDEPTHBUF ) && defined( USE_LOGDEPTHBUF_EXT )\n	gl_FragDepthEXT = vIsPerspective == 0.0 ? gl_FragCoord.z : log2( vFragDepth ) * logDepthBufFC * 0.5;\n#endif", logdepthbuf_pars_fragment: "#if defined( USE_LOGDEPTHBUF ) && defined( USE_LOGDEPTHBUF_EXT )\n	uniform float logDepthBufFC;\n	varying float vFragDepth;\n	varying float vIsPerspective;\n#endif", logdepthbuf_pars_vertex: "#ifdef USE_LOGDEPTHBUF\n	#ifdef USE_LOGDEPTHBUF_EXT\n		varying float vFragDepth;\n		varying float vIsPerspective;\n	#else\n		uniform float logDepthBufFC;\n	#endif\n#endif", logdepthbuf_vertex: "#ifdef USE_LOGDEPTHBUF\n	#ifdef USE_LOGDEPTHBUF_EXT\n		vFragDepth = 1.0 + gl_Position.w;\n		vIsPerspective = float( isPerspectiveMatrix( projectionMatrix ) );\n	#else\n		if ( isPerspectiveMatrix( projectionMatrix ) ) {\n			gl_Position.z = log2( max( EPSILON, gl_Position.w + 1.0 ) ) * logDepthBufFC - 1.0;\n			gl_Position.z *= gl_Position.w;\n		}\n	#endif\n#endif", map_fragment: "#ifdef USE_MAP\n	vec4 texelColor = texture2D( map, vUv );\n	texelColor = mapTexelToLinear( texelColor );\n	diffuseColor *= texelColor;\n#endif", map_pars_fragment: "#ifdef USE_MAP\n	uniform sampler2D map;\n#endif", map_particle_fragment: "#if defined( USE_MAP ) || defined( USE_ALPHAMAP )\n	vec2 uv = ( uvTransform * vec3( gl_PointCoord.x, 1.0 - gl_PointCoord.y, 1 ) ).xy;\n#endif\n#ifdef USE_MAP\n	vec4 mapTexel = texture2D( map, uv );\n	diffuseColor *= mapTexelToLinear( mapTexel );\n#endif\n#ifdef USE_ALPHAMAP\n	diffuseColor.a *= texture2D( alphaMap, uv ).g;\n#endif", map_particle_pars_fragment: "#if defined( USE_MAP ) || defined( USE_ALPHAMAP )\n	uniform mat3 uvTransform;\n#endif\n#ifdef USE_MAP\n	uniform sampler2D map;\n#endif\n#ifdef USE_ALPHAMAP\n	uniform sampler2D alphaMap;\n#endif", metalnessmap_fragment: "float metalnessFactor = metalness;\n#ifdef USE_METALNESSMAP\n	vec4 texelMetalness = texture2D( metalnessMap, vUv );\n	metalnessFactor *= texelMetalness.b;\n#endif", metalnessmap_pars_fragment: "#ifdef USE_METALNESSMAP\n	uniform sampler2D metalnessMap;\n#endif", morphnormal_vertex: "#ifdef USE_MORPHNORMALS\n	objectNormal *= morphTargetBaseInfluence;\n	objectNormal += morphNormal0 * morphTargetInfluences[ 0 ];\n	objectNormal += morphNormal1 * morphTargetInfluences[ 1 ];\n	objectNormal += morphNormal2 * morphTargetInfluences[ 2 ];\n	objectNormal += morphNormal3 * morphTargetInfluences[ 3 ];\n#endif", morphtarget_pars_vertex: "#ifdef USE_MORPHTARGETS\n	uniform float morphTargetBaseInfluence;\n	#ifndef USE_MORPHNORMALS\n		uniform float morphTargetInfluences[ 8 ];\n	#else\n		uniform float morphTargetInfluences[ 4 ];\n	#endif\n#endif", morphtarget_vertex: "#ifdef USE_MORPHTARGETS\n	transformed *= morphTargetBaseInfluence;\n	transformed += morphTarget0 * morphTargetInfluences[ 0 ];\n	transformed += morphTarget1 * morphTargetInfluences[ 1 ];\n	transformed += morphTarget2 * morphTargetInfluences[ 2 ];\n	transformed += morphTarget3 * morphTargetInfluences[ 3 ];\n	#ifndef USE_MORPHNORMALS\n		transformed += morphTarget4 * morphTargetInfluences[ 4 ];\n		transformed += morphTarget5 * morphTargetInfluences[ 5 ];\n		transformed += morphTarget6 * morphTargetInfluences[ 6 ];\n		transformed += morphTarget7 * morphTargetInfluences[ 7 ];\n	#endif\n#endif", normal_fragment_begin: "#ifdef FLAT_SHADED\n	vec3 fdx = vec3( dFdx( vViewPosition.x ), dFdx( vViewPosition.y ), dFdx( vViewPosition.z ) );\n	vec3 fdy = vec3( dFdy( vViewPosition.x ), dFdy( vViewPosition.y ), dFdy( vViewPosition.z ) );\n	vec3 normal = normalize( cross( fdx, fdy ) );\n#else\n	vec3 normal = normalize( vNormal );\n	#ifdef DOUBLE_SIDED\n		normal = normal * ( float( gl_FrontFacing ) * 2.0 - 1.0 );\n	#endif\n	#ifdef USE_TANGENT\n		vec3 tangent = normalize( vTangent );\n		vec3 bitangent = normalize( vBitangent );\n		#ifdef DOUBLE_SIDED\n			tangent = tangent * ( float( gl_FrontFacing ) * 2.0 - 1.0 );\n			bitangent = bitangent * ( float( gl_FrontFacing ) * 2.0 - 1.0 );\n		#endif\n		#if defined( TANGENTSPACE_NORMALMAP ) || defined( USE_CLEARCOAT_NORMALMAP )\n			mat3 vTBN = mat3( tangent, bitangent, normal );\n		#endif\n	#endif\n#endif\nvec3 geometryNormal = normal;", normal_fragment_maps: "#ifdef OBJECTSPACE_NORMALMAP\n	normal = texture2D( normalMap, vUv ).xyz * 2.0 - 1.0;\n	#ifdef FLIP_SIDED\n		normal = - normal;\n	#endif\n	#ifdef DOUBLE_SIDED\n		normal = normal * ( float( gl_FrontFacing ) * 2.0 - 1.0 );\n	#endif\n	normal = normalize( normalMatrix * normal );\n#elif defined( TANGENTSPACE_NORMALMAP )\n	vec3 mapN = texture2D( normalMap, vUv ).xyz * 2.0 - 1.0;\n	mapN.xy *= normalScale;\n	#ifdef USE_TANGENT\n		normal = normalize( vTBN * mapN );\n	#else\n		normal = perturbNormal2Arb( -vViewPosition, normal, mapN );\n	#endif\n#elif defined( USE_BUMPMAP )\n	normal = perturbNormalArb( -vViewPosition, normal, dHdxy_fwd() );\n#endif", normalmap_pars_fragment: "#ifdef USE_NORMALMAP\n	uniform sampler2D normalMap;\n	uniform vec2 normalScale;\n#endif\n#ifdef OBJECTSPACE_NORMALMAP\n	uniform mat3 normalMatrix;\n#endif\n#if ! defined ( USE_TANGENT ) && ( defined ( TANGENTSPACE_NORMALMAP ) || defined ( USE_CLEARCOAT_NORMALMAP ) )\n	vec3 perturbNormal2Arb( vec3 eye_pos, vec3 surf_norm, vec3 mapN ) {\n		vec3 q0 = vec3( dFdx( eye_pos.x ), dFdx( eye_pos.y ), dFdx( eye_pos.z ) );\n		vec3 q1 = vec3( dFdy( eye_pos.x ), dFdy( eye_pos.y ), dFdy( eye_pos.z ) );\n		vec2 st0 = dFdx( vUv.st );\n		vec2 st1 = dFdy( vUv.st );\n		float scale = sign( st1.t * st0.s - st0.t * st1.s );\n		vec3 S = normalize( ( q0 * st1.t - q1 * st0.t ) * scale );\n		vec3 T = normalize( ( - q0 * st1.s + q1 * st0.s ) * scale );\n		vec3 N = normalize( surf_norm );\n		mat3 tsn = mat3( S, T, N );\n		mapN.xy *= ( float( gl_FrontFacing ) * 2.0 - 1.0 );\n		return normalize( tsn * mapN );\n	}\n#endif", clearcoat_normal_fragment_begin: "#ifdef CLEARCOAT\n	vec3 clearcoatNormal = geometryNormal;\n#endif", clearcoat_normal_fragment_maps: "#ifdef USE_CLEARCOAT_NORMALMAP\n	vec3 clearcoatMapN = texture2D( clearcoatNormalMap, vUv ).xyz * 2.0 - 1.0;\n	clearcoatMapN.xy *= clearcoatNormalScale;\n	#ifdef USE_TANGENT\n		clearcoatNormal = normalize( vTBN * clearcoatMapN );\n	#else\n		clearcoatNormal = perturbNormal2Arb( - vViewPosition, clearcoatNormal, clearcoatMapN );\n	#endif\n#endif", clearcoat_pars_fragment: "#ifdef USE_CLEARCOATMAP\n	uniform sampler2D clearcoatMap;\n#endif\n#ifdef USE_CLEARCOAT_ROUGHNESSMAP\n	uniform sampler2D clearcoatRoughnessMap;\n#endif\n#ifdef USE_CLEARCOAT_NORMALMAP\n	uniform sampler2D clearcoatNormalMap;\n	uniform vec2 clearcoatNormalScale;\n#endif", packing: "vec3 packNormalToRGB( const in vec3 normal ) {\n	return normalize( normal ) * 0.5 + 0.5;\n}\nvec3 unpackRGBToNormal( const in vec3 rgb ) {\n	return 2.0 * rgb.xyz - 1.0;\n}\nconst float PackUpscale = 256. / 255.;const float UnpackDownscale = 255. / 256.;\nconst vec3 PackFactors = vec3( 256. * 256. * 256., 256. * 256., 256. );\nconst vec4 UnpackFactors = UnpackDownscale / vec4( PackFactors, 1. );\nconst float ShiftRight8 = 1. / 256.;\nvec4 packDepthToRGBA( const in float v ) {\n	vec4 r = vec4( fract( v * PackFactors ), v );\n	r.yzw -= r.xyz * ShiftRight8;	return r * PackUpscale;\n}\nfloat unpackRGBAToDepth( const in vec4 v ) {\n	return dot( v, UnpackFactors );\n}\nvec4 pack2HalfToRGBA( vec2 v ) {\n	vec4 r = vec4( v.x, fract( v.x * 255.0 ), v.y, fract( v.y * 255.0 ));\n	return vec4( r.x - r.y / 255.0, r.y, r.z - r.w / 255.0, r.w);\n}\nvec2 unpackRGBATo2Half( vec4 v ) {\n	return vec2( v.x + ( v.y / 255.0 ), v.z + ( v.w / 255.0 ) );\n}\nfloat viewZToOrthographicDepth( const in float viewZ, const in float near, const in float far ) {\n	return ( viewZ + near ) / ( near - far );\n}\nfloat orthographicDepthToViewZ( const in float linearClipZ, const in float near, const in float far ) {\n	return linearClipZ * ( near - far ) - near;\n}\nfloat viewZToPerspectiveDepth( const in float viewZ, const in float near, const in float far ) {\n	return (( near + viewZ ) * far ) / (( far - near ) * viewZ );\n}\nfloat perspectiveDepthToViewZ( const in float invClipZ, const in float near, const in float far ) {\n	return ( near * far ) / ( ( far - near ) * invClipZ - far );\n}", premultiplied_alpha_fragment: "#ifdef PREMULTIPLIED_ALPHA\n	gl_FragColor.rgb *= gl_FragColor.a;\n#endif", project_vertex: "vec4 mvPosition = vec4( transformed, 1.0 );\n#ifdef USE_INSTANCING\n	mvPosition = instanceMatrix * mvPosition;\n#endif\nmvPosition = modelViewMatrix * mvPosition;\ngl_Position = projectionMatrix * mvPosition;", dithering_fragment: "#ifdef DITHERING\n	gl_FragColor.rgb = dithering( gl_FragColor.rgb );\n#endif", dithering_pars_fragment: "#ifdef DITHERING\n	vec3 dithering( vec3 color ) {\n		float grid_position = rand( gl_FragCoord.xy );\n		vec3 dither_shift_RGB = vec3( 0.25 / 255.0, -0.25 / 255.0, 0.25 / 255.0 );\n		dither_shift_RGB = mix( 2.0 * dither_shift_RGB, -2.0 * dither_shift_RGB, grid_position );\n		return color + dither_shift_RGB;\n	}\n#endif", roughnessmap_fragment: "float roughnessFactor = roughness;\n#ifdef USE_ROUGHNESSMAP\n	vec4 texelRoughness = texture2D( roughnessMap, vUv );\n	roughnessFactor *= texelRoughness.g;\n#endif", roughnessmap_pars_fragment: "#ifdef USE_ROUGHNESSMAP\n	uniform sampler2D roughnessMap;\n#endif", shadowmap_pars_fragment: "#ifdef USE_SHADOWMAP\n	#if NUM_DIR_LIGHT_SHADOWS > 0\n		uniform sampler2D directionalShadowMap[ NUM_DIR_LIGHT_SHADOWS ];\n		varying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHT_SHADOWS ];\n		struct DirectionalLightShadow {\n			float shadowBias;\n			float shadowNormalBias;\n			float shadowRadius;\n			vec2 shadowMapSize;\n		};\n		uniform DirectionalLightShadow directionalLightShadows[ NUM_DIR_LIGHT_SHADOWS ];\n	#endif\n	#if NUM_SPOT_LIGHT_SHADOWS > 0\n		uniform sampler2D spotShadowMap[ NUM_SPOT_LIGHT_SHADOWS ];\n		varying vec4 vSpotShadowCoord[ NUM_SPOT_LIGHT_SHADOWS ];\n		struct SpotLightShadow {\n			float shadowBias;\n			float shadowNormalBias;\n			float shadowRadius;\n			vec2 shadowMapSize;\n		};\n		uniform SpotLightShadow spotLightShadows[ NUM_SPOT_LIGHT_SHADOWS ];\n	#endif\n	#if NUM_POINT_LIGHT_SHADOWS > 0\n		uniform sampler2D pointShadowMap[ NUM_POINT_LIGHT_SHADOWS ];\n		varying vec4 vPointShadowCoord[ NUM_POINT_LIGHT_SHADOWS ];\n		struct PointLightShadow {\n			float shadowBias;\n			float shadowNormalBias;\n			float shadowRadius;\n			vec2 shadowMapSize;\n			float shadowCameraNear;\n			float shadowCameraFar;\n		};\n		uniform PointLightShadow pointLightShadows[ NUM_POINT_LIGHT_SHADOWS ];\n	#endif\n	float texture2DCompare( sampler2D depths, vec2 uv, float compare ) {\n		return step( compare, unpackRGBAToDepth( texture2D( depths, uv ) ) );\n	}\n	vec2 texture2DDistribution( sampler2D shadow, vec2 uv ) {\n		return unpackRGBATo2Half( texture2D( shadow, uv ) );\n	}\n	float VSMShadow (sampler2D shadow, vec2 uv, float compare ){\n		float occlusion = 1.0;\n		vec2 distribution = texture2DDistribution( shadow, uv );\n		float hard_shadow = step( compare , distribution.x );\n		if (hard_shadow != 1.0 ) {\n			float distance = compare - distribution.x ;\n			float variance = max( 0.00000, distribution.y * distribution.y );\n			float softness_probability = variance / (variance + distance * distance );			softness_probability = clamp( ( softness_probability - 0.3 ) / ( 0.95 - 0.3 ), 0.0, 1.0 );			occlusion = clamp( max( hard_shadow, softness_probability ), 0.0, 1.0 );\n		}\n		return occlusion;\n	}\n	float getShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord ) {\n		float shadow = 1.0;\n		shadowCoord.xyz /= shadowCoord.w;\n		shadowCoord.z += shadowBias;\n		bvec4 inFrustumVec = bvec4 ( shadowCoord.x >= 0.0, shadowCoord.x <= 1.0, shadowCoord.y >= 0.0, shadowCoord.y <= 1.0 );\n		bool inFrustum = all( inFrustumVec );\n		bvec2 frustumTestVec = bvec2( inFrustum, shadowCoord.z <= 1.0 );\n		bool frustumTest = all( frustumTestVec );\n		if ( frustumTest ) {\n		#if defined( SHADOWMAP_TYPE_PCF )\n			vec2 texelSize = vec2( 1.0 ) / shadowMapSize;\n			float dx0 = - texelSize.x * shadowRadius;\n			float dy0 = - texelSize.y * shadowRadius;\n			float dx1 = + texelSize.x * shadowRadius;\n			float dy1 = + texelSize.y * shadowRadius;\n			float dx2 = dx0 / 2.0;\n			float dy2 = dy0 / 2.0;\n			float dx3 = dx1 / 2.0;\n			float dy3 = dy1 / 2.0;\n			shadow = (\n				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy0 ), shadowCoord.z ) +\n				texture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy0 ), shadowCoord.z ) +\n				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy0 ), shadowCoord.z ) +\n				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, dy2 ), shadowCoord.z ) +\n				texture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy2 ), shadowCoord.z ) +\n				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, dy2 ), shadowCoord.z ) +\n				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, 0.0 ), shadowCoord.z ) +\n				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, 0.0 ), shadowCoord.z ) +\n				texture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z ) +\n				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, 0.0 ), shadowCoord.z ) +\n				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, 0.0 ), shadowCoord.z ) +\n				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, dy3 ), shadowCoord.z ) +\n				texture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy3 ), shadowCoord.z ) +\n				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, dy3 ), shadowCoord.z ) +\n				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy1 ), shadowCoord.z ) +\n				texture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy1 ), shadowCoord.z ) +\n				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy1 ), shadowCoord.z )\n			) * ( 1.0 / 17.0 );\n		#elif defined( SHADOWMAP_TYPE_PCF_SOFT )\n			vec2 texelSize = vec2( 1.0 ) / shadowMapSize;\n			float dx = texelSize.x;\n			float dy = texelSize.y;\n			vec2 uv = shadowCoord.xy;\n			vec2 f = fract( uv * shadowMapSize + 0.5 );\n			uv -= f * texelSize;\n			shadow = (\n				texture2DCompare( shadowMap, uv, shadowCoord.z ) +\n				texture2DCompare( shadowMap, uv + vec2( dx, 0.0 ), shadowCoord.z ) +\n				texture2DCompare( shadowMap, uv + vec2( 0.0, dy ), shadowCoord.z ) +\n				texture2DCompare( shadowMap, uv + texelSize, shadowCoord.z ) +\n				mix( texture2DCompare( shadowMap, uv + vec2( -dx, 0.0 ), shadowCoord.z ), \n					 texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, 0.0 ), shadowCoord.z ),\n					 f.x ) +\n				mix( texture2DCompare( shadowMap, uv + vec2( -dx, dy ), shadowCoord.z ), \n					 texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, dy ), shadowCoord.z ),\n					 f.x ) +\n				mix( texture2DCompare( shadowMap, uv + vec2( 0.0, -dy ), shadowCoord.z ), \n					 texture2DCompare( shadowMap, uv + vec2( 0.0, 2.0 * dy ), shadowCoord.z ),\n					 f.y ) +\n				mix( texture2DCompare( shadowMap, uv + vec2( dx, -dy ), shadowCoord.z ), \n					 texture2DCompare( shadowMap, uv + vec2( dx, 2.0 * dy ), shadowCoord.z ),\n					 f.y ) +\n				mix( mix( texture2DCompare( shadowMap, uv + vec2( -dx, -dy ), shadowCoord.z ), \n						  texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, -dy ), shadowCoord.z ),\n						  f.x ),\n					 mix( texture2DCompare( shadowMap, uv + vec2( -dx, 2.0 * dy ), shadowCoord.z ), \n						  texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, 2.0 * dy ), shadowCoord.z ),\n						  f.x ),\n					 f.y )\n			) * ( 1.0 / 9.0 );\n		#elif defined( SHADOWMAP_TYPE_VSM )\n			shadow = VSMShadow( shadowMap, shadowCoord.xy, shadowCoord.z );\n		#else\n			shadow = texture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z );\n		#endif\n		}\n		return shadow;\n	}\n	vec2 cubeToUV( vec3 v, float texelSizeY ) {\n		vec3 absV = abs( v );\n		float scaleToCube = 1.0 / max( absV.x, max( absV.y, absV.z ) );\n		absV *= scaleToCube;\n		v *= scaleToCube * ( 1.0 - 2.0 * texelSizeY );\n		vec2 planar = v.xy;\n		float almostATexel = 1.5 * texelSizeY;\n		float almostOne = 1.0 - almostATexel;\n		if ( absV.z >= almostOne ) {\n			if ( v.z > 0.0 )\n				planar.x = 4.0 - v.x;\n		} else if ( absV.x >= almostOne ) {\n			float signX = sign( v.x );\n			planar.x = v.z * signX + 2.0 * signX;\n		} else if ( absV.y >= almostOne ) {\n			float signY = sign( v.y );\n			planar.x = v.x + 2.0 * signY + 2.0;\n			planar.y = v.z * signY - 2.0;\n		}\n		return vec2( 0.125, 0.25 ) * planar + vec2( 0.375, 0.75 );\n	}\n	float getPointShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord, float shadowCameraNear, float shadowCameraFar ) {\n		vec2 texelSize = vec2( 1.0 ) / ( shadowMapSize * vec2( 4.0, 2.0 ) );\n		vec3 lightToPosition = shadowCoord.xyz;\n		float dp = ( length( lightToPosition ) - shadowCameraNear ) / ( shadowCameraFar - shadowCameraNear );		dp += shadowBias;\n		vec3 bd3D = normalize( lightToPosition );\n		#if defined( SHADOWMAP_TYPE_PCF ) || defined( SHADOWMAP_TYPE_PCF_SOFT ) || defined( SHADOWMAP_TYPE_VSM )\n			vec2 offset = vec2( - 1, 1 ) * shadowRadius * texelSize.y;\n			return (\n				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyy, texelSize.y ), dp ) +\n				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyy, texelSize.y ), dp ) +\n				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyx, texelSize.y ), dp ) +\n				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyx, texelSize.y ), dp ) +\n				texture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp ) +\n				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxy, texelSize.y ), dp ) +\n				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxy, texelSize.y ), dp ) +\n				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxx, texelSize.y ), dp ) +\n				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxx, texelSize.y ), dp )\n			) * ( 1.0 / 9.0 );\n		#else\n			return texture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp );\n		#endif\n	}\n#endif", shadowmap_pars_vertex: "#ifdef USE_SHADOWMAP\n	#if NUM_DIR_LIGHT_SHADOWS > 0\n		uniform mat4 directionalShadowMatrix[ NUM_DIR_LIGHT_SHADOWS ];\n		varying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHT_SHADOWS ];\n		struct DirectionalLightShadow {\n			float shadowBias;\n			float shadowNormalBias;\n			float shadowRadius;\n			vec2 shadowMapSize;\n		};\n		uniform DirectionalLightShadow directionalLightShadows[ NUM_DIR_LIGHT_SHADOWS ];\n	#endif\n	#if NUM_SPOT_LIGHT_SHADOWS > 0\n		uniform mat4 spotShadowMatrix[ NUM_SPOT_LIGHT_SHADOWS ];\n		varying vec4 vSpotShadowCoord[ NUM_SPOT_LIGHT_SHADOWS ];\n		struct SpotLightShadow {\n			float shadowBias;\n			float shadowNormalBias;\n			float shadowRadius;\n			vec2 shadowMapSize;\n		};\n		uniform SpotLightShadow spotLightShadows[ NUM_SPOT_LIGHT_SHADOWS ];\n	#endif\n	#if NUM_POINT_LIGHT_SHADOWS > 0\n		uniform mat4 pointShadowMatrix[ NUM_POINT_LIGHT_SHADOWS ];\n		varying vec4 vPointShadowCoord[ NUM_POINT_LIGHT_SHADOWS ];\n		struct PointLightShadow {\n			float shadowBias;\n			float shadowNormalBias;\n			float shadowRadius;\n			vec2 shadowMapSize;\n			float shadowCameraNear;\n			float shadowCameraFar;\n		};\n		uniform PointLightShadow pointLightShadows[ NUM_POINT_LIGHT_SHADOWS ];\n	#endif\n#endif", shadowmap_vertex: "#ifdef USE_SHADOWMAP\n	#if NUM_DIR_LIGHT_SHADOWS > 0 || NUM_SPOT_LIGHT_SHADOWS > 0 || NUM_POINT_LIGHT_SHADOWS > 0\n		vec3 shadowWorldNormal = inverseTransformDirection( transformedNormal, viewMatrix );\n		vec4 shadowWorldPosition;\n	#endif\n	#if NUM_DIR_LIGHT_SHADOWS > 0\n	#pragma unroll_loop_start\n	for ( int i = 0; i < NUM_DIR_LIGHT_SHADOWS; i ++ ) {\n		shadowWorldPosition = worldPosition + vec4( shadowWorldNormal * directionalLightShadows[ i ].shadowNormalBias, 0 );\n		vDirectionalShadowCoord[ i ] = directionalShadowMatrix[ i ] * shadowWorldPosition;\n	}\n	#pragma unroll_loop_end\n	#endif\n	#if NUM_SPOT_LIGHT_SHADOWS > 0\n	#pragma unroll_loop_start\n	for ( int i = 0; i < NUM_SPOT_LIGHT_SHADOWS; i ++ ) {\n		shadowWorldPosition = worldPosition + vec4( shadowWorldNormal * spotLightShadows[ i ].shadowNormalBias, 0 );\n		vSpotShadowCoord[ i ] = spotShadowMatrix[ i ] * shadowWorldPosition;\n	}\n	#pragma unroll_loop_end\n	#endif\n	#if NUM_POINT_LIGHT_SHADOWS > 0\n	#pragma unroll_loop_start\n	for ( int i = 0; i < NUM_POINT_LIGHT_SHADOWS; i ++ ) {\n		shadowWorldPosition = worldPosition + vec4( shadowWorldNormal * pointLightShadows[ i ].shadowNormalBias, 0 );\n		vPointShadowCoord[ i ] = pointShadowMatrix[ i ] * shadowWorldPosition;\n	}\n	#pragma unroll_loop_end\n	#endif\n#endif", shadowmask_pars_fragment: "float getShadowMask() {\n	float shadow = 1.0;\n	#ifdef USE_SHADOWMAP\n	#if NUM_DIR_LIGHT_SHADOWS > 0\n	DirectionalLightShadow directionalLight;\n	#pragma unroll_loop_start\n	for ( int i = 0; i < NUM_DIR_LIGHT_SHADOWS; i ++ ) {\n		directionalLight = directionalLightShadows[ i ];\n		shadow *= receiveShadow ? getShadow( directionalShadowMap[ i ], directionalLight.shadowMapSize, directionalLight.shadowBias, directionalLight.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;\n	}\n	#pragma unroll_loop_end\n	#endif\n	#if NUM_SPOT_LIGHT_SHADOWS > 0\n	SpotLightShadow spotLight;\n	#pragma unroll_loop_start\n	for ( int i = 0; i < NUM_SPOT_LIGHT_SHADOWS; i ++ ) {\n		spotLight = spotLightShadows[ i ];\n		shadow *= receiveShadow ? getShadow( spotShadowMap[ i ], spotLight.shadowMapSize, spotLight.shadowBias, spotLight.shadowRadius, vSpotShadowCoord[ i ] ) : 1.0;\n	}\n	#pragma unroll_loop_end\n	#endif\n	#if NUM_POINT_LIGHT_SHADOWS > 0\n	PointLightShadow pointLight;\n	#pragma unroll_loop_start\n	for ( int i = 0; i < NUM_POINT_LIGHT_SHADOWS; i ++ ) {\n		pointLight = pointLightShadows[ i ];\n		shadow *= receiveShadow ? getPointShadow( pointShadowMap[ i ], pointLight.shadowMapSize, pointLight.shadowBias, pointLight.shadowRadius, vPointShadowCoord[ i ], pointLight.shadowCameraNear, pointLight.shadowCameraFar ) : 1.0;\n	}\n	#pragma unroll_loop_end\n	#endif\n	#endif\n	return shadow;\n}", skinbase_vertex: "#ifdef USE_SKINNING\n	mat4 boneMatX = getBoneMatrix( skinIndex.x );\n	mat4 boneMatY = getBoneMatrix( skinIndex.y );\n	mat4 boneMatZ = getBoneMatrix( skinIndex.z );\n	mat4 boneMatW = getBoneMatrix( skinIndex.w );\n#endif", skinning_pars_vertex: "#ifdef USE_SKINNING\n	uniform mat4 bindMatrix;\n	uniform mat4 bindMatrixInverse;\n	#ifdef BONE_TEXTURE\n		uniform highp sampler2D boneTexture;\n		uniform int boneTextureSize;\n		mat4 getBoneMatrix( const in float i ) {\n			float j = i * 4.0;\n			float x = mod( j, float( boneTextureSize ) );\n			float y = floor( j / float( boneTextureSize ) );\n			float dx = 1.0 / float( boneTextureSize );\n			float dy = 1.0 / float( boneTextureSize );\n			y = dy * ( y + 0.5 );\n			vec4 v1 = texture2D( boneTexture, vec2( dx * ( x + 0.5 ), y ) );\n			vec4 v2 = texture2D( boneTexture, vec2( dx * ( x + 1.5 ), y ) );\n			vec4 v3 = texture2D( boneTexture, vec2( dx * ( x + 2.5 ), y ) );\n			vec4 v4 = texture2D( boneTexture, vec2( dx * ( x + 3.5 ), y ) );\n			mat4 bone = mat4( v1, v2, v3, v4 );\n			return bone;\n		}\n	#else\n		uniform mat4 boneMatrices[ MAX_BONES ];\n		mat4 getBoneMatrix( const in float i ) {\n			mat4 bone = boneMatrices[ int(i) ];\n			return bone;\n		}\n	#endif\n#endif", skinning_vertex: "#ifdef USE_SKINNING\n	vec4 skinVertex = bindMatrix * vec4( transformed, 1.0 );\n	vec4 skinned = vec4( 0.0 );\n	skinned += boneMatX * skinVertex * skinWeight.x;\n	skinned += boneMatY * skinVertex * skinWeight.y;\n	skinned += boneMatZ * skinVertex * skinWeight.z;\n	skinned += boneMatW * skinVertex * skinWeight.w;\n	transformed = ( bindMatrixInverse * skinned ).xyz;\n#endif", skinnormal_vertex: "#ifdef USE_SKINNING\n	mat4 skinMatrix = mat4( 0.0 );\n	skinMatrix += skinWeight.x * boneMatX;\n	skinMatrix += skinWeight.y * boneMatY;\n	skinMatrix += skinWeight.z * boneMatZ;\n	skinMatrix += skinWeight.w * boneMatW;\n	skinMatrix = bindMatrixInverse * skinMatrix * bindMatrix;\n	objectNormal = vec4( skinMatrix * vec4( objectNormal, 0.0 ) ).xyz;\n	#ifdef USE_TANGENT\n		objectTangent = vec4( skinMatrix * vec4( objectTangent, 0.0 ) ).xyz;\n	#endif\n#endif", specularmap_fragment: "float specularStrength;\n#ifdef USE_SPECULARMAP\n	vec4 texelSpecular = texture2D( specularMap, vUv );\n	specularStrength = texelSpecular.r;\n#else\n	specularStrength = 1.0;\n#endif", specularmap_pars_fragment: "#ifdef USE_SPECULARMAP\n	uniform sampler2D specularMap;\n#endif", tonemapping_fragment: "#if defined( TONE_MAPPING )\n	gl_FragColor.rgb = toneMapping( gl_FragColor.rgb );\n#endif", tonemapping_pars_fragment: "#ifndef saturate\n#define saturate(a) clamp( a, 0.0, 1.0 )\n#endif\nuniform float toneMappingExposure;\nvec3 LinearToneMapping( vec3 color ) {\n	return toneMappingExposure * color;\n}\nvec3 ReinhardToneMapping( vec3 color ) {\n	color *= toneMappingExposure;\n	return saturate( color / ( vec3( 1.0 ) + color ) );\n}\nvec3 OptimizedCineonToneMapping( vec3 color ) {\n	color *= toneMappingExposure;\n	color = max( vec3( 0.0 ), color - 0.004 );\n	return pow( ( color * ( 6.2 * color + 0.5 ) ) / ( color * ( 6.2 * color + 1.7 ) + 0.06 ), vec3( 2.2 ) );\n}\nvec3 RRTAndODTFit( vec3 v ) {\n	vec3 a = v * ( v + 0.0245786 ) - 0.000090537;\n	vec3 b = v * ( 0.983729 * v + 0.4329510 ) + 0.238081;\n	return a / b;\n}\nvec3 ACESFilmicToneMapping( vec3 color ) {\n	const mat3 ACESInputMat = mat3(\n		vec3( 0.59719, 0.07600, 0.02840 ),		vec3( 0.35458, 0.90834, 0.13383 ),\n		vec3( 0.04823, 0.01566, 0.83777 )\n	);\n	const mat3 ACESOutputMat = mat3(\n		vec3(  1.60475, -0.10208, -0.00327 ),		vec3( -0.53108,  1.10813, -0.07276 ),\n		vec3( -0.07367, -0.00605,  1.07602 )\n	);\n	color *= toneMappingExposure / 0.6;\n	color = ACESInputMat * color;\n	color = RRTAndODTFit( color );\n	color = ACESOutputMat * color;\n	return saturate( color );\n}\nvec3 CustomToneMapping( vec3 color ) { return color; }", transmissionmap_fragment: "#ifdef USE_TRANSMISSIONMAP\n	totalTransmission *= texture2D( transmissionMap, vUv ).r;\n#endif", transmissionmap_pars_fragment: "#ifdef USE_TRANSMISSIONMAP\n	uniform sampler2D transmissionMap;\n#endif", uv_pars_fragment: "#if ( defined( USE_UV ) && ! defined( UVS_VERTEX_ONLY ) )\n	varying vec2 vUv;\n#endif", uv_pars_vertex: "#ifdef USE_UV\n	#ifdef UVS_VERTEX_ONLY\n		vec2 vUv;\n	#else\n		varying vec2 vUv;\n	#endif\n	uniform mat3 uvTransform;\n#endif", uv_vertex: "#ifdef USE_UV\n	vUv = ( uvTransform * vec3( uv, 1 ) ).xy;\n#endif", uv2_pars_fragment: "#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\n	varying vec2 vUv2;\n#endif", uv2_pars_vertex: "#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\n	attribute vec2 uv2;\n	varying vec2 vUv2;\n	uniform mat3 uv2Transform;\n#endif", uv2_vertex: "#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\n	vUv2 = ( uv2Transform * vec3( uv2, 1 ) ).xy;\n#endif", worldpos_vertex: "#if defined( USE_ENVMAP ) || defined( DISTANCE ) || defined ( USE_SHADOWMAP )\n	vec4 worldPosition = vec4( transformed, 1.0 );\n	#ifdef USE_INSTANCING\n		worldPosition = instanceMatrix * worldPosition;\n	#endif\n	worldPosition = modelMatrix * worldPosition;\n#endif", background_frag: "uniform sampler2D t2D;\nvarying vec2 vUv;\nvoid main() {\n	vec4 texColor = texture2D( t2D, vUv );\n	gl_FragColor = mapTexelToLinear( texColor );\n	#include <tonemapping_fragment>\n	#include <encodings_fragment>\n}", background_vert: "varying vec2 vUv;\nuniform mat3 uvTransform;\nvoid main() {\n	vUv = ( uvTransform * vec3( uv, 1 ) ).xy;\n	gl_Position = vec4( position.xy, 1.0, 1.0 );\n}", cube_frag: "#include <envmap_common_pars_fragment>\nuniform float opacity;\nvarying vec3 vWorldDirection;\n#include <cube_uv_reflection_fragment>\nvoid main() {\n	vec3 vReflect = vWorldDirection;\n	#include <envmap_fragment>\n	gl_FragColor = envColor;\n	gl_FragColor.a *= opacity;\n	#include <tonemapping_fragment>\n	#include <encodings_fragment>\n}", cube_vert: "varying vec3 vWorldDirection;\n#include <common>\nvoid main() {\n	vWorldDirection = transformDirection( position, modelMatrix );\n	#include <begin_vertex>\n	#include <project_vertex>\n	gl_Position.z = gl_Position.w;\n}", depth_frag: "#if DEPTH_PACKING == 3200\n	uniform float opacity;\n#endif\n#include <common>\n#include <packing>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvarying vec2 vHighPrecisionZW;\nvoid main() {\n	#include <clipping_planes_fragment>\n	vec4 diffuseColor = vec4( 1.0 );\n	#if DEPTH_PACKING == 3200\n		diffuseColor.a = opacity;\n	#endif\n	#include <map_fragment>\n	#include <alphamap_fragment>\n	#include <alphatest_fragment>\n	#include <logdepthbuf_fragment>\n	float fragCoordZ = 0.5 * vHighPrecisionZW[0] / vHighPrecisionZW[1] + 0.5;\n	#if DEPTH_PACKING == 3200\n		gl_FragColor = vec4( vec3( 1.0 - fragCoordZ ), opacity );\n	#elif DEPTH_PACKING == 3201\n		gl_FragColor = packDepthToRGBA( fragCoordZ );\n	#endif\n}", depth_vert: "#include <common>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvarying vec2 vHighPrecisionZW;\nvoid main() {\n	#include <uv_vertex>\n	#include <skinbase_vertex>\n	#ifdef USE_DISPLACEMENTMAP\n		#include <beginnormal_vertex>\n		#include <morphnormal_vertex>\n		#include <skinnormal_vertex>\n	#endif\n	#include <begin_vertex>\n	#include <morphtarget_vertex>\n	#include <skinning_vertex>\n	#include <displacementmap_vertex>\n	#include <project_vertex>\n	#include <logdepthbuf_vertex>\n	#include <clipping_planes_vertex>\n	vHighPrecisionZW = gl_Position.zw;\n}", distanceRGBA_frag: "#define DISTANCE\nuniform vec3 referencePosition;\nuniform float nearDistance;\nuniform float farDistance;\nvarying vec3 vWorldPosition;\n#include <common>\n#include <packing>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main () {\n	#include <clipping_planes_fragment>\n	vec4 diffuseColor = vec4( 1.0 );\n	#include <map_fragment>\n	#include <alphamap_fragment>\n	#include <alphatest_fragment>\n	float dist = length( vWorldPosition - referencePosition );\n	dist = ( dist - nearDistance ) / ( farDistance - nearDistance );\n	dist = saturate( dist );\n	gl_FragColor = packDepthToRGBA( dist );\n}", distanceRGBA_vert: "#define DISTANCE\nvarying vec3 vWorldPosition;\n#include <common>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n	#include <uv_vertex>\n	#include <skinbase_vertex>\n	#ifdef USE_DISPLACEMENTMAP\n		#include <beginnormal_vertex>\n		#include <morphnormal_vertex>\n		#include <skinnormal_vertex>\n	#endif\n	#include <begin_vertex>\n	#include <morphtarget_vertex>\n	#include <skinning_vertex>\n	#include <displacementmap_vertex>\n	#include <project_vertex>\n	#include <worldpos_vertex>\n	#include <clipping_planes_vertex>\n	vWorldPosition = worldPosition.xyz;\n}", equirect_frag: "uniform sampler2D tEquirect;\nvarying vec3 vWorldDirection;\n#include <common>\nvoid main() {\n	vec3 direction = normalize( vWorldDirection );\n	vec2 sampleUV = equirectUv( direction );\n	vec4 texColor = texture2D( tEquirect, sampleUV );\n	gl_FragColor = mapTexelToLinear( texColor );\n	#include <tonemapping_fragment>\n	#include <encodings_fragment>\n}", equirect_vert: "varying vec3 vWorldDirection;\n#include <common>\nvoid main() {\n	vWorldDirection = transformDirection( position, modelMatrix );\n	#include <begin_vertex>\n	#include <project_vertex>\n}", linedashed_frag: "uniform vec3 diffuse;\nuniform float opacity;\nuniform float dashSize;\nuniform float totalSize;\nvarying float vLineDistance;\n#include <common>\n#include <color_pars_fragment>\n#include <fog_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n	#include <clipping_planes_fragment>\n	if ( mod( vLineDistance, totalSize ) > dashSize ) {\n		discard;\n	}\n	vec3 outgoingLight = vec3( 0.0 );\n	vec4 diffuseColor = vec4( diffuse, opacity );\n	#include <logdepthbuf_fragment>\n	#include <color_fragment>\n	outgoingLight = diffuseColor.rgb;\n	gl_FragColor = vec4( outgoingLight, diffuseColor.a );\n	#include <tonemapping_fragment>\n	#include <encodings_fragment>\n	#include <fog_fragment>\n	#include <premultiplied_alpha_fragment>\n}", linedashed_vert: "uniform float scale;\nattribute float lineDistance;\nvarying float vLineDistance;\n#include <common>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n	vLineDistance = scale * lineDistance;\n	#include <color_vertex>\n	#include <begin_vertex>\n	#include <morphtarget_vertex>\n	#include <project_vertex>\n	#include <logdepthbuf_vertex>\n	#include <clipping_planes_vertex>\n	#include <fog_vertex>\n}", meshbasic_frag: "uniform vec3 diffuse;\nuniform float opacity;\n#ifndef FLAT_SHADED\n	varying vec3 vNormal;\n#endif\n#include <common>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <envmap_common_pars_fragment>\n#include <envmap_pars_fragment>\n#include <cube_uv_reflection_fragment>\n#include <fog_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n	#include <clipping_planes_fragment>\n	vec4 diffuseColor = vec4( diffuse, opacity );\n	#include <logdepthbuf_fragment>\n	#include <map_fragment>\n	#include <color_fragment>\n	#include <alphamap_fragment>\n	#include <alphatest_fragment>\n	#include <specularmap_fragment>\n	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n	#ifdef USE_LIGHTMAP\n	\n		vec4 lightMapTexel= texture2D( lightMap, vUv2 );\n		reflectedLight.indirectDiffuse += lightMapTexelToLinear( lightMapTexel ).rgb * lightMapIntensity;\n	#else\n		reflectedLight.indirectDiffuse += vec3( 1.0 );\n	#endif\n	#include <aomap_fragment>\n	reflectedLight.indirectDiffuse *= diffuseColor.rgb;\n	vec3 outgoingLight = reflectedLight.indirectDiffuse;\n	#include <envmap_fragment>\n	gl_FragColor = vec4( outgoingLight, diffuseColor.a );\n	#include <tonemapping_fragment>\n	#include <encodings_fragment>\n	#include <fog_fragment>\n	#include <premultiplied_alpha_fragment>\n	#include <dithering_fragment>\n}", meshbasic_vert: "#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <envmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n	#include <uv_vertex>\n	#include <uv2_vertex>\n	#include <color_vertex>\n	#include <skinbase_vertex>\n	#ifdef USE_ENVMAP\n	#include <beginnormal_vertex>\n	#include <morphnormal_vertex>\n	#include <skinnormal_vertex>\n	#include <defaultnormal_vertex>\n	#endif\n	#include <begin_vertex>\n	#include <morphtarget_vertex>\n	#include <skinning_vertex>\n	#include <project_vertex>\n	#include <logdepthbuf_vertex>\n	#include <worldpos_vertex>\n	#include <clipping_planes_vertex>\n	#include <envmap_vertex>\n	#include <fog_vertex>\n}", meshlambert_frag: "uniform vec3 diffuse;\nuniform vec3 emissive;\nuniform float opacity;\nvarying vec3 vLightFront;\nvarying vec3 vIndirectFront;\n#ifdef DOUBLE_SIDED\n	varying vec3 vLightBack;\n	varying vec3 vIndirectBack;\n#endif\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <envmap_common_pars_fragment>\n#include <envmap_pars_fragment>\n#include <cube_uv_reflection_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <fog_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <shadowmask_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n	#include <clipping_planes_fragment>\n	vec4 diffuseColor = vec4( diffuse, opacity );\n	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n	vec3 totalEmissiveRadiance = emissive;\n	#include <logdepthbuf_fragment>\n	#include <map_fragment>\n	#include <color_fragment>\n	#include <alphamap_fragment>\n	#include <alphatest_fragment>\n	#include <specularmap_fragment>\n	#include <emissivemap_fragment>\n	#ifdef DOUBLE_SIDED\n		reflectedLight.indirectDiffuse += ( gl_FrontFacing ) ? vIndirectFront : vIndirectBack;\n	#else\n		reflectedLight.indirectDiffuse += vIndirectFront;\n	#endif\n	#include <lightmap_fragment>\n	reflectedLight.indirectDiffuse *= BRDF_Diffuse_Lambert( diffuseColor.rgb );\n	#ifdef DOUBLE_SIDED\n		reflectedLight.directDiffuse = ( gl_FrontFacing ) ? vLightFront : vLightBack;\n	#else\n		reflectedLight.directDiffuse = vLightFront;\n	#endif\n	reflectedLight.directDiffuse *= BRDF_Diffuse_Lambert( diffuseColor.rgb ) * getShadowMask();\n	#include <aomap_fragment>\n	vec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + totalEmissiveRadiance;\n	#include <envmap_fragment>\n	gl_FragColor = vec4( outgoingLight, diffuseColor.a );\n	#include <tonemapping_fragment>\n	#include <encodings_fragment>\n	#include <fog_fragment>\n	#include <premultiplied_alpha_fragment>\n	#include <dithering_fragment>\n}", meshlambert_vert: "#define LAMBERT\nvarying vec3 vLightFront;\nvarying vec3 vIndirectFront;\n#ifdef DOUBLE_SIDED\n	varying vec3 vLightBack;\n	varying vec3 vIndirectBack;\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <envmap_pars_vertex>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n	#include <uv_vertex>\n	#include <uv2_vertex>\n	#include <color_vertex>\n	#include <beginnormal_vertex>\n	#include <morphnormal_vertex>\n	#include <skinbase_vertex>\n	#include <skinnormal_vertex>\n	#include <defaultnormal_vertex>\n	#include <begin_vertex>\n	#include <morphtarget_vertex>\n	#include <skinning_vertex>\n	#include <project_vertex>\n	#include <logdepthbuf_vertex>\n	#include <clipping_planes_vertex>\n	#include <worldpos_vertex>\n	#include <envmap_vertex>\n	#include <lights_lambert_vertex>\n	#include <shadowmap_vertex>\n	#include <fog_vertex>\n}", meshmatcap_frag: "#define MATCAP\nuniform vec3 diffuse;\nuniform float opacity;\nuniform sampler2D matcap;\nvarying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n	varying vec3 vNormal;\n#endif\n#include <common>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <fog_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n	#include <clipping_planes_fragment>\n	vec4 diffuseColor = vec4( diffuse, opacity );\n	#include <logdepthbuf_fragment>\n	#include <map_fragment>\n	#include <color_fragment>\n	#include <alphamap_fragment>\n	#include <alphatest_fragment>\n	#include <normal_fragment_begin>\n	#include <normal_fragment_maps>\n	vec3 viewDir = normalize( vViewPosition );\n	vec3 x = normalize( vec3( viewDir.z, 0.0, - viewDir.x ) );\n	vec3 y = cross( viewDir, x );\n	vec2 uv = vec2( dot( x, normal ), dot( y, normal ) ) * 0.495 + 0.5;\n	#ifdef USE_MATCAP\n		vec4 matcapColor = texture2D( matcap, uv );\n		matcapColor = matcapTexelToLinear( matcapColor );\n	#else\n		vec4 matcapColor = vec4( 1.0 );\n	#endif\n	vec3 outgoingLight = diffuseColor.rgb * matcapColor.rgb;\n	gl_FragColor = vec4( outgoingLight, diffuseColor.a );\n	#include <tonemapping_fragment>\n	#include <encodings_fragment>\n	#include <fog_fragment>\n	#include <premultiplied_alpha_fragment>\n	#include <dithering_fragment>\n}", meshmatcap_vert: "#define MATCAP\nvarying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n	varying vec3 vNormal;\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <color_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n	#include <uv_vertex>\n	#include <color_vertex>\n	#include <beginnormal_vertex>\n	#include <morphnormal_vertex>\n	#include <skinbase_vertex>\n	#include <skinnormal_vertex>\n	#include <defaultnormal_vertex>\n	#ifndef FLAT_SHADED\n		vNormal = normalize( transformedNormal );\n	#endif\n	#include <begin_vertex>\n	#include <morphtarget_vertex>\n	#include <skinning_vertex>\n	#include <displacementmap_vertex>\n	#include <project_vertex>\n	#include <logdepthbuf_vertex>\n	#include <clipping_planes_vertex>\n	#include <fog_vertex>\n	vViewPosition = - mvPosition.xyz;\n}", meshtoon_frag: "#define TOON\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform float opacity;\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <gradientmap_pars_fragment>\n#include <fog_pars_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <lights_toon_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n	#include <clipping_planes_fragment>\n	vec4 diffuseColor = vec4( diffuse, opacity );\n	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n	vec3 totalEmissiveRadiance = emissive;\n	#include <logdepthbuf_fragment>\n	#include <map_fragment>\n	#include <color_fragment>\n	#include <alphamap_fragment>\n	#include <alphatest_fragment>\n	#include <normal_fragment_begin>\n	#include <normal_fragment_maps>\n	#include <emissivemap_fragment>\n	#include <lights_toon_fragment>\n	#include <lights_fragment_begin>\n	#include <lights_fragment_maps>\n	#include <lights_fragment_end>\n	#include <aomap_fragment>\n	vec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + totalEmissiveRadiance;\n	gl_FragColor = vec4( outgoingLight, diffuseColor.a );\n	#include <tonemapping_fragment>\n	#include <encodings_fragment>\n	#include <fog_fragment>\n	#include <premultiplied_alpha_fragment>\n	#include <dithering_fragment>\n}", meshtoon_vert: "#define TOON\nvarying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n	varying vec3 vNormal;\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n	#include <uv_vertex>\n	#include <uv2_vertex>\n	#include <color_vertex>\n	#include <beginnormal_vertex>\n	#include <morphnormal_vertex>\n	#include <skinbase_vertex>\n	#include <skinnormal_vertex>\n	#include <defaultnormal_vertex>\n#ifndef FLAT_SHADED\n	vNormal = normalize( transformedNormal );\n#endif\n	#include <begin_vertex>\n	#include <morphtarget_vertex>\n	#include <skinning_vertex>\n	#include <displacementmap_vertex>\n	#include <project_vertex>\n	#include <logdepthbuf_vertex>\n	#include <clipping_planes_vertex>\n	vViewPosition = - mvPosition.xyz;\n	#include <worldpos_vertex>\n	#include <shadowmap_vertex>\n	#include <fog_vertex>\n}", meshphong_frag: "#define PHONG\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform vec3 specular;\nuniform float shininess;\nuniform float opacity;\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <envmap_common_pars_fragment>\n#include <envmap_pars_fragment>\n#include <cube_uv_reflection_fragment>\n#include <fog_pars_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <lights_phong_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n	#include <clipping_planes_fragment>\n	vec4 diffuseColor = vec4( diffuse, opacity );\n	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n	vec3 totalEmissiveRadiance = emissive;\n	#include <logdepthbuf_fragment>\n	#include <map_fragment>\n	#include <color_fragment>\n	#include <alphamap_fragment>\n	#include <alphatest_fragment>\n	#include <specularmap_fragment>\n	#include <normal_fragment_begin>\n	#include <normal_fragment_maps>\n	#include <emissivemap_fragment>\n	#include <lights_phong_fragment>\n	#include <lights_fragment_begin>\n	#include <lights_fragment_maps>\n	#include <lights_fragment_end>\n	#include <aomap_fragment>\n	vec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + reflectedLight.directSpecular + reflectedLight.indirectSpecular + totalEmissiveRadiance;\n	#include <envmap_fragment>\n	gl_FragColor = vec4( outgoingLight, diffuseColor.a );\n	#include <tonemapping_fragment>\n	#include <encodings_fragment>\n	#include <fog_fragment>\n	#include <premultiplied_alpha_fragment>\n	#include <dithering_fragment>\n}", meshphong_vert: "#define PHONG\nvarying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n	varying vec3 vNormal;\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <envmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n	#include <uv_vertex>\n	#include <uv2_vertex>\n	#include <color_vertex>\n	#include <beginnormal_vertex>\n	#include <morphnormal_vertex>\n	#include <skinbase_vertex>\n	#include <skinnormal_vertex>\n	#include <defaultnormal_vertex>\n#ifndef FLAT_SHADED\n	vNormal = normalize( transformedNormal );\n#endif\n	#include <begin_vertex>\n	#include <morphtarget_vertex>\n	#include <skinning_vertex>\n	#include <displacementmap_vertex>\n	#include <project_vertex>\n	#include <logdepthbuf_vertex>\n	#include <clipping_planes_vertex>\n	vViewPosition = - mvPosition.xyz;\n	#include <worldpos_vertex>\n	#include <envmap_vertex>\n	#include <shadowmap_vertex>\n	#include <fog_vertex>\n}", meshphysical_frag: "#define STANDARD\n#ifdef PHYSICAL\n	#define REFLECTIVITY\n	#define CLEARCOAT\n	#define TRANSMISSION\n#endif\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform float roughness;\nuniform float metalness;\nuniform float opacity;\n#ifdef TRANSMISSION\n	uniform float transmission;\n#endif\n#ifdef REFLECTIVITY\n	uniform float reflectivity;\n#endif\n#ifdef CLEARCOAT\n	uniform float clearcoat;\n	uniform float clearcoatRoughness;\n#endif\n#ifdef USE_SHEEN\n	uniform vec3 sheen;\n#endif\nvarying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n	varying vec3 vNormal;\n	#ifdef USE_TANGENT\n		varying vec3 vTangent;\n		varying vec3 vBitangent;\n	#endif\n#endif\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <transmissionmap_pars_fragment>\n#include <bsdfs>\n#include <cube_uv_reflection_fragment>\n#include <envmap_common_pars_fragment>\n#include <envmap_physical_pars_fragment>\n#include <fog_pars_fragment>\n#include <lights_pars_begin>\n#include <lights_physical_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <clearcoat_pars_fragment>\n#include <roughnessmap_pars_fragment>\n#include <metalnessmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n	#include <clipping_planes_fragment>\n	vec4 diffuseColor = vec4( diffuse, opacity );\n	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n	vec3 totalEmissiveRadiance = emissive;\n	#ifdef TRANSMISSION\n		float totalTransmission = transmission;\n	#endif\n	#include <logdepthbuf_fragment>\n	#include <map_fragment>\n	#include <color_fragment>\n	#include <alphamap_fragment>\n	#include <alphatest_fragment>\n	#include <roughnessmap_fragment>\n	#include <metalnessmap_fragment>\n	#include <normal_fragment_begin>\n	#include <normal_fragment_maps>\n	#include <clearcoat_normal_fragment_begin>\n	#include <clearcoat_normal_fragment_maps>\n	#include <emissivemap_fragment>\n	#include <transmissionmap_fragment>\n	#include <lights_physical_fragment>\n	#include <lights_fragment_begin>\n	#include <lights_fragment_maps>\n	#include <lights_fragment_end>\n	#include <aomap_fragment>\n	vec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + reflectedLight.directSpecular + reflectedLight.indirectSpecular + totalEmissiveRadiance;\n	#ifdef TRANSMISSION\n		diffuseColor.a *= mix( saturate( 1. - totalTransmission + linearToRelativeLuminance( reflectedLight.directSpecular + reflectedLight.indirectSpecular ) ), 1.0, metalness );\n	#endif\n	gl_FragColor = vec4( outgoingLight, diffuseColor.a );\n	#include <tonemapping_fragment>\n	#include <encodings_fragment>\n	#include <fog_fragment>\n	#include <premultiplied_alpha_fragment>\n	#include <dithering_fragment>\n}", meshphysical_vert: "#define STANDARD\nvarying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n	varying vec3 vNormal;\n	#ifdef USE_TANGENT\n		varying vec3 vTangent;\n		varying vec3 vBitangent;\n	#endif\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n	#include <uv_vertex>\n	#include <uv2_vertex>\n	#include <color_vertex>\n	#include <beginnormal_vertex>\n	#include <morphnormal_vertex>\n	#include <skinbase_vertex>\n	#include <skinnormal_vertex>\n	#include <defaultnormal_vertex>\n#ifndef FLAT_SHADED\n	vNormal = normalize( transformedNormal );\n	#ifdef USE_TANGENT\n		vTangent = normalize( transformedTangent );\n		vBitangent = normalize( cross( vNormal, vTangent ) * tangent.w );\n	#endif\n#endif\n	#include <begin_vertex>\n	#include <morphtarget_vertex>\n	#include <skinning_vertex>\n	#include <displacementmap_vertex>\n	#include <project_vertex>\n	#include <logdepthbuf_vertex>\n	#include <clipping_planes_vertex>\n	vViewPosition = - mvPosition.xyz;\n	#include <worldpos_vertex>\n	#include <shadowmap_vertex>\n	#include <fog_vertex>\n}", normal_frag: "#define NORMAL\nuniform float opacity;\n#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( TANGENTSPACE_NORMALMAP )\n	varying vec3 vViewPosition;\n#endif\n#ifndef FLAT_SHADED\n	varying vec3 vNormal;\n	#ifdef USE_TANGENT\n		varying vec3 vTangent;\n		varying vec3 vBitangent;\n	#endif\n#endif\n#include <packing>\n#include <uv_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n	#include <clipping_planes_fragment>\n	#include <logdepthbuf_fragment>\n	#include <normal_fragment_begin>\n	#include <normal_fragment_maps>\n	gl_FragColor = vec4( packNormalToRGB( normal ), opacity );\n}", normal_vert: "#define NORMAL\n#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( TANGENTSPACE_NORMALMAP )\n	varying vec3 vViewPosition;\n#endif\n#ifndef FLAT_SHADED\n	varying vec3 vNormal;\n	#ifdef USE_TANGENT\n		varying vec3 vTangent;\n		varying vec3 vBitangent;\n	#endif\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n	#include <uv_vertex>\n	#include <beginnormal_vertex>\n	#include <morphnormal_vertex>\n	#include <skinbase_vertex>\n	#include <skinnormal_vertex>\n	#include <defaultnormal_vertex>\n#ifndef FLAT_SHADED\n	vNormal = normalize( transformedNormal );\n	#ifdef USE_TANGENT\n		vTangent = normalize( transformedTangent );\n		vBitangent = normalize( cross( vNormal, vTangent ) * tangent.w );\n	#endif\n#endif\n	#include <begin_vertex>\n	#include <morphtarget_vertex>\n	#include <skinning_vertex>\n	#include <displacementmap_vertex>\n	#include <project_vertex>\n	#include <logdepthbuf_vertex>\n	#include <clipping_planes_vertex>\n#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( TANGENTSPACE_NORMALMAP )\n	vViewPosition = - mvPosition.xyz;\n#endif\n}", points_frag: "uniform vec3 diffuse;\nuniform float opacity;\n#include <common>\n#include <color_pars_fragment>\n#include <map_particle_pars_fragment>\n#include <fog_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n	#include <clipping_planes_fragment>\n	vec3 outgoingLight = vec3( 0.0 );\n	vec4 diffuseColor = vec4( diffuse, opacity );\n	#include <logdepthbuf_fragment>\n	#include <map_particle_fragment>\n	#include <color_fragment>\n	#include <alphatest_fragment>\n	outgoingLight = diffuseColor.rgb;\n	gl_FragColor = vec4( outgoingLight, diffuseColor.a );\n	#include <tonemapping_fragment>\n	#include <encodings_fragment>\n	#include <fog_fragment>\n	#include <premultiplied_alpha_fragment>\n}", points_vert: "uniform float size;\nuniform float scale;\n#include <common>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n	#include <color_vertex>\n	#include <begin_vertex>\n	#include <morphtarget_vertex>\n	#include <project_vertex>\n	gl_PointSize = size;\n	#ifdef USE_SIZEATTENUATION\n		bool isPerspective = isPerspectiveMatrix( projectionMatrix );\n		if ( isPerspective ) gl_PointSize *= ( scale / - mvPosition.z );\n	#endif\n	#include <logdepthbuf_vertex>\n	#include <clipping_planes_vertex>\n	#include <worldpos_vertex>\n	#include <fog_vertex>\n}", shadow_frag: "uniform vec3 color;\nuniform float opacity;\n#include <common>\n#include <packing>\n#include <fog_pars_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <shadowmap_pars_fragment>\n#include <shadowmask_pars_fragment>\nvoid main() {\n	gl_FragColor = vec4( color, opacity * ( 1.0 - getShadowMask() ) );\n	#include <tonemapping_fragment>\n	#include <encodings_fragment>\n	#include <fog_fragment>\n}", shadow_vert: "#include <common>\n#include <fog_pars_vertex>\n#include <shadowmap_pars_vertex>\nvoid main() {\n	#include <begin_vertex>\n	#include <project_vertex>\n	#include <worldpos_vertex>\n	#include <beginnormal_vertex>\n	#include <morphnormal_vertex>\n	#include <skinbase_vertex>\n	#include <skinnormal_vertex>\n	#include <defaultnormal_vertex>\n	#include <shadowmap_vertex>\n	#include <fog_vertex>\n}", sprite_frag: "uniform vec3 diffuse;\nuniform float opacity;\n#include <common>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <fog_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n	#include <clipping_planes_fragment>\n	vec3 outgoingLight = vec3( 0.0 );\n	vec4 diffuseColor = vec4( diffuse, opacity );\n	#include <logdepthbuf_fragment>\n	#include <map_fragment>\n	#include <alphamap_fragment>\n	#include <alphatest_fragment>\n	outgoingLight = diffuseColor.rgb;\n	gl_FragColor = vec4( outgoingLight, diffuseColor.a );\n	#include <tonemapping_fragment>\n	#include <encodings_fragment>\n	#include <fog_fragment>\n}", sprite_vert: "uniform float rotation;\nuniform vec2 center;\n#include <common>\n#include <uv_pars_vertex>\n#include <fog_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n	#include <uv_vertex>\n	vec4 mvPosition = modelViewMatrix * vec4( 0.0, 0.0, 0.0, 1.0 );\n	vec2 scale;\n	scale.x = length( vec3( modelMatrix[ 0 ].x, modelMatrix[ 0 ].y, modelMatrix[ 0 ].z ) );\n	scale.y = length( vec3( modelMatrix[ 1 ].x, modelMatrix[ 1 ].y, modelMatrix[ 1 ].z ) );\n	#ifndef USE_SIZEATTENUATION\n		bool isPerspective = isPerspectiveMatrix( projectionMatrix );\n		if ( isPerspective ) scale *= - mvPosition.z;\n	#endif\n	vec2 alignedPosition = ( position.xy - ( center - vec2( 0.5 ) ) ) * scale;\n	vec2 rotatedPosition;\n	rotatedPosition.x = cos( rotation ) * alignedPosition.x - sin( rotation ) * alignedPosition.y;\n	rotatedPosition.y = sin( rotation ) * alignedPosition.x + cos( rotation ) * alignedPosition.y;\n	mvPosition.xy += rotatedPosition;\n	gl_Position = projectionMatrix * mvPosition;\n	#include <logdepthbuf_vertex>\n	#include <clipping_planes_vertex>\n	#include <fog_vertex>\n}" }, Do = { common: { diffuse: { value: new yi(15658734) }, opacity: { value: 1 }, map: { value: null }, uvTransform: { value: new Gn() }, uv2Transform: { value: new Gn() }, alphaMap: { value: null } }, specularmap: { specularMap: { value: null } }, envmap: { envMap: { value: null }, flipEnvMap: { value: -1 }, reflectivity: { value: 1 }, refractionRatio: { value: 0.98 }, maxMipLevel: { value: 0 } }, aomap: { aoMap: { value: null }, aoMapIntensity: { value: 1 } }, lightmap: { lightMap: { value: null }, lightMapIntensity: { value: 1 } }, emissivemap: { emissiveMap: { value: null } }, bumpmap: { bumpMap: { value: null }, bumpScale: { value: 1 } }, normalmap: { normalMap: { value: null }, normalScale: { value: new Hn(1, 1) } }, displacementmap: { displacementMap: { value: null }, displacementScale: { value: 1 }, displacementBias: { value: 0 } }, roughnessmap: { roughnessMap: { value: null } }, metalnessmap: { metalnessMap: { value: null } }, gradientmap: { gradientMap: { value: null } }, fog: { fogDensity: { value: 25e-5 }, fogNear: { value: 1 }, fogFar: { value: 2e3 }, fogColor: { value: new yi(16777215) } }, lights: { ambientLightColor: { value: [] }, lightProbe: { value: [] }, directionalLights: { value: [], properties: { direction: {}, color: {} } }, directionalLightShadows: { value: [], properties: { shadowBias: {}, shadowNormalBias: {}, shadowRadius: {}, shadowMapSize: {} } }, directionalShadowMap: { value: [] }, directionalShadowMatrix: { value: [] }, spotLights: { value: [], properties: { color: {}, position: {}, direction: {}, distance: {}, coneCos: {}, penumbraCos: {}, decay: {} } }, spotLightShadows: { value: [], properties: { shadowBias: {}, shadowNormalBias: {}, shadowRadius: {}, shadowMapSize: {} } }, spotShadowMap: { value: [] }, spotShadowMatrix: { value: [] }, pointLights: { value: [], properties: { color: {}, position: {}, decay: {}, distance: {} } }, pointLightShadows: { value: [], properties: { shadowBias: {}, shadowNormalBias: {}, shadowRadius: {}, shadowMapSize: {}, shadowCameraNear: {}, shadowCameraFar: {} } }, pointShadowMap: { value: [] }, pointShadowMatrix: { value: [] }, hemisphereLights: { value: [], properties: { direction: {}, skyColor: {}, groundColor: {} } }, rectAreaLights: { value: [], properties: { color: {}, position: {}, width: {}, height: {} } }, ltc_1: { value: null }, ltc_2: { value: null } }, points: { diffuse: { value: new yi(15658734) }, opacity: { value: 1 }, size: { value: 1 }, scale: { value: 1 }, map: { value: null }, alphaMap: { value: null }, uvTransform: { value: new Gn() } }, sprite: { diffuse: { value: new yi(15658734) }, opacity: { value: 1 }, center: { value: new Hn(0.5, 0.5) }, rotation: { value: 0 }, map: { value: null }, alphaMap: { value: null }, uvTransform: { value: new Gn() } } }, Io = { basic: { uniforms: vo([Do.common, Do.specularmap, Do.envmap, Do.aomap, Do.lightmap, Do.fog]), vertexShader: Oo.meshbasic_vert, fragmentShader: Oo.meshbasic_frag }, lambert: { uniforms: vo([Do.common, Do.specularmap, Do.envmap, Do.aomap, Do.lightmap, Do.emissivemap, Do.fog, Do.lights, { emissive: { value: new yi(0) } }]), vertexShader: Oo.meshlambert_vert, fragmentShader: Oo.meshlambert_frag }, phong: { uniforms: vo([Do.common, Do.specularmap, Do.envmap, Do.aomap, Do.lightmap, Do.emissivemap, Do.bumpmap, Do.normalmap, Do.displacementmap, Do.fog, Do.lights, { emissive: { value: new yi(0) }, specular: { value: new yi(1118481) }, shininess: { value: 30 } }]), vertexShader: Oo.meshphong_vert, fragmentShader: Oo.meshphong_frag }, standard: { uniforms: vo([Do.common, Do.envmap, Do.aomap, Do.lightmap, Do.emissivemap, Do.bumpmap, Do.normalmap, Do.displacementmap, Do.roughnessmap, Do.metalnessmap, Do.fog, Do.lights, { emissive: { value: new yi(0) }, roughness: { value: 1 }, metalness: { value: 0 }, envMapIntensity: { value: 1 } }]), vertexShader: Oo.meshphysical_vert, fragmentShader: Oo.meshphysical_frag }, toon: { uniforms: vo([Do.common, Do.aomap, Do.lightmap, Do.emissivemap, Do.bumpmap, Do.normalmap, Do.displacementmap, Do.gradientmap, Do.fog, Do.lights, { emissive: { value: new yi(0) } }]), vertexShader: Oo.meshtoon_vert, fragmentShader: Oo.meshtoon_frag }, matcap: { uniforms: vo([Do.common, Do.bumpmap, Do.normalmap, Do.displacementmap, Do.fog, { matcap: { value: null } }]), vertexShader: Oo.meshmatcap_vert, fragmentShader: Oo.meshmatcap_frag }, points: { uniforms: vo([Do.points, Do.fog]), vertexShader: Oo.points_vert, fragmentShader: Oo.points_frag }, dashed: { uniforms: vo([Do.common, Do.fog, { scale: { value: 1 }, dashSize: { value: 1 }, totalSize: { value: 2 } }]), vertexShader: Oo.linedashed_vert, fragmentShader: Oo.linedashed_frag }, depth: { uniforms: vo([Do.common, Do.displacementmap]), vertexShader: Oo.depth_vert, fragmentShader: Oo.depth_frag }, normal: { uniforms: vo([Do.common, Do.bumpmap, Do.normalmap, Do.displacementmap, { opacity: { value: 1 } }]), vertexShader: Oo.normal_vert, fragmentShader: Oo.normal_frag }, sprite: { uniforms: vo([Do.sprite, Do.fog]), vertexShader: Oo.sprite_vert, fragmentShader: Oo.sprite_frag }, background: { uniforms: { uvTransform: { value: new Gn() }, t2D: { value: null } }, vertexShader: Oo.background_vert, fragmentShader: Oo.background_frag }, cube: { uniforms: vo([Do.envmap, { opacity: { value: 1 } }]), vertexShader: Oo.cube_vert, fragmentShader: Oo.cube_frag }, equirect: { uniforms: { tEquirect: { value: null } }, vertexShader: Oo.equirect_vert, fragmentShader: Oo.equirect_frag }, distanceRGBA: { uniforms: vo([Do.common, Do.displacementmap, { referencePosition: { value: new $n() }, nearDistance: { value: 1 }, farDistance: { value: 1e3 } }]), vertexShader: Oo.distanceRGBA_vert, fragmentShader: Oo.distanceRGBA_frag }, shadow: { uniforms: vo([Do.lights, Do.fog, { color: { value: new yi(0) }, opacity: { value: 1 } }]), vertexShader: Oo.shadow_vert, fragmentShader: Oo.shadow_frag } };
      function No(t2, e2, n2, r2, i2) {
        const o2 = new yi(0);
        let a2, s2, c2 = 0, u2 = null, l2 = 0, h2 = null;
        function d2(t3, e3) {
          n2.buffers.color.setClear(t3.r, t3.g, t3.b, e3, i2);
        }
        return { getClearColor: function() {
          return o2;
        }, setClearColor: function(t3, e3 = 1) {
          o2.set(t3), c2 = e3, d2(o2, c2);
        }, getClearAlpha: function() {
          return c2;
        }, setClearAlpha: function(t3) {
          c2 = t3, d2(o2, c2);
        }, render: function(n3, i3, p2, g2) {
          let v2 = true === i3.isScene ? i3.background : null;
          v2 && v2.isTexture && (v2 = e2.get(v2));
          const y2 = t2.xr, x2 = y2.getSession && y2.getSession();
          x2 && "additive" === x2.environmentBlendMode && (v2 = null), null === v2 ? d2(o2, c2) : v2 && v2.isColor && (d2(v2, 1), g2 = true), (t2.autoClear || g2) && t2.clear(t2.autoClearColor, t2.autoClearDepth, t2.autoClearStencil), v2 && (v2.isCubeTexture || v2.isWebGLCubeRenderTarget || v2.mapping === ut) ? (void 0 === s2 && (s2 = new ho(new mo(1, 1, 1), new xo({ name: "BackgroundCubeMaterial", uniforms: go(Io.cube.uniforms), vertexShader: Io.cube.vertexShader, fragmentShader: Io.cube.fragmentShader, side: m, depthTest: false, depthWrite: false, fog: false })), s2.geometry.deleteAttribute("normal"), s2.geometry.deleteAttribute("uv"), s2.onBeforeRender = function(t3, e3, n4) {
            this.matrixWorld.copyPosition(n4.matrixWorld);
          }, Object.defineProperty(s2.material, "envMap", { get: function() {
            return this.uniforms.envMap.value;
          } }), r2.update(s2)), v2.isWebGLCubeRenderTarget && (v2 = v2.texture), s2.material.uniforms.envMap.value = v2, s2.material.uniforms.flipEnvMap.value = v2.isCubeTexture && v2._needsFlipEnvMap ? -1 : 1, u2 === v2 && l2 === v2.version && h2 === t2.toneMapping || (s2.material.needsUpdate = true, u2 = v2, l2 = v2.version, h2 = t2.toneMapping), n3.unshift(s2, s2.geometry, s2.material, 0, 0, null)) : v2 && v2.isTexture && (void 0 === a2 && (a2 = new ho(new Ro(2, 2), new xo({ name: "BackgroundMaterial", uniforms: go(Io.background.uniforms), vertexShader: Io.background.vertexShader, fragmentShader: Io.background.fragmentShader, side: f, depthTest: false, depthWrite: false, fog: false })), a2.geometry.deleteAttribute("normal"), Object.defineProperty(a2.material, "map", { get: function() {
            return this.uniforms.t2D.value;
          } }), r2.update(a2)), a2.material.uniforms.t2D.value = v2, true === v2.matrixAutoUpdate && v2.updateMatrix(), a2.material.uniforms.uvTransform.value.copy(v2.matrix), u2 === v2 && l2 === v2.version && h2 === t2.toneMapping || (a2.material.needsUpdate = true, u2 = v2, l2 = v2.version, h2 = t2.toneMapping), n3.unshift(a2, a2.geometry, a2.material, 0, 0, null));
        } };
      }
      function zo(t2, e2, n2, r2) {
        const i2 = t2.getParameter(34921), o2 = r2.isWebGL2 ? null : e2.get("OES_vertex_array_object"), a2 = r2.isWebGL2 || null !== o2, s2 = {}, c2 = d2(null);
        let u2 = c2;
        function l2(e3) {
          return r2.isWebGL2 ? t2.bindVertexArray(e3) : o2.bindVertexArrayOES(e3);
        }
        function h2(e3) {
          return r2.isWebGL2 ? t2.deleteVertexArray(e3) : o2.deleteVertexArrayOES(e3);
        }
        function d2(t3) {
          const e3 = [], n3 = [], r3 = [];
          for (let t4 = 0; t4 < i2; t4++) e3[t4] = 0, n3[t4] = 0, r3[t4] = 0;
          return { geometry: null, program: null, wireframe: false, newAttributes: e3, enabledAttributes: n3, attributeDivisors: r3, object: t3, attributes: {}, index: null };
        }
        function p2() {
          const t3 = u2.newAttributes;
          for (let e3 = 0, n3 = t3.length; e3 < n3; e3++) t3[e3] = 0;
        }
        function f2(t3) {
          m2(t3, 0);
        }
        function m2(n3, i3) {
          const o3 = u2.newAttributes, a3 = u2.enabledAttributes, s3 = u2.attributeDivisors;
          if (o3[n3] = 1, 0 === a3[n3] && (t2.enableVertexAttribArray(n3), a3[n3] = 1), s3[n3] !== i3) {
            (r2.isWebGL2 ? t2 : e2.get("ANGLE_instanced_arrays"))[r2.isWebGL2 ? "vertexAttribDivisor" : "vertexAttribDivisorANGLE"](n3, i3), s3[n3] = i3;
          }
        }
        function g2() {
          const e3 = u2.newAttributes, n3 = u2.enabledAttributes;
          for (let r3 = 0, i3 = n3.length; r3 < i3; r3++) n3[r3] !== e3[r3] && (t2.disableVertexAttribArray(r3), n3[r3] = 0);
        }
        function v2(e3, n3, i3, o3, a3, s3) {
          true !== r2.isWebGL2 || 5124 !== i3 && 5125 !== i3 ? t2.vertexAttribPointer(e3, n3, i3, o3, a3, s3) : t2.vertexAttribIPointer(e3, n3, i3, a3, s3);
        }
        function y2() {
          x2(), u2 !== c2 && (u2 = c2, l2(u2.object));
        }
        function x2() {
          c2.geometry = null, c2.program = null, c2.wireframe = false;
        }
        return { setup: function(i3, c3, h3, y3, x3) {
          let b2 = false;
          if (a2) {
            const e3 = function(e4, n3, i4) {
              const a3 = true === i4.wireframe;
              let c4 = s2[e4.id];
              void 0 === c4 && (c4 = {}, s2[e4.id] = c4);
              let u3 = c4[n3.id];
              void 0 === u3 && (u3 = {}, c4[n3.id] = u3);
              let l3 = u3[a3];
              void 0 === l3 && (l3 = d2(r2.isWebGL2 ? t2.createVertexArray() : o2.createVertexArrayOES()), u3[a3] = l3);
              return l3;
            }(y3, h3, c3);
            u2 !== e3 && (u2 = e3, l2(u2.object)), b2 = function(t3, e4) {
              const n3 = u2.attributes, r3 = t3.attributes;
              let i4 = 0;
              for (const t4 in r3) {
                const e5 = n3[t4], o3 = r3[t4];
                if (void 0 === e5) return true;
                if (e5.attribute !== o3) return true;
                if (e5.data !== o3.data) return true;
                i4++;
              }
              return u2.attributesNum !== i4 || u2.index !== e4;
            }(y3, x3), b2 && function(t3, e4) {
              const n3 = {}, r3 = t3.attributes;
              let i4 = 0;
              for (const t4 in r3) {
                const e5 = r3[t4], o3 = {};
                o3.attribute = e5, e5.data && (o3.data = e5.data), n3[t4] = o3, i4++;
              }
              u2.attributes = n3, u2.attributesNum = i4, u2.index = e4;
            }(y3, x3);
          } else {
            const t3 = true === c3.wireframe;
            u2.geometry === y3.id && u2.program === h3.id && u2.wireframe === t3 || (u2.geometry = y3.id, u2.program = h3.id, u2.wireframe = t3, b2 = true);
          }
          true === i3.isInstancedMesh && (b2 = true), null !== x3 && n2.update(x3, 34963), b2 && (!function(i4, o3, a3, s3) {
            if (false === r2.isWebGL2 && (i4.isInstancedMesh || s3.isInstancedBufferGeometry) && null === e2.get("ANGLE_instanced_arrays")) return;
            p2();
            const c4 = s3.attributes, u3 = a3.getAttributes(), l3 = o3.defaultAttributeValues;
            for (const e3 in u3) {
              const r3 = u3[e3];
              if (r3 >= 0) {
                const o4 = c4[e3];
                if (void 0 !== o4) {
                  const e4 = o4.normalized, i5 = o4.itemSize, a4 = n2.get(o4);
                  if (void 0 === a4) continue;
                  const c5 = a4.buffer, u4 = a4.type, l4 = a4.bytesPerElement;
                  if (o4.isInterleavedBufferAttribute) {
                    const n3 = o4.data, a5 = n3.stride, h4 = o4.offset;
                    n3 && n3.isInstancedInterleavedBuffer ? (m2(r3, n3.meshPerAttribute), void 0 === s3._maxInstanceCount && (s3._maxInstanceCount = n3.meshPerAttribute * n3.count)) : f2(r3), t2.bindBuffer(34962, c5), v2(r3, i5, u4, e4, a5 * l4, h4 * l4);
                  } else o4.isInstancedBufferAttribute ? (m2(r3, o4.meshPerAttribute), void 0 === s3._maxInstanceCount && (s3._maxInstanceCount = o4.meshPerAttribute * o4.count)) : f2(r3), t2.bindBuffer(34962, c5), v2(r3, i5, u4, e4, 0, 0);
                } else if ("instanceMatrix" === e3) {
                  const e4 = n2.get(i4.instanceMatrix);
                  if (void 0 === e4) continue;
                  const o5 = e4.buffer, a4 = e4.type;
                  m2(r3 + 0, 1), m2(r3 + 1, 1), m2(r3 + 2, 1), m2(r3 + 3, 1), t2.bindBuffer(34962, o5), t2.vertexAttribPointer(r3 + 0, 4, a4, false, 64, 0), t2.vertexAttribPointer(r3 + 1, 4, a4, false, 64, 16), t2.vertexAttribPointer(r3 + 2, 4, a4, false, 64, 32), t2.vertexAttribPointer(r3 + 3, 4, a4, false, 64, 48);
                } else if ("instanceColor" === e3) {
                  const e4 = n2.get(i4.instanceColor);
                  if (void 0 === e4) continue;
                  const o5 = e4.buffer, a4 = e4.type;
                  m2(r3, 1), t2.bindBuffer(34962, o5), t2.vertexAttribPointer(r3, 3, a4, false, 12, 0);
                } else if (void 0 !== l3) {
                  const n3 = l3[e3];
                  if (void 0 !== n3) switch (n3.length) {
                    case 2:
                      t2.vertexAttrib2fv(r3, n3);
                      break;
                    case 3:
                      t2.vertexAttrib3fv(r3, n3);
                      break;
                    case 4:
                      t2.vertexAttrib4fv(r3, n3);
                      break;
                    default:
                      t2.vertexAttrib1fv(r3, n3);
                  }
                }
              }
            }
            g2();
          }(i3, c3, h3, y3), null !== x3 && t2.bindBuffer(34963, n2.get(x3).buffer));
        }, reset: y2, resetDefaultState: x2, dispose: function() {
          y2();
          for (const t3 in s2) {
            const e3 = s2[t3];
            for (const t4 in e3) {
              const n3 = e3[t4];
              for (const t5 in n3) h2(n3[t5].object), delete n3[t5];
              delete e3[t4];
            }
            delete s2[t3];
          }
        }, releaseStatesOfGeometry: function(t3) {
          if (void 0 === s2[t3.id]) return;
          const e3 = s2[t3.id];
          for (const t4 in e3) {
            const n3 = e3[t4];
            for (const t5 in n3) h2(n3[t5].object), delete n3[t5];
            delete e3[t4];
          }
          delete s2[t3.id];
        }, releaseStatesOfProgram: function(t3) {
          for (const e3 in s2) {
            const n3 = s2[e3];
            if (void 0 === n3[t3.id]) continue;
            const r3 = n3[t3.id];
            for (const t4 in r3) h2(r3[t4].object), delete r3[t4];
            delete n3[t3.id];
          }
        }, initAttributes: p2, enableAttribute: f2, disableUnusedAttributes: g2 };
      }
      function ko(t2, e2, n2, r2) {
        const i2 = r2.isWebGL2;
        let o2;
        this.setMode = function(t3) {
          o2 = t3;
        }, this.render = function(e3, r3) {
          t2.drawArrays(o2, e3, r3), n2.update(r3, o2, 1);
        }, this.renderInstances = function(r3, a2, s2) {
          if (0 === s2) return;
          let c2, u2;
          if (i2) c2 = t2, u2 = "drawArraysInstanced";
          else if (c2 = e2.get("ANGLE_instanced_arrays"), u2 = "drawArraysInstancedANGLE", null === c2) return void console.error("THREE.WebGLBufferRenderer: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays.");
          c2[u2](o2, r3, a2, s2), n2.update(a2, o2, s2);
        };
      }
      function Fo(t2, e2, n2) {
        let r2;
        function i2(e3) {
          if ("highp" === e3) {
            if (t2.getShaderPrecisionFormat(35633, 36338).precision > 0 && t2.getShaderPrecisionFormat(35632, 36338).precision > 0) return "highp";
            e3 = "mediump";
          }
          return "mediump" === e3 && t2.getShaderPrecisionFormat(35633, 36337).precision > 0 && t2.getShaderPrecisionFormat(35632, 36337).precision > 0 ? "mediump" : "lowp";
        }
        const o2 = "undefined" != typeof WebGL2RenderingContext && t2 instanceof WebGL2RenderingContext || "undefined" != typeof WebGL2ComputeRenderingContext && t2 instanceof WebGL2ComputeRenderingContext;
        let a2 = void 0 !== n2.precision ? n2.precision : "highp";
        const s2 = i2(a2);
        s2 !== a2 && (console.warn("THREE.WebGLRenderer:", a2, "not supported, using", s2, "instead."), a2 = s2);
        const c2 = true === n2.logarithmicDepthBuffer, u2 = t2.getParameter(34930), l2 = t2.getParameter(35660), h2 = t2.getParameter(3379), d2 = t2.getParameter(34076), p2 = t2.getParameter(34921), f2 = t2.getParameter(36347), m2 = t2.getParameter(36348), g2 = t2.getParameter(36349), v2 = l2 > 0, y2 = o2 || !!e2.get("OES_texture_float");
        return { isWebGL2: o2, getMaxAnisotropy: function() {
          if (void 0 !== r2) return r2;
          const n3 = e2.get("EXT_texture_filter_anisotropic");
          return r2 = null !== n3 ? t2.getParameter(n3.MAX_TEXTURE_MAX_ANISOTROPY_EXT) : 0, r2;
        }, getMaxPrecision: i2, precision: a2, logarithmicDepthBuffer: c2, maxTextures: u2, maxVertexTextures: l2, maxTextureSize: h2, maxCubemapSize: d2, maxAttributes: p2, maxVertexUniforms: f2, maxVaryings: m2, maxFragmentUniforms: g2, vertexTextures: v2, floatFragmentTextures: y2, floatVertexTextures: v2 && y2, maxSamples: o2 ? t2.getParameter(36183) : 0 };
      }
      function Bo(t2) {
        const e2 = this;
        let n2 = null, r2 = 0, i2 = false, o2 = false;
        const a2 = new ti(), s2 = new Gn(), c2 = { value: null, needsUpdate: false };
        function u2() {
          c2.value !== n2 && (c2.value = n2, c2.needsUpdate = r2 > 0), e2.numPlanes = r2, e2.numIntersection = 0;
        }
        function l2(t3, n3, r3, i3) {
          const o3 = null !== t3 ? t3.length : 0;
          let u3 = null;
          if (0 !== o3) {
            if (u3 = c2.value, true !== i3 || null === u3) {
              const e3 = r3 + 4 * o3, i4 = n3.matrixWorldInverse;
              s2.getNormalMatrix(i4), (null === u3 || u3.length < e3) && (u3 = new Float32Array(e3));
              for (let e4 = 0, n4 = r3; e4 !== o3; ++e4, n4 += 4) a2.copy(t3[e4]).applyMatrix4(i4, s2), a2.normal.toArray(u3, n4), u3[n4 + 3] = a2.constant;
            }
            c2.value = u3, c2.needsUpdate = true;
          }
          return e2.numPlanes = o3, e2.numIntersection = 0, u3;
        }
        this.uniform = c2, this.numPlanes = 0, this.numIntersection = 0, this.init = function(t3, e3, o3) {
          const a3 = 0 !== t3.length || e3 || 0 !== r2 || i2;
          return i2 = e3, n2 = l2(t3, o3, 0), r2 = t3.length, a3;
        }, this.beginShadows = function() {
          o2 = true, l2(null);
        }, this.endShadows = function() {
          o2 = false, u2();
        }, this.setState = function(e3, a3, s3) {
          const h2 = e3.clippingPlanes, d2 = e3.clipIntersection, p2 = e3.clipShadows, f2 = t2.get(e3);
          if (!i2 || null === h2 || 0 === h2.length || o2 && !p2) o2 ? l2(null) : u2();
          else {
            const t3 = o2 ? 0 : r2, e4 = 4 * t3;
            let i3 = f2.clippingState || null;
            c2.value = i3, i3 = l2(h2, a3, e4, s3);
            for (let t4 = 0; t4 !== e4; ++t4) i3[t4] = n2[t4];
            f2.clippingState = i3, this.numIntersection = d2 ? this.numPlanes : 0, this.numPlanes += t3;
          }
        };
      }
      function Ho(t2) {
        let e2 = /* @__PURE__ */ new WeakMap();
        function n2(t3, e3) {
          return e3 === st ? t3.mapping = ot : e3 === ct && (t3.mapping = at), t3;
        }
        function r2(t3) {
          const n3 = t3.target;
          n3.removeEventListener("dispose", r2);
          const i2 = e2.get(n3);
          void 0 !== i2 && (e2.delete(n3), i2.dispose());
        }
        return { get: function(i2) {
          if (i2 && i2.isTexture) {
            const o2 = i2.mapping;
            if (o2 === st || o2 === ct) {
              if (e2.has(i2)) {
                return n2(e2.get(i2).texture, i2.mapping);
              }
              {
                const o3 = i2.image;
                if (o3 && o3.height > 0) {
                  const a2 = t2.getRenderList(), s2 = t2.getRenderTarget(), c2 = new So(o3.height / 2);
                  return c2.fromEquirectangularTexture(t2, i2), e2.set(i2, c2), t2.setRenderTarget(s2), t2.setRenderList(a2), i2.addEventListener("dispose", r2), n2(c2.texture, i2.mapping);
                }
                return null;
              }
            }
          }
          return i2;
        }, dispose: function() {
          e2 = /* @__PURE__ */ new WeakMap();
        } };
      }
      function Go(t2) {
        const e2 = {};
        return { has: function(n2) {
          if (void 0 !== e2[n2]) return null !== e2[n2];
          let r2;
          switch (n2) {
            case "WEBGL_depth_texture":
              r2 = t2.getExtension("WEBGL_depth_texture") || t2.getExtension("MOZ_WEBGL_depth_texture") || t2.getExtension("WEBKIT_WEBGL_depth_texture");
              break;
            case "EXT_texture_filter_anisotropic":
              r2 = t2.getExtension("EXT_texture_filter_anisotropic") || t2.getExtension("MOZ_EXT_texture_filter_anisotropic") || t2.getExtension("WEBKIT_EXT_texture_filter_anisotropic");
              break;
            case "WEBGL_compressed_texture_s3tc":
              r2 = t2.getExtension("WEBGL_compressed_texture_s3tc") || t2.getExtension("MOZ_WEBGL_compressed_texture_s3tc") || t2.getExtension("WEBKIT_WEBGL_compressed_texture_s3tc");
              break;
            case "WEBGL_compressed_texture_pvrtc":
              r2 = t2.getExtension("WEBGL_compressed_texture_pvrtc") || t2.getExtension("WEBKIT_WEBGL_compressed_texture_pvrtc");
              break;
            default:
              r2 = t2.getExtension(n2);
          }
          return e2[n2] = r2, null !== r2;
        }, get: function(t3) {
          return this.has(t3) || console.warn("THREE.WebGLRenderer: " + t3 + " extension not supported."), e2[t3];
        } };
      }
      function Uo(t2, e2, n2, r2) {
        const i2 = /* @__PURE__ */ new WeakMap(), o2 = /* @__PURE__ */ new WeakMap();
        function a2(t3) {
          const s3 = t3.target, c2 = i2.get(s3);
          null !== c2.index && e2.remove(c2.index);
          for (const t4 in c2.attributes) e2.remove(c2.attributes[t4]);
          s3.removeEventListener("dispose", a2), i2.delete(s3);
          const u2 = o2.get(c2);
          u2 && (e2.remove(u2), o2.delete(c2)), r2.releaseStatesOfGeometry(c2), true === s3.isInstancedBufferGeometry && delete s3._maxInstanceCount, n2.memory.geometries--;
        }
        function s2(t3) {
          const n3 = [], r3 = t3.index, i3 = t3.attributes.position;
          let a3 = 0;
          if (null !== r3) {
            const t4 = r3.array;
            a3 = r3.version;
            for (let e3 = 0, r4 = t4.length; e3 < r4; e3 += 3) {
              const r5 = t4[e3 + 0], i4 = t4[e3 + 1], o3 = t4[e3 + 2];
              n3.push(r5, i4, i4, o3, o3, r5);
            }
          } else {
            const t4 = i3.array;
            a3 = i3.version;
            for (let e3 = 0, r4 = t4.length / 3 - 1; e3 < r4; e3 += 3) {
              const t5 = e3 + 0, r5 = e3 + 1, i4 = e3 + 2;
              n3.push(t5, r5, r5, i4, i4, t5);
            }
          }
          const s3 = new (ki(n3) > 65535 ? Oi : Pi)(n3, 1);
          s3.version = a3;
          const c2 = o2.get(t3);
          c2 && e2.remove(c2), o2.set(t3, s3);
        }
        return { get: function(t3, e3) {
          let r3 = i2.get(e3);
          return r3 || (e3.addEventListener("dispose", a2), e3.isBufferGeometry ? r3 = e3 : e3.isGeometry && (void 0 === e3._bufferGeometry && (e3._bufferGeometry = new Xi().setFromObject(t3)), r3 = e3._bufferGeometry), i2.set(e3, r3), n2.memory.geometries++, r3);
        }, update: function(t3) {
          const n3 = t3.attributes;
          for (const t4 in n3) e2.update(n3[t4], 34962);
          const r3 = t3.morphAttributes;
          for (const t4 in r3) {
            const n4 = r3[t4];
            for (let t5 = 0, r4 = n4.length; t5 < r4; t5++) e2.update(n4[t5], 34962);
          }
        }, getWireframeAttribute: function(t3) {
          const e3 = o2.get(t3);
          if (e3) {
            const n3 = t3.index;
            null !== n3 && e3.version < n3.version && s2(t3);
          } else s2(t3);
          return o2.get(t3);
        } };
      }
      function jo(t2, e2, n2, r2) {
        const i2 = r2.isWebGL2;
        let o2, a2, s2;
        this.setMode = function(t3) {
          o2 = t3;
        }, this.setIndex = function(t3) {
          a2 = t3.type, s2 = t3.bytesPerElement;
        }, this.render = function(e3, r3) {
          t2.drawElements(o2, r3, a2, e3 * s2), n2.update(r3, o2, 1);
        }, this.renderInstances = function(r3, c2, u2) {
          if (0 === u2) return;
          let l2, h2;
          if (i2) l2 = t2, h2 = "drawElementsInstanced";
          else if (l2 = e2.get("ANGLE_instanced_arrays"), h2 = "drawElementsInstancedANGLE", null === l2) return void console.error("THREE.WebGLIndexedBufferRenderer: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays.");
          l2[h2](o2, c2, a2, r3 * s2, u2), n2.update(c2, o2, u2);
        };
      }
      function Vo(t2) {
        const e2 = { frame: 0, calls: 0, triangles: 0, points: 0, lines: 0 };
        return { memory: { geometries: 0, textures: 0 }, render: e2, programs: null, autoReset: true, reset: function() {
          e2.frame++, e2.calls = 0, e2.triangles = 0, e2.points = 0, e2.lines = 0;
        }, update: function(t3, n2, r2) {
          switch (e2.calls++, n2) {
            case 4:
              e2.triangles += r2 * (t3 / 3);
              break;
            case 1:
              e2.lines += r2 * (t3 / 2);
              break;
            case 3:
              e2.lines += r2 * (t3 - 1);
              break;
            case 2:
              e2.lines += r2 * t3;
              break;
            case 0:
              e2.points += r2 * t3;
              break;
            default:
              console.error("THREE.WebGLInfo: Unknown draw mode:", n2);
          }
        } };
      }
      function Wo(t2, e2) {
        return t2[0] - e2[0];
      }
      function qo(t2, e2) {
        return Math.abs(e2[1]) - Math.abs(t2[1]);
      }
      function Xo(t2) {
        const e2 = {}, n2 = new Float32Array(8), r2 = [];
        for (let t3 = 0; t3 < 8; t3++) r2[t3] = [t3, 0];
        return { update: function(i2, o2, a2, s2) {
          const c2 = i2.morphTargetInfluences, u2 = void 0 === c2 ? 0 : c2.length;
          let l2 = e2[o2.id];
          if (void 0 === l2) {
            l2 = [];
            for (let t3 = 0; t3 < u2; t3++) l2[t3] = [t3, 0];
            e2[o2.id] = l2;
          }
          for (let t3 = 0; t3 < u2; t3++) {
            const e3 = l2[t3];
            e3[0] = t3, e3[1] = c2[t3];
          }
          l2.sort(qo);
          for (let t3 = 0; t3 < 8; t3++) t3 < u2 && l2[t3][1] ? (r2[t3][0] = l2[t3][0], r2[t3][1] = l2[t3][1]) : (r2[t3][0] = Number.MAX_SAFE_INTEGER, r2[t3][1] = 0);
          r2.sort(Wo);
          const h2 = a2.morphTargets && o2.morphAttributes.position, d2 = a2.morphNormals && o2.morphAttributes.normal;
          let p2 = 0;
          for (let t3 = 0; t3 < 8; t3++) {
            const e3 = r2[t3], i3 = e3[0], a3 = e3[1];
            i3 !== Number.MAX_SAFE_INTEGER && a3 ? (h2 && o2.getAttribute("morphTarget" + t3) !== h2[i3] && o2.setAttribute("morphTarget" + t3, h2[i3]), d2 && o2.getAttribute("morphNormal" + t3) !== d2[i3] && o2.setAttribute("morphNormal" + t3, d2[i3]), n2[t3] = a3, p2 += a3) : (h2 && true === o2.hasAttribute("morphTarget" + t3) && o2.deleteAttribute("morphTarget" + t3), d2 && true === o2.hasAttribute("morphNormal" + t3) && o2.deleteAttribute("morphNormal" + t3), n2[t3] = 0);
          }
          const f2 = o2.morphTargetsRelative ? 1 : 1 - p2;
          s2.getUniforms().setValue(t2, "morphTargetBaseInfluence", f2), s2.getUniforms().setValue(t2, "morphTargetInfluences", n2);
        } };
      }
      function Yo(t2, e2, n2, r2) {
        let i2 = /* @__PURE__ */ new WeakMap();
        function o2(t3) {
          const e3 = t3.target;
          e3.removeEventListener("dispose", o2), n2.remove(e3.instanceMatrix), null !== e3.instanceColor && n2.remove(e3.instanceColor);
        }
        return { update: function(t3) {
          const a2 = r2.render.frame, s2 = t3.geometry, c2 = e2.get(t3, s2);
          return i2.get(c2) !== a2 && (s2.isGeometry && c2.updateFromObject(t3), e2.update(c2), i2.set(c2, a2)), t3.isInstancedMesh && (false === t3.hasEventListener("dispose", o2) && t3.addEventListener("dispose", o2), n2.update(t3.instanceMatrix, 34962), null !== t3.instanceColor && n2.update(t3.instanceColor, 34962)), c2;
        }, dispose: function() {
          i2 = /* @__PURE__ */ new WeakMap();
        } };
      }
      function Zo(t2 = null, e2 = 1, n2 = 1, r2 = 1) {
        Wn.call(this, null), this.image = { data: t2, width: e2, height: n2, depth: r2 }, this.magFilter = ft, this.minFilter = ft, this.wrapR = dt, this.generateMipmaps = false, this.flipY = false, this.needsUpdate = true;
      }
      function Jo(t2 = null, e2 = 1, n2 = 1, r2 = 1) {
        Wn.call(this, null), this.image = { data: t2, width: e2, height: n2, depth: r2 }, this.magFilter = ft, this.minFilter = ft, this.wrapR = dt, this.generateMipmaps = false, this.flipY = false, this.needsUpdate = true;
      }
      Io.physical = { uniforms: vo([Io.standard.uniforms, { clearcoat: { value: 0 }, clearcoatMap: { value: null }, clearcoatRoughness: { value: 0 }, clearcoatRoughnessMap: { value: null }, clearcoatNormalScale: { value: new Hn(1, 1) }, clearcoatNormalMap: { value: null }, sheen: { value: new yi(0) }, transmission: { value: 0 }, transmissionMap: { value: null } }]), vertexShader: Oo.meshphysical_vert, fragmentShader: Oo.meshphysical_frag }, Zo.prototype = Object.create(Wn.prototype), Zo.prototype.constructor = Zo, Zo.prototype.isDataTexture2DArray = true, Jo.prototype = Object.create(Wn.prototype), Jo.prototype.constructor = Jo, Jo.prototype.isDataTexture3D = true;
      const $o = new Wn(), Qo = new Zo(), Ko = new Jo(), ta = new Mo(), ea = [], na = [], ra = new Float32Array(16), ia = new Float32Array(9), oa = new Float32Array(4);
      function aa(t2, e2, n2) {
        const r2 = t2[0];
        if (r2 <= 0 || r2 > 0) return t2;
        const i2 = e2 * n2;
        let o2 = ea[i2];
        if (void 0 === o2 && (o2 = new Float32Array(i2), ea[i2] = o2), 0 !== e2) {
          r2.toArray(o2, 0);
          for (let r3 = 1, i3 = 0; r3 !== e2; ++r3) i3 += n2, t2[r3].toArray(o2, i3);
        }
        return o2;
      }
      function sa(t2, e2) {
        if (t2.length !== e2.length) return false;
        for (let n2 = 0, r2 = t2.length; n2 < r2; n2++) if (t2[n2] !== e2[n2]) return false;
        return true;
      }
      function ca(t2, e2) {
        for (let n2 = 0, r2 = e2.length; n2 < r2; n2++) t2[n2] = e2[n2];
      }
      function ua(t2, e2) {
        let n2 = na[e2];
        void 0 === n2 && (n2 = new Int32Array(e2), na[e2] = n2);
        for (let r2 = 0; r2 !== e2; ++r2) n2[r2] = t2.allocateTextureUnit();
        return n2;
      }
      function la(t2, e2) {
        const n2 = this.cache;
        n2[0] !== e2 && (t2.uniform1f(this.addr, e2), n2[0] = e2);
      }
      function ha(t2, e2) {
        const n2 = this.cache;
        if (void 0 !== e2.x) n2[0] === e2.x && n2[1] === e2.y || (t2.uniform2f(this.addr, e2.x, e2.y), n2[0] = e2.x, n2[1] = e2.y);
        else {
          if (sa(n2, e2)) return;
          t2.uniform2fv(this.addr, e2), ca(n2, e2);
        }
      }
      function da(t2, e2) {
        const n2 = this.cache;
        if (void 0 !== e2.x) n2[0] === e2.x && n2[1] === e2.y && n2[2] === e2.z || (t2.uniform3f(this.addr, e2.x, e2.y, e2.z), n2[0] = e2.x, n2[1] = e2.y, n2[2] = e2.z);
        else if (void 0 !== e2.r) n2[0] === e2.r && n2[1] === e2.g && n2[2] === e2.b || (t2.uniform3f(this.addr, e2.r, e2.g, e2.b), n2[0] = e2.r, n2[1] = e2.g, n2[2] = e2.b);
        else {
          if (sa(n2, e2)) return;
          t2.uniform3fv(this.addr, e2), ca(n2, e2);
        }
      }
      function pa(t2, e2) {
        const n2 = this.cache;
        if (void 0 !== e2.x) n2[0] === e2.x && n2[1] === e2.y && n2[2] === e2.z && n2[3] === e2.w || (t2.uniform4f(this.addr, e2.x, e2.y, e2.z, e2.w), n2[0] = e2.x, n2[1] = e2.y, n2[2] = e2.z, n2[3] = e2.w);
        else {
          if (sa(n2, e2)) return;
          t2.uniform4fv(this.addr, e2), ca(n2, e2);
        }
      }
      function fa(t2, e2) {
        const n2 = this.cache, r2 = e2.elements;
        if (void 0 === r2) {
          if (sa(n2, e2)) return;
          t2.uniformMatrix2fv(this.addr, false, e2), ca(n2, e2);
        } else {
          if (sa(n2, r2)) return;
          oa.set(r2), t2.uniformMatrix2fv(this.addr, false, oa), ca(n2, r2);
        }
      }
      function ma(t2, e2) {
        const n2 = this.cache, r2 = e2.elements;
        if (void 0 === r2) {
          if (sa(n2, e2)) return;
          t2.uniformMatrix3fv(this.addr, false, e2), ca(n2, e2);
        } else {
          if (sa(n2, r2)) return;
          ia.set(r2), t2.uniformMatrix3fv(this.addr, false, ia), ca(n2, r2);
        }
      }
      function ga(t2, e2) {
        const n2 = this.cache, r2 = e2.elements;
        if (void 0 === r2) {
          if (sa(n2, e2)) return;
          t2.uniformMatrix4fv(this.addr, false, e2), ca(n2, e2);
        } else {
          if (sa(n2, r2)) return;
          ra.set(r2), t2.uniformMatrix4fv(this.addr, false, ra), ca(n2, r2);
        }
      }
      function va(t2, e2, n2) {
        const r2 = this.cache, i2 = n2.allocateTextureUnit();
        r2[0] !== i2 && (t2.uniform1i(this.addr, i2), r2[0] = i2), n2.safeSetTexture2D(e2 || $o, i2);
      }
      function ya(t2, e2, n2) {
        const r2 = this.cache, i2 = n2.allocateTextureUnit();
        r2[0] !== i2 && (t2.uniform1i(this.addr, i2), r2[0] = i2), n2.setTexture2DArray(e2 || Qo, i2);
      }
      function xa(t2, e2, n2) {
        const r2 = this.cache, i2 = n2.allocateTextureUnit();
        r2[0] !== i2 && (t2.uniform1i(this.addr, i2), r2[0] = i2), n2.setTexture3D(e2 || Ko, i2);
      }
      function ba(t2, e2, n2) {
        const r2 = this.cache, i2 = n2.allocateTextureUnit();
        r2[0] !== i2 && (t2.uniform1i(this.addr, i2), r2[0] = i2), n2.safeSetTextureCube(e2 || ta, i2);
      }
      function wa(t2, e2) {
        const n2 = this.cache;
        n2[0] !== e2 && (t2.uniform1i(this.addr, e2), n2[0] = e2);
      }
      function _a(t2, e2) {
        const n2 = this.cache;
        sa(n2, e2) || (t2.uniform2iv(this.addr, e2), ca(n2, e2));
      }
      function Ma(t2, e2) {
        const n2 = this.cache;
        sa(n2, e2) || (t2.uniform3iv(this.addr, e2), ca(n2, e2));
      }
      function Sa(t2, e2) {
        const n2 = this.cache;
        sa(n2, e2) || (t2.uniform4iv(this.addr, e2), ca(n2, e2));
      }
      function Ta(t2, e2) {
        const n2 = this.cache;
        n2[0] !== e2 && (t2.uniform1ui(this.addr, e2), n2[0] = e2);
      }
      function Ea(t2, e2) {
        t2.uniform1fv(this.addr, e2);
      }
      function Aa(t2, e2) {
        t2.uniform1iv(this.addr, e2);
      }
      function Ca(t2, e2) {
        t2.uniform2iv(this.addr, e2);
      }
      function La(t2, e2) {
        t2.uniform3iv(this.addr, e2);
      }
      function Pa(t2, e2) {
        t2.uniform4iv(this.addr, e2);
      }
      function Ra(t2, e2) {
        const n2 = aa(e2, this.size, 2);
        t2.uniform2fv(this.addr, n2);
      }
      function Oa(t2, e2) {
        const n2 = aa(e2, this.size, 3);
        t2.uniform3fv(this.addr, n2);
      }
      function Da(t2, e2) {
        const n2 = aa(e2, this.size, 4);
        t2.uniform4fv(this.addr, n2);
      }
      function Ia(t2, e2) {
        const n2 = aa(e2, this.size, 4);
        t2.uniformMatrix2fv(this.addr, false, n2);
      }
      function Na(t2, e2) {
        const n2 = aa(e2, this.size, 9);
        t2.uniformMatrix3fv(this.addr, false, n2);
      }
      function za(t2, e2) {
        const n2 = aa(e2, this.size, 16);
        t2.uniformMatrix4fv(this.addr, false, n2);
      }
      function ka(t2, e2, n2) {
        const r2 = e2.length, i2 = ua(n2, r2);
        t2.uniform1iv(this.addr, i2);
        for (let t3 = 0; t3 !== r2; ++t3) n2.safeSetTexture2D(e2[t3] || $o, i2[t3]);
      }
      function Fa(t2, e2, n2) {
        const r2 = e2.length, i2 = ua(n2, r2);
        t2.uniform1iv(this.addr, i2);
        for (let t3 = 0; t3 !== r2; ++t3) n2.safeSetTextureCube(e2[t3] || ta, i2[t3]);
      }
      function Ba(t2, e2, n2) {
        this.id = t2, this.addr = n2, this.cache = [], this.setValue = function(t3) {
          switch (t3) {
            case 5126:
              return la;
            case 35664:
              return ha;
            case 35665:
              return da;
            case 35666:
              return pa;
            case 35674:
              return fa;
            case 35675:
              return ma;
            case 35676:
              return ga;
            case 5124:
            case 35670:
              return wa;
            case 35667:
            case 35671:
              return _a;
            case 35668:
            case 35672:
              return Ma;
            case 35669:
            case 35673:
              return Sa;
            case 5125:
              return Ta;
            case 35678:
            case 36198:
            case 36298:
            case 36306:
            case 35682:
              return va;
            case 35679:
            case 36299:
            case 36307:
              return xa;
            case 35680:
            case 36300:
            case 36308:
            case 36293:
              return ba;
            case 36289:
            case 36303:
            case 36311:
            case 36292:
              return ya;
          }
        }(e2.type);
      }
      function Ha(t2, e2, n2) {
        this.id = t2, this.addr = n2, this.cache = [], this.size = e2.size, this.setValue = function(t3) {
          switch (t3) {
            case 5126:
              return Ea;
            case 35664:
              return Ra;
            case 35665:
              return Oa;
            case 35666:
              return Da;
            case 35674:
              return Ia;
            case 35675:
              return Na;
            case 35676:
              return za;
            case 5124:
            case 35670:
              return Aa;
            case 35667:
            case 35671:
              return Ca;
            case 35668:
            case 35672:
              return La;
            case 35669:
            case 35673:
              return Pa;
            case 35678:
            case 36198:
            case 36298:
            case 36306:
            case 35682:
              return ka;
            case 35680:
            case 36300:
            case 36308:
            case 36293:
              return Fa;
          }
        }(e2.type);
      }
      function Ga(t2) {
        this.id = t2, this.seq = [], this.map = {};
      }
      Ha.prototype.updateCache = function(t2) {
        const e2 = this.cache;
        t2 instanceof Float32Array && e2.length !== t2.length && (this.cache = new Float32Array(t2.length)), ca(e2, t2);
      }, Ga.prototype.setValue = function(t2, e2, n2) {
        const r2 = this.seq;
        for (let i2 = 0, o2 = r2.length; i2 !== o2; ++i2) {
          const o3 = r2[i2];
          o3.setValue(t2, e2[o3.id], n2);
        }
      };
      const Ua = /(\w+)(\])?(\[|\.)?/g;
      function ja(t2, e2) {
        t2.seq.push(e2), t2.map[e2.id] = e2;
      }
      function Va(t2, e2, n2) {
        const r2 = t2.name, i2 = r2.length;
        for (Ua.lastIndex = 0; ; ) {
          const o2 = Ua.exec(r2), a2 = Ua.lastIndex;
          let s2 = o2[1];
          const c2 = "]" === o2[2], u2 = o2[3];
          if (c2 && (s2 |= 0), void 0 === u2 || "[" === u2 && a2 + 2 === i2) {
            ja(n2, void 0 === u2 ? new Ba(s2, t2, e2) : new Ha(s2, t2, e2));
            break;
          }
          {
            let t3 = n2.map[s2];
            void 0 === t3 && (t3 = new Ga(s2), ja(n2, t3)), n2 = t3;
          }
        }
      }
      function Wa(t2, e2) {
        this.seq = [], this.map = {};
        const n2 = t2.getProgramParameter(e2, 35718);
        for (let r2 = 0; r2 < n2; ++r2) {
          const n3 = t2.getActiveUniform(e2, r2);
          Va(n3, t2.getUniformLocation(e2, n3.name), this);
        }
      }
      function qa(t2, e2, n2) {
        const r2 = t2.createShader(e2);
        return t2.shaderSource(r2, n2), t2.compileShader(r2), r2;
      }
      Wa.prototype.setValue = function(t2, e2, n2, r2) {
        const i2 = this.map[e2];
        void 0 !== i2 && i2.setValue(t2, n2, r2);
      }, Wa.prototype.setOptional = function(t2, e2, n2) {
        const r2 = e2[n2];
        void 0 !== r2 && this.setValue(t2, n2, r2);
      }, Wa.upload = function(t2, e2, n2, r2) {
        for (let i2 = 0, o2 = e2.length; i2 !== o2; ++i2) {
          const o3 = e2[i2], a2 = n2[o3.id];
          false !== a2.needsUpdate && o3.setValue(t2, a2.value, r2);
        }
      }, Wa.seqWithValue = function(t2, e2) {
        const n2 = [];
        for (let r2 = 0, i2 = t2.length; r2 !== i2; ++r2) {
          const i3 = t2[r2];
          i3.id in e2 && n2.push(i3);
        }
        return n2;
      };
      let Xa = 0;
      function Ya(t2) {
        switch (t2) {
          case Je:
            return ["Linear", "( value )"];
          case $e:
            return ["sRGB", "( value )"];
          case Ke:
            return ["RGBE", "( value )"];
          case en:
            return ["RGBM", "( value, 7.0 )"];
          case nn:
            return ["RGBM", "( value, 16.0 )"];
          case rn:
            return ["RGBD", "( value, 256.0 )"];
          case Qe:
            return ["Gamma", "( value, float( GAMMA_FACTOR ) )"];
          case tn:
            return ["LogLuv", "( value )"];
          default:
            return console.warn("THREE.WebGLProgram: Unsupported encoding:", t2), ["Linear", "( value )"];
        }
      }
      function Za(t2, e2, n2) {
        const r2 = t2.getShaderParameter(e2, 35713), i2 = t2.getShaderInfoLog(e2).trim();
        if (r2 && "" === i2) return "";
        return "THREE.WebGLShader: gl.getShaderInfoLog() " + n2 + "\n" + i2 + function(t3) {
          const e3 = t3.split("\n");
          for (let t4 = 0; t4 < e3.length; t4++) e3[t4] = t4 + 1 + ": " + e3[t4];
          return e3.join("\n");
        }(t2.getShaderSource(e2));
      }
      function Ja(t2, e2) {
        const n2 = Ya(e2);
        return "vec4 " + t2 + "( vec4 value ) { return " + n2[0] + "ToLinear" + n2[1] + "; }";
      }
      function $a(t2, e2) {
        const n2 = Ya(e2);
        return "vec4 " + t2 + "( vec4 value ) { return LinearTo" + n2[0] + n2[1] + "; }";
      }
      function Qa(t2, e2) {
        let n2;
        switch (e2) {
          case K:
            n2 = "Linear";
            break;
          case tt:
            n2 = "Reinhard";
            break;
          case et:
            n2 = "OptimizedCineon";
            break;
          case nt:
            n2 = "ACESFilmic";
            break;
          case rt:
            n2 = "Custom";
            break;
          default:
            console.warn("THREE.WebGLProgram: Unsupported toneMapping:", e2), n2 = "Linear";
        }
        return "vec3 " + t2 + "( vec3 color ) { return " + n2 + "ToneMapping( color ); }";
      }
      function Ka(t2) {
        return "" !== t2;
      }
      function ts(t2, e2) {
        return t2.replace(/NUM_DIR_LIGHTS/g, e2.numDirLights).replace(/NUM_SPOT_LIGHTS/g, e2.numSpotLights).replace(/NUM_RECT_AREA_LIGHTS/g, e2.numRectAreaLights).replace(/NUM_POINT_LIGHTS/g, e2.numPointLights).replace(/NUM_HEMI_LIGHTS/g, e2.numHemiLights).replace(/NUM_DIR_LIGHT_SHADOWS/g, e2.numDirLightShadows).replace(/NUM_SPOT_LIGHT_SHADOWS/g, e2.numSpotLightShadows).replace(/NUM_POINT_LIGHT_SHADOWS/g, e2.numPointLightShadows);
      }
      function es(t2, e2) {
        return t2.replace(/NUM_CLIPPING_PLANES/g, e2.numClippingPlanes).replace(/UNION_CLIPPING_PLANES/g, e2.numClippingPlanes - e2.numClipIntersection);
      }
      const ns = /^[ \t]*#include +<([\w\d./]+)>/gm;
      function rs(t2) {
        return t2.replace(ns, is);
      }
      function is(t2, e2) {
        const n2 = Oo[e2];
        if (void 0 === n2) throw new Error("Can not resolve #include <" + e2 + ">");
        return rs(n2);
      }
      const os = /#pragma unroll_loop[\s]+?for \( int i \= (\d+)\; i < (\d+)\; i \+\+ \) \{([\s\S]+?)(?=\})\}/g, as = /#pragma unroll_loop_start\s+for\s*\(\s*int\s+i\s*=\s*(\d+)\s*;\s*i\s*<\s*(\d+)\s*;\s*i\s*\+\+\s*\)\s*{([\s\S]+?)}\s+#pragma unroll_loop_end/g;
      function ss(t2) {
        return t2.replace(as, us).replace(os, cs);
      }
      function cs(t2, e2, n2, r2) {
        return console.warn("WebGLProgram: #pragma unroll_loop shader syntax is deprecated. Please use #pragma unroll_loop_start syntax instead."), us(t2, e2, n2, r2);
      }
      function us(t2, e2, n2, r2) {
        let i2 = "";
        for (let t3 = parseInt(e2); t3 < parseInt(n2); t3++) i2 += r2.replace(/\[\s*i\s*\]/g, "[ " + t3 + " ]").replace(/UNROLLED_LOOP_INDEX/g, t3);
        return i2;
      }
      function ls(t2) {
        let e2 = "precision " + t2.precision + " float;\nprecision " + t2.precision + " int;";
        return "highp" === t2.precision ? e2 += "\n#define HIGH_PRECISION" : "mediump" === t2.precision ? e2 += "\n#define MEDIUM_PRECISION" : "lowp" === t2.precision && (e2 += "\n#define LOW_PRECISION"), e2;
      }
      function hs(t2, e2, n2, r2) {
        const i2 = t2.getContext(), o2 = n2.defines;
        let a2 = n2.vertexShader, s2 = n2.fragmentShader;
        const c2 = function(t3) {
          let e3 = "SHADOWMAP_TYPE_BASIC";
          return t3.shadowMapType === h ? e3 = "SHADOWMAP_TYPE_PCF" : t3.shadowMapType === d ? e3 = "SHADOWMAP_TYPE_PCF_SOFT" : t3.shadowMapType === p && (e3 = "SHADOWMAP_TYPE_VSM"), e3;
        }(n2), u2 = function(t3) {
          let e3 = "ENVMAP_TYPE_CUBE";
          if (t3.envMap) switch (t3.envMapMode) {
            case ot:
            case at:
              e3 = "ENVMAP_TYPE_CUBE";
              break;
            case ut:
            case lt:
              e3 = "ENVMAP_TYPE_CUBE_UV";
          }
          return e3;
        }(n2), l2 = function(t3) {
          let e3 = "ENVMAP_MODE_REFLECTION";
          if (t3.envMap) switch (t3.envMapMode) {
            case at:
            case lt:
              e3 = "ENVMAP_MODE_REFRACTION";
          }
          return e3;
        }(n2), f2 = function(t3) {
          let e3 = "ENVMAP_BLENDING_NONE";
          if (t3.envMap) switch (t3.combine) {
            case Z:
              e3 = "ENVMAP_BLENDING_MULTIPLY";
              break;
            case J:
              e3 = "ENVMAP_BLENDING_MIX";
              break;
            case $:
              e3 = "ENVMAP_BLENDING_ADD";
          }
          return e3;
        }(n2), m2 = t2.gammaFactor > 0 ? t2.gammaFactor : 1, g2 = n2.isWebGL2 ? "" : function(t3) {
          return [t3.extensionDerivatives || t3.envMapCubeUV || t3.bumpMap || t3.tangentSpaceNormalMap || t3.clearcoatNormalMap || t3.flatShading || "physical" === t3.shaderID ? "#extension GL_OES_standard_derivatives : enable" : "", (t3.extensionFragDepth || t3.logarithmicDepthBuffer) && t3.rendererExtensionFragDepth ? "#extension GL_EXT_frag_depth : enable" : "", t3.extensionDrawBuffers && t3.rendererExtensionDrawBuffers ? "#extension GL_EXT_draw_buffers : require" : "", (t3.extensionShaderTextureLOD || t3.envMap) && t3.rendererExtensionShaderTextureLod ? "#extension GL_EXT_shader_texture_lod : enable" : ""].filter(Ka).join("\n");
        }(n2), v2 = function(t3) {
          const e3 = [];
          for (const n3 in t3) {
            const r3 = t3[n3];
            false !== r3 && e3.push("#define " + n3 + " " + r3);
          }
          return e3.join("\n");
        }(o2), y2 = i2.createProgram();
        let x2, b2, w2 = n2.glslVersion ? "#version " + n2.glslVersion + "\n" : "";
        n2.isRawShaderMaterial ? (x2 = [v2].filter(Ka).join("\n"), x2.length > 0 && (x2 += "\n"), b2 = [g2, v2].filter(Ka).join("\n"), b2.length > 0 && (b2 += "\n")) : (x2 = [ls(n2), "#define SHADER_NAME " + n2.shaderName, v2, n2.instancing ? "#define USE_INSTANCING" : "", n2.instancingColor ? "#define USE_INSTANCING_COLOR" : "", n2.supportsVertexTextures ? "#define VERTEX_TEXTURES" : "", "#define GAMMA_FACTOR " + m2, "#define MAX_BONES " + n2.maxBones, n2.useFog && n2.fog ? "#define USE_FOG" : "", n2.useFog && n2.fogExp2 ? "#define FOG_EXP2" : "", n2.map ? "#define USE_MAP" : "", n2.envMap ? "#define USE_ENVMAP" : "", n2.envMap ? "#define " + l2 : "", n2.lightMap ? "#define USE_LIGHTMAP" : "", n2.aoMap ? "#define USE_AOMAP" : "", n2.emissiveMap ? "#define USE_EMISSIVEMAP" : "", n2.bumpMap ? "#define USE_BUMPMAP" : "", n2.normalMap ? "#define USE_NORMALMAP" : "", n2.normalMap && n2.objectSpaceNormalMap ? "#define OBJECTSPACE_NORMALMAP" : "", n2.normalMap && n2.tangentSpaceNormalMap ? "#define TANGENTSPACE_NORMALMAP" : "", n2.clearcoatMap ? "#define USE_CLEARCOATMAP" : "", n2.clearcoatRoughnessMap ? "#define USE_CLEARCOAT_ROUGHNESSMAP" : "", n2.clearcoatNormalMap ? "#define USE_CLEARCOAT_NORMALMAP" : "", n2.displacementMap && n2.supportsVertexTextures ? "#define USE_DISPLACEMENTMAP" : "", n2.specularMap ? "#define USE_SPECULARMAP" : "", n2.roughnessMap ? "#define USE_ROUGHNESSMAP" : "", n2.metalnessMap ? "#define USE_METALNESSMAP" : "", n2.alphaMap ? "#define USE_ALPHAMAP" : "", n2.transmissionMap ? "#define USE_TRANSMISSIONMAP" : "", n2.vertexTangents ? "#define USE_TANGENT" : "", n2.vertexColors ? "#define USE_COLOR" : "", n2.vertexUvs ? "#define USE_UV" : "", n2.uvsVertexOnly ? "#define UVS_VERTEX_ONLY" : "", n2.flatShading ? "#define FLAT_SHADED" : "", n2.skinning ? "#define USE_SKINNING" : "", n2.useVertexTexture ? "#define BONE_TEXTURE" : "", n2.morphTargets ? "#define USE_MORPHTARGETS" : "", n2.morphNormals && false === n2.flatShading ? "#define USE_MORPHNORMALS" : "", n2.doubleSided ? "#define DOUBLE_SIDED" : "", n2.flipSided ? "#define FLIP_SIDED" : "", n2.shadowMapEnabled ? "#define USE_SHADOWMAP" : "", n2.shadowMapEnabled ? "#define " + c2 : "", n2.sizeAttenuation ? "#define USE_SIZEATTENUATION" : "", n2.logarithmicDepthBuffer ? "#define USE_LOGDEPTHBUF" : "", n2.logarithmicDepthBuffer && n2.rendererExtensionFragDepth ? "#define USE_LOGDEPTHBUF_EXT" : "", "uniform mat4 modelMatrix;", "uniform mat4 modelViewMatrix;", "uniform mat4 projectionMatrix;", "uniform mat4 viewMatrix;", "uniform mat3 normalMatrix;", "uniform vec3 cameraPosition;", "uniform bool isOrthographic;", "#ifdef USE_INSTANCING", "	attribute mat4 instanceMatrix;", "#endif", "#ifdef USE_INSTANCING_COLOR", "	attribute vec3 instanceColor;", "#endif", "attribute vec3 position;", "attribute vec3 normal;", "attribute vec2 uv;", "#ifdef USE_TANGENT", "	attribute vec4 tangent;", "#endif", "#ifdef USE_COLOR", "	attribute vec3 color;", "#endif", "#ifdef USE_MORPHTARGETS", "	attribute vec3 morphTarget0;", "	attribute vec3 morphTarget1;", "	attribute vec3 morphTarget2;", "	attribute vec3 morphTarget3;", "	#ifdef USE_MORPHNORMALS", "		attribute vec3 morphNormal0;", "		attribute vec3 morphNormal1;", "		attribute vec3 morphNormal2;", "		attribute vec3 morphNormal3;", "	#else", "		attribute vec3 morphTarget4;", "		attribute vec3 morphTarget5;", "		attribute vec3 morphTarget6;", "		attribute vec3 morphTarget7;", "	#endif", "#endif", "#ifdef USE_SKINNING", "	attribute vec4 skinIndex;", "	attribute vec4 skinWeight;", "#endif", "\n"].filter(Ka).join("\n"), b2 = [g2, ls(n2), "#define SHADER_NAME " + n2.shaderName, v2, n2.alphaTest ? "#define ALPHATEST " + n2.alphaTest + (n2.alphaTest % 1 ? "" : ".0") : "", "#define GAMMA_FACTOR " + m2, n2.useFog && n2.fog ? "#define USE_FOG" : "", n2.useFog && n2.fogExp2 ? "#define FOG_EXP2" : "", n2.map ? "#define USE_MAP" : "", n2.matcap ? "#define USE_MATCAP" : "", n2.envMap ? "#define USE_ENVMAP" : "", n2.envMap ? "#define " + u2 : "", n2.envMap ? "#define " + l2 : "", n2.envMap ? "#define " + f2 : "", n2.lightMap ? "#define USE_LIGHTMAP" : "", n2.aoMap ? "#define USE_AOMAP" : "", n2.emissiveMap ? "#define USE_EMISSIVEMAP" : "", n2.bumpMap ? "#define USE_BUMPMAP" : "", n2.normalMap ? "#define USE_NORMALMAP" : "", n2.normalMap && n2.objectSpaceNormalMap ? "#define OBJECTSPACE_NORMALMAP" : "", n2.normalMap && n2.tangentSpaceNormalMap ? "#define TANGENTSPACE_NORMALMAP" : "", n2.clearcoatMap ? "#define USE_CLEARCOATMAP" : "", n2.clearcoatRoughnessMap ? "#define USE_CLEARCOAT_ROUGHNESSMAP" : "", n2.clearcoatNormalMap ? "#define USE_CLEARCOAT_NORMALMAP" : "", n2.specularMap ? "#define USE_SPECULARMAP" : "", n2.roughnessMap ? "#define USE_ROUGHNESSMAP" : "", n2.metalnessMap ? "#define USE_METALNESSMAP" : "", n2.alphaMap ? "#define USE_ALPHAMAP" : "", n2.sheen ? "#define USE_SHEEN" : "", n2.transmissionMap ? "#define USE_TRANSMISSIONMAP" : "", n2.vertexTangents ? "#define USE_TANGENT" : "", n2.vertexColors || n2.instancingColor ? "#define USE_COLOR" : "", n2.vertexUvs ? "#define USE_UV" : "", n2.uvsVertexOnly ? "#define UVS_VERTEX_ONLY" : "", n2.gradientMap ? "#define USE_GRADIENTMAP" : "", n2.flatShading ? "#define FLAT_SHADED" : "", n2.doubleSided ? "#define DOUBLE_SIDED" : "", n2.flipSided ? "#define FLIP_SIDED" : "", n2.shadowMapEnabled ? "#define USE_SHADOWMAP" : "", n2.shadowMapEnabled ? "#define " + c2 : "", n2.premultipliedAlpha ? "#define PREMULTIPLIED_ALPHA" : "", n2.physicallyCorrectLights ? "#define PHYSICALLY_CORRECT_LIGHTS" : "", n2.logarithmicDepthBuffer ? "#define USE_LOGDEPTHBUF" : "", n2.logarithmicDepthBuffer && n2.rendererExtensionFragDepth ? "#define USE_LOGDEPTHBUF_EXT" : "", (n2.extensionShaderTextureLOD || n2.envMap) && n2.rendererExtensionShaderTextureLod ? "#define TEXTURE_LOD_EXT" : "", "uniform mat4 viewMatrix;", "uniform vec3 cameraPosition;", "uniform bool isOrthographic;", n2.toneMapping !== Q ? "#define TONE_MAPPING" : "", n2.toneMapping !== Q ? Oo.tonemapping_pars_fragment : "", n2.toneMapping !== Q ? Qa("toneMapping", n2.toneMapping) : "", n2.dithering ? "#define DITHERING" : "", Oo.encodings_pars_fragment, n2.map ? Ja("mapTexelToLinear", n2.mapEncoding) : "", n2.matcap ? Ja("matcapTexelToLinear", n2.matcapEncoding) : "", n2.envMap ? Ja("envMapTexelToLinear", n2.envMapEncoding) : "", n2.emissiveMap ? Ja("emissiveMapTexelToLinear", n2.emissiveMapEncoding) : "", n2.lightMap ? Ja("lightMapTexelToLinear", n2.lightMapEncoding) : "", $a("linearToOutputTexel", n2.outputEncoding), n2.depthPacking ? "#define DEPTH_PACKING " + n2.depthPacking : "", "\n"].filter(Ka).join("\n")), a2 = rs(a2), a2 = ts(a2, n2), a2 = es(a2, n2), s2 = rs(s2), s2 = ts(s2, n2), s2 = es(s2, n2), a2 = ss(a2), s2 = ss(s2), n2.isWebGL2 && true !== n2.isRawShaderMaterial && (w2 = "#version 300 es\n", x2 = ["#define attribute in", "#define varying out", "#define texture2D texture"].join("\n") + "\n" + x2, b2 = ["#define varying in", n2.glslVersion === Nn ? "" : "out highp vec4 pc_fragColor;", n2.glslVersion === Nn ? "" : "#define gl_FragColor pc_fragColor", "#define gl_FragDepthEXT gl_FragDepth", "#define texture2D texture", "#define textureCube texture", "#define texture2DProj textureProj", "#define texture2DLodEXT textureLod", "#define texture2DProjLodEXT textureProjLod", "#define textureCubeLodEXT textureLod", "#define texture2DGradEXT textureGrad", "#define texture2DProjGradEXT textureProjGrad", "#define textureCubeGradEXT textureGrad"].join("\n") + "\n" + b2);
        const _2 = w2 + b2 + s2, M2 = qa(i2, 35633, w2 + x2 + a2), S2 = qa(i2, 35632, _2);
        if (i2.attachShader(y2, M2), i2.attachShader(y2, S2), void 0 !== n2.index0AttributeName ? i2.bindAttribLocation(y2, 0, n2.index0AttributeName) : true === n2.morphTargets && i2.bindAttribLocation(y2, 0, "position"), i2.linkProgram(y2), t2.debug.checkShaderErrors) {
          const t3 = i2.getProgramInfoLog(y2).trim(), e3 = i2.getShaderInfoLog(M2).trim(), n3 = i2.getShaderInfoLog(S2).trim();
          let r3 = true, o3 = true;
          if (false === i2.getProgramParameter(y2, 35714)) {
            r3 = false;
            const e4 = Za(i2, M2, "vertex"), n4 = Za(i2, S2, "fragment");
            console.error("THREE.WebGLProgram: shader error: ", i2.getError(), "35715", i2.getProgramParameter(y2, 35715), "gl.getProgramInfoLog", t3, e4, n4);
          } else "" !== t3 ? console.warn("THREE.WebGLProgram: gl.getProgramInfoLog()", t3) : "" !== e3 && "" !== n3 || (o3 = false);
          o3 && (this.diagnostics = { runnable: r3, programLog: t3, vertexShader: { log: e3, prefix: x2 }, fragmentShader: { log: n3, prefix: b2 } });
        }
        let T2, E2;
        return i2.deleteShader(M2), i2.deleteShader(S2), this.getUniforms = function() {
          return void 0 === T2 && (T2 = new Wa(i2, y2)), T2;
        }, this.getAttributes = function() {
          return void 0 === E2 && (E2 = function(t3, e3) {
            const n3 = {}, r3 = t3.getProgramParameter(e3, 35721);
            for (let i3 = 0; i3 < r3; i3++) {
              const r4 = t3.getActiveAttrib(e3, i3).name;
              n3[r4] = t3.getAttribLocation(e3, r4);
            }
            return n3;
          }(i2, y2)), E2;
        }, this.destroy = function() {
          r2.releaseStatesOfProgram(this), i2.deleteProgram(y2), this.program = void 0;
        }, this.name = n2.shaderName, this.id = Xa++, this.cacheKey = e2, this.usedTimes = 1, this.program = y2, this.vertexShader = M2, this.fragmentShader = S2, this;
      }
      function ds(t2, e2, n2, r2, i2, o2) {
        const a2 = [], s2 = r2.isWebGL2, c2 = r2.logarithmicDepthBuffer, u2 = r2.floatVertexTextures, l2 = r2.maxVertexUniforms, h2 = r2.vertexTextures;
        let d2 = r2.precision;
        const p2 = { MeshDepthMaterial: "depth", MeshDistanceMaterial: "distanceRGBA", MeshNormalMaterial: "normal", MeshBasicMaterial: "basic", MeshLambertMaterial: "lambert", MeshPhongMaterial: "phong", MeshToonMaterial: "toon", MeshStandardMaterial: "physical", MeshPhysicalMaterial: "physical", MeshMatcapMaterial: "matcap", LineBasicMaterial: "basic", LineDashedMaterial: "dashed", PointsMaterial: "points", ShadowMaterial: "shadow", SpriteMaterial: "sprite" }, f2 = ["precision", "isWebGL2", "supportsVertexTextures", "outputEncoding", "instancing", "instancingColor", "map", "mapEncoding", "matcap", "matcapEncoding", "envMap", "envMapMode", "envMapEncoding", "envMapCubeUV", "lightMap", "lightMapEncoding", "aoMap", "emissiveMap", "emissiveMapEncoding", "bumpMap", "normalMap", "objectSpaceNormalMap", "tangentSpaceNormalMap", "clearcoatMap", "clearcoatRoughnessMap", "clearcoatNormalMap", "displacementMap", "specularMap", "roughnessMap", "metalnessMap", "gradientMap", "alphaMap", "combine", "vertexColors", "vertexTangents", "vertexUvs", "uvsVertexOnly", "fog", "useFog", "fogExp2", "flatShading", "sizeAttenuation", "logarithmicDepthBuffer", "skinning", "maxBones", "useVertexTexture", "morphTargets", "morphNormals", "maxMorphTargets", "maxMorphNormals", "premultipliedAlpha", "numDirLights", "numPointLights", "numSpotLights", "numHemiLights", "numRectAreaLights", "numDirLightShadows", "numPointLightShadows", "numSpotLightShadows", "shadowMapEnabled", "shadowMapType", "toneMapping", "physicallyCorrectLights", "alphaTest", "doubleSided", "flipSided", "numClippingPlanes", "numClipIntersection", "depthPacking", "dithering", "sheen", "transmissionMap"];
        function v2(t3) {
          let e3;
          return t3 && t3.isTexture ? e3 = t3.encoding : t3 && t3.isWebGLRenderTarget ? (console.warn("THREE.WebGLPrograms.getTextureEncodingFromMap: don't use render targets as textures. Use their .texture property instead."), e3 = t3.texture.encoding) : e3 = Je, e3;
        }
        return { getParameters: function(i3, a3, f3, y2, x2) {
          const b2 = y2.fog, w2 = i3.isMeshStandardMaterial ? y2.environment : null, _2 = e2.get(i3.envMap || w2), M2 = p2[i3.type], S2 = x2.isSkinnedMesh ? function(t3) {
            const e3 = t3.skeleton.bones;
            if (u2) return 1024;
            {
              const t4 = l2, n3 = Math.floor((t4 - 20) / 4), r3 = Math.min(n3, e3.length);
              return r3 < e3.length ? (console.warn("THREE.WebGLRenderer: Skeleton has " + e3.length + " bones. This GPU supports " + r3 + "."), 0) : r3;
            }
          }(x2) : 0;
          let T2, E2;
          if (null !== i3.precision && (d2 = r2.getMaxPrecision(i3.precision), d2 !== i3.precision && console.warn("THREE.WebGLProgram.getParameters:", i3.precision, "not supported, using", d2, "instead.")), M2) {
            const t3 = Io[M2];
            T2 = t3.vertexShader, E2 = t3.fragmentShader;
          } else T2 = i3.vertexShader, E2 = i3.fragmentShader;
          const A2 = t2.getRenderTarget();
          return { isWebGL2: s2, shaderID: M2, shaderName: i3.type, vertexShader: T2, fragmentShader: E2, defines: i3.defines, isRawShaderMaterial: true === i3.isRawShaderMaterial, glslVersion: i3.glslVersion, precision: d2, instancing: true === x2.isInstancedMesh, instancingColor: true === x2.isInstancedMesh && null !== x2.instanceColor, supportsVertexTextures: h2, outputEncoding: null !== A2 ? v2(A2.texture) : t2.outputEncoding, map: !!i3.map, mapEncoding: v2(i3.map), matcap: !!i3.matcap, matcapEncoding: v2(i3.matcap), envMap: !!_2, envMapMode: _2 && _2.mapping, envMapEncoding: v2(_2), envMapCubeUV: !!_2 && (_2.mapping === ut || _2.mapping === lt), lightMap: !!i3.lightMap, lightMapEncoding: v2(i3.lightMap), aoMap: !!i3.aoMap, emissiveMap: !!i3.emissiveMap, emissiveMapEncoding: v2(i3.emissiveMap), bumpMap: !!i3.bumpMap, normalMap: !!i3.normalMap, objectSpaceNormalMap: i3.normalMapType === cn, tangentSpaceNormalMap: i3.normalMapType === sn, clearcoatMap: !!i3.clearcoatMap, clearcoatRoughnessMap: !!i3.clearcoatRoughnessMap, clearcoatNormalMap: !!i3.clearcoatNormalMap, displacementMap: !!i3.displacementMap, roughnessMap: !!i3.roughnessMap, metalnessMap: !!i3.metalnessMap, specularMap: !!i3.specularMap, alphaMap: !!i3.alphaMap, gradientMap: !!i3.gradientMap, sheen: !!i3.sheen, transmissionMap: !!i3.transmissionMap, combine: i3.combine, vertexTangents: i3.normalMap && i3.vertexTangents, vertexColors: i3.vertexColors, vertexUvs: !!(i3.map || i3.bumpMap || i3.normalMap || i3.specularMap || i3.alphaMap || i3.emissiveMap || i3.roughnessMap || i3.metalnessMap || i3.clearcoatMap || i3.clearcoatRoughnessMap || i3.clearcoatNormalMap || i3.displacementMap || i3.transmissionMap), uvsVertexOnly: !(i3.map || i3.bumpMap || i3.normalMap || i3.specularMap || i3.alphaMap || i3.emissiveMap || i3.roughnessMap || i3.metalnessMap || i3.clearcoatNormalMap || i3.transmissionMap || !i3.displacementMap), fog: !!b2, useFog: i3.fog, fogExp2: b2 && b2.isFogExp2, flatShading: i3.flatShading, sizeAttenuation: i3.sizeAttenuation, logarithmicDepthBuffer: c2, skinning: i3.skinning && S2 > 0, maxBones: S2, useVertexTexture: u2, morphTargets: i3.morphTargets, morphNormals: i3.morphNormals, maxMorphTargets: t2.maxMorphTargets, maxMorphNormals: t2.maxMorphNormals, numDirLights: a3.directional.length, numPointLights: a3.point.length, numSpotLights: a3.spot.length, numRectAreaLights: a3.rectArea.length, numHemiLights: a3.hemi.length, numDirLightShadows: a3.directionalShadowMap.length, numPointLightShadows: a3.pointShadowMap.length, numSpotLightShadows: a3.spotShadowMap.length, numClippingPlanes: o2.numPlanes, numClipIntersection: o2.numIntersection, dithering: i3.dithering, shadowMapEnabled: t2.shadowMap.enabled && f3.length > 0, shadowMapType: t2.shadowMap.type, toneMapping: i3.toneMapped ? t2.toneMapping : Q, physicallyCorrectLights: t2.physicallyCorrectLights, premultipliedAlpha: i3.premultipliedAlpha, alphaTest: i3.alphaTest, doubleSided: i3.side === g, flipSided: i3.side === m, depthPacking: void 0 !== i3.depthPacking && i3.depthPacking, index0AttributeName: i3.index0AttributeName, extensionDerivatives: i3.extensions && i3.extensions.derivatives, extensionFragDepth: i3.extensions && i3.extensions.fragDepth, extensionDrawBuffers: i3.extensions && i3.extensions.drawBuffers, extensionShaderTextureLOD: i3.extensions && i3.extensions.shaderTextureLOD, rendererExtensionFragDepth: s2 || n2.has("EXT_frag_depth"), rendererExtensionDrawBuffers: s2 || n2.has("WEBGL_draw_buffers"), rendererExtensionShaderTextureLod: s2 || n2.has("EXT_shader_texture_lod"), customProgramCacheKey: i3.customProgramCacheKey() };
        }, getProgramCacheKey: function(e3) {
          const n3 = [];
          if (e3.shaderID ? n3.push(e3.shaderID) : (n3.push(e3.fragmentShader), n3.push(e3.vertexShader)), void 0 !== e3.defines) for (const t3 in e3.defines) n3.push(t3), n3.push(e3.defines[t3]);
          if (false === e3.isRawShaderMaterial) {
            for (let t3 = 0; t3 < f2.length; t3++) n3.push(e3[f2[t3]]);
            n3.push(t2.outputEncoding), n3.push(t2.gammaFactor);
          }
          return n3.push(e3.customProgramCacheKey), n3.join();
        }, getUniforms: function(t3) {
          const e3 = p2[t3.type];
          let n3;
          if (e3) {
            const t4 = Io[e3];
            n3 = yo.clone(t4.uniforms);
          } else n3 = t3.uniforms;
          return n3;
        }, acquireProgram: function(e3, n3) {
          let r3;
          for (let t3 = 0, e4 = a2.length; t3 < e4; t3++) {
            const e5 = a2[t3];
            if (e5.cacheKey === n3) {
              r3 = e5, ++r3.usedTimes;
              break;
            }
          }
          return void 0 === r3 && (r3 = new hs(t2, n3, e3, i2), a2.push(r3)), r3;
        }, releaseProgram: function(t3) {
          if (0 == --t3.usedTimes) {
            const e3 = a2.indexOf(t3);
            a2[e3] = a2[a2.length - 1], a2.pop(), t3.destroy();
          }
        }, programs: a2 };
      }
      function ps() {
        let t2 = /* @__PURE__ */ new WeakMap();
        return { get: function(e2) {
          let n2 = t2.get(e2);
          return void 0 === n2 && (n2 = {}, t2.set(e2, n2)), n2;
        }, remove: function(e2) {
          t2.delete(e2);
        }, update: function(e2, n2, r2) {
          t2.get(e2)[n2] = r2;
        }, dispose: function() {
          t2 = /* @__PURE__ */ new WeakMap();
        } };
      }
      function fs(t2, e2) {
        return t2.groupOrder !== e2.groupOrder ? t2.groupOrder - e2.groupOrder : t2.renderOrder !== e2.renderOrder ? t2.renderOrder - e2.renderOrder : t2.program !== e2.program ? t2.program.id - e2.program.id : t2.material.id !== e2.material.id ? t2.material.id - e2.material.id : t2.z !== e2.z ? t2.z - e2.z : t2.id - e2.id;
      }
      function ms(t2, e2) {
        return t2.groupOrder !== e2.groupOrder ? t2.groupOrder - e2.groupOrder : t2.renderOrder !== e2.renderOrder ? t2.renderOrder - e2.renderOrder : t2.z !== e2.z ? e2.z - t2.z : t2.id - e2.id;
      }
      function gs(t2) {
        const e2 = [];
        let n2 = 0;
        const r2 = [], i2 = [], o2 = { id: -1 };
        function a2(r3, i3, a3, s2, c2, u2) {
          let l2 = e2[n2];
          const h2 = t2.get(a3);
          return void 0 === l2 ? (l2 = { id: r3.id, object: r3, geometry: i3, material: a3, program: h2.program || o2, groupOrder: s2, renderOrder: r3.renderOrder, z: c2, group: u2 }, e2[n2] = l2) : (l2.id = r3.id, l2.object = r3, l2.geometry = i3, l2.material = a3, l2.program = h2.program || o2, l2.groupOrder = s2, l2.renderOrder = r3.renderOrder, l2.z = c2, l2.group = u2), n2++, l2;
        }
        return { opaque: r2, transparent: i2, init: function() {
          n2 = 0, r2.length = 0, i2.length = 0;
        }, push: function(t3, e3, n3, o3, s2, c2) {
          const u2 = a2(t3, e3, n3, o3, s2, c2);
          (true === n3.transparent ? i2 : r2).push(u2);
        }, unshift: function(t3, e3, n3, o3, s2, c2) {
          const u2 = a2(t3, e3, n3, o3, s2, c2);
          (true === n3.transparent ? i2 : r2).unshift(u2);
        }, finish: function() {
          for (let t3 = n2, r3 = e2.length; t3 < r3; t3++) {
            const n3 = e2[t3];
            if (null === n3.id) break;
            n3.id = null, n3.object = null, n3.geometry = null, n3.material = null, n3.program = null, n3.group = null;
          }
        }, sort: function(t3, e3) {
          r2.length > 1 && r2.sort(t3 || fs), i2.length > 1 && i2.sort(e3 || ms);
        } };
      }
      function vs(t2) {
        let e2 = /* @__PURE__ */ new WeakMap();
        return { get: function(n2, r2) {
          const i2 = e2.get(n2);
          let o2;
          return void 0 === i2 ? (o2 = new gs(t2), e2.set(n2, /* @__PURE__ */ new WeakMap()), e2.get(n2).set(r2, o2)) : (o2 = i2.get(r2), void 0 === o2 && (o2 = new gs(t2), i2.set(r2, o2))), o2;
        }, dispose: function() {
          e2 = /* @__PURE__ */ new WeakMap();
        } };
      }
      function ys() {
        const t2 = {};
        return { get: function(e2) {
          if (void 0 !== t2[e2.id]) return t2[e2.id];
          let n2;
          switch (e2.type) {
            case "DirectionalLight":
              n2 = { direction: new $n(), color: new yi() };
              break;
            case "SpotLight":
              n2 = { position: new $n(), direction: new $n(), color: new yi(), distance: 0, coneCos: 0, penumbraCos: 0, decay: 0 };
              break;
            case "PointLight":
              n2 = { position: new $n(), color: new yi(), distance: 0, decay: 0 };
              break;
            case "HemisphereLight":
              n2 = { direction: new $n(), skyColor: new yi(), groundColor: new yi() };
              break;
            case "RectAreaLight":
              n2 = { color: new yi(), position: new $n(), halfWidth: new $n(), halfHeight: new $n() };
          }
          return t2[e2.id] = n2, n2;
        } };
      }
      let xs = 0;
      function bs(t2, e2) {
        return (e2.castShadow ? 1 : 0) - (t2.castShadow ? 1 : 0);
      }
      function ws(t2, e2) {
        const n2 = new ys(), r2 = /* @__PURE__ */ function() {
          const t3 = {};
          return { get: function(e3) {
            if (void 0 !== t3[e3.id]) return t3[e3.id];
            let n3;
            switch (e3.type) {
              case "DirectionalLight":
              case "SpotLight":
                n3 = { shadowBias: 0, shadowNormalBias: 0, shadowRadius: 1, shadowMapSize: new Hn() };
                break;
              case "PointLight":
                n3 = { shadowBias: 0, shadowNormalBias: 0, shadowRadius: 1, shadowMapSize: new Hn(), shadowCameraNear: 1, shadowCameraFar: 1e3 };
            }
            return t3[e3.id] = n3, n3;
          } };
        }(), i2 = { version: 0, hash: { directionalLength: -1, pointLength: -1, spotLength: -1, rectAreaLength: -1, hemiLength: -1, numDirectionalShadows: -1, numPointShadows: -1, numSpotShadows: -1 }, ambient: [0, 0, 0], probe: [], directional: [], directionalShadow: [], directionalShadowMap: [], directionalShadowMatrix: [], spot: [], spotShadow: [], spotShadowMap: [], spotShadowMatrix: [], rectArea: [], rectAreaLTC1: null, rectAreaLTC2: null, point: [], pointShadow: [], pointShadowMap: [], pointShadowMatrix: [], hemi: [] };
        for (let t3 = 0; t3 < 9; t3++) i2.probe.push(new $n());
        const o2 = new $n(), a2 = new Tr(), s2 = new Tr();
        return { setup: function(o3) {
          let a3 = 0, s3 = 0, c2 = 0;
          for (let t3 = 0; t3 < 9; t3++) i2.probe[t3].set(0, 0, 0);
          let u2 = 0, l2 = 0, h2 = 0, d2 = 0, p2 = 0, f2 = 0, m2 = 0, g2 = 0;
          o3.sort(bs);
          for (let t3 = 0, e3 = o3.length; t3 < e3; t3++) {
            const e4 = o3[t3], v3 = e4.color, y2 = e4.intensity, x2 = e4.distance, b2 = e4.shadow && e4.shadow.map ? e4.shadow.map.texture : null;
            if (e4.isAmbientLight) a3 += v3.r * y2, s3 += v3.g * y2, c2 += v3.b * y2;
            else if (e4.isLightProbe) for (let t4 = 0; t4 < 9; t4++) i2.probe[t4].addScaledVector(e4.sh.coefficients[t4], y2);
            else if (e4.isDirectionalLight) {
              const t4 = n2.get(e4);
              if (t4.color.copy(e4.color).multiplyScalar(e4.intensity), e4.castShadow) {
                const t5 = e4.shadow, n3 = r2.get(e4);
                n3.shadowBias = t5.bias, n3.shadowNormalBias = t5.normalBias, n3.shadowRadius = t5.radius, n3.shadowMapSize = t5.mapSize, i2.directionalShadow[u2] = n3, i2.directionalShadowMap[u2] = b2, i2.directionalShadowMatrix[u2] = e4.shadow.matrix, f2++;
              }
              i2.directional[u2] = t4, u2++;
            } else if (e4.isSpotLight) {
              const t4 = n2.get(e4);
              if (t4.position.setFromMatrixPosition(e4.matrixWorld), t4.color.copy(v3).multiplyScalar(y2), t4.distance = x2, t4.coneCos = Math.cos(e4.angle), t4.penumbraCos = Math.cos(e4.angle * (1 - e4.penumbra)), t4.decay = e4.decay, e4.castShadow) {
                const t5 = e4.shadow, n3 = r2.get(e4);
                n3.shadowBias = t5.bias, n3.shadowNormalBias = t5.normalBias, n3.shadowRadius = t5.radius, n3.shadowMapSize = t5.mapSize, i2.spotShadow[h2] = n3, i2.spotShadowMap[h2] = b2, i2.spotShadowMatrix[h2] = e4.shadow.matrix, g2++;
              }
              i2.spot[h2] = t4, h2++;
            } else if (e4.isRectAreaLight) {
              const t4 = n2.get(e4);
              t4.color.copy(v3).multiplyScalar(y2), t4.halfWidth.set(0.5 * e4.width, 0, 0), t4.halfHeight.set(0, 0.5 * e4.height, 0), i2.rectArea[d2] = t4, d2++;
            } else if (e4.isPointLight) {
              const t4 = n2.get(e4);
              if (t4.color.copy(e4.color).multiplyScalar(e4.intensity), t4.distance = e4.distance, t4.decay = e4.decay, e4.castShadow) {
                const t5 = e4.shadow, n3 = r2.get(e4);
                n3.shadowBias = t5.bias, n3.shadowNormalBias = t5.normalBias, n3.shadowRadius = t5.radius, n3.shadowMapSize = t5.mapSize, n3.shadowCameraNear = t5.camera.near, n3.shadowCameraFar = t5.camera.far, i2.pointShadow[l2] = n3, i2.pointShadowMap[l2] = b2, i2.pointShadowMatrix[l2] = e4.shadow.matrix, m2++;
              }
              i2.point[l2] = t4, l2++;
            } else if (e4.isHemisphereLight) {
              const t4 = n2.get(e4);
              t4.skyColor.copy(e4.color).multiplyScalar(y2), t4.groundColor.copy(e4.groundColor).multiplyScalar(y2), i2.hemi[p2] = t4, p2++;
            }
          }
          d2 > 0 && (e2.isWebGL2 || true === t2.has("OES_texture_float_linear") ? (i2.rectAreaLTC1 = Do.LTC_FLOAT_1, i2.rectAreaLTC2 = Do.LTC_FLOAT_2) : true === t2.has("OES_texture_half_float_linear") ? (i2.rectAreaLTC1 = Do.LTC_HALF_1, i2.rectAreaLTC2 = Do.LTC_HALF_2) : console.error("THREE.WebGLRenderer: Unable to use RectAreaLight. Missing WebGL extensions.")), i2.ambient[0] = a3, i2.ambient[1] = s3, i2.ambient[2] = c2;
          const v2 = i2.hash;
          v2.directionalLength === u2 && v2.pointLength === l2 && v2.spotLength === h2 && v2.rectAreaLength === d2 && v2.hemiLength === p2 && v2.numDirectionalShadows === f2 && v2.numPointShadows === m2 && v2.numSpotShadows === g2 || (i2.directional.length = u2, i2.spot.length = h2, i2.rectArea.length = d2, i2.point.length = l2, i2.hemi.length = p2, i2.directionalShadow.length = f2, i2.directionalShadowMap.length = f2, i2.pointShadow.length = m2, i2.pointShadowMap.length = m2, i2.spotShadow.length = g2, i2.spotShadowMap.length = g2, i2.directionalShadowMatrix.length = f2, i2.pointShadowMatrix.length = m2, i2.spotShadowMatrix.length = g2, v2.directionalLength = u2, v2.pointLength = l2, v2.spotLength = h2, v2.rectAreaLength = d2, v2.hemiLength = p2, v2.numDirectionalShadows = f2, v2.numPointShadows = m2, v2.numSpotShadows = g2, i2.version = xs++);
        }, setupView: function(t3, e3) {
          let n3 = 0, r3 = 0, c2 = 0, u2 = 0, l2 = 0;
          const h2 = e3.matrixWorldInverse;
          for (let e4 = 0, d2 = t3.length; e4 < d2; e4++) {
            const d3 = t3[e4];
            if (d3.isDirectionalLight) {
              const t4 = i2.directional[n3];
              t4.direction.setFromMatrixPosition(d3.matrixWorld), o2.setFromMatrixPosition(d3.target.matrixWorld), t4.direction.sub(o2), t4.direction.transformDirection(h2), n3++;
            } else if (d3.isSpotLight) {
              const t4 = i2.spot[c2];
              t4.position.setFromMatrixPosition(d3.matrixWorld), t4.position.applyMatrix4(h2), t4.direction.setFromMatrixPosition(d3.matrixWorld), o2.setFromMatrixPosition(d3.target.matrixWorld), t4.direction.sub(o2), t4.direction.transformDirection(h2), c2++;
            } else if (d3.isRectAreaLight) {
              const t4 = i2.rectArea[u2];
              t4.position.setFromMatrixPosition(d3.matrixWorld), t4.position.applyMatrix4(h2), s2.identity(), a2.copy(d3.matrixWorld), a2.premultiply(h2), s2.extractRotation(a2), t4.halfWidth.set(0.5 * d3.width, 0, 0), t4.halfHeight.set(0, 0.5 * d3.height, 0), t4.halfWidth.applyMatrix4(s2), t4.halfHeight.applyMatrix4(s2), u2++;
            } else if (d3.isPointLight) {
              const t4 = i2.point[r3];
              t4.position.setFromMatrixPosition(d3.matrixWorld), t4.position.applyMatrix4(h2), r3++;
            } else if (d3.isHemisphereLight) {
              const t4 = i2.hemi[l2];
              t4.direction.setFromMatrixPosition(d3.matrixWorld), t4.direction.transformDirection(h2), t4.direction.normalize(), l2++;
            }
          }
        }, state: i2 };
      }
      function _s(t2, e2) {
        const n2 = new ws(t2, e2), r2 = [], i2 = [];
        return { init: function() {
          r2.length = 0, i2.length = 0;
        }, state: { lightsArray: r2, shadowsArray: i2, lights: n2 }, setupLights: function() {
          n2.setup(r2);
        }, setupLightsView: function(t3) {
          n2.setupView(r2, t3);
        }, pushLight: function(t3) {
          r2.push(t3);
        }, pushShadow: function(t3) {
          i2.push(t3);
        } };
      }
      function Ms(t2, e2) {
        let n2 = /* @__PURE__ */ new WeakMap();
        return { get: function(r2, i2 = 0) {
          let o2;
          return false === n2.has(r2) ? (o2 = new _s(t2, e2), n2.set(r2, []), n2.get(r2).push(o2)) : i2 >= n2.get(r2).length ? (o2 = new _s(t2, e2), n2.get(r2).push(o2)) : o2 = n2.get(r2)[i2], o2;
        }, dispose: function() {
          n2 = /* @__PURE__ */ new WeakMap();
        } };
      }
      function Ss(t2) {
        wi.call(this), this.type = "MeshDepthMaterial", this.depthPacking = on, this.skinning = false, this.morphTargets = false, this.map = null, this.alphaMap = null, this.displacementMap = null, this.displacementScale = 1, this.displacementBias = 0, this.wireframe = false, this.wireframeLinewidth = 1, this.fog = false, this.setValues(t2);
      }
      function Ts(t2) {
        wi.call(this), this.type = "MeshDistanceMaterial", this.referencePosition = new $n(), this.nearDistance = 1, this.farDistance = 1e3, this.skinning = false, this.morphTargets = false, this.map = null, this.alphaMap = null, this.displacementMap = null, this.displacementScale = 1, this.displacementBias = 0, this.fog = false, this.setValues(t2);
      }
      Ss.prototype = Object.create(wi.prototype), Ss.prototype.constructor = Ss, Ss.prototype.isMeshDepthMaterial = true, Ss.prototype.copy = function(t2) {
        return wi.prototype.copy.call(this, t2), this.depthPacking = t2.depthPacking, this.skinning = t2.skinning, this.morphTargets = t2.morphTargets, this.map = t2.map, this.alphaMap = t2.alphaMap, this.displacementMap = t2.displacementMap, this.displacementScale = t2.displacementScale, this.displacementBias = t2.displacementBias, this.wireframe = t2.wireframe, this.wireframeLinewidth = t2.wireframeLinewidth, this;
      }, Ts.prototype = Object.create(wi.prototype), Ts.prototype.constructor = Ts, Ts.prototype.isMeshDistanceMaterial = true, Ts.prototype.copy = function(t2) {
        return wi.prototype.copy.call(this, t2), this.referencePosition.copy(t2.referencePosition), this.nearDistance = t2.nearDistance, this.farDistance = t2.farDistance, this.skinning = t2.skinning, this.morphTargets = t2.morphTargets, this.map = t2.map, this.alphaMap = t2.alphaMap, this.displacementMap = t2.displacementMap, this.displacementScale = t2.displacementScale, this.displacementBias = t2.displacementBias, this;
      };
      function Es(t2, e2, n2) {
        let r2 = new Co();
        const i2 = new Hn(), o2 = new Hn(), a2 = new Xn(), s2 = [], c2 = [], u2 = {}, l2 = { 0: m, 1: f, 2: g }, d2 = new xo({ defines: { SAMPLE_RATE: 2 / 8, HALF_SAMPLE_RATE: 1 / 8 }, uniforms: { shadow_pass: { value: null }, resolution: { value: new Hn() }, radius: { value: 4 } }, vertexShader: "void main() {\n	gl_Position = vec4( position, 1.0 );\n}", fragmentShader: "uniform sampler2D shadow_pass;\nuniform vec2 resolution;\nuniform float radius;\n#include <packing>\nvoid main() {\n	float mean = 0.0;\n	float squared_mean = 0.0;\n	float depth = unpackRGBAToDepth( texture2D( shadow_pass, ( gl_FragCoord.xy ) / resolution ) );\n	for ( float i = -1.0; i < 1.0 ; i += SAMPLE_RATE) {\n		#ifdef HORIZONTAL_PASS\n			vec2 distribution = unpackRGBATo2Half( texture2D( shadow_pass, ( gl_FragCoord.xy + vec2( i, 0.0 ) * radius ) / resolution ) );\n			mean += distribution.x;\n			squared_mean += distribution.y * distribution.y + distribution.x * distribution.x;\n		#else\n			float depth = unpackRGBAToDepth( texture2D( shadow_pass, ( gl_FragCoord.xy + vec2( 0.0, i ) * radius ) / resolution ) );\n			mean += depth;\n			squared_mean += depth * depth;\n		#endif\n	}\n	mean = mean * HALF_SAMPLE_RATE;\n	squared_mean = squared_mean * HALF_SAMPLE_RATE;\n	float std_dev = sqrt( squared_mean - mean * mean );\n	gl_FragColor = pack2HalfToRGBA( vec2( mean, std_dev ) );\n}" }), v2 = d2.clone();
        v2.defines.HORIZONTAL_PASS = 1;
        const y2 = new Xi();
        y2.setAttribute("position", new Ti(new Float32Array([-1, -1, 0.5, 3, -1, 0.5, -1, 3, 0.5]), 3));
        const b2 = new ho(y2, d2), w2 = this;
        function _2(n3, r3) {
          const i3 = e2.update(b2);
          d2.uniforms.shadow_pass.value = n3.map.texture, d2.uniforms.resolution.value = n3.mapSize, d2.uniforms.radius.value = n3.radius, t2.setRenderTarget(n3.mapPass), t2.clear(), t2.renderBufferDirect(r3, null, i3, d2, b2, null), v2.uniforms.shadow_pass.value = n3.mapPass.texture, v2.uniforms.resolution.value = n3.mapSize, v2.uniforms.radius.value = n3.radius, t2.setRenderTarget(n3.map), t2.clear(), t2.renderBufferDirect(r3, null, i3, v2, b2, null);
        }
        function M2(t3, e3, n3) {
          const r3 = t3 << 0 | e3 << 1 | n3 << 2;
          let i3 = s2[r3];
          return void 0 === i3 && (i3 = new Ss({ depthPacking: an, morphTargets: t3, skinning: e3 }), s2[r3] = i3), i3;
        }
        function S2(t3, e3, n3) {
          const r3 = t3 << 0 | e3 << 1 | n3 << 2;
          let i3 = c2[r3];
          return void 0 === i3 && (i3 = new Ts({ morphTargets: t3, skinning: e3 }), c2[r3] = i3), i3;
        }
        function T2(e3, n3, r3, i3, o3, a3, s3) {
          let c3 = null, h2 = M2, d3 = e3.customDepthMaterial;
          if (true === i3.isPointLight && (h2 = S2, d3 = e3.customDistanceMaterial), void 0 === d3) {
            let t3 = false;
            true === r3.morphTargets && (t3 = n3.morphAttributes && n3.morphAttributes.position && n3.morphAttributes.position.length > 0);
            let i4 = false;
            true === e3.isSkinnedMesh && (true === r3.skinning ? i4 = true : console.warn("THREE.WebGLShadowMap: THREE.SkinnedMesh with material.skinning set to false:", e3));
            c3 = h2(t3, i4, true === e3.isInstancedMesh);
          } else c3 = d3;
          if (t2.localClippingEnabled && true === r3.clipShadows && 0 !== r3.clippingPlanes.length) {
            const t3 = c3.uuid, e4 = r3.uuid;
            let n4 = u2[t3];
            void 0 === n4 && (n4 = {}, u2[t3] = n4);
            let i4 = n4[e4];
            void 0 === i4 && (i4 = c3.clone(), n4[e4] = i4), c3 = i4;
          }
          return c3.visible = r3.visible, c3.wireframe = r3.wireframe, c3.side = s3 === p ? null !== r3.shadowSide ? r3.shadowSide : r3.side : null !== r3.shadowSide ? r3.shadowSide : l2[r3.side], c3.clipShadows = r3.clipShadows, c3.clippingPlanes = r3.clippingPlanes, c3.clipIntersection = r3.clipIntersection, c3.wireframeLinewidth = r3.wireframeLinewidth, c3.linewidth = r3.linewidth, true === i3.isPointLight && true === c3.isMeshDistanceMaterial && (c3.referencePosition.setFromMatrixPosition(i3.matrixWorld), c3.nearDistance = o3, c3.farDistance = a3), c3;
        }
        function E2(n3, i3, o3, a3, s3) {
          if (false === n3.visible) return;
          if (n3.layers.test(i3.layers) && (n3.isMesh || n3.isLine || n3.isPoints) && (n3.castShadow || n3.receiveShadow && s3 === p) && (!n3.frustumCulled || r2.intersectsObject(n3))) {
            n3.modelViewMatrix.multiplyMatrices(o3.matrixWorldInverse, n3.matrixWorld);
            const r3 = e2.update(n3), i4 = n3.material;
            if (Array.isArray(i4)) {
              const e3 = r3.groups;
              for (let c4 = 0, u3 = e3.length; c4 < u3; c4++) {
                const u4 = e3[c4], l3 = i4[u4.materialIndex];
                if (l3 && l3.visible) {
                  const e4 = T2(n3, r3, l3, a3, o3.near, o3.far, s3);
                  t2.renderBufferDirect(o3, null, r3, e4, n3, u4);
                }
              }
            } else if (i4.visible) {
              const e3 = T2(n3, r3, i4, a3, o3.near, o3.far, s3);
              t2.renderBufferDirect(o3, null, r3, e3, n3, null);
            }
          }
          const c3 = n3.children;
          for (let t3 = 0, e3 = c3.length; t3 < e3; t3++) E2(c3[t3], i3, o3, a3, s3);
        }
        this.enabled = false, this.autoUpdate = true, this.needsUpdate = false, this.type = h, this.render = function(e3, s3, c3) {
          if (false === w2.enabled) return;
          if (false === w2.autoUpdate && false === w2.needsUpdate) return;
          if (0 === e3.length) return;
          const u3 = t2.getRenderTarget(), l3 = t2.getActiveCubeFace(), h2 = t2.getActiveMipmapLevel(), d3 = t2.state;
          d3.setBlending(x), d3.buffers.color.setClear(1, 1, 1, 1), d3.buffers.depth.setTest(true), d3.setScissorTest(false);
          for (let u4 = 0, l4 = e3.length; u4 < l4; u4++) {
            const l5 = e3[u4], h3 = l5.shadow;
            if (void 0 === h3) {
              console.warn("THREE.WebGLShadowMap:", l5, "has no shadow.");
              continue;
            }
            if (false === h3.autoUpdate && false === h3.needsUpdate) continue;
            i2.copy(h3.mapSize);
            const f2 = h3.getFrameExtents();
            if (i2.multiply(f2), o2.copy(h3.mapSize), (i2.x > n2 || i2.y > n2) && (i2.x > n2 && (o2.x = Math.floor(n2 / f2.x), i2.x = o2.x * f2.x, h3.mapSize.x = o2.x), i2.y > n2 && (o2.y = Math.floor(n2 / f2.y), i2.y = o2.y * f2.y, h3.mapSize.y = o2.y)), null === h3.map && !h3.isPointLightShadow && this.type === p) {
              const t3 = { minFilter: xt, magFilter: xt, format: Ft };
              h3.map = new Yn(i2.x, i2.y, t3), h3.map.texture.name = l5.name + ".shadowMap", h3.mapPass = new Yn(i2.x, i2.y, t3), h3.camera.updateProjectionMatrix();
            }
            if (null === h3.map) {
              const t3 = { minFilter: ft, magFilter: ft, format: Ft };
              h3.map = new Yn(i2.x, i2.y, t3), h3.map.texture.name = l5.name + ".shadowMap", h3.camera.updateProjectionMatrix();
            }
            t2.setRenderTarget(h3.map), t2.clear();
            const m2 = h3.getViewportCount();
            for (let t3 = 0; t3 < m2; t3++) {
              const e4 = h3.getViewport(t3);
              a2.set(o2.x * e4.x, o2.y * e4.y, o2.x * e4.z, o2.y * e4.w), d3.viewport(a2), h3.updateMatrices(l5, t3), r2 = h3.getFrustum(), E2(s3, c3, h3.camera, l5, this.type);
            }
            h3.isPointLightShadow || this.type !== p || _2(h3, c3), h3.needsUpdate = false;
          }
          w2.needsUpdate = false, t2.setRenderTarget(u3, l3, h2);
        };
      }
      function As(t2, e2, n2) {
        const r2 = n2.isWebGL2;
        const i2 = new function() {
          let e3 = false;
          const n3 = new Xn();
          let r3 = null;
          const i3 = new Xn(0, 0, 0, 0);
          return { setMask: function(n4) {
            r3 === n4 || e3 || (t2.colorMask(n4, n4, n4, n4), r3 = n4);
          }, setLocked: function(t3) {
            e3 = t3;
          }, setClear: function(e4, r4, o3, a2, s2) {
            true === s2 && (e4 *= a2, r4 *= a2, o3 *= a2), n3.set(e4, r4, o3, a2), false === i3.equals(n3) && (t2.clearColor(e4, r4, o3, a2), i3.copy(n3));
          }, reset: function() {
            e3 = false, r3 = null, i3.set(-1, 0, 0, 0);
          } };
        }(), o2 = new function() {
          let e3 = false, n3 = null, r3 = null, i3 = null;
          return { setTest: function(t3) {
            t3 ? ft2(2929) : mt2(2929);
          }, setMask: function(r4) {
            n3 === r4 || e3 || (t2.depthMask(r4), n3 = r4);
          }, setFunc: function(e4) {
            if (r3 !== e4) {
              if (e4) switch (e4) {
                case G:
                  t2.depthFunc(512);
                  break;
                case U:
                  t2.depthFunc(519);
                  break;
                case j:
                  t2.depthFunc(513);
                  break;
                case V:
                  t2.depthFunc(515);
                  break;
                case W:
                  t2.depthFunc(514);
                  break;
                case q:
                  t2.depthFunc(518);
                  break;
                case X:
                  t2.depthFunc(516);
                  break;
                case Y:
                  t2.depthFunc(517);
                  break;
                default:
                  t2.depthFunc(515);
              }
              else t2.depthFunc(515);
              r3 = e4;
            }
          }, setLocked: function(t3) {
            e3 = t3;
          }, setClear: function(e4) {
            i3 !== e4 && (t2.clearDepth(e4), i3 = e4);
          }, reset: function() {
            e3 = false, n3 = null, r3 = null, i3 = null;
          } };
        }(), u2 = new function() {
          let e3 = false, n3 = null, r3 = null, i3 = null, o3 = null, a2 = null, s2 = null, c2 = null, u3 = null;
          return { setTest: function(t3) {
            e3 || (t3 ? ft2(2960) : mt2(2960));
          }, setMask: function(r4) {
            n3 === r4 || e3 || (t2.stencilMask(r4), n3 = r4);
          }, setFunc: function(e4, n4, a3) {
            r3 === e4 && i3 === n4 && o3 === a3 || (t2.stencilFunc(e4, n4, a3), r3 = e4, i3 = n4, o3 = a3);
          }, setOp: function(e4, n4, r4) {
            a2 === e4 && s2 === n4 && c2 === r4 || (t2.stencilOp(e4, n4, r4), a2 = e4, s2 = n4, c2 = r4);
          }, setLocked: function(t3) {
            e3 = t3;
          }, setClear: function(e4) {
            u3 !== e4 && (t2.clearStencil(e4), u3 = e4);
          }, reset: function() {
            e3 = false, n3 = null, r3 = null, i3 = null, o3 = null, a2 = null, s2 = null, c2 = null, u3 = null;
          } };
        }();
        let l2 = {}, h2 = null, d2 = null, p2 = null, f2 = null, v2 = null, y2 = null, Z2 = null, J2 = null, $2 = null, Q2 = false, K2 = null, tt2 = null, et2 = null, nt2 = null, rt2 = null;
        const it2 = t2.getParameter(35661);
        let ot2 = false, at2 = 0;
        const st2 = t2.getParameter(7938);
        -1 !== st2.indexOf("WebGL") ? (at2 = parseFloat(/^WebGL (\d)/.exec(st2)[1]), ot2 = at2 >= 1) : -1 !== st2.indexOf("OpenGL ES") && (at2 = parseFloat(/^OpenGL ES (\d)/.exec(st2)[1]), ot2 = at2 >= 2);
        let ct2 = null, ut2 = {};
        const lt2 = new Xn(), ht2 = new Xn();
        function dt2(e3, n3, r3) {
          const i3 = new Uint8Array(4), o3 = t2.createTexture();
          t2.bindTexture(e3, o3), t2.texParameteri(e3, 10241, 9728), t2.texParameteri(e3, 10240, 9728);
          for (let e4 = 0; e4 < r3; e4++) t2.texImage2D(n3 + e4, 0, 6408, 1, 1, 0, 6408, 5121, i3);
          return o3;
        }
        const pt2 = {};
        function ft2(e3) {
          true !== l2[e3] && (t2.enable(e3), l2[e3] = true);
        }
        function mt2(e3) {
          false !== l2[e3] && (t2.disable(e3), l2[e3] = false);
        }
        pt2[3553] = dt2(3553, 3553, 1), pt2[34067] = dt2(34067, 34069, 6), i2.setClear(0, 0, 0, 1), o2.setClear(1), u2.setClear(0), ft2(2929), o2.setFunc(V), xt2(false), bt2(s), ft2(2884), yt2(x);
        const gt2 = { [T]: 32774, [E]: 32778, [A]: 32779 };
        if (r2) gt2[C] = 32775, gt2[L] = 32776;
        else {
          const t3 = e2.get("EXT_blend_minmax");
          null !== t3 && (gt2[C] = t3.MIN_EXT, gt2[L] = t3.MAX_EXT);
        }
        const vt2 = { [P]: 0, [R]: 1, [O]: 768, [I]: 770, [H]: 776, [F]: 774, [z]: 772, [D]: 769, [N]: 771, [B]: 775, [k]: 773 };
        function yt2(e3, n3, r3, i3, o3, a2, s2, c2) {
          if (e3 !== x) {
            if (d2 || (ft2(3042), d2 = true), e3 === S) o3 = o3 || n3, a2 = a2 || r3, s2 = s2 || i3, n3 === f2 && o3 === Z2 || (t2.blendEquationSeparate(gt2[n3], gt2[o3]), f2 = n3, Z2 = o3), r3 === v2 && i3 === y2 && a2 === J2 && s2 === $2 || (t2.blendFuncSeparate(vt2[r3], vt2[i3], vt2[a2], vt2[s2]), v2 = r3, y2 = i3, J2 = a2, $2 = s2), p2 = e3, Q2 = null;
            else if (e3 !== p2 || c2 !== Q2) {
              if (f2 === T && Z2 === T || (t2.blendEquation(32774), f2 = T, Z2 = T), c2) switch (e3) {
                case b:
                  t2.blendFuncSeparate(1, 771, 1, 771);
                  break;
                case w:
                  t2.blendFunc(1, 1);
                  break;
                case _:
                  t2.blendFuncSeparate(0, 0, 769, 771);
                  break;
                case M:
                  t2.blendFuncSeparate(0, 768, 0, 770);
                  break;
                default:
                  console.error("THREE.WebGLState: Invalid blending: ", e3);
              }
              else switch (e3) {
                case b:
                  t2.blendFuncSeparate(770, 771, 1, 771);
                  break;
                case w:
                  t2.blendFunc(770, 1);
                  break;
                case _:
                  t2.blendFunc(0, 769);
                  break;
                case M:
                  t2.blendFunc(0, 768);
                  break;
                default:
                  console.error("THREE.WebGLState: Invalid blending: ", e3);
              }
              v2 = null, y2 = null, J2 = null, $2 = null, p2 = e3, Q2 = c2;
            }
          } else d2 && (mt2(3042), d2 = false);
        }
        function xt2(e3) {
          K2 !== e3 && (e3 ? t2.frontFace(2304) : t2.frontFace(2305), K2 = e3);
        }
        function bt2(e3) {
          e3 !== a ? (ft2(2884), e3 !== tt2 && (e3 === s ? t2.cullFace(1029) : e3 === c ? t2.cullFace(1028) : t2.cullFace(1032))) : mt2(2884), tt2 = e3;
        }
        function wt2(e3, n3, r3) {
          e3 ? (ft2(32823), nt2 === n3 && rt2 === r3 || (t2.polygonOffset(n3, r3), nt2 = n3, rt2 = r3)) : mt2(32823);
        }
        function _t2(e3) {
          void 0 === e3 && (e3 = 33984 + it2 - 1), ct2 !== e3 && (t2.activeTexture(e3), ct2 = e3);
        }
        return { buffers: { color: i2, depth: o2, stencil: u2 }, enable: ft2, disable: mt2, useProgram: function(e3) {
          return h2 !== e3 && (t2.useProgram(e3), h2 = e3, true);
        }, setBlending: yt2, setMaterial: function(t3, e3) {
          t3.side === g ? mt2(2884) : ft2(2884);
          let n3 = t3.side === m;
          e3 && (n3 = !n3), xt2(n3), t3.blending === b && false === t3.transparent ? yt2(x) : yt2(t3.blending, t3.blendEquation, t3.blendSrc, t3.blendDst, t3.blendEquationAlpha, t3.blendSrcAlpha, t3.blendDstAlpha, t3.premultipliedAlpha), o2.setFunc(t3.depthFunc), o2.setTest(t3.depthTest), o2.setMask(t3.depthWrite), i2.setMask(t3.colorWrite);
          const r3 = t3.stencilWrite;
          u2.setTest(r3), r3 && (u2.setMask(t3.stencilWriteMask), u2.setFunc(t3.stencilFunc, t3.stencilRef, t3.stencilFuncMask), u2.setOp(t3.stencilFail, t3.stencilZFail, t3.stencilZPass)), wt2(t3.polygonOffset, t3.polygonOffsetFactor, t3.polygonOffsetUnits);
        }, setFlipSided: xt2, setCullFace: bt2, setLineWidth: function(e3) {
          e3 !== et2 && (ot2 && t2.lineWidth(e3), et2 = e3);
        }, setPolygonOffset: wt2, setScissorTest: function(t3) {
          t3 ? ft2(3089) : mt2(3089);
        }, activeTexture: _t2, bindTexture: function(e3, n3) {
          null === ct2 && _t2();
          let r3 = ut2[ct2];
          void 0 === r3 && (r3 = { type: void 0, texture: void 0 }, ut2[ct2] = r3), r3.type === e3 && r3.texture === n3 || (t2.bindTexture(e3, n3 || pt2[e3]), r3.type = e3, r3.texture = n3);
        }, unbindTexture: function() {
          const e3 = ut2[ct2];
          void 0 !== e3 && void 0 !== e3.type && (t2.bindTexture(e3.type, null), e3.type = void 0, e3.texture = void 0);
        }, compressedTexImage2D: function() {
          try {
            t2.compressedTexImage2D.apply(t2, arguments);
          } catch (t3) {
            console.error("THREE.WebGLState:", t3);
          }
        }, texImage2D: function() {
          try {
            t2.texImage2D.apply(t2, arguments);
          } catch (t3) {
            console.error("THREE.WebGLState:", t3);
          }
        }, texImage3D: function() {
          try {
            t2.texImage3D.apply(t2, arguments);
          } catch (t3) {
            console.error("THREE.WebGLState:", t3);
          }
        }, scissor: function(e3) {
          false === lt2.equals(e3) && (t2.scissor(e3.x, e3.y, e3.z, e3.w), lt2.copy(e3));
        }, viewport: function(e3) {
          false === ht2.equals(e3) && (t2.viewport(e3.x, e3.y, e3.z, e3.w), ht2.copy(e3));
        }, reset: function() {
          l2 = {}, ct2 = null, ut2 = {}, h2 = null, d2 = null, p2 = null, f2 = null, v2 = null, y2 = null, Z2 = null, J2 = null, $2 = null, Q2 = false, K2 = null, tt2 = null, et2 = null, nt2 = null, rt2 = null, i2.reset(), o2.reset(), u2.reset();
        } };
      }
      function Cs(t2, e2, n2, r2, i2, o2, a2) {
        const s2 = i2.isWebGL2, c2 = i2.maxTextures, u2 = i2.maxCubemapSize, l2 = i2.maxTextureSize, h2 = i2.maxSamples, d2 = /* @__PURE__ */ new WeakMap();
        let p2, f2 = false;
        try {
          f2 = "undefined" != typeof OffscreenCanvas && null !== new OffscreenCanvas(1, 1).getContext("2d");
        } catch (t3) {
        }
        function m2(t3, e3) {
          return f2 ? new OffscreenCanvas(t3, e3) : document.createElementNS("http://www.w3.org/1999/xhtml", "canvas");
        }
        function g2(t3, e3, n3, r3) {
          let i3 = 1;
          if ((t3.width > r3 || t3.height > r3) && (i3 = r3 / Math.max(t3.width, t3.height)), i3 < 1 || true === e3) {
            if ("undefined" != typeof HTMLImageElement && t3 instanceof HTMLImageElement || "undefined" != typeof HTMLCanvasElement && t3 instanceof HTMLCanvasElement || "undefined" != typeof ImageBitmap && t3 instanceof ImageBitmap) {
              const r4 = e3 ? Bn.floorPowerOfTwo : Math.floor, o3 = r4(i3 * t3.width), a3 = r4(i3 * t3.height);
              void 0 === p2 && (p2 = m2(o3, a3));
              const s3 = n3 ? m2(o3, a3) : p2;
              s3.width = o3, s3.height = a3;
              return s3.getContext("2d").drawImage(t3, 0, 0, o3, a3), console.warn("THREE.WebGLRenderer: Texture has been resized from (" + t3.width + "x" + t3.height + ") to (" + o3 + "x" + a3 + ")."), s3;
            }
            return "data" in t3 && console.warn("THREE.WebGLRenderer: Image in DataTexture is too big (" + t3.width + "x" + t3.height + ")."), t3;
          }
          return t3;
        }
        function v2(t3) {
          return Bn.isPowerOfTwo(t3.width) && Bn.isPowerOfTwo(t3.height);
        }
        function y2(t3, e3) {
          return t3.generateMipmaps && e3 && t3.minFilter !== ft && t3.minFilter !== xt;
        }
        function x2(e3, n3, i3, o3) {
          t2.generateMipmap(e3);
          r2.get(n3).__maxMipLevel = Math.log(Math.max(i3, o3)) * Math.LOG2E;
        }
        function b2(n3, r3, i3) {
          if (false === s2) return r3;
          if (null !== n3) {
            if (void 0 !== t2[n3]) return t2[n3];
            console.warn("THREE.WebGLRenderer: Attempt to use non-existing WebGL internal format '" + n3 + "'");
          }
          let o3 = r3;
          return 6403 === r3 && (5126 === i3 && (o3 = 33326), 5131 === i3 && (o3 = 33325), 5121 === i3 && (o3 = 33321)), 6407 === r3 && (5126 === i3 && (o3 = 34837), 5131 === i3 && (o3 = 34843), 5121 === i3 && (o3 = 32849)), 6408 === r3 && (5126 === i3 && (o3 = 34836), 5131 === i3 && (o3 = 34842), 5121 === i3 && (o3 = 32856)), 33325 !== o3 && 33326 !== o3 && 34842 !== o3 && 34836 !== o3 || e2.get("EXT_color_buffer_float"), o3;
        }
        function w2(t3) {
          return t3 === ft || t3 === mt || t3 === vt ? 9728 : 9729;
        }
        function _2(e3) {
          const n3 = e3.target;
          n3.removeEventListener("dispose", _2), function(e4) {
            const n4 = r2.get(e4);
            if (void 0 === n4.__webglInit) return;
            t2.deleteTexture(n4.__webglTexture), r2.remove(e4);
          }(n3), n3.isVideoTexture && d2.delete(n3), a2.memory.textures--;
        }
        function M2(e3) {
          const n3 = e3.target;
          n3.removeEventListener("dispose", M2), function(e4) {
            const n4 = r2.get(e4), i3 = r2.get(e4.texture);
            if (!e4) return;
            void 0 !== i3.__webglTexture && t2.deleteTexture(i3.__webglTexture);
            e4.depthTexture && e4.depthTexture.dispose();
            if (e4.isWebGLCubeRenderTarget) for (let e5 = 0; e5 < 6; e5++) t2.deleteFramebuffer(n4.__webglFramebuffer[e5]), n4.__webglDepthbuffer && t2.deleteRenderbuffer(n4.__webglDepthbuffer[e5]);
            else t2.deleteFramebuffer(n4.__webglFramebuffer), n4.__webglDepthbuffer && t2.deleteRenderbuffer(n4.__webglDepthbuffer), n4.__webglMultisampledFramebuffer && t2.deleteFramebuffer(n4.__webglMultisampledFramebuffer), n4.__webglColorRenderbuffer && t2.deleteRenderbuffer(n4.__webglColorRenderbuffer), n4.__webglDepthRenderbuffer && t2.deleteRenderbuffer(n4.__webglDepthRenderbuffer);
            r2.remove(e4.texture), r2.remove(e4);
          }(n3), a2.memory.textures--;
        }
        let S2 = 0;
        function T2(t3, e3) {
          const i3 = r2.get(t3);
          if (t3.isVideoTexture && function(t4) {
            const e4 = a2.render.frame;
            d2.get(t4) !== e4 && (d2.set(t4, e4), t4.update());
          }(t3), t3.version > 0 && i3.__version !== t3.version) {
            const n3 = t3.image;
            if (void 0 === n3) console.warn("THREE.WebGLRenderer: Texture marked for update but image is undefined");
            else {
              if (false !== n3.complete) return void R2(i3, t3, e3);
              console.warn("THREE.WebGLRenderer: Texture marked for update but image is incomplete");
            }
          }
          n2.activeTexture(33984 + e3), n2.bindTexture(3553, i3.__webglTexture);
        }
        function E2(e3, i3) {
          const a3 = r2.get(e3);
          e3.version > 0 && a3.__version !== e3.version ? function(e4, r3, i4) {
            if (6 !== r3.image.length) return;
            P2(e4, r3), n2.activeTexture(33984 + i4), n2.bindTexture(34067, e4.__webglTexture), t2.pixelStorei(37440, r3.flipY);
            const a4 = r3 && (r3.isCompressedTexture || r3.image[0].isCompressedTexture), c3 = r3.image[0] && r3.image[0].isDataTexture, l3 = [];
            for (let t3 = 0; t3 < 6; t3++) l3[t3] = a4 || c3 ? c3 ? r3.image[t3].image : r3.image[t3] : g2(r3.image[t3], false, true, u2);
            const h3 = l3[0], d3 = v2(h3) || s2, p3 = o2.convert(r3.format), f3 = o2.convert(r3.type), m3 = b2(r3.internalFormat, p3, f3);
            let w3;
            if (L2(34067, r3, d3), a4) {
              for (let t3 = 0; t3 < 6; t3++) {
                w3 = l3[t3].mipmaps;
                for (let e5 = 0; e5 < w3.length; e5++) {
                  const i5 = w3[e5];
                  r3.format !== Ft && r3.format !== kt ? null !== p3 ? n2.compressedTexImage2D(34069 + t3, e5, m3, i5.width, i5.height, 0, i5.data) : console.warn("THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .setTextureCube()") : n2.texImage2D(34069 + t3, e5, m3, i5.width, i5.height, 0, p3, f3, i5.data);
                }
              }
              e4.__maxMipLevel = w3.length - 1;
            } else {
              w3 = r3.mipmaps;
              for (let t3 = 0; t3 < 6; t3++) if (c3) {
                n2.texImage2D(34069 + t3, 0, m3, l3[t3].width, l3[t3].height, 0, p3, f3, l3[t3].data);
                for (let e5 = 0; e5 < w3.length; e5++) {
                  const r4 = w3[e5].image[t3].image;
                  n2.texImage2D(34069 + t3, e5 + 1, m3, r4.width, r4.height, 0, p3, f3, r4.data);
                }
              } else {
                n2.texImage2D(34069 + t3, 0, m3, p3, f3, l3[t3]);
                for (let e5 = 0; e5 < w3.length; e5++) {
                  const r4 = w3[e5];
                  n2.texImage2D(34069 + t3, e5 + 1, m3, p3, f3, r4.image[t3]);
                }
              }
              e4.__maxMipLevel = w3.length;
            }
            y2(r3, d3) && x2(34067, r3, h3.width, h3.height);
            e4.__version = r3.version, r3.onUpdate && r3.onUpdate(r3);
          }(a3, e3, i3) : (n2.activeTexture(33984 + i3), n2.bindTexture(34067, a3.__webglTexture));
        }
        const A2 = { [ht]: 10497, [dt]: 33071, [pt]: 33648 }, C2 = { [ft]: 9728, [mt]: 9984, [vt]: 9986, [xt]: 9729, [bt]: 9985, [_t]: 9987 };
        function L2(n3, o3, a3) {
          a3 ? (t2.texParameteri(n3, 10242, A2[o3.wrapS]), t2.texParameteri(n3, 10243, A2[o3.wrapT]), 32879 !== n3 && 35866 !== n3 || t2.texParameteri(n3, 32882, A2[o3.wrapR]), t2.texParameteri(n3, 10240, C2[o3.magFilter]), t2.texParameteri(n3, 10241, C2[o3.minFilter])) : (t2.texParameteri(n3, 10242, 33071), t2.texParameteri(n3, 10243, 33071), 32879 !== n3 && 35866 !== n3 || t2.texParameteri(n3, 32882, 33071), o3.wrapS === dt && o3.wrapT === dt || console.warn("THREE.WebGLRenderer: Texture is not power of two. Texture.wrapS and Texture.wrapT should be set to THREE.ClampToEdgeWrapping."), t2.texParameteri(n3, 10240, w2(o3.magFilter)), t2.texParameteri(n3, 10241, w2(o3.minFilter)), o3.minFilter !== ft && o3.minFilter !== xt && console.warn("THREE.WebGLRenderer: Texture is not power of two. Texture.minFilter should be set to THREE.NearestFilter or THREE.LinearFilter."));
          const c3 = e2.get("EXT_texture_filter_anisotropic");
          if (c3) {
            if (o3.type === Pt && null === e2.get("OES_texture_float_linear")) return;
            if (o3.type === Rt && null === (s2 || e2.get("OES_texture_half_float_linear"))) return;
            (o3.anisotropy > 1 || r2.get(o3).__currentAnisotropy) && (t2.texParameterf(n3, c3.TEXTURE_MAX_ANISOTROPY_EXT, Math.min(o3.anisotropy, i2.getMaxAnisotropy())), r2.get(o3).__currentAnisotropy = o3.anisotropy);
          }
        }
        function P2(e3, n3) {
          void 0 === e3.__webglInit && (e3.__webglInit = true, n3.addEventListener("dispose", _2), e3.__webglTexture = t2.createTexture(), a2.memory.textures++);
        }
        function R2(e3, r3, i3) {
          let a3 = 3553;
          r3.isDataTexture2DArray && (a3 = 35866), r3.isDataTexture3D && (a3 = 32879), P2(e3, r3), n2.activeTexture(33984 + i3), n2.bindTexture(a3, e3.__webglTexture), t2.pixelStorei(37440, r3.flipY), t2.pixelStorei(37441, r3.premultiplyAlpha), t2.pixelStorei(3317, r3.unpackAlignment);
          const c3 = function(t3) {
            return !s2 && (t3.wrapS !== dt || t3.wrapT !== dt || t3.minFilter !== ft && t3.minFilter !== xt);
          }(r3) && false === v2(r3.image), u3 = g2(r3.image, c3, false, l2), h3 = v2(u3) || s2, d3 = o2.convert(r3.format);
          let p3, f3 = o2.convert(r3.type), m3 = b2(r3.internalFormat, d3, f3);
          L2(a3, r3, h3);
          const w3 = r3.mipmaps;
          if (r3.isDepthTexture) m3 = 6402, s2 ? m3 = r3.type === Pt ? 36012 : r3.type === Lt ? 33190 : r3.type === Nt ? 35056 : 33189 : r3.type === Pt && console.error("WebGLRenderer: Floating point depth texture requires WebGL2."), r3.format === Ut && 6402 === m3 && r3.type !== At && r3.type !== Lt && (console.warn("THREE.WebGLRenderer: Use UnsignedShortType or UnsignedIntType for DepthFormat DepthTexture."), r3.type = At, f3 = o2.convert(r3.type)), r3.format === jt && 6402 === m3 && (m3 = 34041, r3.type !== Nt && (console.warn("THREE.WebGLRenderer: Use UnsignedInt248Type for DepthStencilFormat DepthTexture."), r3.type = Nt, f3 = o2.convert(r3.type))), n2.texImage2D(3553, 0, m3, u3.width, u3.height, 0, d3, f3, null);
          else if (r3.isDataTexture) if (w3.length > 0 && h3) {
            for (let t3 = 0, e4 = w3.length; t3 < e4; t3++) p3 = w3[t3], n2.texImage2D(3553, t3, m3, p3.width, p3.height, 0, d3, f3, p3.data);
            r3.generateMipmaps = false, e3.__maxMipLevel = w3.length - 1;
          } else n2.texImage2D(3553, 0, m3, u3.width, u3.height, 0, d3, f3, u3.data), e3.__maxMipLevel = 0;
          else if (r3.isCompressedTexture) {
            for (let t3 = 0, e4 = w3.length; t3 < e4; t3++) p3 = w3[t3], r3.format !== Ft && r3.format !== kt ? null !== d3 ? n2.compressedTexImage2D(3553, t3, m3, p3.width, p3.height, 0, p3.data) : console.warn("THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .uploadTexture()") : n2.texImage2D(3553, t3, m3, p3.width, p3.height, 0, d3, f3, p3.data);
            e3.__maxMipLevel = w3.length - 1;
          } else if (r3.isDataTexture2DArray) n2.texImage3D(35866, 0, m3, u3.width, u3.height, u3.depth, 0, d3, f3, u3.data), e3.__maxMipLevel = 0;
          else if (r3.isDataTexture3D) n2.texImage3D(32879, 0, m3, u3.width, u3.height, u3.depth, 0, d3, f3, u3.data), e3.__maxMipLevel = 0;
          else if (w3.length > 0 && h3) {
            for (let t3 = 0, e4 = w3.length; t3 < e4; t3++) p3 = w3[t3], n2.texImage2D(3553, t3, m3, d3, f3, p3);
            r3.generateMipmaps = false, e3.__maxMipLevel = w3.length - 1;
          } else n2.texImage2D(3553, 0, m3, d3, f3, u3), e3.__maxMipLevel = 0;
          y2(r3, h3) && x2(a3, r3, u3.width, u3.height), e3.__version = r3.version, r3.onUpdate && r3.onUpdate(r3);
        }
        function O2(e3, i3, a3, s3) {
          const c3 = o2.convert(i3.texture.format), u3 = o2.convert(i3.texture.type), l3 = b2(i3.texture.internalFormat, c3, u3);
          n2.texImage2D(s3, 0, l3, i3.width, i3.height, 0, c3, u3, null), t2.bindFramebuffer(36160, e3), t2.framebufferTexture2D(36160, a3, s3, r2.get(i3.texture).__webglTexture, 0), t2.bindFramebuffer(36160, null);
        }
        function D2(e3, n3, r3) {
          if (t2.bindRenderbuffer(36161, e3), n3.depthBuffer && !n3.stencilBuffer) {
            let i3 = 33189;
            if (r3) {
              const e4 = n3.depthTexture;
              e4 && e4.isDepthTexture && (e4.type === Pt ? i3 = 36012 : e4.type === Lt && (i3 = 33190));
              const r4 = N2(n3);
              t2.renderbufferStorageMultisample(36161, r4, i3, n3.width, n3.height);
            } else t2.renderbufferStorage(36161, i3, n3.width, n3.height);
            t2.framebufferRenderbuffer(36160, 36096, 36161, e3);
          } else if (n3.depthBuffer && n3.stencilBuffer) {
            if (r3) {
              const e4 = N2(n3);
              t2.renderbufferStorageMultisample(36161, e4, 35056, n3.width, n3.height);
            } else t2.renderbufferStorage(36161, 34041, n3.width, n3.height);
            t2.framebufferRenderbuffer(36160, 33306, 36161, e3);
          } else {
            const e4 = o2.convert(n3.texture.format), i3 = o2.convert(n3.texture.type), a3 = b2(n3.texture.internalFormat, e4, i3);
            if (r3) {
              const e5 = N2(n3);
              t2.renderbufferStorageMultisample(36161, e5, a3, n3.width, n3.height);
            } else t2.renderbufferStorage(36161, a3, n3.width, n3.height);
          }
          t2.bindRenderbuffer(36161, null);
        }
        function I2(e3) {
          const n3 = r2.get(e3), i3 = true === e3.isWebGLCubeRenderTarget;
          if (e3.depthTexture) {
            if (i3) throw new Error("target.depthTexture not supported in Cube render targets");
            !function(e4, n4) {
              if (n4 && n4.isWebGLCubeRenderTarget) throw new Error("Depth Texture with cube render targets is not supported");
              if (t2.bindFramebuffer(36160, e4), !n4.depthTexture || !n4.depthTexture.isDepthTexture) throw new Error("renderTarget.depthTexture must be an instance of THREE.DepthTexture");
              r2.get(n4.depthTexture).__webglTexture && n4.depthTexture.image.width === n4.width && n4.depthTexture.image.height === n4.height || (n4.depthTexture.image.width = n4.width, n4.depthTexture.image.height = n4.height, n4.depthTexture.needsUpdate = true), T2(n4.depthTexture, 0);
              const i4 = r2.get(n4.depthTexture).__webglTexture;
              if (n4.depthTexture.format === Ut) t2.framebufferTexture2D(36160, 36096, 3553, i4, 0);
              else {
                if (n4.depthTexture.format !== jt) throw new Error("Unknown depthTexture format");
                t2.framebufferTexture2D(36160, 33306, 3553, i4, 0);
              }
            }(n3.__webglFramebuffer, e3);
          } else if (i3) {
            n3.__webglDepthbuffer = [];
            for (let r3 = 0; r3 < 6; r3++) t2.bindFramebuffer(36160, n3.__webglFramebuffer[r3]), n3.__webglDepthbuffer[r3] = t2.createRenderbuffer(), D2(n3.__webglDepthbuffer[r3], e3, false);
          } else t2.bindFramebuffer(36160, n3.__webglFramebuffer), n3.__webglDepthbuffer = t2.createRenderbuffer(), D2(n3.__webglDepthbuffer, e3, false);
          t2.bindFramebuffer(36160, null);
        }
        function N2(t3) {
          return s2 && t3.isWebGLMultisampleRenderTarget ? Math.min(h2, t3.samples) : 0;
        }
        let z2 = false, k2 = false;
        this.allocateTextureUnit = function() {
          const t3 = S2;
          return t3 >= c2 && console.warn("THREE.WebGLTextures: Trying to use " + t3 + " texture units while this GPU supports only " + c2), S2 += 1, t3;
        }, this.resetTextureUnits = function() {
          S2 = 0;
        }, this.setTexture2D = T2, this.setTexture2DArray = function(t3, e3) {
          const i3 = r2.get(t3);
          t3.version > 0 && i3.__version !== t3.version ? R2(i3, t3, e3) : (n2.activeTexture(33984 + e3), n2.bindTexture(35866, i3.__webglTexture));
        }, this.setTexture3D = function(t3, e3) {
          const i3 = r2.get(t3);
          t3.version > 0 && i3.__version !== t3.version ? R2(i3, t3, e3) : (n2.activeTexture(33984 + e3), n2.bindTexture(32879, i3.__webglTexture));
        }, this.setTextureCube = E2, this.setupRenderTarget = function(e3) {
          const i3 = r2.get(e3), c3 = r2.get(e3.texture);
          e3.addEventListener("dispose", M2), c3.__webglTexture = t2.createTexture(), a2.memory.textures++;
          const u3 = true === e3.isWebGLCubeRenderTarget, l3 = true === e3.isWebGLMultisampleRenderTarget, h3 = v2(e3) || s2;
          if (!s2 || e3.texture.format !== kt || e3.texture.type !== Pt && e3.texture.type !== Rt || (e3.texture.format = Ft, console.warn("THREE.WebGLRenderer: Rendering to textures with RGB format is not supported. Using RGBA format instead.")), u3) {
            i3.__webglFramebuffer = [];
            for (let e4 = 0; e4 < 6; e4++) i3.__webglFramebuffer[e4] = t2.createFramebuffer();
          } else if (i3.__webglFramebuffer = t2.createFramebuffer(), l3) if (s2) {
            i3.__webglMultisampledFramebuffer = t2.createFramebuffer(), i3.__webglColorRenderbuffer = t2.createRenderbuffer(), t2.bindRenderbuffer(36161, i3.__webglColorRenderbuffer);
            const n3 = o2.convert(e3.texture.format), r3 = o2.convert(e3.texture.type), a3 = b2(e3.texture.internalFormat, n3, r3), s3 = N2(e3);
            t2.renderbufferStorageMultisample(36161, s3, a3, e3.width, e3.height), t2.bindFramebuffer(36160, i3.__webglMultisampledFramebuffer), t2.framebufferRenderbuffer(36160, 36064, 36161, i3.__webglColorRenderbuffer), t2.bindRenderbuffer(36161, null), e3.depthBuffer && (i3.__webglDepthRenderbuffer = t2.createRenderbuffer(), D2(i3.__webglDepthRenderbuffer, e3, true)), t2.bindFramebuffer(36160, null);
          } else console.warn("THREE.WebGLRenderer: WebGLMultisampleRenderTarget can only be used with WebGL2.");
          if (u3) {
            n2.bindTexture(34067, c3.__webglTexture), L2(34067, e3.texture, h3);
            for (let t3 = 0; t3 < 6; t3++) O2(i3.__webglFramebuffer[t3], e3, 36064, 34069 + t3);
            y2(e3.texture, h3) && x2(34067, e3.texture, e3.width, e3.height), n2.bindTexture(34067, null);
          } else n2.bindTexture(3553, c3.__webglTexture), L2(3553, e3.texture, h3), O2(i3.__webglFramebuffer, e3, 36064, 3553), y2(e3.texture, h3) && x2(3553, e3.texture, e3.width, e3.height), n2.bindTexture(3553, null);
          e3.depthBuffer && I2(e3);
        }, this.updateRenderTargetMipmap = function(t3) {
          const e3 = t3.texture;
          if (y2(e3, v2(t3) || s2)) {
            const i3 = t3.isWebGLCubeRenderTarget ? 34067 : 3553, o3 = r2.get(e3).__webglTexture;
            n2.bindTexture(i3, o3), x2(i3, e3, t3.width, t3.height), n2.bindTexture(i3, null);
          }
        }, this.updateMultisampleRenderTarget = function(e3) {
          if (e3.isWebGLMultisampleRenderTarget) if (s2) {
            const n3 = r2.get(e3);
            t2.bindFramebuffer(36008, n3.__webglMultisampledFramebuffer), t2.bindFramebuffer(36009, n3.__webglFramebuffer);
            const i3 = e3.width, o3 = e3.height;
            let a3 = 16384;
            e3.depthBuffer && (a3 |= 256), e3.stencilBuffer && (a3 |= 1024), t2.blitFramebuffer(0, 0, i3, o3, 0, 0, i3, o3, a3, 9728), t2.bindFramebuffer(36160, n3.__webglMultisampledFramebuffer);
          } else console.warn("THREE.WebGLRenderer: WebGLMultisampleRenderTarget can only be used with WebGL2.");
        }, this.safeSetTexture2D = function(t3, e3) {
          t3 && t3.isWebGLRenderTarget && (false === z2 && (console.warn("THREE.WebGLTextures.safeSetTexture2D: don't use render targets as textures. Use their .texture property instead."), z2 = true), t3 = t3.texture), T2(t3, e3);
        }, this.safeSetTextureCube = function(t3, e3) {
          t3 && t3.isWebGLCubeRenderTarget && (false === k2 && (console.warn("THREE.WebGLTextures.safeSetTextureCube: don't use cube render targets as textures. Use their .texture property instead."), k2 = true), t3 = t3.texture), E2(t3, e3);
        };
      }
      function Ls(t2, e2, n2) {
        const r2 = n2.isWebGL2;
        return { convert: function(t3) {
          let n3;
          if (t3 === St) return 5121;
          if (t3 === Ot) return 32819;
          if (t3 === Dt) return 32820;
          if (t3 === It) return 33635;
          if (t3 === Tt) return 5120;
          if (t3 === Et) return 5122;
          if (t3 === At) return 5123;
          if (t3 === Ct) return 5124;
          if (t3 === Lt) return 5125;
          if (t3 === Pt) return 5126;
          if (t3 === Rt) return r2 ? 5131 : (n3 = e2.get("OES_texture_half_float"), null !== n3 ? n3.HALF_FLOAT_OES : null);
          if (t3 === zt) return 6406;
          if (t3 === kt) return 6407;
          if (t3 === Ft) return 6408;
          if (t3 === Bt) return 6409;
          if (t3 === Ht) return 6410;
          if (t3 === Ut) return 6402;
          if (t3 === jt) return 34041;
          if (t3 === Vt) return 6403;
          if (t3 === Wt) return 36244;
          if (t3 === qt) return 33319;
          if (t3 === Xt) return 33320;
          if (t3 === Yt) return 36248;
          if (t3 === Zt) return 36249;
          if (t3 === Jt || t3 === $t || t3 === Qt || t3 === Kt) {
            if (n3 = e2.get("WEBGL_compressed_texture_s3tc"), null === n3) return null;
            if (t3 === Jt) return n3.COMPRESSED_RGB_S3TC_DXT1_EXT;
            if (t3 === $t) return n3.COMPRESSED_RGBA_S3TC_DXT1_EXT;
            if (t3 === Qt) return n3.COMPRESSED_RGBA_S3TC_DXT3_EXT;
            if (t3 === Kt) return n3.COMPRESSED_RGBA_S3TC_DXT5_EXT;
          }
          if (t3 === te || t3 === ee || t3 === ne || t3 === re) {
            if (n3 = e2.get("WEBGL_compressed_texture_pvrtc"), null === n3) return null;
            if (t3 === te) return n3.COMPRESSED_RGB_PVRTC_4BPPV1_IMG;
            if (t3 === ee) return n3.COMPRESSED_RGB_PVRTC_2BPPV1_IMG;
            if (t3 === ne) return n3.COMPRESSED_RGBA_PVRTC_4BPPV1_IMG;
            if (t3 === re) return n3.COMPRESSED_RGBA_PVRTC_2BPPV1_IMG;
          }
          if (t3 === ie) return n3 = e2.get("WEBGL_compressed_texture_etc1"), null !== n3 ? n3.COMPRESSED_RGB_ETC1_WEBGL : null;
          if ((t3 === oe || t3 === ae) && (n3 = e2.get("WEBGL_compressed_texture_etc"), null !== n3)) {
            if (t3 === oe) return n3.COMPRESSED_RGB8_ETC2;
            if (t3 === ae) return n3.COMPRESSED_RGBA8_ETC2_EAC;
          }
          return t3 === se || t3 === ce || t3 === ue || t3 === le || t3 === he || t3 === de || t3 === pe || t3 === fe || t3 === me || t3 === ge || t3 === ve || t3 === ye || t3 === xe || t3 === be || t3 === _e || t3 === Me || t3 === Se || t3 === Te || t3 === Ee || t3 === Ae || t3 === Ce || t3 === Le || t3 === Pe || t3 === Re || t3 === Oe || t3 === De || t3 === Ie || t3 === Ne ? (n3 = e2.get("WEBGL_compressed_texture_astc"), null !== n3 ? t3 : null) : t3 === we ? (n3 = e2.get("EXT_texture_compression_bptc"), null !== n3 ? t3 : null) : t3 === Nt ? r2 ? 34042 : (n3 = e2.get("WEBGL_depth_texture"), null !== n3 ? n3.UNSIGNED_INT_24_8_WEBGL : null) : void 0;
        } };
      }
      function Ps(t2 = []) {
        wo.call(this), this.cameras = t2;
      }
      function Rs() {
        Jr.call(this), this.type = "Group";
      }
      function Os() {
        this._targetRay = null, this._grip = null, this._hand = null;
      }
      function Ds(t2, e2) {
        const n2 = this;
        let r2 = null, i2 = 1, o2 = null, a2 = "local-floor", s2 = null;
        const c2 = [], u2 = /* @__PURE__ */ new Map(), l2 = new wo();
        l2.layers.enable(1), l2.viewport = new Xn();
        const h2 = new wo();
        h2.layers.enable(2), h2.viewport = new Xn();
        const d2 = [l2, h2], p2 = new Ps();
        p2.layers.enable(1), p2.layers.enable(2);
        let f2 = null, m2 = null;
        function g2(t3) {
          const e3 = u2.get(t3.inputSource);
          e3 && e3.dispatchEvent({ type: t3.type, data: t3.inputSource });
        }
        function v2() {
          u2.forEach(function(t3, e3) {
            t3.disconnect(e3);
          }), u2.clear(), t2.setFramebuffer(null), t2.setRenderTarget(t2.getRenderTarget()), S2.stop(), n2.isPresenting = false, n2.dispatchEvent({ type: "sessionend" });
        }
        function y2(t3) {
          o2 = t3, S2.setContext(r2), S2.start(), n2.isPresenting = true, n2.dispatchEvent({ type: "sessionstart" });
        }
        function x2(t3) {
          const e3 = r2.inputSources;
          for (let t4 = 0; t4 < c2.length; t4++) u2.set(e3[t4], c2[t4]);
          for (let e4 = 0; e4 < t3.removed.length; e4++) {
            const n3 = t3.removed[e4], r3 = u2.get(n3);
            r3 && (r3.dispatchEvent({ type: "disconnected", data: n3 }), u2.delete(n3));
          }
          for (let e4 = 0; e4 < t3.added.length; e4++) {
            const n3 = t3.added[e4], r3 = u2.get(n3);
            r3 && r3.dispatchEvent({ type: "connected", data: n3 });
          }
        }
        this.enabled = false, this.isPresenting = false, this.getController = function(t3) {
          let e3 = c2[t3];
          return void 0 === e3 && (e3 = new Os(), c2[t3] = e3), e3.getTargetRaySpace();
        }, this.getControllerGrip = function(t3) {
          let e3 = c2[t3];
          return void 0 === e3 && (e3 = new Os(), c2[t3] = e3), e3.getGripSpace();
        }, this.getHand = function(t3) {
          let e3 = c2[t3];
          return void 0 === e3 && (e3 = new Os(), c2[t3] = e3), e3.getHandSpace();
        }, this.setFramebufferScaleFactor = function(t3) {
          i2 = t3, true === n2.isPresenting && console.warn("THREE.WebXRManager: Cannot change framebuffer scale while presenting.");
        }, this.setReferenceSpaceType = function(t3) {
          a2 = t3, true === n2.isPresenting && console.warn("THREE.WebXRManager: Cannot change reference space type while presenting.");
        }, this.getReferenceSpace = function() {
          return o2;
        }, this.getSession = function() {
          return r2;
        }, this.setSession = function(t3) {
          if (r2 = t3, null !== r2) {
            r2.addEventListener("select", g2), r2.addEventListener("selectstart", g2), r2.addEventListener("selectend", g2), r2.addEventListener("squeeze", g2), r2.addEventListener("squeezestart", g2), r2.addEventListener("squeezeend", g2), r2.addEventListener("end", v2);
            const t4 = e2.getContextAttributes();
            true !== t4.xrCompatible && e2.makeXRCompatible();
            const n3 = { antialias: t4.antialias, alpha: t4.alpha, depth: t4.depth, stencil: t4.stencil, framebufferScaleFactor: i2 }, o3 = new XRWebGLLayer(r2, e2, n3);
            r2.updateRenderState({ baseLayer: o3 }), r2.requestReferenceSpace(a2).then(y2), r2.addEventListener("inputsourceschange", x2);
          }
        };
        const b2 = new $n(), w2 = new $n();
        function _2(t3, e3) {
          null === e3 ? t3.matrixWorld.copy(t3.matrix) : t3.matrixWorld.multiplyMatrices(e3.matrixWorld, t3.matrix), t3.matrixWorldInverse.copy(t3.matrixWorld).invert();
        }
        this.getCamera = function(t3) {
          p2.near = h2.near = l2.near = t3.near, p2.far = h2.far = l2.far = t3.far, f2 === p2.near && m2 === p2.far || (r2.updateRenderState({ depthNear: p2.near, depthFar: p2.far }), f2 = p2.near, m2 = p2.far);
          const e3 = t3.parent, n3 = p2.cameras;
          _2(p2, e3);
          for (let t4 = 0; t4 < n3.length; t4++) _2(n3[t4], e3);
          t3.matrixWorld.copy(p2.matrixWorld);
          const i3 = t3.children;
          for (let t4 = 0, e4 = i3.length; t4 < e4; t4++) i3[t4].updateMatrixWorld(true);
          return 2 === n3.length ? function(t4, e4, n4) {
            b2.setFromMatrixPosition(e4.matrixWorld), w2.setFromMatrixPosition(n4.matrixWorld);
            const r3 = b2.distanceTo(w2), i4 = e4.projectionMatrix.elements, o3 = n4.projectionMatrix.elements, a3 = i4[14] / (i4[10] - 1), s3 = i4[14] / (i4[10] + 1), c3 = (i4[9] + 1) / i4[5], u3 = (i4[9] - 1) / i4[5], l3 = (i4[8] - 1) / i4[0], h3 = (o3[8] + 1) / o3[0], d3 = a3 * l3, p3 = a3 * h3, f3 = r3 / (-l3 + h3), m3 = f3 * -l3;
            e4.matrixWorld.decompose(t4.position, t4.quaternion, t4.scale), t4.translateX(m3), t4.translateZ(f3), t4.matrixWorld.compose(t4.position, t4.quaternion, t4.scale), t4.matrixWorldInverse.copy(t4.matrixWorld).invert();
            const g3 = a3 + f3, v3 = s3 + f3, y3 = d3 - m3, x3 = p3 + (r3 - m3), _3 = c3 * s3 / v3 * g3, M3 = u3 * s3 / v3 * g3;
            t4.projectionMatrix.makePerspective(y3, x3, _3, M3, g3, v3);
          }(p2, l2, h2) : p2.projectionMatrix.copy(l2.projectionMatrix), p2;
        };
        let M2 = null;
        const S2 = new Lo();
        S2.setAnimationLoop(function(e3, n3) {
          if (s2 = n3.getViewerPose(o2), null !== s2) {
            const e4 = s2.views, n4 = r2.renderState.baseLayer;
            t2.setFramebuffer(n4.framebuffer);
            let i4 = false;
            e4.length !== p2.cameras.length && (p2.cameras.length = 0, i4 = true);
            for (let t3 = 0; t3 < e4.length; t3++) {
              const r3 = e4[t3], o3 = n4.getViewport(r3), a3 = d2[t3];
              a3.matrix.fromArray(r3.transform.matrix), a3.projectionMatrix.fromArray(r3.projectionMatrix), a3.viewport.set(o3.x, o3.y, o3.width, o3.height), 0 === t3 && p2.matrix.copy(a3.matrix), true === i4 && p2.cameras.push(a3);
            }
          }
          const i3 = r2.inputSources;
          for (let t3 = 0; t3 < c2.length; t3++) {
            const e4 = c2[t3], r3 = i3[t3];
            e4.update(r3, n3, o2);
          }
          M2 && M2(e3, n3);
        }), this.setAnimationLoop = function(t3) {
          M2 = t3;
        }, this.dispose = function() {
        };
      }
      function Is(t2) {
        function e2(e3, n3) {
          e3.opacity.value = n3.opacity, n3.color && e3.diffuse.value.copy(n3.color), n3.emissive && e3.emissive.value.copy(n3.emissive).multiplyScalar(n3.emissiveIntensity), n3.map && (e3.map.value = n3.map), n3.alphaMap && (e3.alphaMap.value = n3.alphaMap), n3.specularMap && (e3.specularMap.value = n3.specularMap);
          const r2 = t2.get(n3).envMap;
          if (r2) {
            e3.envMap.value = r2, e3.flipEnvMap.value = r2.isCubeTexture && r2._needsFlipEnvMap ? -1 : 1, e3.reflectivity.value = n3.reflectivity, e3.refractionRatio.value = n3.refractionRatio;
            const i3 = t2.get(r2).__maxMipLevel;
            void 0 !== i3 && (e3.maxMipLevel.value = i3);
          }
          let i2, o2;
          n3.lightMap && (e3.lightMap.value = n3.lightMap, e3.lightMapIntensity.value = n3.lightMapIntensity), n3.aoMap && (e3.aoMap.value = n3.aoMap, e3.aoMapIntensity.value = n3.aoMapIntensity), n3.map ? i2 = n3.map : n3.specularMap ? i2 = n3.specularMap : n3.displacementMap ? i2 = n3.displacementMap : n3.normalMap ? i2 = n3.normalMap : n3.bumpMap ? i2 = n3.bumpMap : n3.roughnessMap ? i2 = n3.roughnessMap : n3.metalnessMap ? i2 = n3.metalnessMap : n3.alphaMap ? i2 = n3.alphaMap : n3.emissiveMap ? i2 = n3.emissiveMap : n3.clearcoatMap ? i2 = n3.clearcoatMap : n3.clearcoatNormalMap ? i2 = n3.clearcoatNormalMap : n3.clearcoatRoughnessMap && (i2 = n3.clearcoatRoughnessMap), void 0 !== i2 && (i2.isWebGLRenderTarget && (i2 = i2.texture), true === i2.matrixAutoUpdate && i2.updateMatrix(), e3.uvTransform.value.copy(i2.matrix)), n3.aoMap ? o2 = n3.aoMap : n3.lightMap && (o2 = n3.lightMap), void 0 !== o2 && (o2.isWebGLRenderTarget && (o2 = o2.texture), true === o2.matrixAutoUpdate && o2.updateMatrix(), e3.uv2Transform.value.copy(o2.matrix));
        }
        function n2(e3, n3) {
          e3.roughness.value = n3.roughness, e3.metalness.value = n3.metalness, n3.roughnessMap && (e3.roughnessMap.value = n3.roughnessMap), n3.metalnessMap && (e3.metalnessMap.value = n3.metalnessMap), n3.emissiveMap && (e3.emissiveMap.value = n3.emissiveMap), n3.bumpMap && (e3.bumpMap.value = n3.bumpMap, e3.bumpScale.value = n3.bumpScale, n3.side === m && (e3.bumpScale.value *= -1)), n3.normalMap && (e3.normalMap.value = n3.normalMap, e3.normalScale.value.copy(n3.normalScale), n3.side === m && e3.normalScale.value.negate()), n3.displacementMap && (e3.displacementMap.value = n3.displacementMap, e3.displacementScale.value = n3.displacementScale, e3.displacementBias.value = n3.displacementBias);
          t2.get(n3).envMap && (e3.envMapIntensity.value = n3.envMapIntensity);
        }
        return { refreshFogUniforms: function(t3, e3) {
          t3.fogColor.value.copy(e3.color), e3.isFog ? (t3.fogNear.value = e3.near, t3.fogFar.value = e3.far) : e3.isFogExp2 && (t3.fogDensity.value = e3.density);
        }, refreshMaterialUniforms: function(t3, r2, i2, o2) {
          r2.isMeshBasicMaterial ? e2(t3, r2) : r2.isMeshLambertMaterial ? (e2(t3, r2), function(t4, e3) {
            e3.emissiveMap && (t4.emissiveMap.value = e3.emissiveMap);
          }(t3, r2)) : r2.isMeshToonMaterial ? (e2(t3, r2), function(t4, e3) {
            e3.gradientMap && (t4.gradientMap.value = e3.gradientMap);
            e3.emissiveMap && (t4.emissiveMap.value = e3.emissiveMap);
            e3.bumpMap && (t4.bumpMap.value = e3.bumpMap, t4.bumpScale.value = e3.bumpScale, e3.side === m && (t4.bumpScale.value *= -1));
            e3.normalMap && (t4.normalMap.value = e3.normalMap, t4.normalScale.value.copy(e3.normalScale), e3.side === m && t4.normalScale.value.negate());
            e3.displacementMap && (t4.displacementMap.value = e3.displacementMap, t4.displacementScale.value = e3.displacementScale, t4.displacementBias.value = e3.displacementBias);
          }(t3, r2)) : r2.isMeshPhongMaterial ? (e2(t3, r2), function(t4, e3) {
            t4.specular.value.copy(e3.specular), t4.shininess.value = Math.max(e3.shininess, 1e-4), e3.emissiveMap && (t4.emissiveMap.value = e3.emissiveMap);
            e3.bumpMap && (t4.bumpMap.value = e3.bumpMap, t4.bumpScale.value = e3.bumpScale, e3.side === m && (t4.bumpScale.value *= -1));
            e3.normalMap && (t4.normalMap.value = e3.normalMap, t4.normalScale.value.copy(e3.normalScale), e3.side === m && t4.normalScale.value.negate());
            e3.displacementMap && (t4.displacementMap.value = e3.displacementMap, t4.displacementScale.value = e3.displacementScale, t4.displacementBias.value = e3.displacementBias);
          }(t3, r2)) : r2.isMeshStandardMaterial ? (e2(t3, r2), r2.isMeshPhysicalMaterial ? function(t4, e3) {
            n2(t4, e3), t4.reflectivity.value = e3.reflectivity, t4.clearcoat.value = e3.clearcoat, t4.clearcoatRoughness.value = e3.clearcoatRoughness, e3.sheen && t4.sheen.value.copy(e3.sheen);
            e3.clearcoatMap && (t4.clearcoatMap.value = e3.clearcoatMap);
            e3.clearcoatRoughnessMap && (t4.clearcoatRoughnessMap.value = e3.clearcoatRoughnessMap);
            e3.clearcoatNormalMap && (t4.clearcoatNormalScale.value.copy(e3.clearcoatNormalScale), t4.clearcoatNormalMap.value = e3.clearcoatNormalMap, e3.side === m && t4.clearcoatNormalScale.value.negate());
            t4.transmission.value = e3.transmission, e3.transmissionMap && (t4.transmissionMap.value = e3.transmissionMap);
          }(t3, r2) : n2(t3, r2)) : r2.isMeshMatcapMaterial ? (e2(t3, r2), function(t4, e3) {
            e3.matcap && (t4.matcap.value = e3.matcap);
            e3.bumpMap && (t4.bumpMap.value = e3.bumpMap, t4.bumpScale.value = e3.bumpScale, e3.side === m && (t4.bumpScale.value *= -1));
            e3.normalMap && (t4.normalMap.value = e3.normalMap, t4.normalScale.value.copy(e3.normalScale), e3.side === m && t4.normalScale.value.negate());
            e3.displacementMap && (t4.displacementMap.value = e3.displacementMap, t4.displacementScale.value = e3.displacementScale, t4.displacementBias.value = e3.displacementBias);
          }(t3, r2)) : r2.isMeshDepthMaterial ? (e2(t3, r2), function(t4, e3) {
            e3.displacementMap && (t4.displacementMap.value = e3.displacementMap, t4.displacementScale.value = e3.displacementScale, t4.displacementBias.value = e3.displacementBias);
          }(t3, r2)) : r2.isMeshDistanceMaterial ? (e2(t3, r2), function(t4, e3) {
            e3.displacementMap && (t4.displacementMap.value = e3.displacementMap, t4.displacementScale.value = e3.displacementScale, t4.displacementBias.value = e3.displacementBias);
            t4.referencePosition.value.copy(e3.referencePosition), t4.nearDistance.value = e3.nearDistance, t4.farDistance.value = e3.farDistance;
          }(t3, r2)) : r2.isMeshNormalMaterial ? (e2(t3, r2), function(t4, e3) {
            e3.bumpMap && (t4.bumpMap.value = e3.bumpMap, t4.bumpScale.value = e3.bumpScale, e3.side === m && (t4.bumpScale.value *= -1));
            e3.normalMap && (t4.normalMap.value = e3.normalMap, t4.normalScale.value.copy(e3.normalScale), e3.side === m && t4.normalScale.value.negate());
            e3.displacementMap && (t4.displacementMap.value = e3.displacementMap, t4.displacementScale.value = e3.displacementScale, t4.displacementBias.value = e3.displacementBias);
          }(t3, r2)) : r2.isLineBasicMaterial ? (function(t4, e3) {
            t4.diffuse.value.copy(e3.color), t4.opacity.value = e3.opacity;
          }(t3, r2), r2.isLineDashedMaterial && function(t4, e3) {
            t4.dashSize.value = e3.dashSize, t4.totalSize.value = e3.dashSize + e3.gapSize, t4.scale.value = e3.scale;
          }(t3, r2)) : r2.isPointsMaterial ? function(t4, e3, n3, r3) {
            t4.diffuse.value.copy(e3.color), t4.opacity.value = e3.opacity, t4.size.value = e3.size * n3, t4.scale.value = 0.5 * r3, e3.map && (t4.map.value = e3.map);
            e3.alphaMap && (t4.alphaMap.value = e3.alphaMap);
            let i3;
            e3.map ? i3 = e3.map : e3.alphaMap && (i3 = e3.alphaMap);
            void 0 !== i3 && (true === i3.matrixAutoUpdate && i3.updateMatrix(), t4.uvTransform.value.copy(i3.matrix));
          }(t3, r2, i2, o2) : r2.isSpriteMaterial ? function(t4, e3) {
            t4.diffuse.value.copy(e3.color), t4.opacity.value = e3.opacity, t4.rotation.value = e3.rotation, e3.map && (t4.map.value = e3.map);
            e3.alphaMap && (t4.alphaMap.value = e3.alphaMap);
            let n3;
            e3.map ? n3 = e3.map : e3.alphaMap && (n3 = e3.alphaMap);
            void 0 !== n3 && (true === n3.matrixAutoUpdate && n3.updateMatrix(), t4.uvTransform.value.copy(n3.matrix));
          }(t3, r2) : r2.isShadowMaterial ? (t3.color.value.copy(r2.color), t3.opacity.value = r2.opacity) : r2.isShaderMaterial && (r2.uniformsNeedUpdate = false);
        } };
      }
      function Ns(t2) {
        const e2 = void 0 !== (t2 = t2 || {}).canvas ? t2.canvas : function() {
          const t3 = document.createElementNS("http://www.w3.org/1999/xhtml", "canvas");
          return t3.style.display = "block", t3;
        }(), n2 = void 0 !== t2.context ? t2.context : null, r2 = void 0 !== t2.alpha && t2.alpha, i2 = void 0 === t2.depth || t2.depth, o2 = void 0 === t2.stencil || t2.stencil, a2 = void 0 !== t2.antialias && t2.antialias, s2 = void 0 === t2.premultipliedAlpha || t2.premultipliedAlpha, c2 = void 0 !== t2.preserveDrawingBuffer && t2.preserveDrawingBuffer, u2 = void 0 !== t2.powerPreference ? t2.powerPreference : "default", l2 = void 0 !== t2.failIfMajorPerformanceCaveat && t2.failIfMajorPerformanceCaveat;
        let h2 = null, d2 = null;
        const p2 = [];
        this.domElement = e2, this.debug = { checkShaderErrors: true }, this.autoClear = true, this.autoClearColor = true, this.autoClearDepth = true, this.autoClearStencil = true, this.sortObjects = true, this.clippingPlanes = [], this.localClippingEnabled = false, this.gammaFactor = 2, this.outputEncoding = Je, this.physicallyCorrectLights = false, this.toneMapping = Q, this.toneMappingExposure = 1, this.maxMorphTargets = 8, this.maxMorphNormals = 4;
        const f2 = this;
        let m2 = false, g2 = null, v2 = 0, y2 = 0, x2 = null, b2 = null, w2 = -1, _2 = null;
        const M2 = new Xn(), S2 = new Xn();
        let T2 = null, E2 = e2.width, A2 = e2.height, C2 = 1, L2 = null, P2 = null;
        const R2 = new Xn(0, 0, E2, A2), O2 = new Xn(0, 0, E2, A2);
        let D2 = false;
        const I2 = new Co();
        let N2 = false, z2 = false;
        const k2 = new Tr(), F2 = new $n(), B2 = { background: null, fog: null, environment: null, overrideMaterial: null, isScene: true };
        function H2() {
          return null === x2 ? C2 : 1;
        }
        let G2, U2, j2, V2, W2, q2, X2, Y2, Z2, J2, $2, K2, tt2, et2, nt2, rt2, it2, ot2, at2, st2, ct2, ut2 = n2;
        function lt2(t3, n3) {
          for (let r3 = 0; r3 < t3.length; r3++) {
            const i3 = t3[r3], o3 = e2.getContext(i3, n3);
            if (null !== o3) return o3;
          }
          return null;
        }
        try {
          const t3 = { alpha: r2, depth: i2, stencil: o2, antialias: a2, premultipliedAlpha: s2, preserveDrawingBuffer: c2, powerPreference: u2, failIfMajorPerformanceCaveat: l2 };
          if (e2.addEventListener("webglcontextlost", ft2, false), e2.addEventListener("webglcontextrestored", mt2, false), null === ut2) {
            const e3 = ["webgl2", "webgl", "experimental-webgl"];
            if (true === f2.isWebGL1Renderer && e3.shift(), ut2 = lt2(e3, t3), null === ut2) throw lt2(e3) ? new Error("Error creating WebGL context with your selected attributes.") : new Error("Error creating WebGL context.");
          }
          void 0 === ut2.getShaderPrecisionFormat && (ut2.getShaderPrecisionFormat = function() {
            return { rangeMin: 1, rangeMax: 1, precision: 1 };
          });
        } catch (t3) {
          throw console.error("THREE.WebGLRenderer: " + t3.message), t3;
        }
        function ht2() {
          G2 = new Go(ut2), U2 = new Fo(ut2, G2, t2), false === U2.isWebGL2 && (G2.get("WEBGL_depth_texture"), G2.get("OES_texture_float"), G2.get("OES_texture_half_float"), G2.get("OES_texture_half_float_linear"), G2.get("OES_standard_derivatives"), G2.get("OES_element_index_uint"), G2.get("OES_vertex_array_object"), G2.get("ANGLE_instanced_arrays")), G2.get("OES_texture_float_linear"), st2 = new Ls(ut2, G2, U2), j2 = new As(ut2, G2, U2), j2.scissor(S2.copy(O2).multiplyScalar(C2).floor()), j2.viewport(M2.copy(R2).multiplyScalar(C2).floor()), V2 = new Vo(ut2), W2 = new ps(), q2 = new Cs(ut2, G2, j2, W2, U2, st2, V2), X2 = new Ho(f2), Y2 = new Po(ut2, U2), ct2 = new zo(ut2, G2, Y2, U2), Z2 = new Uo(ut2, Y2, V2, ct2), J2 = new Yo(ut2, Z2, Y2, V2), it2 = new Xo(ut2), nt2 = new Bo(W2), $2 = new ds(f2, X2, G2, U2, ct2, nt2), K2 = new Is(W2), tt2 = new vs(W2), et2 = new Ms(G2, U2), rt2 = new No(f2, X2, j2, J2, s2), ot2 = new ko(ut2, G2, V2, U2), at2 = new jo(ut2, G2, V2, U2), V2.programs = $2.programs, f2.capabilities = U2, f2.extensions = G2, f2.properties = W2, f2.renderLists = tt2, f2.state = j2, f2.info = V2;
        }
        ht2();
        const dt2 = new Ds(f2, ut2);
        this.xr = dt2;
        const pt2 = new Es(f2, J2, U2.maxTextureSize);
        function ft2(t3) {
          t3.preventDefault(), console.log("THREE.WebGLRenderer: Context Lost."), m2 = true;
        }
        function mt2() {
          console.log("THREE.WebGLRenderer: Context Restored."), m2 = false, ht2();
        }
        function gt2(t3) {
          const e3 = t3.target;
          e3.removeEventListener("dispose", gt2), function(t4) {
            vt2(t4), W2.remove(t4);
          }(e3);
        }
        function vt2(t3) {
          const e3 = W2.get(t3).program;
          void 0 !== e3 && $2.releaseProgram(e3);
        }
        this.shadowMap = pt2, this.getContext = function() {
          return ut2;
        }, this.getContextAttributes = function() {
          return ut2.getContextAttributes();
        }, this.forceContextLoss = function() {
          const t3 = G2.get("WEBGL_lose_context");
          t3 && t3.loseContext();
        }, this.forceContextRestore = function() {
          const t3 = G2.get("WEBGL_lose_context");
          t3 && t3.restoreContext();
        }, this.getPixelRatio = function() {
          return C2;
        }, this.setPixelRatio = function(t3) {
          void 0 !== t3 && (C2 = t3, this.setSize(E2, A2, false));
        }, this.getSize = function(t3) {
          return void 0 === t3 && (console.warn("WebGLRenderer: .getsize() now requires a Vector2 as an argument"), t3 = new Hn()), t3.set(E2, A2);
        }, this.setSize = function(t3, n3, r3) {
          dt2.isPresenting ? console.warn("THREE.WebGLRenderer: Can't change size while VR device is presenting.") : (E2 = t3, A2 = n3, e2.width = Math.floor(t3 * C2), e2.height = Math.floor(n3 * C2), false !== r3 && (e2.style.width = t3 + "px", e2.style.height = n3 + "px"), this.setViewport(0, 0, t3, n3));
        }, this.getDrawingBufferSize = function(t3) {
          return void 0 === t3 && (console.warn("WebGLRenderer: .getdrawingBufferSize() now requires a Vector2 as an argument"), t3 = new Hn()), t3.set(E2 * C2, A2 * C2).floor();
        }, this.setDrawingBufferSize = function(t3, n3, r3) {
          E2 = t3, A2 = n3, C2 = r3, e2.width = Math.floor(t3 * r3), e2.height = Math.floor(n3 * r3), this.setViewport(0, 0, t3, n3);
        }, this.getCurrentViewport = function(t3) {
          return void 0 === t3 && (console.warn("WebGLRenderer: .getCurrentViewport() now requires a Vector4 as an argument"), t3 = new Xn()), t3.copy(M2);
        }, this.getViewport = function(t3) {
          return t3.copy(R2);
        }, this.setViewport = function(t3, e3, n3, r3) {
          t3.isVector4 ? R2.set(t3.x, t3.y, t3.z, t3.w) : R2.set(t3, e3, n3, r3), j2.viewport(M2.copy(R2).multiplyScalar(C2).floor());
        }, this.getScissor = function(t3) {
          return t3.copy(O2);
        }, this.setScissor = function(t3, e3, n3, r3) {
          t3.isVector4 ? O2.set(t3.x, t3.y, t3.z, t3.w) : O2.set(t3, e3, n3, r3), j2.scissor(S2.copy(O2).multiplyScalar(C2).floor());
        }, this.getScissorTest = function() {
          return D2;
        }, this.setScissorTest = function(t3) {
          j2.setScissorTest(D2 = t3);
        }, this.setOpaqueSort = function(t3) {
          L2 = t3;
        }, this.setTransparentSort = function(t3) {
          P2 = t3;
        }, this.getClearColor = function(t3) {
          return void 0 === t3 && (console.warn("WebGLRenderer: .getClearColor() now requires a Color as an argument"), t3 = new yi()), t3.copy(rt2.getClearColor());
        }, this.setClearColor = function() {
          rt2.setClearColor.apply(rt2, arguments);
        }, this.getClearAlpha = function() {
          return rt2.getClearAlpha();
        }, this.setClearAlpha = function() {
          rt2.setClearAlpha.apply(rt2, arguments);
        }, this.clear = function(t3, e3, n3) {
          let r3 = 0;
          (void 0 === t3 || t3) && (r3 |= 16384), (void 0 === e3 || e3) && (r3 |= 256), (void 0 === n3 || n3) && (r3 |= 1024), ut2.clear(r3);
        }, this.clearColor = function() {
          this.clear(true, false, false);
        }, this.clearDepth = function() {
          this.clear(false, true, false);
        }, this.clearStencil = function() {
          this.clear(false, false, true);
        }, this.dispose = function() {
          e2.removeEventListener("webglcontextlost", ft2, false), e2.removeEventListener("webglcontextrestored", mt2, false), tt2.dispose(), et2.dispose(), W2.dispose(), X2.dispose(), J2.dispose(), ct2.dispose(), dt2.dispose(), xt2.stop();
        }, this.renderBufferImmediate = function(t3, e3) {
          ct2.initAttributes();
          const n3 = W2.get(t3);
          t3.hasPositions && !n3.position && (n3.position = ut2.createBuffer()), t3.hasNormals && !n3.normal && (n3.normal = ut2.createBuffer()), t3.hasUvs && !n3.uv && (n3.uv = ut2.createBuffer()), t3.hasColors && !n3.color && (n3.color = ut2.createBuffer());
          const r3 = e3.getAttributes();
          t3.hasPositions && (ut2.bindBuffer(34962, n3.position), ut2.bufferData(34962, t3.positionArray, 35048), ct2.enableAttribute(r3.position), ut2.vertexAttribPointer(r3.position, 3, 5126, false, 0, 0)), t3.hasNormals && (ut2.bindBuffer(34962, n3.normal), ut2.bufferData(34962, t3.normalArray, 35048), ct2.enableAttribute(r3.normal), ut2.vertexAttribPointer(r3.normal, 3, 5126, false, 0, 0)), t3.hasUvs && (ut2.bindBuffer(34962, n3.uv), ut2.bufferData(34962, t3.uvArray, 35048), ct2.enableAttribute(r3.uv), ut2.vertexAttribPointer(r3.uv, 2, 5126, false, 0, 0)), t3.hasColors && (ut2.bindBuffer(34962, n3.color), ut2.bufferData(34962, t3.colorArray, 35048), ct2.enableAttribute(r3.color), ut2.vertexAttribPointer(r3.color, 3, 5126, false, 0, 0)), ct2.disableUnusedAttributes(), ut2.drawArrays(4, 0, t3.count), t3.count = 0;
        }, this.renderBufferDirect = function(t3, e3, n3, r3, i3, o3) {
          null === e3 && (e3 = B2);
          const a3 = i3.isMesh && i3.matrixWorld.determinant() < 0, s3 = Tt2(t3, e3, r3, i3);
          j2.setMaterial(r3, a3);
          let c3 = n3.index;
          const u3 = n3.attributes.position;
          if (null === c3) {
            if (void 0 === u3 || 0 === u3.count) return;
          } else if (0 === c3.count) return;
          let l3, h3 = 1;
          true === r3.wireframe && (c3 = Z2.getWireframeAttribute(n3), h3 = 2), (r3.morphTargets || r3.morphNormals) && it2.update(i3, n3, r3, s3), ct2.setup(i3, r3, s3, n3, c3);
          let d3 = ot2;
          null !== c3 && (l3 = Y2.get(c3), d3 = at2, d3.setIndex(l3));
          const p3 = null !== c3 ? c3.count : u3.count, f3 = n3.drawRange.start * h3, m3 = n3.drawRange.count * h3, g3 = null !== o3 ? o3.start * h3 : 0, v3 = null !== o3 ? o3.count * h3 : 1 / 0, y3 = Math.max(f3, g3), x3 = Math.min(p3, f3 + m3, g3 + v3) - 1, b3 = Math.max(0, x3 - y3 + 1);
          if (0 !== b3) {
            if (i3.isMesh) true === r3.wireframe ? (j2.setLineWidth(r3.wireframeLinewidth * H2()), d3.setMode(1)) : d3.setMode(4);
            else if (i3.isLine) {
              let t4 = r3.linewidth;
              void 0 === t4 && (t4 = 1), j2.setLineWidth(t4 * H2()), i3.isLineSegments ? d3.setMode(1) : i3.isLineLoop ? d3.setMode(2) : d3.setMode(3);
            } else i3.isPoints ? d3.setMode(0) : i3.isSprite && d3.setMode(4);
            if (i3.isInstancedMesh) d3.renderInstances(y3, b3, i3.count);
            else if (n3.isInstancedBufferGeometry) {
              const t4 = Math.min(n3.instanceCount, n3._maxInstanceCount);
              d3.renderInstances(y3, b3, t4);
            } else d3.render(y3, b3);
          }
        }, this.compile = function(t3, e3) {
          d2 = et2.get(t3), d2.init(), t3.traverseVisible(function(t4) {
            t4.isLight && t4.layers.test(e3.layers) && (d2.pushLight(t4), t4.castShadow && d2.pushShadow(t4));
          }), d2.setupLights();
          const n3 = /* @__PURE__ */ new WeakMap();
          t3.traverse(function(e4) {
            const r3 = e4.material;
            if (r3) if (Array.isArray(r3)) for (let i3 = 0; i3 < r3.length; i3++) {
              const o3 = r3[i3];
              false === n3.has(o3) && (Mt2(o3, t3, e4), n3.set(o3));
            }
            else false === n3.has(r3) && (Mt2(r3, t3, e4), n3.set(r3));
          });
        };
        let yt2 = null;
        const xt2 = new Lo();
        function bt2(t3, e3, n3, r3) {
          if (false === t3.visible) return;
          if (t3.layers.test(e3.layers)) {
            if (t3.isGroup) n3 = t3.renderOrder;
            else if (t3.isLOD) true === t3.autoUpdate && t3.update(e3);
            else if (t3.isLight) d2.pushLight(t3), t3.castShadow && d2.pushShadow(t3);
            else if (t3.isSprite) {
              if (!t3.frustumCulled || I2.intersectsSprite(t3)) {
                r3 && F2.setFromMatrixPosition(t3.matrixWorld).applyMatrix4(k2);
                const e4 = J2.update(t3), i4 = t3.material;
                i4.visible && h2.push(t3, e4, i4, n3, F2.z, null);
              }
            } else if (t3.isImmediateRenderObject) r3 && F2.setFromMatrixPosition(t3.matrixWorld).applyMatrix4(k2), h2.push(t3, null, t3.material, n3, F2.z, null);
            else if ((t3.isMesh || t3.isLine || t3.isPoints) && (t3.isSkinnedMesh && t3.skeleton.frame !== V2.render.frame && (t3.skeleton.update(), t3.skeleton.frame = V2.render.frame), !t3.frustumCulled || I2.intersectsObject(t3))) {
              r3 && F2.setFromMatrixPosition(t3.matrixWorld).applyMatrix4(k2);
              const e4 = J2.update(t3), i4 = t3.material;
              if (Array.isArray(i4)) {
                const r4 = e4.groups;
                for (let o3 = 0, a3 = r4.length; o3 < a3; o3++) {
                  const a4 = r4[o3], s3 = i4[a4.materialIndex];
                  s3 && s3.visible && h2.push(t3, e4, s3, n3, F2.z, a4);
                }
              } else i4.visible && h2.push(t3, e4, i4, n3, F2.z, null);
            }
          }
          const i3 = t3.children;
          for (let t4 = 0, o3 = i3.length; t4 < o3; t4++) bt2(i3[t4], e3, n3, r3);
        }
        function wt2(t3, e3, n3) {
          const r3 = true === e3.isScene ? e3.overrideMaterial : null;
          for (let i3 = 0, o3 = t3.length; i3 < o3; i3++) {
            const o4 = t3[i3], a3 = o4.object, s3 = o4.geometry, c3 = null === r3 ? o4.material : r3, u3 = o4.group;
            if (n3.isArrayCamera) {
              const t4 = n3.cameras;
              for (let n4 = 0, r4 = t4.length; n4 < r4; n4++) {
                const r5 = t4[n4];
                a3.layers.test(r5.layers) && (j2.viewport(M2.copy(r5.viewport)), d2.setupLightsView(r5), _t2(a3, e3, r5, s3, c3, u3));
              }
            } else _t2(a3, e3, n3, s3, c3, u3);
          }
        }
        function _t2(t3, e3, n3, r3, i3, o3) {
          if (t3.onBeforeRender(f2, e3, n3, r3, i3, o3), t3.modelViewMatrix.multiplyMatrices(n3.matrixWorldInverse, t3.matrixWorld), t3.normalMatrix.getNormalMatrix(t3.modelViewMatrix), t3.isImmediateRenderObject) {
            const r4 = Tt2(n3, e3, i3, t3);
            j2.setMaterial(i3), ct2.reset(), function(t4, e4) {
              t4.render(function(t5) {
                f2.renderBufferImmediate(t5, e4);
              });
            }(t3, r4);
          } else f2.renderBufferDirect(n3, e3, r3, i3, t3, o3);
          t3.onAfterRender(f2, e3, n3, r3, i3, o3);
        }
        function Mt2(t3, e3, n3) {
          true !== e3.isScene && (e3 = B2);
          const r3 = W2.get(t3), i3 = d2.state.lights, o3 = d2.state.shadowsArray, a3 = i3.state.version, s3 = $2.getParameters(t3, i3.state, o3, e3, n3), c3 = $2.getProgramCacheKey(s3);
          let u3 = r3.program, l3 = true;
          if (void 0 === u3) t3.addEventListener("dispose", gt2);
          else if (u3.cacheKey !== c3) vt2(t3);
          else if (r3.lightsStateVersion !== a3) l3 = false;
          else {
            if (void 0 !== s3.shaderID) {
              const n4 = t3.isMeshStandardMaterial ? e3.environment : null;
              return void (r3.envMap = X2.get(t3.envMap || n4));
            }
            l3 = false;
          }
          l3 && (s3.uniforms = $2.getUniforms(t3), t3.onBeforeCompile(s3, f2), u3 = $2.acquireProgram(s3, c3), r3.program = u3, r3.uniforms = s3.uniforms, r3.outputEncoding = s3.outputEncoding);
          const h3 = r3.uniforms;
          (t3.isShaderMaterial || t3.isRawShaderMaterial) && true !== t3.clipping || (r3.numClippingPlanes = nt2.numPlanes, r3.numIntersection = nt2.numIntersection, h3.clippingPlanes = nt2.uniform), r3.environment = t3.isMeshStandardMaterial ? e3.environment : null, r3.fog = e3.fog, r3.envMap = X2.get(t3.envMap || r3.environment), r3.needsLights = function(t4) {
            return t4.isMeshLambertMaterial || t4.isMeshToonMaterial || t4.isMeshPhongMaterial || t4.isMeshStandardMaterial || t4.isShadowMaterial || t4.isShaderMaterial && true === t4.lights;
          }(t3), r3.lightsStateVersion = a3, r3.needsLights && (h3.ambientLightColor.value = i3.state.ambient, h3.lightProbe.value = i3.state.probe, h3.directionalLights.value = i3.state.directional, h3.directionalLightShadows.value = i3.state.directionalShadow, h3.spotLights.value = i3.state.spot, h3.spotLightShadows.value = i3.state.spotShadow, h3.rectAreaLights.value = i3.state.rectArea, h3.ltc_1.value = i3.state.rectAreaLTC1, h3.ltc_2.value = i3.state.rectAreaLTC2, h3.pointLights.value = i3.state.point, h3.pointLightShadows.value = i3.state.pointShadow, h3.hemisphereLights.value = i3.state.hemi, h3.directionalShadowMap.value = i3.state.directionalShadowMap, h3.directionalShadowMatrix.value = i3.state.directionalShadowMatrix, h3.spotShadowMap.value = i3.state.spotShadowMap, h3.spotShadowMatrix.value = i3.state.spotShadowMatrix, h3.pointShadowMap.value = i3.state.pointShadowMap, h3.pointShadowMatrix.value = i3.state.pointShadowMatrix);
          const p3 = r3.program.getUniforms(), m3 = Wa.seqWithValue(p3.seq, h3);
          r3.uniformsList = m3;
        }
        function Tt2(t3, e3, n3, r3) {
          true !== e3.isScene && (e3 = B2), q2.resetTextureUnits();
          const i3 = e3.fog, o3 = n3.isMeshStandardMaterial ? e3.environment : null, a3 = null === x2 ? f2.outputEncoding : x2.texture.encoding, s3 = X2.get(n3.envMap || o3), c3 = W2.get(n3), u3 = d2.state.lights;
          if (true === N2 && (true === z2 || t3 !== _2)) {
            const e4 = t3 === _2 && n3.id === w2;
            nt2.setState(n3, t3, e4);
          }
          n3.version === c3.__version ? n3.fog && c3.fog !== i3 || c3.environment !== o3 || c3.needsLights && c3.lightsStateVersion !== u3.state.version ? Mt2(n3, e3, r3) : void 0 === c3.numClippingPlanes || c3.numClippingPlanes === nt2.numPlanes && c3.numIntersection === nt2.numIntersection ? (c3.outputEncoding !== a3 || c3.envMap !== s3) && Mt2(n3, e3, r3) : Mt2(n3, e3, r3) : (Mt2(n3, e3, r3), c3.__version = n3.version);
          let l3 = false, h3 = false, p3 = false;
          const m3 = c3.program, g3 = m3.getUniforms(), v3 = c3.uniforms;
          if (j2.useProgram(m3.program) && (l3 = true, h3 = true, p3 = true), n3.id !== w2 && (w2 = n3.id, h3 = true), l3 || _2 !== t3) {
            if (g3.setValue(ut2, "projectionMatrix", t3.projectionMatrix), U2.logarithmicDepthBuffer && g3.setValue(ut2, "logDepthBufFC", 2 / (Math.log(t3.far + 1) / Math.LN2)), _2 !== t3 && (_2 = t3, h3 = true, p3 = true), n3.isShaderMaterial || n3.isMeshPhongMaterial || n3.isMeshToonMaterial || n3.isMeshStandardMaterial || n3.envMap) {
              const e4 = g3.map.cameraPosition;
              void 0 !== e4 && e4.setValue(ut2, F2.setFromMatrixPosition(t3.matrixWorld));
            }
            (n3.isMeshPhongMaterial || n3.isMeshToonMaterial || n3.isMeshLambertMaterial || n3.isMeshBasicMaterial || n3.isMeshStandardMaterial || n3.isShaderMaterial) && g3.setValue(ut2, "isOrthographic", true === t3.isOrthographicCamera), (n3.isMeshPhongMaterial || n3.isMeshToonMaterial || n3.isMeshLambertMaterial || n3.isMeshBasicMaterial || n3.isMeshStandardMaterial || n3.isShaderMaterial || n3.isShadowMaterial || n3.skinning) && g3.setValue(ut2, "viewMatrix", t3.matrixWorldInverse);
          }
          if (n3.skinning) {
            g3.setOptional(ut2, r3, "bindMatrix"), g3.setOptional(ut2, r3, "bindMatrixInverse");
            const t4 = r3.skeleton;
            if (t4) {
              const e4 = t4.bones;
              if (U2.floatVertexTextures) {
                if (null === t4.boneTexture) {
                  let n4 = Math.sqrt(4 * e4.length);
                  n4 = Bn.ceilPowerOfTwo(n4), n4 = Math.max(n4, 4);
                  const r4 = new Float32Array(n4 * n4 * 4);
                  r4.set(t4.boneMatrices);
                  const i4 = new To(r4, n4, n4, Ft, Pt);
                  t4.boneMatrices = r4, t4.boneTexture = i4, t4.boneTextureSize = n4;
                }
                g3.setValue(ut2, "boneTexture", t4.boneTexture, q2), g3.setValue(ut2, "boneTextureSize", t4.boneTextureSize);
              } else g3.setOptional(ut2, t4, "boneMatrices");
            }
          }
          var y3, b3;
          return (h3 || c3.receiveShadow !== r3.receiveShadow) && (c3.receiveShadow = r3.receiveShadow, g3.setValue(ut2, "receiveShadow", r3.receiveShadow)), h3 && (g3.setValue(ut2, "toneMappingExposure", f2.toneMappingExposure), c3.needsLights && (b3 = p3, (y3 = v3).ambientLightColor.needsUpdate = b3, y3.lightProbe.needsUpdate = b3, y3.directionalLights.needsUpdate = b3, y3.directionalLightShadows.needsUpdate = b3, y3.pointLights.needsUpdate = b3, y3.pointLightShadows.needsUpdate = b3, y3.spotLights.needsUpdate = b3, y3.spotLightShadows.needsUpdate = b3, y3.rectAreaLights.needsUpdate = b3, y3.hemisphereLights.needsUpdate = b3), i3 && n3.fog && K2.refreshFogUniforms(v3, i3), K2.refreshMaterialUniforms(v3, n3, C2, A2), Wa.upload(ut2, c3.uniformsList, v3, q2)), n3.isShaderMaterial && true === n3.uniformsNeedUpdate && (Wa.upload(ut2, c3.uniformsList, v3, q2), n3.uniformsNeedUpdate = false), n3.isSpriteMaterial && g3.setValue(ut2, "center", r3.center), g3.setValue(ut2, "modelViewMatrix", r3.modelViewMatrix), g3.setValue(ut2, "normalMatrix", r3.normalMatrix), g3.setValue(ut2, "modelMatrix", r3.matrixWorld), m3;
        }
        xt2.setAnimationLoop(function(t3) {
          dt2.isPresenting || yt2 && yt2(t3);
        }), "undefined" != typeof window && xt2.setContext(window), this.setAnimationLoop = function(t3) {
          yt2 = t3, dt2.setAnimationLoop(t3), null === t3 ? xt2.stop() : xt2.start();
        }, this.render = function(t3, e3) {
          let n3, r3;
          if (void 0 !== arguments[2] && (console.warn("THREE.WebGLRenderer.render(): the renderTarget argument has been removed. Use .setRenderTarget() instead."), n3 = arguments[2]), void 0 !== arguments[3] && (console.warn("THREE.WebGLRenderer.render(): the forceClear argument has been removed. Use .clear() instead."), r3 = arguments[3]), void 0 !== e3 && true !== e3.isCamera) return void console.error("THREE.WebGLRenderer.render: camera is not an instance of THREE.Camera.");
          if (true === m2) return;
          ct2.resetDefaultState(), w2 = -1, _2 = null, true === t3.autoUpdate && t3.updateMatrixWorld(), null === e3.parent && e3.updateMatrixWorld(), true === dt2.enabled && true === dt2.isPresenting && (e3 = dt2.getCamera(e3)), true === t3.isScene && t3.onBeforeRender(f2, t3, e3, n3 || x2), d2 = et2.get(t3, p2.length), d2.init(), p2.push(d2), k2.multiplyMatrices(e3.projectionMatrix, e3.matrixWorldInverse), I2.setFromProjectionMatrix(k2), z2 = this.localClippingEnabled, N2 = nt2.init(this.clippingPlanes, z2, e3), h2 = tt2.get(t3, e3), h2.init(), bt2(t3, e3, 0, f2.sortObjects), h2.finish(), true === f2.sortObjects && h2.sort(L2, P2), true === N2 && nt2.beginShadows();
          const i3 = d2.state.shadowsArray;
          pt2.render(i3, t3, e3), d2.setupLights(), d2.setupLightsView(e3), true === N2 && nt2.endShadows(), true === this.info.autoReset && this.info.reset(), void 0 !== n3 && this.setRenderTarget(n3), rt2.render(h2, t3, e3, r3);
          const o3 = h2.opaque, a3 = h2.transparent;
          o3.length > 0 && wt2(o3, t3, e3), a3.length > 0 && wt2(a3, t3, e3), true === t3.isScene && t3.onAfterRender(f2, t3, e3), null !== x2 && (q2.updateRenderTargetMipmap(x2), q2.updateMultisampleRenderTarget(x2)), j2.buffers.depth.setTest(true), j2.buffers.depth.setMask(true), j2.buffers.color.setMask(true), j2.setPolygonOffset(false), p2.pop(), d2 = p2.length > 0 ? p2[p2.length - 1] : null, h2 = null;
        }, this.setFramebuffer = function(t3) {
          g2 !== t3 && null === x2 && ut2.bindFramebuffer(36160, t3), g2 = t3;
        }, this.getActiveCubeFace = function() {
          return v2;
        }, this.getActiveMipmapLevel = function() {
          return y2;
        }, this.getRenderList = function() {
          return h2;
        }, this.setRenderList = function(t3) {
          h2 = t3;
        }, this.getRenderTarget = function() {
          return x2;
        }, this.setRenderTarget = function(t3, e3 = 0, n3 = 0) {
          x2 = t3, v2 = e3, y2 = n3, t3 && void 0 === W2.get(t3).__webglFramebuffer && q2.setupRenderTarget(t3);
          let r3 = g2, i3 = false;
          if (t3) {
            const n4 = W2.get(t3).__webglFramebuffer;
            t3.isWebGLCubeRenderTarget ? (r3 = n4[e3], i3 = true) : r3 = t3.isWebGLMultisampleRenderTarget ? W2.get(t3).__webglMultisampledFramebuffer : n4, M2.copy(t3.viewport), S2.copy(t3.scissor), T2 = t3.scissorTest;
          } else M2.copy(R2).multiplyScalar(C2).floor(), S2.copy(O2).multiplyScalar(C2).floor(), T2 = D2;
          if (b2 !== r3 && (ut2.bindFramebuffer(36160, r3), b2 = r3), j2.viewport(M2), j2.scissor(S2), j2.setScissorTest(T2), i3) {
            const r4 = W2.get(t3.texture);
            ut2.framebufferTexture2D(36160, 36064, 34069 + e3, r4.__webglTexture, n3);
          }
        }, this.readRenderTargetPixels = function(t3, e3, n3, r3, i3, o3, a3) {
          if (!t3 || !t3.isWebGLRenderTarget) return void console.error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not THREE.WebGLRenderTarget.");
          let s3 = W2.get(t3).__webglFramebuffer;
          if (t3.isWebGLCubeRenderTarget && void 0 !== a3 && (s3 = s3[a3]), s3) {
            let a4 = false;
            s3 !== b2 && (ut2.bindFramebuffer(36160, s3), a4 = true);
            try {
              const s4 = t3.texture, c3 = s4.format, u3 = s4.type;
              if (c3 !== Ft && st2.convert(c3) !== ut2.getParameter(35739)) return void console.error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in RGBA or implementation defined format.");
              if (!(u3 === St || st2.convert(u3) === ut2.getParameter(35738) || u3 === Pt && (U2.isWebGL2 || G2.get("OES_texture_float") || G2.get("WEBGL_color_buffer_float")) || u3 === Rt && (U2.isWebGL2 ? G2.get("EXT_color_buffer_float") : G2.get("EXT_color_buffer_half_float")))) return void console.error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in UnsignedByteType or implementation defined type.");
              36053 === ut2.checkFramebufferStatus(36160) ? e3 >= 0 && e3 <= t3.width - r3 && n3 >= 0 && n3 <= t3.height - i3 && ut2.readPixels(e3, n3, r3, i3, st2.convert(c3), st2.convert(u3), o3) : console.error("THREE.WebGLRenderer.readRenderTargetPixels: readPixels from renderTarget failed. Framebuffer not complete.");
            } finally {
              a4 && ut2.bindFramebuffer(36160, b2);
            }
          }
        }, this.copyFramebufferToTexture = function(t3, e3, n3 = 0) {
          const r3 = Math.pow(2, -n3), i3 = Math.floor(e3.image.width * r3), o3 = Math.floor(e3.image.height * r3), a3 = st2.convert(e3.format);
          q2.setTexture2D(e3, 0), ut2.copyTexImage2D(3553, n3, a3, t3.x, t3.y, i3, o3, 0), j2.unbindTexture();
        }, this.copyTextureToTexture = function(t3, e3, n3, r3 = 0) {
          const i3 = e3.image.width, o3 = e3.image.height, a3 = st2.convert(n3.format), s3 = st2.convert(n3.type);
          q2.setTexture2D(n3, 0), ut2.pixelStorei(37440, n3.flipY), ut2.pixelStorei(37441, n3.premultiplyAlpha), ut2.pixelStorei(3317, n3.unpackAlignment), e3.isDataTexture ? ut2.texSubImage2D(3553, r3, t3.x, t3.y, i3, o3, a3, s3, e3.image.data) : e3.isCompressedTexture ? ut2.compressedTexSubImage2D(3553, r3, t3.x, t3.y, e3.mipmaps[0].width, e3.mipmaps[0].height, a3, e3.mipmaps[0].data) : ut2.texSubImage2D(3553, r3, t3.x, t3.y, a3, s3, e3.image), 0 === r3 && n3.generateMipmaps && ut2.generateMipmap(3553), j2.unbindTexture();
        }, this.initTexture = function(t3) {
          q2.setTexture2D(t3, 0), j2.unbindTexture();
        }, this.resetState = function() {
          j2.reset(), ct2.reset();
        }, "undefined" != typeof __THREE_DEVTOOLS__ && __THREE_DEVTOOLS__.dispatchEvent(new CustomEvent("observe", { detail: this }));
      }
      function zs(t2) {
        Ns.call(this, t2);
      }
      Ps.prototype = Object.assign(Object.create(wo.prototype), { constructor: Ps, isArrayCamera: true }), Rs.prototype = Object.assign(Object.create(Jr.prototype), { constructor: Rs, isGroup: true }), Object.assign(Os.prototype, { constructor: Os, getHandSpace: function() {
        if (null === this._hand && (this._hand = new Rs(), this._hand.matrixAutoUpdate = false, this._hand.visible = false, this._hand.joints = [], this._hand.inputState = { pinching: false }, window.XRHand)) for (let t2 = 0; t2 <= window.XRHand.LITTLE_PHALANX_TIP; t2++) {
          const t3 = new Rs();
          t3.matrixAutoUpdate = false, t3.visible = false, this._hand.joints.push(t3), this._hand.add(t3);
        }
        return this._hand;
      }, getTargetRaySpace: function() {
        return null === this._targetRay && (this._targetRay = new Rs(), this._targetRay.matrixAutoUpdate = false, this._targetRay.visible = false), this._targetRay;
      }, getGripSpace: function() {
        return null === this._grip && (this._grip = new Rs(), this._grip.matrixAutoUpdate = false, this._grip.visible = false), this._grip;
      }, dispatchEvent: function(t2) {
        return null !== this._targetRay && this._targetRay.dispatchEvent(t2), null !== this._grip && this._grip.dispatchEvent(t2), null !== this._hand && this._hand.dispatchEvent(t2), this;
      }, disconnect: function(t2) {
        return this.dispatchEvent({ type: "disconnected", data: t2 }), null !== this._targetRay && (this._targetRay.visible = false), null !== this._grip && (this._grip.visible = false), null !== this._hand && (this._hand.visible = false), this;
      }, update: function(t2, e2, n2) {
        let r2 = null, i2 = null, o2 = null;
        const a2 = this._targetRay, s2 = this._grip, c2 = this._hand;
        if (t2 && "visible-blurred" !== e2.session.visibilityState) if (c2 && t2.hand) {
          o2 = true;
          for (let r3 = 0; r3 <= window.XRHand.LITTLE_PHALANX_TIP; r3++) if (t2.hand[r3]) {
            const i3 = e2.getJointPose(t2.hand[r3], n2), o3 = c2.joints[r3];
            null !== i3 && (o3.matrix.fromArray(i3.transform.matrix), o3.matrix.decompose(o3.position, o3.rotation, o3.scale), o3.jointRadius = i3.radius), o3.visible = null !== i3;
            const a3 = c2.joints[window.XRHand.INDEX_PHALANX_TIP], s3 = c2.joints[window.XRHand.THUMB_PHALANX_TIP], u2 = a3.position.distanceTo(s3.position), l2 = 0.02, h2 = 5e-3;
            c2.inputState.pinching && u2 > l2 + h2 ? (c2.inputState.pinching = false, this.dispatchEvent({ type: "pinchend", handedness: t2.handedness, target: this })) : !c2.inputState.pinching && u2 <= l2 - h2 && (c2.inputState.pinching = true, this.dispatchEvent({ type: "pinchstart", handedness: t2.handedness, target: this }));
          }
        } else null !== a2 && (r2 = e2.getPose(t2.targetRaySpace, n2), null !== r2 && (a2.matrix.fromArray(r2.transform.matrix), a2.matrix.decompose(a2.position, a2.rotation, a2.scale))), null !== s2 && t2.gripSpace && (i2 = e2.getPose(t2.gripSpace, n2), null !== i2 && (s2.matrix.fromArray(i2.transform.matrix), s2.matrix.decompose(s2.position, s2.rotation, s2.scale)));
        return null !== a2 && (a2.visible = null !== r2), null !== s2 && (s2.visible = null !== i2), null !== c2 && (c2.visible = null !== o2), this;
      } }), Object.assign(Ds.prototype, zn.prototype), zs.prototype = Object.assign(Object.create(Ns.prototype), { constructor: zs, isWebGL1Renderer: true });
      class ks {
        constructor(t2, e2) {
          Object.defineProperty(this, "isFogExp2", { value: true }), this.name = "", this.color = new yi(t2), this.density = void 0 !== e2 ? e2 : 25e-5;
        }
        clone() {
          return new ks(this.color, this.density);
        }
        toJSON() {
          return { type: "FogExp2", color: this.color.getHex(), density: this.density };
        }
      }
      class Fs {
        constructor(t2, e2, n2) {
          Object.defineProperty(this, "isFog", { value: true }), this.name = "", this.color = new yi(t2), this.near = void 0 !== e2 ? e2 : 1, this.far = void 0 !== n2 ? n2 : 1e3;
        }
        clone() {
          return new Fs(this.color, this.near, this.far);
        }
        toJSON() {
          return { type: "Fog", color: this.color.getHex(), near: this.near, far: this.far };
        }
      }
      class Bs extends Jr {
        constructor() {
          super(), Object.defineProperty(this, "isScene", { value: true }), this.type = "Scene", this.background = null, this.environment = null, this.fog = null, this.overrideMaterial = null, this.autoUpdate = true, "undefined" != typeof __THREE_DEVTOOLS__ && __THREE_DEVTOOLS__.dispatchEvent(new CustomEvent("observe", { detail: this }));
        }
        copy(t2, e2) {
          return super.copy(t2, e2), null !== t2.background && (this.background = t2.background.clone()), null !== t2.environment && (this.environment = t2.environment.clone()), null !== t2.fog && (this.fog = t2.fog.clone()), null !== t2.overrideMaterial && (this.overrideMaterial = t2.overrideMaterial.clone()), this.autoUpdate = t2.autoUpdate, this.matrixAutoUpdate = t2.matrixAutoUpdate, this;
        }
        toJSON(t2) {
          const e2 = super.toJSON(t2);
          return null !== this.background && (e2.object.background = this.background.toJSON(t2)), null !== this.environment && (e2.object.environment = this.environment.toJSON(t2)), null !== this.fog && (e2.object.fog = this.fog.toJSON()), e2;
        }
      }
      function Hs(t2, e2) {
        this.array = t2, this.stride = e2, this.count = void 0 !== t2 ? t2.length / e2 : 0, this.usage = Tn, this.updateRange = { offset: 0, count: -1 }, this.version = 0, this.uuid = Bn.generateUUID();
      }
      Object.defineProperty(Hs.prototype, "needsUpdate", { set: function(t2) {
        true === t2 && this.version++;
      } }), Object.assign(Hs.prototype, { isInterleavedBuffer: true, onUploadCallback: function() {
      }, setUsage: function(t2) {
        return this.usage = t2, this;
      }, copy: function(t2) {
        return this.array = new t2.array.constructor(t2.array), this.count = t2.count, this.stride = t2.stride, this.usage = t2.usage, this;
      }, copyAt: function(t2, e2, n2) {
        t2 *= this.stride, n2 *= e2.stride;
        for (let r2 = 0, i2 = this.stride; r2 < i2; r2++) this.array[t2 + r2] = e2.array[n2 + r2];
        return this;
      }, set: function(t2, e2 = 0) {
        return this.array.set(t2, e2), this;
      }, clone: function(t2) {
        void 0 === t2.arrayBuffers && (t2.arrayBuffers = {}), void 0 === this.array.buffer._uuid && (this.array.buffer._uuid = Bn.generateUUID()), void 0 === t2.arrayBuffers[this.array.buffer._uuid] && (t2.arrayBuffers[this.array.buffer._uuid] = this.array.slice(0).buffer);
        const e2 = new Hs(new this.array.constructor(t2.arrayBuffers[this.array.buffer._uuid]), this.stride);
        return e2.setUsage(this.usage), e2;
      }, onUpload: function(t2) {
        return this.onUploadCallback = t2, this;
      }, toJSON: function(t2) {
        return void 0 === t2.arrayBuffers && (t2.arrayBuffers = {}), void 0 === this.array.buffer._uuid && (this.array.buffer._uuid = Bn.generateUUID()), void 0 === t2.arrayBuffers[this.array.buffer._uuid] && (t2.arrayBuffers[this.array.buffer._uuid] = Array.prototype.slice.call(new Uint32Array(this.array.buffer))), { uuid: this.uuid, buffer: this.array.buffer._uuid, type: this.array.constructor.name, stride: this.stride };
      } });
      const Gs = new $n();
      function Us(t2, e2, n2, r2) {
        this.name = "", this.data = t2, this.itemSize = e2, this.offset = n2, this.normalized = true === r2;
      }
      function js(t2) {
        wi.call(this), this.type = "SpriteMaterial", this.color = new yi(16777215), this.map = null, this.alphaMap = null, this.rotation = 0, this.sizeAttenuation = true, this.transparent = true, this.setValues(t2);
      }
      let Vs;
      Object.defineProperties(Us.prototype, { count: { get: function() {
        return this.data.count;
      } }, array: { get: function() {
        return this.data.array;
      } }, needsUpdate: { set: function(t2) {
        this.data.needsUpdate = t2;
      } } }), Object.assign(Us.prototype, { isInterleavedBufferAttribute: true, applyMatrix4: function(t2) {
        for (let e2 = 0, n2 = this.data.count; e2 < n2; e2++) Gs.x = this.getX(e2), Gs.y = this.getY(e2), Gs.z = this.getZ(e2), Gs.applyMatrix4(t2), this.setXYZ(e2, Gs.x, Gs.y, Gs.z);
        return this;
      }, setX: function(t2, e2) {
        return this.data.array[t2 * this.data.stride + this.offset] = e2, this;
      }, setY: function(t2, e2) {
        return this.data.array[t2 * this.data.stride + this.offset + 1] = e2, this;
      }, setZ: function(t2, e2) {
        return this.data.array[t2 * this.data.stride + this.offset + 2] = e2, this;
      }, setW: function(t2, e2) {
        return this.data.array[t2 * this.data.stride + this.offset + 3] = e2, this;
      }, getX: function(t2) {
        return this.data.array[t2 * this.data.stride + this.offset];
      }, getY: function(t2) {
        return this.data.array[t2 * this.data.stride + this.offset + 1];
      }, getZ: function(t2) {
        return this.data.array[t2 * this.data.stride + this.offset + 2];
      }, getW: function(t2) {
        return this.data.array[t2 * this.data.stride + this.offset + 3];
      }, setXY: function(t2, e2, n2) {
        return t2 = t2 * this.data.stride + this.offset, this.data.array[t2 + 0] = e2, this.data.array[t2 + 1] = n2, this;
      }, setXYZ: function(t2, e2, n2, r2) {
        return t2 = t2 * this.data.stride + this.offset, this.data.array[t2 + 0] = e2, this.data.array[t2 + 1] = n2, this.data.array[t2 + 2] = r2, this;
      }, setXYZW: function(t2, e2, n2, r2, i2) {
        return t2 = t2 * this.data.stride + this.offset, this.data.array[t2 + 0] = e2, this.data.array[t2 + 1] = n2, this.data.array[t2 + 2] = r2, this.data.array[t2 + 3] = i2, this;
      }, clone: function(t2) {
        if (void 0 === t2) {
          console.log("THREE.InterleavedBufferAttribute.clone(): Cloning an interlaved buffer attribute will deinterleave buffer data.");
          const t3 = [];
          for (let e2 = 0; e2 < this.count; e2++) {
            const n2 = e2 * this.data.stride + this.offset;
            for (let e3 = 0; e3 < this.itemSize; e3++) t3.push(this.data.array[n2 + e3]);
          }
          return new Ti(new this.array.constructor(t3), this.itemSize, this.normalized);
        }
        return void 0 === t2.interleavedBuffers && (t2.interleavedBuffers = {}), void 0 === t2.interleavedBuffers[this.data.uuid] && (t2.interleavedBuffers[this.data.uuid] = this.data.clone(t2)), new Us(t2.interleavedBuffers[this.data.uuid], this.itemSize, this.offset, this.normalized);
      }, toJSON: function(t2) {
        if (void 0 === t2) {
          console.log("THREE.InterleavedBufferAttribute.toJSON(): Serializing an interlaved buffer attribute will deinterleave buffer data.");
          const t3 = [];
          for (let e2 = 0; e2 < this.count; e2++) {
            const n2 = e2 * this.data.stride + this.offset;
            for (let e3 = 0; e3 < this.itemSize; e3++) t3.push(this.data.array[n2 + e3]);
          }
          return { itemSize: this.itemSize, type: this.array.constructor.name, array: t3, normalized: this.normalized };
        }
        return void 0 === t2.interleavedBuffers && (t2.interleavedBuffers = {}), void 0 === t2.interleavedBuffers[this.data.uuid] && (t2.interleavedBuffers[this.data.uuid] = this.data.toJSON(t2)), { isInterleavedBufferAttribute: true, itemSize: this.itemSize, data: this.data.uuid, offset: this.offset, normalized: this.normalized };
      } }), js.prototype = Object.create(wi.prototype), js.prototype.constructor = js, js.prototype.isSpriteMaterial = true, js.prototype.copy = function(t2) {
        return wi.prototype.copy.call(this, t2), this.color.copy(t2.color), this.map = t2.map, this.alphaMap = t2.alphaMap, this.rotation = t2.rotation, this.sizeAttenuation = t2.sizeAttenuation, this;
      };
      const Ws = new $n(), qs = new $n(), Xs = new $n(), Ys = new Hn(), Zs = new Hn(), Js = new Tr(), $s = new $n(), Qs = new $n(), Ks = new $n(), tc = new Hn(), ec = new Hn(), nc = new Hn();
      function rc(t2) {
        if (Jr.call(this), this.type = "Sprite", void 0 === Vs) {
          Vs = new Xi();
          const t3 = new Hs(new Float32Array([-0.5, -0.5, 0, 0, 0, 0.5, -0.5, 0, 1, 0, 0.5, 0.5, 0, 1, 1, -0.5, 0.5, 0, 0, 1]), 5);
          Vs.setIndex([0, 1, 2, 0, 2, 3]), Vs.setAttribute("position", new Us(t3, 3, 0, false)), Vs.setAttribute("uv", new Us(t3, 2, 3, false));
        }
        this.geometry = Vs, this.material = void 0 !== t2 ? t2 : new js(), this.center = new Hn(0.5, 0.5);
      }
      function ic(t2, e2, n2, r2, i2, o2) {
        Ys.subVectors(t2, n2).addScalar(0.5).multiply(r2), void 0 !== i2 ? (Zs.x = o2 * Ys.x - i2 * Ys.y, Zs.y = i2 * Ys.x + o2 * Ys.y) : Zs.copy(Ys), t2.copy(e2), t2.x += Zs.x, t2.y += Zs.y, t2.applyMatrix4(Js);
      }
      rc.prototype = Object.assign(Object.create(Jr.prototype), { constructor: rc, isSprite: true, raycast: function(t2, e2) {
        null === t2.camera && console.error('THREE.Sprite: "Raycaster.camera" needs to be set in order to raycast against sprites.'), qs.setFromMatrixScale(this.matrixWorld), Js.copy(t2.camera.matrixWorld), this.modelViewMatrix.multiplyMatrices(t2.camera.matrixWorldInverse, this.matrixWorld), Xs.setFromMatrixPosition(this.modelViewMatrix), t2.camera.isPerspectiveCamera && false === this.material.sizeAttenuation && qs.multiplyScalar(-Xs.z);
        const n2 = this.material.rotation;
        let r2, i2;
        0 !== n2 && (i2 = Math.cos(n2), r2 = Math.sin(n2));
        const o2 = this.center;
        ic($s.set(-0.5, -0.5, 0), Xs, o2, qs, r2, i2), ic(Qs.set(0.5, -0.5, 0), Xs, o2, qs, r2, i2), ic(Ks.set(0.5, 0.5, 0), Xs, o2, qs, r2, i2), tc.set(0, 0), ec.set(1, 0), nc.set(1, 1);
        let a2 = t2.ray.intersectTriangle($s, Qs, Ks, false, Ws);
        if (null === a2 && (ic(Qs.set(-0.5, 0.5, 0), Xs, o2, qs, r2, i2), ec.set(0, 1), a2 = t2.ray.intersectTriangle($s, Ks, Qs, false, Ws), null === a2)) return;
        const s2 = t2.ray.origin.distanceTo(Ws);
        s2 < t2.near || s2 > t2.far || e2.push({ distance: s2, point: Ws.clone(), uv: hi.getUV(Ws, $s, Qs, Ks, tc, ec, nc, new Hn()), face: null, object: this });
      }, copy: function(t2) {
        return Jr.prototype.copy.call(this, t2), void 0 !== t2.center && this.center.copy(t2.center), this.material = t2.material, this;
      } });
      const oc = new $n(), ac = new $n();
      function sc() {
        Jr.call(this), this._currentLevel = 0, this.type = "LOD", Object.defineProperties(this, { levels: { enumerable: true, value: [] } }), this.autoUpdate = true;
      }
      sc.prototype = Object.assign(Object.create(Jr.prototype), { constructor: sc, isLOD: true, copy: function(t2) {
        Jr.prototype.copy.call(this, t2, false);
        const e2 = t2.levels;
        for (let t3 = 0, n2 = e2.length; t3 < n2; t3++) {
          const n3 = e2[t3];
          this.addLevel(n3.object.clone(), n3.distance);
        }
        return this.autoUpdate = t2.autoUpdate, this;
      }, addLevel: function(t2, e2 = 0) {
        e2 = Math.abs(e2);
        const n2 = this.levels;
        let r2;
        for (r2 = 0; r2 < n2.length && !(e2 < n2[r2].distance); r2++) ;
        return n2.splice(r2, 0, { distance: e2, object: t2 }), this.add(t2), this;
      }, getCurrentLevel: function() {
        return this._currentLevel;
      }, getObjectForDistance: function(t2) {
        const e2 = this.levels;
        if (e2.length > 0) {
          let n2, r2;
          for (n2 = 1, r2 = e2.length; n2 < r2 && !(t2 < e2[n2].distance); n2++) ;
          return e2[n2 - 1].object;
        }
        return null;
      }, raycast: function(t2, e2) {
        if (this.levels.length > 0) {
          oc.setFromMatrixPosition(this.matrixWorld);
          const n2 = t2.ray.origin.distanceTo(oc);
          this.getObjectForDistance(n2).raycast(t2, e2);
        }
      }, update: function(t2) {
        const e2 = this.levels;
        if (e2.length > 1) {
          oc.setFromMatrixPosition(t2.matrixWorld), ac.setFromMatrixPosition(this.matrixWorld);
          const n2 = oc.distanceTo(ac) / t2.zoom;
          let r2, i2;
          for (e2[0].object.visible = true, r2 = 1, i2 = e2.length; r2 < i2 && n2 >= e2[r2].distance; r2++) e2[r2 - 1].object.visible = false, e2[r2].object.visible = true;
          for (this._currentLevel = r2 - 1; r2 < i2; r2++) e2[r2].object.visible = false;
        }
      }, toJSON: function(t2) {
        const e2 = Jr.prototype.toJSON.call(this, t2);
        false === this.autoUpdate && (e2.object.autoUpdate = false), e2.object.levels = [];
        const n2 = this.levels;
        for (let t3 = 0, r2 = n2.length; t3 < r2; t3++) {
          const r3 = n2[t3];
          e2.object.levels.push({ object: r3.object.uuid, distance: r3.distance });
        }
        return e2;
      } });
      const cc = new $n(), uc = new Xn(), lc = new Xn(), hc = new $n(), dc = new Tr();
      function pc(t2, e2) {
        t2 && t2.isGeometry && console.error("THREE.SkinnedMesh no longer supports THREE.Geometry. Use THREE.BufferGeometry instead."), ho.call(this, t2, e2), this.type = "SkinnedMesh", this.bindMode = "attached", this.bindMatrix = new Tr(), this.bindMatrixInverse = new Tr();
      }
      function fc() {
        Jr.call(this), this.type = "Bone";
      }
      pc.prototype = Object.assign(Object.create(ho.prototype), { constructor: pc, isSkinnedMesh: true, copy: function(t2) {
        return ho.prototype.copy.call(this, t2), this.bindMode = t2.bindMode, this.bindMatrix.copy(t2.bindMatrix), this.bindMatrixInverse.copy(t2.bindMatrixInverse), this.skeleton = t2.skeleton, this;
      }, bind: function(t2, e2) {
        this.skeleton = t2, void 0 === e2 && (this.updateMatrixWorld(true), this.skeleton.calculateInverses(), e2 = this.matrixWorld), this.bindMatrix.copy(e2), this.bindMatrixInverse.copy(e2).invert();
      }, pose: function() {
        this.skeleton.pose();
      }, normalizeSkinWeights: function() {
        const t2 = new Xn(), e2 = this.geometry.attributes.skinWeight;
        for (let n2 = 0, r2 = e2.count; n2 < r2; n2++) {
          t2.x = e2.getX(n2), t2.y = e2.getY(n2), t2.z = e2.getZ(n2), t2.w = e2.getW(n2);
          const r3 = 1 / t2.manhattanLength();
          r3 !== 1 / 0 ? t2.multiplyScalar(r3) : t2.set(1, 0, 0, 0), e2.setXYZW(n2, t2.x, t2.y, t2.z, t2.w);
        }
      }, updateMatrixWorld: function(t2) {
        ho.prototype.updateMatrixWorld.call(this, t2), "attached" === this.bindMode ? this.bindMatrixInverse.copy(this.matrixWorld).invert() : "detached" === this.bindMode ? this.bindMatrixInverse.copy(this.bindMatrix).invert() : console.warn("THREE.SkinnedMesh: Unrecognized bindMode: " + this.bindMode);
      }, boneTransform: function(t2, e2) {
        const n2 = this.skeleton, r2 = this.geometry;
        uc.fromBufferAttribute(r2.attributes.skinIndex, t2), lc.fromBufferAttribute(r2.attributes.skinWeight, t2), cc.fromBufferAttribute(r2.attributes.position, t2).applyMatrix4(this.bindMatrix), e2.set(0, 0, 0);
        for (let t3 = 0; t3 < 4; t3++) {
          const r3 = lc.getComponent(t3);
          if (0 !== r3) {
            const i2 = uc.getComponent(t3);
            dc.multiplyMatrices(n2.bones[i2].matrixWorld, n2.boneInverses[i2]), e2.addScaledVector(hc.copy(cc).applyMatrix4(dc), r3);
          }
        }
        return e2.applyMatrix4(this.bindMatrixInverse);
      } }), fc.prototype = Object.assign(Object.create(Jr.prototype), { constructor: fc, isBone: true });
      const mc = new Tr(), gc = new Tr();
      function vc(t2 = [], e2 = []) {
        this.uuid = Bn.generateUUID(), this.bones = t2.slice(0), this.boneInverses = e2, this.boneMatrices = null, this.boneTexture = null, this.boneTextureSize = 0, this.frame = -1, this.init();
      }
      Object.assign(vc.prototype, { init: function() {
        const t2 = this.bones, e2 = this.boneInverses;
        if (this.boneMatrices = new Float32Array(16 * t2.length), 0 === e2.length) this.calculateInverses();
        else if (t2.length !== e2.length) {
          console.warn("THREE.Skeleton: Number of inverse bone matrices does not match amount of bones."), this.boneInverses = [];
          for (let t3 = 0, e3 = this.bones.length; t3 < e3; t3++) this.boneInverses.push(new Tr());
        }
      }, calculateInverses: function() {
        this.boneInverses.length = 0;
        for (let t2 = 0, e2 = this.bones.length; t2 < e2; t2++) {
          const e3 = new Tr();
          this.bones[t2] && e3.copy(this.bones[t2].matrixWorld).invert(), this.boneInverses.push(e3);
        }
      }, pose: function() {
        for (let t2 = 0, e2 = this.bones.length; t2 < e2; t2++) {
          const e3 = this.bones[t2];
          e3 && e3.matrixWorld.copy(this.boneInverses[t2]).invert();
        }
        for (let t2 = 0, e2 = this.bones.length; t2 < e2; t2++) {
          const e3 = this.bones[t2];
          e3 && (e3.parent && e3.parent.isBone ? (e3.matrix.copy(e3.parent.matrixWorld).invert(), e3.matrix.multiply(e3.matrixWorld)) : e3.matrix.copy(e3.matrixWorld), e3.matrix.decompose(e3.position, e3.quaternion, e3.scale));
        }
      }, update: function() {
        const t2 = this.bones, e2 = this.boneInverses, n2 = this.boneMatrices, r2 = this.boneTexture;
        for (let r3 = 0, i2 = t2.length; r3 < i2; r3++) {
          const i3 = t2[r3] ? t2[r3].matrixWorld : gc;
          mc.multiplyMatrices(i3, e2[r3]), mc.toArray(n2, 16 * r3);
        }
        null !== r2 && (r2.needsUpdate = true);
      }, clone: function() {
        return new vc(this.bones, this.boneInverses);
      }, getBoneByName: function(t2) {
        for (let e2 = 0, n2 = this.bones.length; e2 < n2; e2++) {
          const n3 = this.bones[e2];
          if (n3.name === t2) return n3;
        }
      }, dispose: function() {
        null !== this.boneTexture && (this.boneTexture.dispose(), this.boneTexture = null);
      }, fromJSON: function(t2, e2) {
        this.uuid = t2.uuid;
        for (let n2 = 0, r2 = t2.bones.length; n2 < r2; n2++) {
          const r3 = t2.bones[n2];
          let i2 = e2[r3];
          void 0 === i2 && (console.warn("THREE.Skeleton: No bone found with UUID:", r3), i2 = new fc()), this.bones.push(i2), this.boneInverses.push(new Tr().fromArray(t2.boneInverses[n2]));
        }
        return this.init(), this;
      }, toJSON: function() {
        const t2 = { metadata: { version: 4.5, type: "Skeleton", generator: "Skeleton.toJSON" }, bones: [], boneInverses: [] };
        t2.uuid = this.uuid;
        const e2 = this.bones, n2 = this.boneInverses;
        for (let r2 = 0, i2 = e2.length; r2 < i2; r2++) {
          const i3 = e2[r2];
          t2.bones.push(i3.uuid);
          const o2 = n2[r2];
          t2.boneInverses.push(o2.toArray());
        }
        return t2;
      } });
      const yc = new Tr(), xc = new Tr(), bc = [], wc = new ho();
      function _c(t2, e2, n2) {
        ho.call(this, t2, e2), this.instanceMatrix = new Ti(new Float32Array(16 * n2), 16), this.instanceColor = null, this.count = n2, this.frustumCulled = false;
      }
      function Mc(t2) {
        wi.call(this), this.type = "LineBasicMaterial", this.color = new yi(16777215), this.linewidth = 1, this.linecap = "round", this.linejoin = "round", this.morphTargets = false, this.setValues(t2);
      }
      _c.prototype = Object.assign(Object.create(ho.prototype), { constructor: _c, isInstancedMesh: true, copy: function(t2) {
        return ho.prototype.copy.call(this, t2), this.instanceMatrix.copy(t2.instanceMatrix), this.count = t2.count, this;
      }, getColorAt: function(t2, e2) {
        e2.fromArray(this.instanceColor.array, 3 * t2);
      }, getMatrixAt: function(t2, e2) {
        e2.fromArray(this.instanceMatrix.array, 16 * t2);
      }, raycast: function(t2, e2) {
        const n2 = this.matrixWorld, r2 = this.count;
        if (wc.geometry = this.geometry, wc.material = this.material, void 0 !== wc.material) for (let i2 = 0; i2 < r2; i2++) {
          this.getMatrixAt(i2, yc), xc.multiplyMatrices(n2, yc), wc.matrixWorld = xc, wc.raycast(t2, bc);
          for (let t3 = 0, n3 = bc.length; t3 < n3; t3++) {
            const n4 = bc[t3];
            n4.instanceId = i2, n4.object = this, e2.push(n4);
          }
          bc.length = 0;
        }
      }, setColorAt: function(t2, e2) {
        null === this.instanceColor && (this.instanceColor = new Ti(new Float32Array(3 * this.count), 3)), e2.toArray(this.instanceColor.array, 3 * t2);
      }, setMatrixAt: function(t2, e2) {
        e2.toArray(this.instanceMatrix.array, 16 * t2);
      }, updateMorphTargets: function() {
      }, dispose: function() {
        this.dispatchEvent({ type: "dispose" });
      } }), Mc.prototype = Object.create(wi.prototype), Mc.prototype.constructor = Mc, Mc.prototype.isLineBasicMaterial = true, Mc.prototype.copy = function(t2) {
        return wi.prototype.copy.call(this, t2), this.color.copy(t2.color), this.linewidth = t2.linewidth, this.linecap = t2.linecap, this.linejoin = t2.linejoin, this.morphTargets = t2.morphTargets, this;
      };
      const Sc = new $n(), Tc = new $n(), Ec = new Tr(), Ac = new Sr(), Cc = new gr();
      function Lc(t2 = new Xi(), e2 = new Mc()) {
        Jr.call(this), this.type = "Line", this.geometry = t2, this.material = e2, this.updateMorphTargets();
      }
      Lc.prototype = Object.assign(Object.create(Jr.prototype), { constructor: Lc, isLine: true, copy: function(t2) {
        return Jr.prototype.copy.call(this, t2), this.material = t2.material, this.geometry = t2.geometry, this;
      }, computeLineDistances: function() {
        const t2 = this.geometry;
        if (t2.isBufferGeometry) if (null === t2.index) {
          const e2 = t2.attributes.position, n2 = [0];
          for (let t3 = 1, r2 = e2.count; t3 < r2; t3++) Sc.fromBufferAttribute(e2, t3 - 1), Tc.fromBufferAttribute(e2, t3), n2[t3] = n2[t3 - 1], n2[t3] += Sc.distanceTo(Tc);
          t2.setAttribute("lineDistance", new Ii(n2, 1));
        } else console.warn("THREE.Line.computeLineDistances(): Computation only possible with non-indexed BufferGeometry.");
        else if (t2.isGeometry) {
          const e2 = t2.vertices, n2 = t2.lineDistances;
          n2[0] = 0;
          for (let t3 = 1, r2 = e2.length; t3 < r2; t3++) n2[t3] = n2[t3 - 1], n2[t3] += e2[t3 - 1].distanceTo(e2[t3]);
        }
        return this;
      }, raycast: function(t2, e2) {
        const n2 = this.geometry, r2 = this.matrixWorld, i2 = t2.params.Line.threshold;
        if (null === n2.boundingSphere && n2.computeBoundingSphere(), Cc.copy(n2.boundingSphere), Cc.applyMatrix4(r2), Cc.radius += i2, false === t2.ray.intersectsSphere(Cc)) return;
        Ec.copy(r2).invert(), Ac.copy(t2.ray).applyMatrix4(Ec);
        const o2 = i2 / ((this.scale.x + this.scale.y + this.scale.z) / 3), a2 = o2 * o2, s2 = new $n(), c2 = new $n(), u2 = new $n(), l2 = new $n(), h2 = this.isLineSegments ? 2 : 1;
        if (n2.isBufferGeometry) {
          const r3 = n2.index, i3 = n2.attributes.position;
          if (null !== r3) {
            const n3 = r3.array;
            for (let r4 = 0, o3 = n3.length - 1; r4 < o3; r4 += h2) {
              const o4 = n3[r4], h3 = n3[r4 + 1];
              s2.fromBufferAttribute(i3, o4), c2.fromBufferAttribute(i3, h3);
              if (Ac.distanceSqToSegment(s2, c2, l2, u2) > a2) continue;
              l2.applyMatrix4(this.matrixWorld);
              const d2 = t2.ray.origin.distanceTo(l2);
              d2 < t2.near || d2 > t2.far || e2.push({ distance: d2, point: u2.clone().applyMatrix4(this.matrixWorld), index: r4, face: null, faceIndex: null, object: this });
            }
          } else for (let n3 = 0, r4 = i3.count - 1; n3 < r4; n3 += h2) {
            s2.fromBufferAttribute(i3, n3), c2.fromBufferAttribute(i3, n3 + 1);
            if (Ac.distanceSqToSegment(s2, c2, l2, u2) > a2) continue;
            l2.applyMatrix4(this.matrixWorld);
            const r5 = t2.ray.origin.distanceTo(l2);
            r5 < t2.near || r5 > t2.far || e2.push({ distance: r5, point: u2.clone().applyMatrix4(this.matrixWorld), index: n3, face: null, faceIndex: null, object: this });
          }
        } else if (n2.isGeometry) {
          const r3 = n2.vertices, i3 = r3.length;
          for (let n3 = 0; n3 < i3 - 1; n3 += h2) {
            if (Ac.distanceSqToSegment(r3[n3], r3[n3 + 1], l2, u2) > a2) continue;
            l2.applyMatrix4(this.matrixWorld);
            const i4 = t2.ray.origin.distanceTo(l2);
            i4 < t2.near || i4 > t2.far || e2.push({ distance: i4, point: u2.clone().applyMatrix4(this.matrixWorld), index: n3, face: null, faceIndex: null, object: this });
          }
        }
      }, updateMorphTargets: function() {
        const t2 = this.geometry;
        if (t2.isBufferGeometry) {
          const e2 = t2.morphAttributes, n2 = Object.keys(e2);
          if (n2.length > 0) {
            const t3 = e2[n2[0]];
            if (void 0 !== t3) {
              this.morphTargetInfluences = [], this.morphTargetDictionary = {};
              for (let e3 = 0, n3 = t3.length; e3 < n3; e3++) {
                const n4 = t3[e3].name || String(e3);
                this.morphTargetInfluences.push(0), this.morphTargetDictionary[n4] = e3;
              }
            }
          }
        } else {
          const e2 = t2.morphTargets;
          void 0 !== e2 && e2.length > 0 && console.error("THREE.Line.updateMorphTargets() does not support THREE.Geometry. Use THREE.BufferGeometry instead.");
        }
      } });
      const Pc = new $n(), Rc = new $n();
      function Oc(t2, e2) {
        Lc.call(this, t2, e2), this.type = "LineSegments";
      }
      function Dc(t2, e2) {
        Lc.call(this, t2, e2), this.type = "LineLoop";
      }
      function Ic(t2) {
        wi.call(this), this.type = "PointsMaterial", this.color = new yi(16777215), this.map = null, this.alphaMap = null, this.size = 1, this.sizeAttenuation = true, this.morphTargets = false, this.setValues(t2);
      }
      Oc.prototype = Object.assign(Object.create(Lc.prototype), { constructor: Oc, isLineSegments: true, computeLineDistances: function() {
        const t2 = this.geometry;
        if (t2.isBufferGeometry) if (null === t2.index) {
          const e2 = t2.attributes.position, n2 = [];
          for (let t3 = 0, r2 = e2.count; t3 < r2; t3 += 2) Pc.fromBufferAttribute(e2, t3), Rc.fromBufferAttribute(e2, t3 + 1), n2[t3] = 0 === t3 ? 0 : n2[t3 - 1], n2[t3 + 1] = n2[t3] + Pc.distanceTo(Rc);
          t2.setAttribute("lineDistance", new Ii(n2, 1));
        } else console.warn("THREE.LineSegments.computeLineDistances(): Computation only possible with non-indexed BufferGeometry.");
        else if (t2.isGeometry) {
          const e2 = t2.vertices, n2 = t2.lineDistances;
          for (let t3 = 0, r2 = e2.length; t3 < r2; t3 += 2) Pc.copy(e2[t3]), Rc.copy(e2[t3 + 1]), n2[t3] = 0 === t3 ? 0 : n2[t3 - 1], n2[t3 + 1] = n2[t3] + Pc.distanceTo(Rc);
        }
        return this;
      } }), Dc.prototype = Object.assign(Object.create(Lc.prototype), { constructor: Dc, isLineLoop: true }), Ic.prototype = Object.create(wi.prototype), Ic.prototype.constructor = Ic, Ic.prototype.isPointsMaterial = true, Ic.prototype.copy = function(t2) {
        return wi.prototype.copy.call(this, t2), this.color.copy(t2.color), this.map = t2.map, this.alphaMap = t2.alphaMap, this.size = t2.size, this.sizeAttenuation = t2.sizeAttenuation, this.morphTargets = t2.morphTargets, this;
      };
      const Nc = new Tr(), zc = new Sr(), kc = new gr(), Fc = new $n();
      function Bc(t2 = new Xi(), e2 = new Ic()) {
        Jr.call(this), this.type = "Points", this.geometry = t2, this.material = e2, this.updateMorphTargets();
      }
      function Hc(t2, e2, n2, r2, i2, o2, a2) {
        const s2 = zc.distanceSqToPoint(t2);
        if (s2 < n2) {
          const n3 = new $n();
          zc.closestPointToPoint(t2, n3), n3.applyMatrix4(r2);
          const c2 = i2.ray.origin.distanceTo(n3);
          if (c2 < i2.near || c2 > i2.far) return;
          o2.push({ distance: c2, distanceToRay: Math.sqrt(s2), point: n3, index: e2, face: null, object: a2 });
        }
      }
      function Gc(t2, e2, n2, r2, i2, o2, a2, s2, c2) {
        Wn.call(this, t2, e2, n2, r2, i2, o2, a2, s2, c2), this.format = void 0 !== a2 ? a2 : kt, this.minFilter = void 0 !== o2 ? o2 : xt, this.magFilter = void 0 !== i2 ? i2 : xt, this.generateMipmaps = false;
        const u2 = this;
        "requestVideoFrameCallback" in t2 && t2.requestVideoFrameCallback(function e3() {
          u2.needsUpdate = true, t2.requestVideoFrameCallback(e3);
        });
      }
      function Uc(t2, e2, n2, r2, i2, o2, a2, s2, c2, u2, l2, h2) {
        Wn.call(this, null, o2, a2, s2, c2, u2, r2, i2, l2, h2), this.image = { width: e2, height: n2 }, this.mipmaps = t2, this.flipY = false, this.generateMipmaps = false;
      }
      function jc(t2, e2, n2, r2, i2, o2, a2, s2, c2) {
        Wn.call(this, t2, e2, n2, r2, i2, o2, a2, s2, c2), this.needsUpdate = true;
      }
      function Vc(t2, e2, n2, r2, i2, o2, a2, s2, c2, u2) {
        if ((u2 = void 0 !== u2 ? u2 : Ut) !== Ut && u2 !== jt) throw new Error("DepthTexture format must be either THREE.DepthFormat or THREE.DepthStencilFormat");
        void 0 === n2 && u2 === Ut && (n2 = At), void 0 === n2 && u2 === jt && (n2 = Nt), Wn.call(this, null, r2, i2, o2, a2, s2, u2, n2, c2), this.image = { width: t2, height: e2 }, this.magFilter = void 0 !== a2 ? a2 : ft, this.minFilter = void 0 !== s2 ? s2 : ft, this.flipY = false, this.generateMipmaps = false;
      }
      Bc.prototype = Object.assign(Object.create(Jr.prototype), { constructor: Bc, isPoints: true, copy: function(t2) {
        return Jr.prototype.copy.call(this, t2), this.material = t2.material, this.geometry = t2.geometry, this;
      }, raycast: function(t2, e2) {
        const n2 = this.geometry, r2 = this.matrixWorld, i2 = t2.params.Points.threshold;
        if (null === n2.boundingSphere && n2.computeBoundingSphere(), kc.copy(n2.boundingSphere), kc.applyMatrix4(r2), kc.radius += i2, false === t2.ray.intersectsSphere(kc)) return;
        Nc.copy(r2).invert(), zc.copy(t2.ray).applyMatrix4(Nc);
        const o2 = i2 / ((this.scale.x + this.scale.y + this.scale.z) / 3), a2 = o2 * o2;
        if (n2.isBufferGeometry) {
          const i3 = n2.index, o3 = n2.attributes.position;
          if (null !== i3) {
            const n3 = i3.array;
            for (let i4 = 0, s2 = n3.length; i4 < s2; i4++) {
              const s3 = n3[i4];
              Fc.fromBufferAttribute(o3, s3), Hc(Fc, s3, a2, r2, t2, e2, this);
            }
          } else for (let n3 = 0, i4 = o3.count; n3 < i4; n3++) Fc.fromBufferAttribute(o3, n3), Hc(Fc, n3, a2, r2, t2, e2, this);
        } else {
          const i3 = n2.vertices;
          for (let n3 = 0, o3 = i3.length; n3 < o3; n3++) Hc(i3[n3], n3, a2, r2, t2, e2, this);
        }
      }, updateMorphTargets: function() {
        const t2 = this.geometry;
        if (t2.isBufferGeometry) {
          const e2 = t2.morphAttributes, n2 = Object.keys(e2);
          if (n2.length > 0) {
            const t3 = e2[n2[0]];
            if (void 0 !== t3) {
              this.morphTargetInfluences = [], this.morphTargetDictionary = {};
              for (let e3 = 0, n3 = t3.length; e3 < n3; e3++) {
                const n4 = t3[e3].name || String(e3);
                this.morphTargetInfluences.push(0), this.morphTargetDictionary[n4] = e3;
              }
            }
          }
        } else {
          const e2 = t2.morphTargets;
          void 0 !== e2 && e2.length > 0 && console.error("THREE.Points.updateMorphTargets() does not support THREE.Geometry. Use THREE.BufferGeometry instead.");
        }
      } }), Gc.prototype = Object.assign(Object.create(Wn.prototype), { constructor: Gc, clone: function() {
        return new this.constructor(this.image).copy(this);
      }, isVideoTexture: true, update: function() {
        const t2 = this.image;
        false === "requestVideoFrameCallback" in t2 && t2.readyState >= t2.HAVE_CURRENT_DATA && (this.needsUpdate = true);
      } }), Uc.prototype = Object.create(Wn.prototype), Uc.prototype.constructor = Uc, Uc.prototype.isCompressedTexture = true, jc.prototype = Object.create(Wn.prototype), jc.prototype.constructor = jc, jc.prototype.isCanvasTexture = true, Vc.prototype = Object.create(Wn.prototype), Vc.prototype.constructor = Vc, Vc.prototype.isDepthTexture = true;
      let Wc = 0;
      const qc = new Tr(), Xc = new Jr(), Yc = new $n();
      function Zc() {
        Object.defineProperty(this, "id", { value: Wc += 2 }), this.uuid = Bn.generateUUID(), this.name = "", this.type = "Geometry", this.vertices = [], this.colors = [], this.faces = [], this.faceVertexUvs = [[]], this.morphTargets = [], this.morphNormals = [], this.skinWeights = [], this.skinIndices = [], this.lineDistances = [], this.boundingBox = null, this.boundingSphere = null, this.elementsNeedUpdate = false, this.verticesNeedUpdate = false, this.uvsNeedUpdate = false, this.normalsNeedUpdate = false, this.colorsNeedUpdate = false, this.lineDistancesNeedUpdate = false, this.groupsNeedUpdate = false;
      }
      Zc.prototype = Object.assign(Object.create(zn.prototype), { constructor: Zc, isGeometry: true, applyMatrix4: function(t2) {
        const e2 = new Gn().getNormalMatrix(t2);
        for (let e3 = 0, n2 = this.vertices.length; e3 < n2; e3++) {
          this.vertices[e3].applyMatrix4(t2);
        }
        for (let t3 = 0, n2 = this.faces.length; t3 < n2; t3++) {
          const n3 = this.faces[t3];
          n3.normal.applyMatrix3(e2).normalize();
          for (let t4 = 0, r2 = n3.vertexNormals.length; t4 < r2; t4++) n3.vertexNormals[t4].applyMatrix3(e2).normalize();
        }
        return null !== this.boundingBox && this.computeBoundingBox(), null !== this.boundingSphere && this.computeBoundingSphere(), this.verticesNeedUpdate = true, this.normalsNeedUpdate = true, this;
      }, rotateX: function(t2) {
        return qc.makeRotationX(t2), this.applyMatrix4(qc), this;
      }, rotateY: function(t2) {
        return qc.makeRotationY(t2), this.applyMatrix4(qc), this;
      }, rotateZ: function(t2) {
        return qc.makeRotationZ(t2), this.applyMatrix4(qc), this;
      }, translate: function(t2, e2, n2) {
        return qc.makeTranslation(t2, e2, n2), this.applyMatrix4(qc), this;
      }, scale: function(t2, e2, n2) {
        return qc.makeScale(t2, e2, n2), this.applyMatrix4(qc), this;
      }, lookAt: function(t2) {
        return Xc.lookAt(t2), Xc.updateMatrix(), this.applyMatrix4(Xc.matrix), this;
      }, fromBufferGeometry: function(t2) {
        const e2 = this, n2 = null !== t2.index ? t2.index : void 0, r2 = t2.attributes;
        if (void 0 === r2.position) return console.error("THREE.Geometry.fromBufferGeometry(): Position attribute required for conversion."), this;
        const i2 = r2.position, o2 = r2.normal, a2 = r2.color, s2 = r2.uv, c2 = r2.uv2;
        void 0 !== c2 && (this.faceVertexUvs[1] = []);
        for (let t3 = 0; t3 < i2.count; t3++) e2.vertices.push(new $n().fromBufferAttribute(i2, t3)), void 0 !== a2 && e2.colors.push(new yi().fromBufferAttribute(a2, t3));
        function u2(t3, n3, r3, i3) {
          const u3 = void 0 === a2 ? [] : [e2.colors[t3].clone(), e2.colors[n3].clone(), e2.colors[r3].clone()], l3 = void 0 === o2 ? [] : [new $n().fromBufferAttribute(o2, t3), new $n().fromBufferAttribute(o2, n3), new $n().fromBufferAttribute(o2, r3)], h2 = new xi(t3, n3, r3, l3, u3, i3);
          e2.faces.push(h2), void 0 !== s2 && e2.faceVertexUvs[0].push([new Hn().fromBufferAttribute(s2, t3), new Hn().fromBufferAttribute(s2, n3), new Hn().fromBufferAttribute(s2, r3)]), void 0 !== c2 && e2.faceVertexUvs[1].push([new Hn().fromBufferAttribute(c2, t3), new Hn().fromBufferAttribute(c2, n3), new Hn().fromBufferAttribute(c2, r3)]);
        }
        const l2 = t2.groups;
        if (l2.length > 0) for (let t3 = 0; t3 < l2.length; t3++) {
          const e3 = l2[t3], r3 = e3.start;
          for (let t4 = r3, i3 = r3 + e3.count; t4 < i3; t4 += 3) void 0 !== n2 ? u2(n2.getX(t4), n2.getX(t4 + 1), n2.getX(t4 + 2), e3.materialIndex) : u2(t4, t4 + 1, t4 + 2, e3.materialIndex);
        }
        else if (void 0 !== n2) for (let t3 = 0; t3 < n2.count; t3 += 3) u2(n2.getX(t3), n2.getX(t3 + 1), n2.getX(t3 + 2));
        else for (let t3 = 0; t3 < i2.count; t3 += 3) u2(t3, t3 + 1, t3 + 2);
        return this.computeFaceNormals(), null !== t2.boundingBox && (this.boundingBox = t2.boundingBox.clone()), null !== t2.boundingSphere && (this.boundingSphere = t2.boundingSphere.clone()), this;
      }, center: function() {
        return this.computeBoundingBox(), this.boundingBox.getCenter(Yc).negate(), this.translate(Yc.x, Yc.y, Yc.z), this;
      }, normalize: function() {
        this.computeBoundingSphere();
        const t2 = this.boundingSphere.center, e2 = this.boundingSphere.radius, n2 = 0 === e2 ? 1 : 1 / e2, r2 = new Tr();
        return r2.set(n2, 0, 0, -n2 * t2.x, 0, n2, 0, -n2 * t2.y, 0, 0, n2, -n2 * t2.z, 0, 0, 0, 1), this.applyMatrix4(r2), this;
      }, computeFaceNormals: function() {
        const t2 = new $n(), e2 = new $n();
        for (let n2 = 0, r2 = this.faces.length; n2 < r2; n2++) {
          const r3 = this.faces[n2], i2 = this.vertices[r3.a], o2 = this.vertices[r3.b], a2 = this.vertices[r3.c];
          t2.subVectors(a2, o2), e2.subVectors(i2, o2), t2.cross(e2), t2.normalize(), r3.normal.copy(t2);
        }
      }, computeVertexNormals: function(t2 = true) {
        const e2 = new Array(this.vertices.length);
        for (let t3 = 0, n2 = this.vertices.length; t3 < n2; t3++) e2[t3] = new $n();
        if (t2) {
          const t3 = new $n(), n2 = new $n();
          for (let r2 = 0, i2 = this.faces.length; r2 < i2; r2++) {
            const i3 = this.faces[r2], o2 = this.vertices[i3.a], a2 = this.vertices[i3.b], s2 = this.vertices[i3.c];
            t3.subVectors(s2, a2), n2.subVectors(o2, a2), t3.cross(n2), e2[i3.a].add(t3), e2[i3.b].add(t3), e2[i3.c].add(t3);
          }
        } else {
          this.computeFaceNormals();
          for (let t3 = 0, n2 = this.faces.length; t3 < n2; t3++) {
            const n3 = this.faces[t3];
            e2[n3.a].add(n3.normal), e2[n3.b].add(n3.normal), e2[n3.c].add(n3.normal);
          }
        }
        for (let t3 = 0, n2 = this.vertices.length; t3 < n2; t3++) e2[t3].normalize();
        for (let t3 = 0, n2 = this.faces.length; t3 < n2; t3++) {
          const n3 = this.faces[t3], r2 = n3.vertexNormals;
          3 === r2.length ? (r2[0].copy(e2[n3.a]), r2[1].copy(e2[n3.b]), r2[2].copy(e2[n3.c])) : (r2[0] = e2[n3.a].clone(), r2[1] = e2[n3.b].clone(), r2[2] = e2[n3.c].clone());
        }
        this.faces.length > 0 && (this.normalsNeedUpdate = true);
      }, computeFlatVertexNormals: function() {
        this.computeFaceNormals();
        for (let t2 = 0, e2 = this.faces.length; t2 < e2; t2++) {
          const e3 = this.faces[t2], n2 = e3.vertexNormals;
          3 === n2.length ? (n2[0].copy(e3.normal), n2[1].copy(e3.normal), n2[2].copy(e3.normal)) : (n2[0] = e3.normal.clone(), n2[1] = e3.normal.clone(), n2[2] = e3.normal.clone());
        }
        this.faces.length > 0 && (this.normalsNeedUpdate = true);
      }, computeMorphNormals: function() {
        for (let t3 = 0, e2 = this.faces.length; t3 < e2; t3++) {
          const e3 = this.faces[t3];
          e3.__originalFaceNormal ? e3.__originalFaceNormal.copy(e3.normal) : e3.__originalFaceNormal = e3.normal.clone(), e3.__originalVertexNormals || (e3.__originalVertexNormals = []);
          for (let t4 = 0, n2 = e3.vertexNormals.length; t4 < n2; t4++) e3.__originalVertexNormals[t4] ? e3.__originalVertexNormals[t4].copy(e3.vertexNormals[t4]) : e3.__originalVertexNormals[t4] = e3.vertexNormals[t4].clone();
        }
        const t2 = new Zc();
        t2.faces = this.faces;
        for (let e2 = 0, n2 = this.morphTargets.length; e2 < n2; e2++) {
          if (!this.morphNormals[e2]) {
            this.morphNormals[e2] = {}, this.morphNormals[e2].faceNormals = [], this.morphNormals[e2].vertexNormals = [];
            const t3 = this.morphNormals[e2].faceNormals, n4 = this.morphNormals[e2].vertexNormals;
            for (let e3 = 0, r2 = this.faces.length; e3 < r2; e3++) {
              const e4 = new $n(), r3 = { a: new $n(), b: new $n(), c: new $n() };
              t3.push(e4), n4.push(r3);
            }
          }
          const n3 = this.morphNormals[e2];
          t2.vertices = this.morphTargets[e2].vertices, t2.computeFaceNormals(), t2.computeVertexNormals();
          for (let t3 = 0, e3 = this.faces.length; t3 < e3; t3++) {
            const e4 = this.faces[t3], r2 = n3.faceNormals[t3], i2 = n3.vertexNormals[t3];
            r2.copy(e4.normal), i2.a.copy(e4.vertexNormals[0]), i2.b.copy(e4.vertexNormals[1]), i2.c.copy(e4.vertexNormals[2]);
          }
        }
        for (let t3 = 0, e2 = this.faces.length; t3 < e2; t3++) {
          const e3 = this.faces[t3];
          e3.normal = e3.__originalFaceNormal, e3.vertexNormals = e3.__originalVertexNormals;
        }
      }, computeBoundingBox: function() {
        null === this.boundingBox && (this.boundingBox = new tr()), this.boundingBox.setFromPoints(this.vertices);
      }, computeBoundingSphere: function() {
        null === this.boundingSphere && (this.boundingSphere = new gr()), this.boundingSphere.setFromPoints(this.vertices);
      }, merge: function(t2, e2, n2 = 0) {
        if (!t2 || !t2.isGeometry) return void console.error("THREE.Geometry.merge(): geometry not an instance of THREE.Geometry.", t2);
        let r2;
        const i2 = this.vertices.length, o2 = this.vertices, a2 = t2.vertices, s2 = this.faces, c2 = t2.faces, u2 = this.colors, l2 = t2.colors;
        void 0 !== e2 && (r2 = new Gn().getNormalMatrix(e2));
        for (let t3 = 0, n3 = a2.length; t3 < n3; t3++) {
          const n4 = a2[t3].clone();
          void 0 !== e2 && n4.applyMatrix4(e2), o2.push(n4);
        }
        for (let t3 = 0, e3 = l2.length; t3 < e3; t3++) u2.push(l2[t3].clone());
        for (let t3 = 0, e3 = c2.length; t3 < e3; t3++) {
          const e4 = c2[t3];
          let o3, a3;
          const u3 = e4.vertexNormals, l3 = e4.vertexColors, h2 = new xi(e4.a + i2, e4.b + i2, e4.c + i2);
          h2.normal.copy(e4.normal), void 0 !== r2 && h2.normal.applyMatrix3(r2).normalize();
          for (let t4 = 0, e5 = u3.length; t4 < e5; t4++) o3 = u3[t4].clone(), void 0 !== r2 && o3.applyMatrix3(r2).normalize(), h2.vertexNormals.push(o3);
          h2.color.copy(e4.color);
          for (let t4 = 0, e5 = l3.length; t4 < e5; t4++) a3 = l3[t4], h2.vertexColors.push(a3.clone());
          h2.materialIndex = e4.materialIndex + n2, s2.push(h2);
        }
        for (let e3 = 0, n3 = t2.faceVertexUvs.length; e3 < n3; e3++) {
          const n4 = t2.faceVertexUvs[e3];
          void 0 === this.faceVertexUvs[e3] && (this.faceVertexUvs[e3] = []);
          for (let t3 = 0, r3 = n4.length; t3 < r3; t3++) {
            const r4 = n4[t3], i3 = [];
            for (let t4 = 0, e4 = r4.length; t4 < e4; t4++) i3.push(r4[t4].clone());
            this.faceVertexUvs[e3].push(i3);
          }
        }
      }, mergeMesh: function(t2) {
        t2 && t2.isMesh ? (t2.matrixAutoUpdate && t2.updateMatrix(), this.merge(t2.geometry, t2.matrix)) : console.error("THREE.Geometry.mergeMesh(): mesh not an instance of THREE.Mesh.", t2);
      }, mergeVertices: function(t2 = 4) {
        const e2 = {}, n2 = [], r2 = [], i2 = Math.pow(10, t2);
        for (let t3 = 0, o3 = this.vertices.length; t3 < o3; t3++) {
          const o4 = this.vertices[t3], a3 = Math.round(o4.x * i2) + "_" + Math.round(o4.y * i2) + "_" + Math.round(o4.z * i2);
          void 0 === e2[a3] ? (e2[a3] = t3, n2.push(this.vertices[t3]), r2[t3] = n2.length - 1) : r2[t3] = r2[e2[a3]];
        }
        const o2 = [];
        for (let t3 = 0, e3 = this.faces.length; t3 < e3; t3++) {
          const e4 = this.faces[t3];
          e4.a = r2[e4.a], e4.b = r2[e4.b], e4.c = r2[e4.c];
          const n3 = [e4.a, e4.b, e4.c];
          for (let e5 = 0; e5 < 3; e5++) if (n3[e5] === n3[(e5 + 1) % 3]) {
            o2.push(t3);
            break;
          }
        }
        for (let t3 = o2.length - 1; t3 >= 0; t3--) {
          const e3 = o2[t3];
          this.faces.splice(e3, 1);
          for (let t4 = 0, n3 = this.faceVertexUvs.length; t4 < n3; t4++) this.faceVertexUvs[t4].splice(e3, 1);
        }
        const a2 = this.vertices.length - n2.length;
        return this.vertices = n2, a2;
      }, setFromPoints: function(t2) {
        this.vertices = [];
        for (let e2 = 0, n2 = t2.length; e2 < n2; e2++) {
          const n3 = t2[e2];
          this.vertices.push(new $n(n3.x, n3.y, n3.z || 0));
        }
        return this;
      }, sortFacesByMaterialIndex: function() {
        const t2 = this.faces, e2 = t2.length;
        for (let n3 = 0; n3 < e2; n3++) t2[n3]._id = n3;
        t2.sort(function(t3, e3) {
          return t3.materialIndex - e3.materialIndex;
        });
        const n2 = this.faceVertexUvs[0], r2 = this.faceVertexUvs[1];
        let i2, o2;
        n2 && n2.length === e2 && (i2 = []), r2 && r2.length === e2 && (o2 = []);
        for (let a2 = 0; a2 < e2; a2++) {
          const e3 = t2[a2]._id;
          i2 && i2.push(n2[e3]), o2 && o2.push(r2[e3]);
        }
        i2 && (this.faceVertexUvs[0] = i2), o2 && (this.faceVertexUvs[1] = o2);
      }, toJSON: function() {
        const t2 = { metadata: { version: 4.5, type: "Geometry", generator: "Geometry.toJSON" } };
        if (t2.uuid = this.uuid, t2.type = this.type, "" !== this.name && (t2.name = this.name), void 0 !== this.parameters) {
          const e3 = this.parameters;
          for (const n3 in e3) void 0 !== e3[n3] && (t2[n3] = e3[n3]);
          return t2;
        }
        const e2 = [];
        for (let t3 = 0; t3 < this.vertices.length; t3++) {
          const n3 = this.vertices[t3];
          e2.push(n3.x, n3.y, n3.z);
        }
        const n2 = [], r2 = [], i2 = {}, o2 = [], a2 = {}, s2 = [], c2 = {};
        for (let t3 = 0; t3 < this.faces.length; t3++) {
          const e3 = this.faces[t3], r3 = true, i3 = false, o3 = void 0 !== this.faceVertexUvs[0][t3], a3 = e3.normal.length() > 0, s3 = e3.vertexNormals.length > 0, c3 = 1 !== e3.color.r || 1 !== e3.color.g || 1 !== e3.color.b, p2 = e3.vertexColors.length > 0;
          let f2 = 0;
          if (f2 = u2(f2, 0, 0), f2 = u2(f2, 1, r3), f2 = u2(f2, 2, i3), f2 = u2(f2, 3, o3), f2 = u2(f2, 4, a3), f2 = u2(f2, 5, s3), f2 = u2(f2, 6, c3), f2 = u2(f2, 7, p2), n2.push(f2), n2.push(e3.a, e3.b, e3.c), n2.push(e3.materialIndex), o3) {
            const e4 = this.faceVertexUvs[0][t3];
            n2.push(d2(e4[0]), d2(e4[1]), d2(e4[2]));
          }
          if (a3 && n2.push(l2(e3.normal)), s3) {
            const t4 = e3.vertexNormals;
            n2.push(l2(t4[0]), l2(t4[1]), l2(t4[2]));
          }
          if (c3 && n2.push(h2(e3.color)), p2) {
            const t4 = e3.vertexColors;
            n2.push(h2(t4[0]), h2(t4[1]), h2(t4[2]));
          }
        }
        function u2(t3, e3, n3) {
          return n3 ? t3 | 1 << e3 : t3 & ~(1 << e3);
        }
        function l2(t3) {
          const e3 = t3.x.toString() + t3.y.toString() + t3.z.toString();
          return void 0 !== i2[e3] || (i2[e3] = r2.length / 3, r2.push(t3.x, t3.y, t3.z)), i2[e3];
        }
        function h2(t3) {
          const e3 = t3.r.toString() + t3.g.toString() + t3.b.toString();
          return void 0 !== a2[e3] || (a2[e3] = o2.length, o2.push(t3.getHex())), a2[e3];
        }
        function d2(t3) {
          const e3 = t3.x.toString() + t3.y.toString();
          return void 0 !== c2[e3] || (c2[e3] = s2.length / 2, s2.push(t3.x, t3.y)), c2[e3];
        }
        return t2.data = {}, t2.data.vertices = e2, t2.data.normals = r2, o2.length > 0 && (t2.data.colors = o2), s2.length > 0 && (t2.data.uvs = [s2]), t2.data.faces = n2, t2;
      }, clone: function() {
        return new Zc().copy(this);
      }, copy: function(t2) {
        this.vertices = [], this.colors = [], this.faces = [], this.faceVertexUvs = [[]], this.morphTargets = [], this.morphNormals = [], this.skinWeights = [], this.skinIndices = [], this.lineDistances = [], this.boundingBox = null, this.boundingSphere = null, this.name = t2.name;
        const e2 = t2.vertices;
        for (let t3 = 0, n3 = e2.length; t3 < n3; t3++) this.vertices.push(e2[t3].clone());
        const n2 = t2.colors;
        for (let t3 = 0, e3 = n2.length; t3 < e3; t3++) this.colors.push(n2[t3].clone());
        const r2 = t2.faces;
        for (let t3 = 0, e3 = r2.length; t3 < e3; t3++) this.faces.push(r2[t3].clone());
        for (let e3 = 0, n3 = t2.faceVertexUvs.length; e3 < n3; e3++) {
          const n4 = t2.faceVertexUvs[e3];
          void 0 === this.faceVertexUvs[e3] && (this.faceVertexUvs[e3] = []);
          for (let t3 = 0, r3 = n4.length; t3 < r3; t3++) {
            const r4 = n4[t3], i3 = [];
            for (let t4 = 0, e4 = r4.length; t4 < e4; t4++) {
              const e5 = r4[t4];
              i3.push(e5.clone());
            }
            this.faceVertexUvs[e3].push(i3);
          }
        }
        const i2 = t2.morphTargets;
        for (let t3 = 0, e3 = i2.length; t3 < e3; t3++) {
          const e4 = {};
          if (e4.name = i2[t3].name, void 0 !== i2[t3].vertices) {
            e4.vertices = [];
            for (let n3 = 0, r3 = i2[t3].vertices.length; n3 < r3; n3++) e4.vertices.push(i2[t3].vertices[n3].clone());
          }
          if (void 0 !== i2[t3].normals) {
            e4.normals = [];
            for (let n3 = 0, r3 = i2[t3].normals.length; n3 < r3; n3++) e4.normals.push(i2[t3].normals[n3].clone());
          }
          this.morphTargets.push(e4);
        }
        const o2 = t2.morphNormals;
        for (let t3 = 0, e3 = o2.length; t3 < e3; t3++) {
          const e4 = {};
          if (void 0 !== o2[t3].vertexNormals) {
            e4.vertexNormals = [];
            for (let n3 = 0, r3 = o2[t3].vertexNormals.length; n3 < r3; n3++) {
              const r4 = o2[t3].vertexNormals[n3], i3 = {};
              i3.a = r4.a.clone(), i3.b = r4.b.clone(), i3.c = r4.c.clone(), e4.vertexNormals.push(i3);
            }
          }
          if (void 0 !== o2[t3].faceNormals) {
            e4.faceNormals = [];
            for (let n3 = 0, r3 = o2[t3].faceNormals.length; n3 < r3; n3++) e4.faceNormals.push(o2[t3].faceNormals[n3].clone());
          }
          this.morphNormals.push(e4);
        }
        const a2 = t2.skinWeights;
        for (let t3 = 0, e3 = a2.length; t3 < e3; t3++) this.skinWeights.push(a2[t3].clone());
        const s2 = t2.skinIndices;
        for (let t3 = 0, e3 = s2.length; t3 < e3; t3++) this.skinIndices.push(s2[t3].clone());
        const c2 = t2.lineDistances;
        for (let t3 = 0, e3 = c2.length; t3 < e3; t3++) this.lineDistances.push(c2[t3]);
        const u2 = t2.boundingBox;
        null !== u2 && (this.boundingBox = u2.clone());
        const l2 = t2.boundingSphere;
        return null !== l2 && (this.boundingSphere = l2.clone()), this.elementsNeedUpdate = t2.elementsNeedUpdate, this.verticesNeedUpdate = t2.verticesNeedUpdate, this.uvsNeedUpdate = t2.uvsNeedUpdate, this.normalsNeedUpdate = t2.normalsNeedUpdate, this.colorsNeedUpdate = t2.colorsNeedUpdate, this.lineDistancesNeedUpdate = t2.lineDistancesNeedUpdate, this.groupsNeedUpdate = t2.groupsNeedUpdate, this;
      }, dispose: function() {
        this.dispatchEvent({ type: "dispose" });
      } });
      class Jc extends Zc {
        constructor(t2, e2, n2, r2, i2, o2) {
          super(), this.type = "BoxGeometry", this.parameters = { width: t2, height: e2, depth: n2, widthSegments: r2, heightSegments: i2, depthSegments: o2 }, this.fromBufferGeometry(new mo(t2, e2, n2, r2, i2, o2)), this.mergeVertices();
        }
      }
      class $c extends Xi {
        constructor(t2 = 1, e2 = 8, n2 = 0, r2 = 2 * Math.PI) {
          super(), this.type = "CircleBufferGeometry", this.parameters = { radius: t2, segments: e2, thetaStart: n2, thetaLength: r2 }, e2 = Math.max(3, e2);
          const i2 = [], o2 = [], a2 = [], s2 = [], c2 = new $n(), u2 = new Hn();
          o2.push(0, 0, 0), a2.push(0, 0, 1), s2.push(0.5, 0.5);
          for (let i3 = 0, l2 = 3; i3 <= e2; i3++, l2 += 3) {
            const h2 = n2 + i3 / e2 * r2;
            c2.x = t2 * Math.cos(h2), c2.y = t2 * Math.sin(h2), o2.push(c2.x, c2.y, c2.z), a2.push(0, 0, 1), u2.x = (o2[l2] / t2 + 1) / 2, u2.y = (o2[l2 + 1] / t2 + 1) / 2, s2.push(u2.x, u2.y);
          }
          for (let t3 = 1; t3 <= e2; t3++) i2.push(t3, t3 + 1, 0);
          this.setIndex(i2), this.setAttribute("position", new Ii(o2, 3)), this.setAttribute("normal", new Ii(a2, 3)), this.setAttribute("uv", new Ii(s2, 2));
        }
      }
      class Qc extends Zc {
        constructor(t2, e2, n2, r2) {
          super(), this.type = "CircleGeometry", this.parameters = { radius: t2, segments: e2, thetaStart: n2, thetaLength: r2 }, this.fromBufferGeometry(new $c(t2, e2, n2, r2)), this.mergeVertices();
        }
      }
      class Kc extends Xi {
        constructor(t2 = 1, e2 = 1, n2 = 1, r2 = 8, i2 = 1, o2 = false, a2 = 0, s2 = 2 * Math.PI) {
          super(), this.type = "CylinderBufferGeometry", this.parameters = { radiusTop: t2, radiusBottom: e2, height: n2, radialSegments: r2, heightSegments: i2, openEnded: o2, thetaStart: a2, thetaLength: s2 };
          const c2 = this;
          r2 = Math.floor(r2), i2 = Math.floor(i2);
          const u2 = [], l2 = [], h2 = [], d2 = [];
          let p2 = 0;
          const f2 = [], m2 = n2 / 2;
          let g2 = 0;
          function v2(n3) {
            const i3 = p2, o3 = new Hn(), f3 = new $n();
            let v3 = 0;
            const y2 = true === n3 ? t2 : e2, x2 = true === n3 ? 1 : -1;
            for (let t3 = 1; t3 <= r2; t3++) l2.push(0, m2 * x2, 0), h2.push(0, x2, 0), d2.push(0.5, 0.5), p2++;
            const b2 = p2;
            for (let t3 = 0; t3 <= r2; t3++) {
              const e3 = t3 / r2 * s2 + a2, n4 = Math.cos(e3), i4 = Math.sin(e3);
              f3.x = y2 * i4, f3.y = m2 * x2, f3.z = y2 * n4, l2.push(f3.x, f3.y, f3.z), h2.push(0, x2, 0), o3.x = 0.5 * n4 + 0.5, o3.y = 0.5 * i4 * x2 + 0.5, d2.push(o3.x, o3.y), p2++;
            }
            for (let t3 = 0; t3 < r2; t3++) {
              const e3 = i3 + t3, r3 = b2 + t3;
              true === n3 ? u2.push(r3, r3 + 1, e3) : u2.push(r3 + 1, r3, e3), v3 += 3;
            }
            c2.addGroup(g2, v3, true === n3 ? 1 : 2), g2 += v3;
          }
          !function() {
            const o3 = new $n(), v3 = new $n();
            let y2 = 0;
            const x2 = (e2 - t2) / n2;
            for (let c3 = 0; c3 <= i2; c3++) {
              const u3 = [], g3 = c3 / i2, y3 = g3 * (e2 - t2) + t2;
              for (let t3 = 0; t3 <= r2; t3++) {
                const e3 = t3 / r2, i3 = e3 * s2 + a2, c4 = Math.sin(i3), f3 = Math.cos(i3);
                v3.x = y3 * c4, v3.y = -g3 * n2 + m2, v3.z = y3 * f3, l2.push(v3.x, v3.y, v3.z), o3.set(c4, x2, f3).normalize(), h2.push(o3.x, o3.y, o3.z), d2.push(e3, 1 - g3), u3.push(p2++);
              }
              f2.push(u3);
            }
            for (let t3 = 0; t3 < r2; t3++) for (let e3 = 0; e3 < i2; e3++) {
              const n3 = f2[e3][t3], r3 = f2[e3 + 1][t3], i3 = f2[e3 + 1][t3 + 1], o4 = f2[e3][t3 + 1];
              u2.push(n3, r3, o4), u2.push(r3, i3, o4), y2 += 6;
            }
            c2.addGroup(g2, y2, 0), g2 += y2;
          }(), false === o2 && (t2 > 0 && v2(true), e2 > 0 && v2(false)), this.setIndex(u2), this.setAttribute("position", new Ii(l2, 3)), this.setAttribute("normal", new Ii(h2, 3)), this.setAttribute("uv", new Ii(d2, 2));
        }
      }
      class tu extends Zc {
        constructor(t2, e2, n2, r2, i2, o2, a2, s2) {
          super(), this.type = "CylinderGeometry", this.parameters = { radiusTop: t2, radiusBottom: e2, height: n2, radialSegments: r2, heightSegments: i2, openEnded: o2, thetaStart: a2, thetaLength: s2 }, this.fromBufferGeometry(new Kc(t2, e2, n2, r2, i2, o2, a2, s2)), this.mergeVertices();
        }
      }
      class eu extends tu {
        constructor(t2, e2, n2, r2, i2, o2, a2) {
          super(0, t2, e2, n2, r2, i2, o2, a2), this.type = "ConeGeometry", this.parameters = { radius: t2, height: e2, radialSegments: n2, heightSegments: r2, openEnded: i2, thetaStart: o2, thetaLength: a2 };
        }
      }
      class nu extends Kc {
        constructor(t2 = 1, e2 = 1, n2 = 8, r2 = 1, i2 = false, o2 = 0, a2 = 2 * Math.PI) {
          super(0, t2, e2, n2, r2, i2, o2, a2), this.type = "ConeBufferGeometry", this.parameters = { radius: t2, height: e2, radialSegments: n2, heightSegments: r2, openEnded: i2, thetaStart: o2, thetaLength: a2 };
        }
      }
      class ru extends Xi {
        constructor(t2, e2, n2 = 1, r2 = 0) {
          super(), this.type = "PolyhedronBufferGeometry", this.parameters = { vertices: t2, indices: e2, radius: n2, detail: r2 };
          const i2 = [], o2 = [];
          function a2(t3, e3, n3, r3) {
            const i3 = r3 + 1, o3 = [];
            for (let r4 = 0; r4 <= i3; r4++) {
              o3[r4] = [];
              const a3 = t3.clone().lerp(n3, r4 / i3), s3 = e3.clone().lerp(n3, r4 / i3), c3 = i3 - r4;
              for (let t4 = 0; t4 <= c3; t4++) o3[r4][t4] = 0 === t4 && r4 === i3 ? a3 : a3.clone().lerp(s3, t4 / c3);
            }
            for (let t4 = 0; t4 < i3; t4++) for (let e4 = 0; e4 < 2 * (i3 - t4) - 1; e4++) {
              const n4 = Math.floor(e4 / 2);
              e4 % 2 == 0 ? (s2(o3[t4][n4 + 1]), s2(o3[t4 + 1][n4]), s2(o3[t4][n4])) : (s2(o3[t4][n4 + 1]), s2(o3[t4 + 1][n4 + 1]), s2(o3[t4 + 1][n4]));
            }
          }
          function s2(t3) {
            i2.push(t3.x, t3.y, t3.z);
          }
          function c2(e3, n3) {
            const r3 = 3 * e3;
            n3.x = t2[r3 + 0], n3.y = t2[r3 + 1], n3.z = t2[r3 + 2];
          }
          function u2(t3, e3, n3, r3) {
            r3 < 0 && 1 === t3.x && (o2[e3] = t3.x - 1), 0 === n3.x && 0 === n3.z && (o2[e3] = r3 / 2 / Math.PI + 0.5);
          }
          function l2(t3) {
            return Math.atan2(t3.z, -t3.x);
          }
          !function(t3) {
            const n3 = new $n(), r3 = new $n(), i3 = new $n();
            for (let o3 = 0; o3 < e2.length; o3 += 3) c2(e2[o3 + 0], n3), c2(e2[o3 + 1], r3), c2(e2[o3 + 2], i3), a2(n3, r3, i3, t3);
          }(r2), function(t3) {
            const e3 = new $n();
            for (let n3 = 0; n3 < i2.length; n3 += 3) e3.x = i2[n3 + 0], e3.y = i2[n3 + 1], e3.z = i2[n3 + 2], e3.normalize().multiplyScalar(t3), i2[n3 + 0] = e3.x, i2[n3 + 1] = e3.y, i2[n3 + 2] = e3.z;
          }(n2), function() {
            const t3 = new $n();
            for (let n3 = 0; n3 < i2.length; n3 += 3) {
              t3.x = i2[n3 + 0], t3.y = i2[n3 + 1], t3.z = i2[n3 + 2];
              const r3 = l2(t3) / 2 / Math.PI + 0.5, a3 = (e3 = t3, Math.atan2(-e3.y, Math.sqrt(e3.x * e3.x + e3.z * e3.z)) / Math.PI + 0.5);
              o2.push(r3, 1 - a3);
            }
            var e3;
            (function() {
              const t4 = new $n(), e4 = new $n(), n3 = new $n(), r3 = new $n(), a3 = new Hn(), s3 = new Hn(), c3 = new Hn();
              for (let h2 = 0, d2 = 0; h2 < i2.length; h2 += 9, d2 += 6) {
                t4.set(i2[h2 + 0], i2[h2 + 1], i2[h2 + 2]), e4.set(i2[h2 + 3], i2[h2 + 4], i2[h2 + 5]), n3.set(i2[h2 + 6], i2[h2 + 7], i2[h2 + 8]), a3.set(o2[d2 + 0], o2[d2 + 1]), s3.set(o2[d2 + 2], o2[d2 + 3]), c3.set(o2[d2 + 4], o2[d2 + 5]), r3.copy(t4).add(e4).add(n3).divideScalar(3);
                const p2 = l2(r3);
                u2(a3, d2 + 0, t4, p2), u2(s3, d2 + 2, e4, p2), u2(c3, d2 + 4, n3, p2);
              }
            })(), function() {
              for (let t4 = 0; t4 < o2.length; t4 += 6) {
                const e4 = o2[t4 + 0], n3 = o2[t4 + 2], r3 = o2[t4 + 4], i3 = Math.max(e4, n3, r3), a3 = Math.min(e4, n3, r3);
                i3 > 0.9 && a3 < 0.1 && (e4 < 0.2 && (o2[t4 + 0] += 1), n3 < 0.2 && (o2[t4 + 2] += 1), r3 < 0.2 && (o2[t4 + 4] += 1));
              }
            }();
          }(), this.setAttribute("position", new Ii(i2, 3)), this.setAttribute("normal", new Ii(i2.slice(), 3)), this.setAttribute("uv", new Ii(o2, 2)), 0 === r2 ? this.computeVertexNormals() : this.normalizeNormals();
        }
      }
      class iu extends ru {
        constructor(t2 = 1, e2 = 0) {
          const n2 = (1 + Math.sqrt(5)) / 2, r2 = 1 / n2;
          super([-1, -1, -1, -1, -1, 1, -1, 1, -1, -1, 1, 1, 1, -1, -1, 1, -1, 1, 1, 1, -1, 1, 1, 1, 0, -r2, -n2, 0, -r2, n2, 0, r2, -n2, 0, r2, n2, -r2, -n2, 0, -r2, n2, 0, r2, -n2, 0, r2, n2, 0, -n2, 0, -r2, n2, 0, -r2, -n2, 0, r2, n2, 0, r2], [3, 11, 7, 3, 7, 15, 3, 15, 13, 7, 19, 17, 7, 17, 6, 7, 6, 15, 17, 4, 8, 17, 8, 10, 17, 10, 6, 8, 0, 16, 8, 16, 2, 8, 2, 10, 0, 12, 1, 0, 1, 18, 0, 18, 16, 6, 10, 2, 6, 2, 13, 6, 13, 15, 2, 16, 18, 2, 18, 3, 2, 3, 13, 18, 1, 9, 18, 9, 11, 18, 11, 3, 4, 14, 12, 4, 12, 0, 4, 0, 8, 11, 9, 5, 11, 5, 19, 11, 19, 7, 19, 5, 14, 19, 14, 4, 19, 4, 17, 1, 12, 14, 1, 14, 5, 1, 5, 9], t2, e2), this.type = "DodecahedronBufferGeometry", this.parameters = { radius: t2, detail: e2 };
        }
      }
      class ou extends Zc {
        constructor(t2, e2) {
          super(), this.type = "DodecahedronGeometry", this.parameters = { radius: t2, detail: e2 }, this.fromBufferGeometry(new iu(t2, e2)), this.mergeVertices();
        }
      }
      const au = new $n(), su = new $n(), cu = new $n(), uu = new hi();
      class lu extends Xi {
        constructor(t2, e2) {
          super(), this.type = "EdgesGeometry", this.parameters = { thresholdAngle: e2 }, e2 = void 0 !== e2 ? e2 : 1, t2.isGeometry && (t2 = new Xi().fromGeometry(t2));
          const n2 = Math.pow(10, 4), r2 = Math.cos(Bn.DEG2RAD * e2), i2 = t2.getIndex(), o2 = t2.getAttribute("position"), a2 = i2 ? i2.count : o2.count, s2 = [0, 0, 0], c2 = ["a", "b", "c"], u2 = new Array(3), l2 = {}, h2 = [];
          for (let t3 = 0; t3 < a2; t3 += 3) {
            i2 ? (s2[0] = i2.getX(t3), s2[1] = i2.getX(t3 + 1), s2[2] = i2.getX(t3 + 2)) : (s2[0] = t3, s2[1] = t3 + 1, s2[2] = t3 + 2);
            const { a: e3, b: a3, c: d2 } = uu;
            if (e3.fromBufferAttribute(o2, s2[0]), a3.fromBufferAttribute(o2, s2[1]), d2.fromBufferAttribute(o2, s2[2]), uu.getNormal(cu), u2[0] = `${Math.round(e3.x * n2)},${Math.round(e3.y * n2)},${Math.round(e3.z * n2)}`, u2[1] = `${Math.round(a3.x * n2)},${Math.round(a3.y * n2)},${Math.round(a3.z * n2)}`, u2[2] = `${Math.round(d2.x * n2)},${Math.round(d2.y * n2)},${Math.round(d2.z * n2)}`, u2[0] !== u2[1] && u2[1] !== u2[2] && u2[2] !== u2[0]) for (let t4 = 0; t4 < 3; t4++) {
              const e4 = (t4 + 1) % 3, n3 = u2[t4], i3 = u2[e4], o3 = uu[c2[t4]], a4 = uu[c2[e4]], d3 = `${n3}_${i3}`, p2 = `${i3}_${n3}`;
              p2 in l2 && l2[p2] ? (cu.dot(l2[p2].normal) <= r2 && (h2.push(o3.x, o3.y, o3.z), h2.push(a4.x, a4.y, a4.z)), l2[p2] = null) : d3 in l2 || (l2[d3] = { index0: s2[t4], index1: s2[e4], normal: cu.clone() });
            }
          }
          for (const t3 in l2) if (l2[t3]) {
            const { index0: e3, index1: n3 } = l2[t3];
            au.fromBufferAttribute(o2, e3), su.fromBufferAttribute(o2, n3), h2.push(au.x, au.y, au.z), h2.push(su.x, su.y, su.z);
          }
          this.setAttribute("position", new Ii(h2, 3));
        }
      }
      const hu = function(t2, e2, n2) {
        n2 = n2 || 2;
        const r2 = e2 && e2.length, i2 = r2 ? e2[0] * n2 : t2.length;
        let o2 = du(t2, 0, i2, n2, true);
        const a2 = [];
        if (!o2 || o2.next === o2.prev) return a2;
        let s2, c2, u2, l2, h2, d2, p2;
        if (r2 && (o2 = function(t3, e3, n3, r3) {
          const i3 = [];
          let o3, a3, s3, c3, u3;
          for (o3 = 0, a3 = e3.length; o3 < a3; o3++) s3 = e3[o3] * r3, c3 = o3 < a3 - 1 ? e3[o3 + 1] * r3 : t3.length, u3 = du(t3, s3, c3, r3, false), u3 === u3.next && (u3.steiner = true), i3.push(Mu(u3));
          for (i3.sort(xu), o3 = 0; o3 < i3.length; o3++) bu(i3[o3], n3), n3 = pu(n3, n3.next);
          return n3;
        }(t2, e2, o2, n2)), t2.length > 80 * n2) {
          s2 = u2 = t2[0], c2 = l2 = t2[1];
          for (let e3 = n2; e3 < i2; e3 += n2) h2 = t2[e3], d2 = t2[e3 + 1], h2 < s2 && (s2 = h2), d2 < c2 && (c2 = d2), h2 > u2 && (u2 = h2), d2 > l2 && (l2 = d2);
          p2 = Math.max(u2 - s2, l2 - c2), p2 = 0 !== p2 ? 1 / p2 : 0;
        }
        return fu(o2, a2, n2, s2, c2, p2), a2;
      };
      function du(t2, e2, n2, r2, i2) {
        let o2, a2;
        if (i2 === function(t3, e3, n3, r3) {
          let i3 = 0;
          for (let o3 = e3, a3 = n3 - r3; o3 < n3; o3 += r3) i3 += (t3[a3] - t3[o3]) * (t3[o3 + 1] + t3[a3 + 1]), a3 = o3;
          return i3;
        }(t2, e2, n2, r2) > 0) for (o2 = e2; o2 < n2; o2 += r2) a2 = Du(o2, t2[o2], t2[o2 + 1], a2);
        else for (o2 = n2 - r2; o2 >= e2; o2 -= r2) a2 = Du(o2, t2[o2], t2[o2 + 1], a2);
        return a2 && Au(a2, a2.next) && (Iu(a2), a2 = a2.next), a2;
      }
      function pu(t2, e2) {
        if (!t2) return t2;
        e2 || (e2 = t2);
        let n2, r2 = t2;
        do {
          if (n2 = false, r2.steiner || !Au(r2, r2.next) && 0 !== Eu(r2.prev, r2, r2.next)) r2 = r2.next;
          else {
            if (Iu(r2), r2 = e2 = r2.prev, r2 === r2.next) break;
            n2 = true;
          }
        } while (n2 || r2 !== e2);
        return e2;
      }
      function fu(t2, e2, n2, r2, i2, o2, a2) {
        if (!t2) return;
        !a2 && o2 && function(t3, e3, n3, r3) {
          let i3 = t3;
          do {
            null === i3.z && (i3.z = _u(i3.x, i3.y, e3, n3, r3)), i3.prevZ = i3.prev, i3.nextZ = i3.next, i3 = i3.next;
          } while (i3 !== t3);
          i3.prevZ.nextZ = null, i3.prevZ = null, function(t4) {
            let e4, n4, r4, i4, o3, a3, s3, c3, u3 = 1;
            do {
              for (n4 = t4, t4 = null, o3 = null, a3 = 0; n4; ) {
                for (a3++, r4 = n4, s3 = 0, e4 = 0; e4 < u3 && (s3++, r4 = r4.nextZ, r4); e4++) ;
                for (c3 = u3; s3 > 0 || c3 > 0 && r4; ) 0 !== s3 && (0 === c3 || !r4 || n4.z <= r4.z) ? (i4 = n4, n4 = n4.nextZ, s3--) : (i4 = r4, r4 = r4.nextZ, c3--), o3 ? o3.nextZ = i4 : t4 = i4, i4.prevZ = o3, o3 = i4;
                n4 = r4;
              }
              o3.nextZ = null, u3 *= 2;
            } while (a3 > 1);
          }(i3);
        }(t2, r2, i2, o2);
        let s2, c2, u2 = t2;
        for (; t2.prev !== t2.next; ) if (s2 = t2.prev, c2 = t2.next, o2 ? gu(t2, r2, i2, o2) : mu(t2)) e2.push(s2.i / n2), e2.push(t2.i / n2), e2.push(c2.i / n2), Iu(t2), t2 = c2.next, u2 = c2.next;
        else if ((t2 = c2) === u2) {
          a2 ? 1 === a2 ? fu(t2 = vu(pu(t2), e2, n2), e2, n2, r2, i2, o2, 2) : 2 === a2 && yu(t2, e2, n2, r2, i2, o2) : fu(pu(t2), e2, n2, r2, i2, o2, 1);
          break;
        }
      }
      function mu(t2) {
        const e2 = t2.prev, n2 = t2, r2 = t2.next;
        if (Eu(e2, n2, r2) >= 0) return false;
        let i2 = t2.next.next;
        for (; i2 !== t2.prev; ) {
          if (Su(e2.x, e2.y, n2.x, n2.y, r2.x, r2.y, i2.x, i2.y) && Eu(i2.prev, i2, i2.next) >= 0) return false;
          i2 = i2.next;
        }
        return true;
      }
      function gu(t2, e2, n2, r2) {
        const i2 = t2.prev, o2 = t2, a2 = t2.next;
        if (Eu(i2, o2, a2) >= 0) return false;
        const s2 = i2.x < o2.x ? i2.x < a2.x ? i2.x : a2.x : o2.x < a2.x ? o2.x : a2.x, c2 = i2.y < o2.y ? i2.y < a2.y ? i2.y : a2.y : o2.y < a2.y ? o2.y : a2.y, u2 = i2.x > o2.x ? i2.x > a2.x ? i2.x : a2.x : o2.x > a2.x ? o2.x : a2.x, l2 = i2.y > o2.y ? i2.y > a2.y ? i2.y : a2.y : o2.y > a2.y ? o2.y : a2.y, h2 = _u(s2, c2, e2, n2, r2), d2 = _u(u2, l2, e2, n2, r2);
        let p2 = t2.prevZ, f2 = t2.nextZ;
        for (; p2 && p2.z >= h2 && f2 && f2.z <= d2; ) {
          if (p2 !== t2.prev && p2 !== t2.next && Su(i2.x, i2.y, o2.x, o2.y, a2.x, a2.y, p2.x, p2.y) && Eu(p2.prev, p2, p2.next) >= 0) return false;
          if (p2 = p2.prevZ, f2 !== t2.prev && f2 !== t2.next && Su(i2.x, i2.y, o2.x, o2.y, a2.x, a2.y, f2.x, f2.y) && Eu(f2.prev, f2, f2.next) >= 0) return false;
          f2 = f2.nextZ;
        }
        for (; p2 && p2.z >= h2; ) {
          if (p2 !== t2.prev && p2 !== t2.next && Su(i2.x, i2.y, o2.x, o2.y, a2.x, a2.y, p2.x, p2.y) && Eu(p2.prev, p2, p2.next) >= 0) return false;
          p2 = p2.prevZ;
        }
        for (; f2 && f2.z <= d2; ) {
          if (f2 !== t2.prev && f2 !== t2.next && Su(i2.x, i2.y, o2.x, o2.y, a2.x, a2.y, f2.x, f2.y) && Eu(f2.prev, f2, f2.next) >= 0) return false;
          f2 = f2.nextZ;
        }
        return true;
      }
      function vu(t2, e2, n2) {
        let r2 = t2;
        do {
          const i2 = r2.prev, o2 = r2.next.next;
          !Au(i2, o2) && Cu(i2, r2, r2.next, o2) && Ru(i2, o2) && Ru(o2, i2) && (e2.push(i2.i / n2), e2.push(r2.i / n2), e2.push(o2.i / n2), Iu(r2), Iu(r2.next), r2 = t2 = o2), r2 = r2.next;
        } while (r2 !== t2);
        return pu(r2);
      }
      function yu(t2, e2, n2, r2, i2, o2) {
        let a2 = t2;
        do {
          let t3 = a2.next.next;
          for (; t3 !== a2.prev; ) {
            if (a2.i !== t3.i && Tu(a2, t3)) {
              let s2 = Ou(a2, t3);
              return a2 = pu(a2, a2.next), s2 = pu(s2, s2.next), fu(a2, e2, n2, r2, i2, o2), void fu(s2, e2, n2, r2, i2, o2);
            }
            t3 = t3.next;
          }
          a2 = a2.next;
        } while (a2 !== t2);
      }
      function xu(t2, e2) {
        return t2.x - e2.x;
      }
      function bu(t2, e2) {
        if (e2 = function(t3, e3) {
          let n2 = e3;
          const r2 = t3.x, i2 = t3.y;
          let o2, a2 = -1 / 0;
          do {
            if (i2 <= n2.y && i2 >= n2.next.y && n2.next.y !== n2.y) {
              const t4 = n2.x + (i2 - n2.y) * (n2.next.x - n2.x) / (n2.next.y - n2.y);
              if (t4 <= r2 && t4 > a2) {
                if (a2 = t4, t4 === r2) {
                  if (i2 === n2.y) return n2;
                  if (i2 === n2.next.y) return n2.next;
                }
                o2 = n2.x < n2.next.x ? n2 : n2.next;
              }
            }
            n2 = n2.next;
          } while (n2 !== e3);
          if (!o2) return null;
          if (r2 === a2) return o2;
          const s2 = o2, c2 = o2.x, u2 = o2.y;
          let l2, h2 = 1 / 0;
          n2 = o2;
          do {
            r2 >= n2.x && n2.x >= c2 && r2 !== n2.x && Su(i2 < u2 ? r2 : a2, i2, c2, u2, i2 < u2 ? a2 : r2, i2, n2.x, n2.y) && (l2 = Math.abs(i2 - n2.y) / (r2 - n2.x), Ru(n2, t3) && (l2 < h2 || l2 === h2 && (n2.x > o2.x || n2.x === o2.x && wu(o2, n2))) && (o2 = n2, h2 = l2)), n2 = n2.next;
          } while (n2 !== s2);
          return o2;
        }(t2, e2)) {
          const n2 = Ou(e2, t2);
          pu(e2, e2.next), pu(n2, n2.next);
        }
      }
      function wu(t2, e2) {
        return Eu(t2.prev, t2, e2.prev) < 0 && Eu(e2.next, t2, t2.next) < 0;
      }
      function _u(t2, e2, n2, r2, i2) {
        return (t2 = 1431655765 & ((t2 = 858993459 & ((t2 = 252645135 & ((t2 = 16711935 & ((t2 = 32767 * (t2 - n2) * i2) | t2 << 8)) | t2 << 4)) | t2 << 2)) | t2 << 1)) | (e2 = 1431655765 & ((e2 = 858993459 & ((e2 = 252645135 & ((e2 = 16711935 & ((e2 = 32767 * (e2 - r2) * i2) | e2 << 8)) | e2 << 4)) | e2 << 2)) | e2 << 1)) << 1;
      }
      function Mu(t2) {
        let e2 = t2, n2 = t2;
        do {
          (e2.x < n2.x || e2.x === n2.x && e2.y < n2.y) && (n2 = e2), e2 = e2.next;
        } while (e2 !== t2);
        return n2;
      }
      function Su(t2, e2, n2, r2, i2, o2, a2, s2) {
        return (i2 - a2) * (e2 - s2) - (t2 - a2) * (o2 - s2) >= 0 && (t2 - a2) * (r2 - s2) - (n2 - a2) * (e2 - s2) >= 0 && (n2 - a2) * (o2 - s2) - (i2 - a2) * (r2 - s2) >= 0;
      }
      function Tu(t2, e2) {
        return t2.next.i !== e2.i && t2.prev.i !== e2.i && !function(t3, e3) {
          let n2 = t3;
          do {
            if (n2.i !== t3.i && n2.next.i !== t3.i && n2.i !== e3.i && n2.next.i !== e3.i && Cu(n2, n2.next, t3, e3)) return true;
            n2 = n2.next;
          } while (n2 !== t3);
          return false;
        }(t2, e2) && (Ru(t2, e2) && Ru(e2, t2) && function(t3, e3) {
          let n2 = t3, r2 = false;
          const i2 = (t3.x + e3.x) / 2, o2 = (t3.y + e3.y) / 2;
          do {
            n2.y > o2 != n2.next.y > o2 && n2.next.y !== n2.y && i2 < (n2.next.x - n2.x) * (o2 - n2.y) / (n2.next.y - n2.y) + n2.x && (r2 = !r2), n2 = n2.next;
          } while (n2 !== t3);
          return r2;
        }(t2, e2) && (Eu(t2.prev, t2, e2.prev) || Eu(t2, e2.prev, e2)) || Au(t2, e2) && Eu(t2.prev, t2, t2.next) > 0 && Eu(e2.prev, e2, e2.next) > 0);
      }
      function Eu(t2, e2, n2) {
        return (e2.y - t2.y) * (n2.x - e2.x) - (e2.x - t2.x) * (n2.y - e2.y);
      }
      function Au(t2, e2) {
        return t2.x === e2.x && t2.y === e2.y;
      }
      function Cu(t2, e2, n2, r2) {
        const i2 = Pu(Eu(t2, e2, n2)), o2 = Pu(Eu(t2, e2, r2)), a2 = Pu(Eu(n2, r2, t2)), s2 = Pu(Eu(n2, r2, e2));
        return i2 !== o2 && a2 !== s2 || (!(0 !== i2 || !Lu(t2, n2, e2)) || (!(0 !== o2 || !Lu(t2, r2, e2)) || (!(0 !== a2 || !Lu(n2, t2, r2)) || !(0 !== s2 || !Lu(n2, e2, r2)))));
      }
      function Lu(t2, e2, n2) {
        return e2.x <= Math.max(t2.x, n2.x) && e2.x >= Math.min(t2.x, n2.x) && e2.y <= Math.max(t2.y, n2.y) && e2.y >= Math.min(t2.y, n2.y);
      }
      function Pu(t2) {
        return t2 > 0 ? 1 : t2 < 0 ? -1 : 0;
      }
      function Ru(t2, e2) {
        return Eu(t2.prev, t2, t2.next) < 0 ? Eu(t2, e2, t2.next) >= 0 && Eu(t2, t2.prev, e2) >= 0 : Eu(t2, e2, t2.prev) < 0 || Eu(t2, t2.next, e2) < 0;
      }
      function Ou(t2, e2) {
        const n2 = new Nu(t2.i, t2.x, t2.y), r2 = new Nu(e2.i, e2.x, e2.y), i2 = t2.next, o2 = e2.prev;
        return t2.next = e2, e2.prev = t2, n2.next = i2, i2.prev = n2, r2.next = n2, n2.prev = r2, o2.next = r2, r2.prev = o2, r2;
      }
      function Du(t2, e2, n2, r2) {
        const i2 = new Nu(t2, e2, n2);
        return r2 ? (i2.next = r2.next, i2.prev = r2, r2.next.prev = i2, r2.next = i2) : (i2.prev = i2, i2.next = i2), i2;
      }
      function Iu(t2) {
        t2.next.prev = t2.prev, t2.prev.next = t2.next, t2.prevZ && (t2.prevZ.nextZ = t2.nextZ), t2.nextZ && (t2.nextZ.prevZ = t2.prevZ);
      }
      function Nu(t2, e2, n2) {
        this.i = t2, this.x = e2, this.y = n2, this.prev = null, this.next = null, this.z = null, this.prevZ = null, this.nextZ = null, this.steiner = false;
      }
      const zu = { area: function(t2) {
        const e2 = t2.length;
        let n2 = 0;
        for (let r2 = e2 - 1, i2 = 0; i2 < e2; r2 = i2++) n2 += t2[r2].x * t2[i2].y - t2[i2].x * t2[r2].y;
        return 0.5 * n2;
      }, isClockWise: function(t2) {
        return zu.area(t2) < 0;
      }, triangulateShape: function(t2, e2) {
        const n2 = [], r2 = [], i2 = [];
        ku(t2), Fu(n2, t2);
        let o2 = t2.length;
        e2.forEach(ku);
        for (let t3 = 0; t3 < e2.length; t3++) r2.push(o2), o2 += e2[t3].length, Fu(n2, e2[t3]);
        const a2 = hu(n2, r2);
        for (let t3 = 0; t3 < a2.length; t3 += 3) i2.push(a2.slice(t3, t3 + 3));
        return i2;
      } };
      function ku(t2) {
        const e2 = t2.length;
        e2 > 2 && t2[e2 - 1].equals(t2[0]) && t2.pop();
      }
      function Fu(t2, e2) {
        for (let n2 = 0; n2 < e2.length; n2++) t2.push(e2[n2].x), t2.push(e2[n2].y);
      }
      class Bu extends Xi {
        constructor(t2, e2) {
          super(), this.type = "ExtrudeBufferGeometry", this.parameters = { shapes: t2, options: e2 }, t2 = Array.isArray(t2) ? t2 : [t2];
          const n2 = this, r2 = [], i2 = [];
          for (let e3 = 0, n3 = t2.length; e3 < n3; e3++) {
            o2(t2[e3]);
          }
          function o2(t3) {
            const o3 = [], a2 = void 0 !== e2.curveSegments ? e2.curveSegments : 12, s2 = void 0 !== e2.steps ? e2.steps : 1;
            let c2 = void 0 !== e2.depth ? e2.depth : 100, u2 = void 0 === e2.bevelEnabled || e2.bevelEnabled, l2 = void 0 !== e2.bevelThickness ? e2.bevelThickness : 6, h2 = void 0 !== e2.bevelSize ? e2.bevelSize : l2 - 2, d2 = void 0 !== e2.bevelOffset ? e2.bevelOffset : 0, p2 = void 0 !== e2.bevelSegments ? e2.bevelSegments : 3;
            const f2 = e2.extrudePath, m2 = void 0 !== e2.UVGenerator ? e2.UVGenerator : Hu;
            void 0 !== e2.amount && (console.warn("THREE.ExtrudeBufferGeometry: amount has been renamed to depth."), c2 = e2.amount);
            let g2, v2, y2, x2, b2, w2 = false;
            f2 && (g2 = f2.getSpacedPoints(s2), w2 = true, u2 = false, v2 = f2.computeFrenetFrames(s2, false), y2 = new $n(), x2 = new $n(), b2 = new $n()), u2 || (p2 = 0, l2 = 0, h2 = 0, d2 = 0);
            const _2 = t3.extractPoints(a2);
            let M2 = _2.shape;
            const S2 = _2.holes;
            if (!zu.isClockWise(M2)) {
              M2 = M2.reverse();
              for (let t4 = 0, e3 = S2.length; t4 < e3; t4++) {
                const e4 = S2[t4];
                zu.isClockWise(e4) && (S2[t4] = e4.reverse());
              }
            }
            const T2 = zu.triangulateShape(M2, S2), E2 = M2;
            for (let t4 = 0, e3 = S2.length; t4 < e3; t4++) {
              const e4 = S2[t4];
              M2 = M2.concat(e4);
            }
            function A2(t4, e3, n3) {
              return e3 || console.error("THREE.ExtrudeGeometry: vec does not exist"), e3.clone().multiplyScalar(n3).add(t4);
            }
            const C2 = M2.length, L2 = T2.length;
            function P2(t4, e3, n3) {
              let r3, i3, o4;
              const a3 = t4.x - e3.x, s3 = t4.y - e3.y, c3 = n3.x - t4.x, u3 = n3.y - t4.y, l3 = a3 * a3 + s3 * s3, h3 = a3 * u3 - s3 * c3;
              if (Math.abs(h3) > Number.EPSILON) {
                const h4 = Math.sqrt(l3), d3 = Math.sqrt(c3 * c3 + u3 * u3), p3 = e3.x - s3 / h4, f3 = e3.y + a3 / h4, m3 = ((n3.x - u3 / d3 - p3) * u3 - (n3.y + c3 / d3 - f3) * c3) / (a3 * u3 - s3 * c3);
                r3 = p3 + a3 * m3 - t4.x, i3 = f3 + s3 * m3 - t4.y;
                const g3 = r3 * r3 + i3 * i3;
                if (g3 <= 2) return new Hn(r3, i3);
                o4 = Math.sqrt(g3 / 2);
              } else {
                let t5 = false;
                a3 > Number.EPSILON ? c3 > Number.EPSILON && (t5 = true) : a3 < -Number.EPSILON ? c3 < -Number.EPSILON && (t5 = true) : Math.sign(s3) === Math.sign(u3) && (t5 = true), t5 ? (r3 = -s3, i3 = a3, o4 = Math.sqrt(l3)) : (r3 = a3, i3 = s3, o4 = Math.sqrt(l3 / 2));
              }
              return new Hn(r3 / o4, i3 / o4);
            }
            const R2 = [];
            for (let t4 = 0, e3 = E2.length, n3 = e3 - 1, r3 = t4 + 1; t4 < e3; t4++, n3++, r3++) n3 === e3 && (n3 = 0), r3 === e3 && (r3 = 0), R2[t4] = P2(E2[t4], E2[n3], E2[r3]);
            const O2 = [];
            let D2, I2 = R2.concat();
            for (let t4 = 0, e3 = S2.length; t4 < e3; t4++) {
              const e4 = S2[t4];
              D2 = [];
              for (let t5 = 0, n3 = e4.length, r3 = n3 - 1, i3 = t5 + 1; t5 < n3; t5++, r3++, i3++) r3 === n3 && (r3 = 0), i3 === n3 && (i3 = 0), D2[t5] = P2(e4[t5], e4[r3], e4[i3]);
              O2.push(D2), I2 = I2.concat(D2);
            }
            for (let t4 = 0; t4 < p2; t4++) {
              const e3 = t4 / p2, n3 = l2 * Math.cos(e3 * Math.PI / 2), r3 = h2 * Math.sin(e3 * Math.PI / 2) + d2;
              for (let t5 = 0, e4 = E2.length; t5 < e4; t5++) {
                const e5 = A2(E2[t5], R2[t5], r3);
                k2(e5.x, e5.y, -n3);
              }
              for (let t5 = 0, e4 = S2.length; t5 < e4; t5++) {
                const e5 = S2[t5];
                D2 = O2[t5];
                for (let t6 = 0, i3 = e5.length; t6 < i3; t6++) {
                  const i4 = A2(e5[t6], D2[t6], r3);
                  k2(i4.x, i4.y, -n3);
                }
              }
            }
            const N2 = h2 + d2;
            for (let t4 = 0; t4 < C2; t4++) {
              const e3 = u2 ? A2(M2[t4], I2[t4], N2) : M2[t4];
              w2 ? (x2.copy(v2.normals[0]).multiplyScalar(e3.x), y2.copy(v2.binormals[0]).multiplyScalar(e3.y), b2.copy(g2[0]).add(x2).add(y2), k2(b2.x, b2.y, b2.z)) : k2(e3.x, e3.y, 0);
            }
            for (let t4 = 1; t4 <= s2; t4++) for (let e3 = 0; e3 < C2; e3++) {
              const n3 = u2 ? A2(M2[e3], I2[e3], N2) : M2[e3];
              w2 ? (x2.copy(v2.normals[t4]).multiplyScalar(n3.x), y2.copy(v2.binormals[t4]).multiplyScalar(n3.y), b2.copy(g2[t4]).add(x2).add(y2), k2(b2.x, b2.y, b2.z)) : k2(n3.x, n3.y, c2 / s2 * t4);
            }
            for (let t4 = p2 - 1; t4 >= 0; t4--) {
              const e3 = t4 / p2, n3 = l2 * Math.cos(e3 * Math.PI / 2), r3 = h2 * Math.sin(e3 * Math.PI / 2) + d2;
              for (let t5 = 0, e4 = E2.length; t5 < e4; t5++) {
                const e5 = A2(E2[t5], R2[t5], r3);
                k2(e5.x, e5.y, c2 + n3);
              }
              for (let t5 = 0, e4 = S2.length; t5 < e4; t5++) {
                const e5 = S2[t5];
                D2 = O2[t5];
                for (let t6 = 0, i3 = e5.length; t6 < i3; t6++) {
                  const i4 = A2(e5[t6], D2[t6], r3);
                  w2 ? k2(i4.x, i4.y + g2[s2 - 1].y, g2[s2 - 1].x + n3) : k2(i4.x, i4.y, c2 + n3);
                }
              }
            }
            function z2(t4, e3) {
              let n3 = t4.length;
              for (; --n3 >= 0; ) {
                const r3 = n3;
                let i3 = n3 - 1;
                i3 < 0 && (i3 = t4.length - 1);
                for (let t5 = 0, n4 = s2 + 2 * p2; t5 < n4; t5++) {
                  const n5 = C2 * t5, o4 = C2 * (t5 + 1);
                  B2(e3 + r3 + n5, e3 + i3 + n5, e3 + i3 + o4, e3 + r3 + o4);
                }
              }
            }
            function k2(t4, e3, n3) {
              o3.push(t4), o3.push(e3), o3.push(n3);
            }
            function F2(t4, e3, i3) {
              H2(t4), H2(e3), H2(i3);
              const o4 = r2.length / 3, a3 = m2.generateTopUV(n2, r2, o4 - 3, o4 - 2, o4 - 1);
              G2(a3[0]), G2(a3[1]), G2(a3[2]);
            }
            function B2(t4, e3, i3, o4) {
              H2(t4), H2(e3), H2(o4), H2(e3), H2(i3), H2(o4);
              const a3 = r2.length / 3, s3 = m2.generateSideWallUV(n2, r2, a3 - 6, a3 - 3, a3 - 2, a3 - 1);
              G2(s3[0]), G2(s3[1]), G2(s3[3]), G2(s3[1]), G2(s3[2]), G2(s3[3]);
            }
            function H2(t4) {
              r2.push(o3[3 * t4 + 0]), r2.push(o3[3 * t4 + 1]), r2.push(o3[3 * t4 + 2]);
            }
            function G2(t4) {
              i2.push(t4.x), i2.push(t4.y);
            }
            !function() {
              const t4 = r2.length / 3;
              if (u2) {
                let t5 = 0, e3 = C2 * t5;
                for (let t6 = 0; t6 < L2; t6++) {
                  const n3 = T2[t6];
                  F2(n3[2] + e3, n3[1] + e3, n3[0] + e3);
                }
                t5 = s2 + 2 * p2, e3 = C2 * t5;
                for (let t6 = 0; t6 < L2; t6++) {
                  const n3 = T2[t6];
                  F2(n3[0] + e3, n3[1] + e3, n3[2] + e3);
                }
              } else {
                for (let t5 = 0; t5 < L2; t5++) {
                  const e3 = T2[t5];
                  F2(e3[2], e3[1], e3[0]);
                }
                for (let t5 = 0; t5 < L2; t5++) {
                  const e3 = T2[t5];
                  F2(e3[0] + C2 * s2, e3[1] + C2 * s2, e3[2] + C2 * s2);
                }
              }
              n2.addGroup(t4, r2.length / 3 - t4, 0);
            }(), function() {
              const t4 = r2.length / 3;
              let e3 = 0;
              z2(E2, e3), e3 += E2.length;
              for (let t5 = 0, n3 = S2.length; t5 < n3; t5++) {
                const n4 = S2[t5];
                z2(n4, e3), e3 += n4.length;
              }
              n2.addGroup(t4, r2.length / 3 - t4, 1);
            }();
          }
          this.setAttribute("position", new Ii(r2, 3)), this.setAttribute("uv", new Ii(i2, 2)), this.computeVertexNormals();
        }
        toJSON() {
          const t2 = Xi.prototype.toJSON.call(this);
          return function(t3, e2, n2) {
            if (n2.shapes = [], Array.isArray(t3)) for (let e3 = 0, r2 = t3.length; e3 < r2; e3++) {
              const r3 = t3[e3];
              n2.shapes.push(r3.uuid);
            }
            else n2.shapes.push(t3.uuid);
            void 0 !== e2.extrudePath && (n2.options.extrudePath = e2.extrudePath.toJSON());
            return n2;
          }(this.parameters.shapes, this.parameters.options, t2);
        }
      }
      const Hu = { generateTopUV: function(t2, e2, n2, r2, i2) {
        const o2 = e2[3 * n2], a2 = e2[3 * n2 + 1], s2 = e2[3 * r2], c2 = e2[3 * r2 + 1], u2 = e2[3 * i2], l2 = e2[3 * i2 + 1];
        return [new Hn(o2, a2), new Hn(s2, c2), new Hn(u2, l2)];
      }, generateSideWallUV: function(t2, e2, n2, r2, i2, o2) {
        const a2 = e2[3 * n2], s2 = e2[3 * n2 + 1], c2 = e2[3 * n2 + 2], u2 = e2[3 * r2], l2 = e2[3 * r2 + 1], h2 = e2[3 * r2 + 2], d2 = e2[3 * i2], p2 = e2[3 * i2 + 1], f2 = e2[3 * i2 + 2], m2 = e2[3 * o2], g2 = e2[3 * o2 + 1], v2 = e2[3 * o2 + 2];
        return Math.abs(s2 - l2) < 0.01 ? [new Hn(a2, 1 - c2), new Hn(u2, 1 - h2), new Hn(d2, 1 - f2), new Hn(m2, 1 - v2)] : [new Hn(s2, 1 - c2), new Hn(l2, 1 - h2), new Hn(p2, 1 - f2), new Hn(g2, 1 - v2)];
      } };
      class Gu extends Zc {
        constructor(t2, e2) {
          super(), this.type = "ExtrudeGeometry", this.parameters = { shapes: t2, options: e2 }, this.fromBufferGeometry(new Bu(t2, e2)), this.mergeVertices();
        }
        toJSON() {
          const t2 = super.toJSON();
          return function(t3, e2, n2) {
            if (n2.shapes = [], Array.isArray(t3)) for (let e3 = 0, r2 = t3.length; e3 < r2; e3++) {
              const r3 = t3[e3];
              n2.shapes.push(r3.uuid);
            }
            else n2.shapes.push(t3.uuid);
            void 0 !== e2.extrudePath && (n2.options.extrudePath = e2.extrudePath.toJSON());
            return n2;
          }(this.parameters.shapes, this.parameters.options, t2);
        }
      }
      class Uu extends ru {
        constructor(t2 = 1, e2 = 0) {
          const n2 = (1 + Math.sqrt(5)) / 2;
          super([-1, n2, 0, 1, n2, 0, -1, -n2, 0, 1, -n2, 0, 0, -1, n2, 0, 1, n2, 0, -1, -n2, 0, 1, -n2, n2, 0, -1, n2, 0, 1, -n2, 0, -1, -n2, 0, 1], [0, 11, 5, 0, 5, 1, 0, 1, 7, 0, 7, 10, 0, 10, 11, 1, 5, 9, 5, 11, 4, 11, 10, 2, 10, 7, 6, 7, 1, 8, 3, 9, 4, 3, 4, 2, 3, 2, 6, 3, 6, 8, 3, 8, 9, 4, 9, 5, 2, 4, 11, 6, 2, 10, 8, 6, 7, 9, 8, 1], t2, e2), this.type = "IcosahedronBufferGeometry", this.parameters = { radius: t2, detail: e2 };
        }
      }
      class ju extends Zc {
        constructor(t2, e2) {
          super(), this.type = "IcosahedronGeometry", this.parameters = { radius: t2, detail: e2 }, this.fromBufferGeometry(new Uu(t2, e2)), this.mergeVertices();
        }
      }
      class Vu extends Xi {
        constructor(t2, e2 = 12, n2 = 0, r2 = 2 * Math.PI) {
          super(), this.type = "LatheBufferGeometry", this.parameters = { points: t2, segments: e2, phiStart: n2, phiLength: r2 }, e2 = Math.floor(e2), r2 = Bn.clamp(r2, 0, 2 * Math.PI);
          const i2 = [], o2 = [], a2 = [], s2 = 1 / e2, c2 = new $n(), u2 = new Hn();
          for (let i3 = 0; i3 <= e2; i3++) {
            const l2 = n2 + i3 * s2 * r2, h2 = Math.sin(l2), d2 = Math.cos(l2);
            for (let n3 = 0; n3 <= t2.length - 1; n3++) c2.x = t2[n3].x * h2, c2.y = t2[n3].y, c2.z = t2[n3].x * d2, o2.push(c2.x, c2.y, c2.z), u2.x = i3 / e2, u2.y = n3 / (t2.length - 1), a2.push(u2.x, u2.y);
          }
          for (let n3 = 0; n3 < e2; n3++) for (let e3 = 0; e3 < t2.length - 1; e3++) {
            const r3 = e3 + n3 * t2.length, o3 = r3, a3 = r3 + t2.length, s3 = r3 + t2.length + 1, c3 = r3 + 1;
            i2.push(o3, a3, c3), i2.push(a3, s3, c3);
          }
          if (this.setIndex(i2), this.setAttribute("position", new Ii(o2, 3)), this.setAttribute("uv", new Ii(a2, 2)), this.computeVertexNormals(), r2 === 2 * Math.PI) {
            const n3 = this.attributes.normal.array, r3 = new $n(), i3 = new $n(), o3 = new $n(), a3 = e2 * t2.length * 3;
            for (let e3 = 0, s3 = 0; e3 < t2.length; e3++, s3 += 3) r3.x = n3[s3 + 0], r3.y = n3[s3 + 1], r3.z = n3[s3 + 2], i3.x = n3[a3 + s3 + 0], i3.y = n3[a3 + s3 + 1], i3.z = n3[a3 + s3 + 2], o3.addVectors(r3, i3).normalize(), n3[s3 + 0] = n3[a3 + s3 + 0] = o3.x, n3[s3 + 1] = n3[a3 + s3 + 1] = o3.y, n3[s3 + 2] = n3[a3 + s3 + 2] = o3.z;
          }
        }
      }
      class Wu extends Zc {
        constructor(t2, e2, n2, r2) {
          super(), this.type = "LatheGeometry", this.parameters = { points: t2, segments: e2, phiStart: n2, phiLength: r2 }, this.fromBufferGeometry(new Vu(t2, e2, n2, r2)), this.mergeVertices();
        }
      }
      class qu extends ru {
        constructor(t2 = 1, e2 = 0) {
          super([1, 0, 0, -1, 0, 0, 0, 1, 0, 0, -1, 0, 0, 0, 1, 0, 0, -1], [0, 2, 4, 0, 4, 3, 0, 3, 5, 0, 5, 2, 1, 2, 5, 1, 5, 3, 1, 3, 4, 1, 4, 2], t2, e2), this.type = "OctahedronBufferGeometry", this.parameters = { radius: t2, detail: e2 };
        }
      }
      class Xu extends Zc {
        constructor(t2, e2) {
          super(), this.type = "OctahedronGeometry", this.parameters = { radius: t2, detail: e2 }, this.fromBufferGeometry(new qu(t2, e2)), this.mergeVertices();
        }
      }
      function Yu(t2, e2, n2) {
        Xi.call(this), this.type = "ParametricBufferGeometry", this.parameters = { func: t2, slices: e2, stacks: n2 };
        const r2 = [], i2 = [], o2 = [], a2 = [], s2 = 1e-5, c2 = new $n(), u2 = new $n(), l2 = new $n(), h2 = new $n(), d2 = new $n();
        t2.length < 3 && console.error("THREE.ParametricGeometry: Function must now modify a Vector3 as third parameter.");
        const p2 = e2 + 1;
        for (let r3 = 0; r3 <= n2; r3++) {
          const p3 = r3 / n2;
          for (let n3 = 0; n3 <= e2; n3++) {
            const r4 = n3 / e2;
            t2(r4, p3, u2), i2.push(u2.x, u2.y, u2.z), r4 - s2 >= 0 ? (t2(r4 - s2, p3, l2), h2.subVectors(u2, l2)) : (t2(r4 + s2, p3, l2), h2.subVectors(l2, u2)), p3 - s2 >= 0 ? (t2(r4, p3 - s2, l2), d2.subVectors(u2, l2)) : (t2(r4, p3 + s2, l2), d2.subVectors(l2, u2)), c2.crossVectors(h2, d2).normalize(), o2.push(c2.x, c2.y, c2.z), a2.push(r4, p3);
          }
        }
        for (let t3 = 0; t3 < n2; t3++) for (let n3 = 0; n3 < e2; n3++) {
          const e3 = t3 * p2 + n3, i3 = t3 * p2 + n3 + 1, o3 = (t3 + 1) * p2 + n3 + 1, a3 = (t3 + 1) * p2 + n3;
          r2.push(e3, i3, a3), r2.push(i3, o3, a3);
        }
        this.setIndex(r2), this.setAttribute("position", new Ii(i2, 3)), this.setAttribute("normal", new Ii(o2, 3)), this.setAttribute("uv", new Ii(a2, 2));
      }
      function Zu(t2, e2, n2) {
        Zc.call(this), this.type = "ParametricGeometry", this.parameters = { func: t2, slices: e2, stacks: n2 }, this.fromBufferGeometry(new Yu(t2, e2, n2)), this.mergeVertices();
      }
      Yu.prototype = Object.create(Xi.prototype), Yu.prototype.constructor = Yu, Zu.prototype = Object.create(Zc.prototype), Zu.prototype.constructor = Zu;
      class Ju extends Zc {
        constructor(t2, e2, n2, r2) {
          super(), this.type = "PlaneGeometry", this.parameters = { width: t2, height: e2, widthSegments: n2, heightSegments: r2 }, this.fromBufferGeometry(new Ro(t2, e2, n2, r2)), this.mergeVertices();
        }
      }
      class $u extends Zc {
        constructor(t2, e2, n2, r2) {
          super(), this.type = "PolyhedronGeometry", this.parameters = { vertices: t2, indices: e2, radius: n2, detail: r2 }, this.fromBufferGeometry(new ru(t2, e2, n2, r2)), this.mergeVertices();
        }
      }
      class Qu extends Xi {
        constructor(t2 = 0.5, e2 = 1, n2 = 8, r2 = 1, i2 = 0, o2 = 2 * Math.PI) {
          super(), this.type = "RingBufferGeometry", this.parameters = { innerRadius: t2, outerRadius: e2, thetaSegments: n2, phiSegments: r2, thetaStart: i2, thetaLength: o2 }, n2 = Math.max(3, n2);
          const a2 = [], s2 = [], c2 = [], u2 = [];
          let l2 = t2;
          const h2 = (e2 - t2) / (r2 = Math.max(1, r2)), d2 = new $n(), p2 = new Hn();
          for (let t3 = 0; t3 <= r2; t3++) {
            for (let t4 = 0; t4 <= n2; t4++) {
              const r3 = i2 + t4 / n2 * o2;
              d2.x = l2 * Math.cos(r3), d2.y = l2 * Math.sin(r3), s2.push(d2.x, d2.y, d2.z), c2.push(0, 0, 1), p2.x = (d2.x / e2 + 1) / 2, p2.y = (d2.y / e2 + 1) / 2, u2.push(p2.x, p2.y);
            }
            l2 += h2;
          }
          for (let t3 = 0; t3 < r2; t3++) {
            const e3 = t3 * (n2 + 1);
            for (let t4 = 0; t4 < n2; t4++) {
              const r3 = t4 + e3, i3 = r3, o3 = r3 + n2 + 1, s3 = r3 + n2 + 2, c3 = r3 + 1;
              a2.push(i3, o3, c3), a2.push(o3, s3, c3);
            }
          }
          this.setIndex(a2), this.setAttribute("position", new Ii(s2, 3)), this.setAttribute("normal", new Ii(c2, 3)), this.setAttribute("uv", new Ii(u2, 2));
        }
      }
      class Ku extends Zc {
        constructor(t2, e2, n2, r2, i2, o2) {
          super(), this.type = "RingGeometry", this.parameters = { innerRadius: t2, outerRadius: e2, thetaSegments: n2, phiSegments: r2, thetaStart: i2, thetaLength: o2 }, this.fromBufferGeometry(new Qu(t2, e2, n2, r2, i2, o2)), this.mergeVertices();
        }
      }
      class tl extends Xi {
        constructor(t2, e2 = 12) {
          super(), this.type = "ShapeBufferGeometry", this.parameters = { shapes: t2, curveSegments: e2 };
          const n2 = [], r2 = [], i2 = [], o2 = [];
          let a2 = 0, s2 = 0;
          if (false === Array.isArray(t2)) c2(t2);
          else for (let e3 = 0; e3 < t2.length; e3++) c2(t2[e3]), this.addGroup(a2, s2, e3), a2 += s2, s2 = 0;
          function c2(t3) {
            const a3 = r2.length / 3, c3 = t3.extractPoints(e2);
            let u2 = c3.shape;
            const l2 = c3.holes;
            false === zu.isClockWise(u2) && (u2 = u2.reverse());
            for (let t4 = 0, e3 = l2.length; t4 < e3; t4++) {
              const e4 = l2[t4];
              true === zu.isClockWise(e4) && (l2[t4] = e4.reverse());
            }
            const h2 = zu.triangulateShape(u2, l2);
            for (let t4 = 0, e3 = l2.length; t4 < e3; t4++) {
              const e4 = l2[t4];
              u2 = u2.concat(e4);
            }
            for (let t4 = 0, e3 = u2.length; t4 < e3; t4++) {
              const e4 = u2[t4];
              r2.push(e4.x, e4.y, 0), i2.push(0, 0, 1), o2.push(e4.x, e4.y);
            }
            for (let t4 = 0, e3 = h2.length; t4 < e3; t4++) {
              const e4 = h2[t4], r3 = e4[0] + a3, i3 = e4[1] + a3, o3 = e4[2] + a3;
              n2.push(r3, i3, o3), s2 += 3;
            }
          }
          this.setIndex(n2), this.setAttribute("position", new Ii(r2, 3)), this.setAttribute("normal", new Ii(i2, 3)), this.setAttribute("uv", new Ii(o2, 2));
        }
        toJSON() {
          const t2 = Xi.prototype.toJSON.call(this);
          return function(t3, e2) {
            if (e2.shapes = [], Array.isArray(t3)) for (let n2 = 0, r2 = t3.length; n2 < r2; n2++) {
              const r3 = t3[n2];
              e2.shapes.push(r3.uuid);
            }
            else e2.shapes.push(t3.uuid);
            return e2;
          }(this.parameters.shapes, t2);
        }
      }
      class el extends Zc {
        constructor(t2, e2) {
          super(), this.type = "ShapeGeometry", "object" == typeof e2 && (console.warn("THREE.ShapeGeometry: Options parameter has been removed."), e2 = e2.curveSegments), this.parameters = { shapes: t2, curveSegments: e2 }, this.fromBufferGeometry(new tl(t2, e2)), this.mergeVertices();
        }
        toJSON() {
          const t2 = Zc.prototype.toJSON.call(this);
          return function(t3, e2) {
            if (e2.shapes = [], Array.isArray(t3)) for (let n2 = 0, r2 = t3.length; n2 < r2; n2++) {
              const r3 = t3[n2];
              e2.shapes.push(r3.uuid);
            }
            else e2.shapes.push(t3.uuid);
            return e2;
          }(this.parameters.shapes, t2);
        }
      }
      class nl extends Xi {
        constructor(t2 = 1, e2 = 8, n2 = 6, r2 = 0, i2 = 2 * Math.PI, o2 = 0, a2 = Math.PI) {
          super(), this.type = "SphereBufferGeometry", this.parameters = { radius: t2, widthSegments: e2, heightSegments: n2, phiStart: r2, phiLength: i2, thetaStart: o2, thetaLength: a2 }, e2 = Math.max(3, Math.floor(e2)), n2 = Math.max(2, Math.floor(n2));
          const s2 = Math.min(o2 + a2, Math.PI);
          let c2 = 0;
          const u2 = [], l2 = new $n(), h2 = new $n(), d2 = [], p2 = [], f2 = [], m2 = [];
          for (let d3 = 0; d3 <= n2; d3++) {
            const g2 = [], v2 = d3 / n2;
            let y2 = 0;
            0 == d3 && 0 == o2 ? y2 = 0.5 / e2 : d3 == n2 && s2 == Math.PI && (y2 = -0.5 / e2);
            for (let n3 = 0; n3 <= e2; n3++) {
              const s3 = n3 / e2;
              l2.x = -t2 * Math.cos(r2 + s3 * i2) * Math.sin(o2 + v2 * a2), l2.y = t2 * Math.cos(o2 + v2 * a2), l2.z = t2 * Math.sin(r2 + s3 * i2) * Math.sin(o2 + v2 * a2), p2.push(l2.x, l2.y, l2.z), h2.copy(l2).normalize(), f2.push(h2.x, h2.y, h2.z), m2.push(s3 + y2, 1 - v2), g2.push(c2++);
            }
            u2.push(g2);
          }
          for (let t3 = 0; t3 < n2; t3++) for (let r3 = 0; r3 < e2; r3++) {
            const e3 = u2[t3][r3 + 1], i3 = u2[t3][r3], a3 = u2[t3 + 1][r3], c3 = u2[t3 + 1][r3 + 1];
            (0 !== t3 || o2 > 0) && d2.push(e3, i3, c3), (t3 !== n2 - 1 || s2 < Math.PI) && d2.push(i3, a3, c3);
          }
          this.setIndex(d2), this.setAttribute("position", new Ii(p2, 3)), this.setAttribute("normal", new Ii(f2, 3)), this.setAttribute("uv", new Ii(m2, 2));
        }
      }
      class rl extends Zc {
        constructor(t2, e2, n2, r2, i2, o2, a2) {
          super(), this.type = "SphereGeometry", this.parameters = { radius: t2, widthSegments: e2, heightSegments: n2, phiStart: r2, phiLength: i2, thetaStart: o2, thetaLength: a2 }, this.fromBufferGeometry(new nl(t2, e2, n2, r2, i2, o2, a2)), this.mergeVertices();
        }
      }
      class il extends ru {
        constructor(t2 = 1, e2 = 0) {
          super([1, 1, 1, -1, -1, 1, -1, 1, -1, 1, -1, -1], [2, 1, 0, 0, 3, 2, 1, 3, 0, 2, 3, 1], t2, e2), this.type = "TetrahedronBufferGeometry", this.parameters = { radius: t2, detail: e2 };
        }
      }
      class ol extends Zc {
        constructor(t2, e2) {
          super(), this.type = "TetrahedronGeometry", this.parameters = { radius: t2, detail: e2 }, this.fromBufferGeometry(new il(t2, e2)), this.mergeVertices();
        }
      }
      class al extends Bu {
        constructor(t2, e2 = {}) {
          const n2 = e2.font;
          if (!n2 || !n2.isFont) return console.error("THREE.TextGeometry: font parameter is not an instance of THREE.Font."), new Xi();
          const r2 = n2.generateShapes(t2, e2.size);
          e2.depth = void 0 !== e2.height ? e2.height : 50, void 0 === e2.bevelThickness && (e2.bevelThickness = 10), void 0 === e2.bevelSize && (e2.bevelSize = 8), void 0 === e2.bevelEnabled && (e2.bevelEnabled = false), super(r2, e2), this.type = "TextBufferGeometry";
        }
      }
      class sl extends Zc {
        constructor(t2, e2) {
          super(), this.type = "TextGeometry", this.parameters = { text: t2, parameters: e2 }, this.fromBufferGeometry(new al(t2, e2)), this.mergeVertices();
        }
      }
      class cl extends Xi {
        constructor(t2 = 1, e2 = 0.4, n2 = 8, r2 = 6, i2 = 2 * Math.PI) {
          super(), this.type = "TorusBufferGeometry", this.parameters = { radius: t2, tube: e2, radialSegments: n2, tubularSegments: r2, arc: i2 }, n2 = Math.floor(n2), r2 = Math.floor(r2);
          const o2 = [], a2 = [], s2 = [], c2 = [], u2 = new $n(), l2 = new $n(), h2 = new $n();
          for (let o3 = 0; o3 <= n2; o3++) for (let d2 = 0; d2 <= r2; d2++) {
            const p2 = d2 / r2 * i2, f2 = o3 / n2 * Math.PI * 2;
            l2.x = (t2 + e2 * Math.cos(f2)) * Math.cos(p2), l2.y = (t2 + e2 * Math.cos(f2)) * Math.sin(p2), l2.z = e2 * Math.sin(f2), a2.push(l2.x, l2.y, l2.z), u2.x = t2 * Math.cos(p2), u2.y = t2 * Math.sin(p2), h2.subVectors(l2, u2).normalize(), s2.push(h2.x, h2.y, h2.z), c2.push(d2 / r2), c2.push(o3 / n2);
          }
          for (let t3 = 1; t3 <= n2; t3++) for (let e3 = 1; e3 <= r2; e3++) {
            const n3 = (r2 + 1) * t3 + e3 - 1, i3 = (r2 + 1) * (t3 - 1) + e3 - 1, a3 = (r2 + 1) * (t3 - 1) + e3, s3 = (r2 + 1) * t3 + e3;
            o2.push(n3, i3, s3), o2.push(i3, a3, s3);
          }
          this.setIndex(o2), this.setAttribute("position", new Ii(a2, 3)), this.setAttribute("normal", new Ii(s2, 3)), this.setAttribute("uv", new Ii(c2, 2));
        }
      }
      class ul extends Zc {
        constructor(t2, e2, n2, r2, i2) {
          super(), this.type = "TorusGeometry", this.parameters = { radius: t2, tube: e2, radialSegments: n2, tubularSegments: r2, arc: i2 }, this.fromBufferGeometry(new cl(t2, e2, n2, r2, i2)), this.mergeVertices();
        }
      }
      class ll extends Xi {
        constructor(t2 = 1, e2 = 0.4, n2 = 64, r2 = 8, i2 = 2, o2 = 3) {
          super(), this.type = "TorusKnotBufferGeometry", this.parameters = { radius: t2, tube: e2, tubularSegments: n2, radialSegments: r2, p: i2, q: o2 }, n2 = Math.floor(n2), r2 = Math.floor(r2);
          const a2 = [], s2 = [], c2 = [], u2 = [], l2 = new $n(), h2 = new $n(), d2 = new $n(), p2 = new $n(), f2 = new $n(), m2 = new $n(), g2 = new $n();
          for (let a3 = 0; a3 <= n2; ++a3) {
            const y2 = a3 / n2 * i2 * Math.PI * 2;
            v2(y2, i2, o2, t2, d2), v2(y2 + 0.01, i2, o2, t2, p2), m2.subVectors(p2, d2), g2.addVectors(p2, d2), f2.crossVectors(m2, g2), g2.crossVectors(f2, m2), f2.normalize(), g2.normalize();
            for (let t3 = 0; t3 <= r2; ++t3) {
              const i3 = t3 / r2 * Math.PI * 2, o3 = -e2 * Math.cos(i3), p3 = e2 * Math.sin(i3);
              l2.x = d2.x + (o3 * g2.x + p3 * f2.x), l2.y = d2.y + (o3 * g2.y + p3 * f2.y), l2.z = d2.z + (o3 * g2.z + p3 * f2.z), s2.push(l2.x, l2.y, l2.z), h2.subVectors(l2, d2).normalize(), c2.push(h2.x, h2.y, h2.z), u2.push(a3 / n2), u2.push(t3 / r2);
            }
          }
          for (let t3 = 1; t3 <= n2; t3++) for (let e3 = 1; e3 <= r2; e3++) {
            const n3 = (r2 + 1) * (t3 - 1) + (e3 - 1), i3 = (r2 + 1) * t3 + (e3 - 1), o3 = (r2 + 1) * t3 + e3, s3 = (r2 + 1) * (t3 - 1) + e3;
            a2.push(n3, i3, s3), a2.push(i3, o3, s3);
          }
          function v2(t3, e3, n3, r3, i3) {
            const o3 = Math.cos(t3), a3 = Math.sin(t3), s3 = n3 / e3 * t3, c3 = Math.cos(s3);
            i3.x = r3 * (2 + c3) * 0.5 * o3, i3.y = r3 * (2 + c3) * a3 * 0.5, i3.z = r3 * Math.sin(s3) * 0.5;
          }
          this.setIndex(a2), this.setAttribute("position", new Ii(s2, 3)), this.setAttribute("normal", new Ii(c2, 3)), this.setAttribute("uv", new Ii(u2, 2));
        }
      }
      class hl extends Zc {
        constructor(t2, e2, n2, r2, i2, o2, a2) {
          super(), this.type = "TorusKnotGeometry", this.parameters = { radius: t2, tube: e2, tubularSegments: n2, radialSegments: r2, p: i2, q: o2 }, void 0 !== a2 && console.warn("THREE.TorusKnotGeometry: heightScale has been deprecated. Use .scale( x, y, z ) instead."), this.fromBufferGeometry(new ll(t2, e2, n2, r2, i2, o2)), this.mergeVertices();
        }
      }
      class dl extends Xi {
        constructor(t2, e2 = 64, n2 = 1, r2 = 8, i2 = false) {
          super(), this.type = "TubeBufferGeometry", this.parameters = { path: t2, tubularSegments: e2, radius: n2, radialSegments: r2, closed: i2 };
          const o2 = t2.computeFrenetFrames(e2, i2);
          this.tangents = o2.tangents, this.normals = o2.normals, this.binormals = o2.binormals;
          const a2 = new $n(), s2 = new $n(), c2 = new Hn();
          let u2 = new $n();
          const l2 = [], h2 = [], d2 = [], p2 = [];
          function f2(i3) {
            u2 = t2.getPointAt(i3 / e2, u2);
            const c3 = o2.normals[i3], d3 = o2.binormals[i3];
            for (let t3 = 0; t3 <= r2; t3++) {
              const e3 = t3 / r2 * Math.PI * 2, i4 = Math.sin(e3), o3 = -Math.cos(e3);
              s2.x = o3 * c3.x + i4 * d3.x, s2.y = o3 * c3.y + i4 * d3.y, s2.z = o3 * c3.z + i4 * d3.z, s2.normalize(), h2.push(s2.x, s2.y, s2.z), a2.x = u2.x + n2 * s2.x, a2.y = u2.y + n2 * s2.y, a2.z = u2.z + n2 * s2.z, l2.push(a2.x, a2.y, a2.z);
            }
          }
          !function() {
            for (let t3 = 0; t3 < e2; t3++) f2(t3);
            f2(false === i2 ? e2 : 0), function() {
              for (let t3 = 0; t3 <= e2; t3++) for (let n3 = 0; n3 <= r2; n3++) c2.x = t3 / e2, c2.y = n3 / r2, d2.push(c2.x, c2.y);
            }(), function() {
              for (let t3 = 1; t3 <= e2; t3++) for (let e3 = 1; e3 <= r2; e3++) {
                const n3 = (r2 + 1) * (t3 - 1) + (e3 - 1), i3 = (r2 + 1) * t3 + (e3 - 1), o3 = (r2 + 1) * t3 + e3, a3 = (r2 + 1) * (t3 - 1) + e3;
                p2.push(n3, i3, a3), p2.push(i3, o3, a3);
              }
            }();
          }(), this.setIndex(p2), this.setAttribute("position", new Ii(l2, 3)), this.setAttribute("normal", new Ii(h2, 3)), this.setAttribute("uv", new Ii(d2, 2));
        }
        toJSON() {
          const t2 = Xi.prototype.toJSON.call(this);
          return t2.path = this.parameters.path.toJSON(), t2;
        }
      }
      class pl extends Zc {
        constructor(t2, e2, n2, r2, i2, o2) {
          super(), this.type = "TubeGeometry", this.parameters = { path: t2, tubularSegments: e2, radius: n2, radialSegments: r2, closed: i2 }, void 0 !== o2 && console.warn("THREE.TubeGeometry: taper has been removed.");
          const a2 = new dl(t2, e2, n2, r2, i2);
          this.tangents = a2.tangents, this.normals = a2.normals, this.binormals = a2.binormals, this.fromBufferGeometry(a2), this.mergeVertices();
        }
      }
      class fl extends Xi {
        constructor(t2) {
          super(), this.type = "WireframeGeometry";
          const e2 = [], n2 = [0, 0], r2 = {}, i2 = ["a", "b", "c"];
          if (t2 && t2.isGeometry) {
            const o2 = t2.faces;
            for (let t3 = 0, e3 = o2.length; t3 < e3; t3++) {
              const e4 = o2[t3];
              for (let t4 = 0; t4 < 3; t4++) {
                const o3 = e4[i2[t4]], a2 = e4[i2[(t4 + 1) % 3]];
                n2[0] = Math.min(o3, a2), n2[1] = Math.max(o3, a2);
                const s2 = n2[0] + "," + n2[1];
                void 0 === r2[s2] && (r2[s2] = { index1: n2[0], index2: n2[1] });
              }
            }
            for (const n3 in r2) {
              const i3 = r2[n3];
              let o3 = t2.vertices[i3.index1];
              e2.push(o3.x, o3.y, o3.z), o3 = t2.vertices[i3.index2], e2.push(o3.x, o3.y, o3.z);
            }
          } else if (t2 && t2.isBufferGeometry) {
            const i3 = new $n();
            if (null !== t2.index) {
              const o2 = t2.attributes.position, a2 = t2.index;
              let s2 = t2.groups;
              0 === s2.length && (s2 = [{ start: 0, count: a2.count, materialIndex: 0 }]);
              for (let t3 = 0, e3 = s2.length; t3 < e3; ++t3) {
                const e4 = s2[t3], i4 = e4.start;
                for (let t4 = i4, o3 = i4 + e4.count; t4 < o3; t4 += 3) for (let e5 = 0; e5 < 3; e5++) {
                  const i5 = a2.getX(t4 + e5), o4 = a2.getX(t4 + (e5 + 1) % 3);
                  n2[0] = Math.min(i5, o4), n2[1] = Math.max(i5, o4);
                  const s3 = n2[0] + "," + n2[1];
                  void 0 === r2[s3] && (r2[s3] = { index1: n2[0], index2: n2[1] });
                }
              }
              for (const t3 in r2) {
                const n3 = r2[t3];
                i3.fromBufferAttribute(o2, n3.index1), e2.push(i3.x, i3.y, i3.z), i3.fromBufferAttribute(o2, n3.index2), e2.push(i3.x, i3.y, i3.z);
              }
            } else {
              const n3 = t2.attributes.position;
              for (let t3 = 0, r3 = n3.count / 3; t3 < r3; t3++) for (let r4 = 0; r4 < 3; r4++) {
                const o2 = 3 * t3 + r4;
                i3.fromBufferAttribute(n3, o2), e2.push(i3.x, i3.y, i3.z);
                const a2 = 3 * t3 + (r4 + 1) % 3;
                i3.fromBufferAttribute(n3, a2), e2.push(i3.x, i3.y, i3.z);
              }
            }
          }
          this.setAttribute("position", new Ii(e2, 3));
        }
      }
      var ml = Object.freeze({ __proto__: null, BoxGeometry: Jc, BoxBufferGeometry: mo, CircleGeometry: Qc, CircleBufferGeometry: $c, ConeGeometry: eu, ConeBufferGeometry: nu, CylinderGeometry: tu, CylinderBufferGeometry: Kc, DodecahedronGeometry: ou, DodecahedronBufferGeometry: iu, EdgesGeometry: lu, ExtrudeGeometry: Gu, ExtrudeBufferGeometry: Bu, IcosahedronGeometry: ju, IcosahedronBufferGeometry: Uu, LatheGeometry: Wu, LatheBufferGeometry: Vu, OctahedronGeometry: Xu, OctahedronBufferGeometry: qu, ParametricGeometry: Zu, ParametricBufferGeometry: Yu, PlaneGeometry: Ju, PlaneBufferGeometry: Ro, PolyhedronGeometry: $u, PolyhedronBufferGeometry: ru, RingGeometry: Ku, RingBufferGeometry: Qu, ShapeGeometry: el, ShapeBufferGeometry: tl, SphereGeometry: rl, SphereBufferGeometry: nl, TetrahedronGeometry: ol, TetrahedronBufferGeometry: il, TextGeometry: sl, TextBufferGeometry: al, TorusGeometry: ul, TorusBufferGeometry: cl, TorusKnotGeometry: hl, TorusKnotBufferGeometry: ll, TubeGeometry: pl, TubeBufferGeometry: dl, WireframeGeometry: fl });
      function gl(t2) {
        wi.call(this), this.type = "ShadowMaterial", this.color = new yi(0), this.transparent = true, this.setValues(t2);
      }
      function vl(t2) {
        xo.call(this, t2), this.type = "RawShaderMaterial";
      }
      function yl(t2) {
        wi.call(this), this.defines = { STANDARD: "" }, this.type = "MeshStandardMaterial", this.color = new yi(16777215), this.roughness = 1, this.metalness = 0, this.map = null, this.lightMap = null, this.lightMapIntensity = 1, this.aoMap = null, this.aoMapIntensity = 1, this.emissive = new yi(0), this.emissiveIntensity = 1, this.emissiveMap = null, this.bumpMap = null, this.bumpScale = 1, this.normalMap = null, this.normalMapType = sn, this.normalScale = new Hn(1, 1), this.displacementMap = null, this.displacementScale = 1, this.displacementBias = 0, this.roughnessMap = null, this.metalnessMap = null, this.alphaMap = null, this.envMap = null, this.envMapIntensity = 1, this.refractionRatio = 0.98, this.wireframe = false, this.wireframeLinewidth = 1, this.wireframeLinecap = "round", this.wireframeLinejoin = "round", this.skinning = false, this.morphTargets = false, this.morphNormals = false, this.vertexTangents = false, this.setValues(t2);
      }
      function xl(t2) {
        yl.call(this), this.defines = { STANDARD: "", PHYSICAL: "" }, this.type = "MeshPhysicalMaterial", this.clearcoat = 0, this.clearcoatMap = null, this.clearcoatRoughness = 0, this.clearcoatRoughnessMap = null, this.clearcoatNormalScale = new Hn(1, 1), this.clearcoatNormalMap = null, this.reflectivity = 0.5, Object.defineProperty(this, "ior", { get: function() {
          return (1 + 0.4 * this.reflectivity) / (1 - 0.4 * this.reflectivity);
        }, set: function(t3) {
          this.reflectivity = Bn.clamp(2.5 * (t3 - 1) / (t3 + 1), 0, 1);
        } }), this.sheen = null, this.transmission = 0, this.transmissionMap = null, this.setValues(t2);
      }
      function bl(t2) {
        wi.call(this), this.type = "MeshPhongMaterial", this.color = new yi(16777215), this.specular = new yi(1118481), this.shininess = 30, this.map = null, this.lightMap = null, this.lightMapIntensity = 1, this.aoMap = null, this.aoMapIntensity = 1, this.emissive = new yi(0), this.emissiveIntensity = 1, this.emissiveMap = null, this.bumpMap = null, this.bumpScale = 1, this.normalMap = null, this.normalMapType = sn, this.normalScale = new Hn(1, 1), this.displacementMap = null, this.displacementScale = 1, this.displacementBias = 0, this.specularMap = null, this.alphaMap = null, this.envMap = null, this.combine = Z, this.reflectivity = 1, this.refractionRatio = 0.98, this.wireframe = false, this.wireframeLinewidth = 1, this.wireframeLinecap = "round", this.wireframeLinejoin = "round", this.skinning = false, this.morphTargets = false, this.morphNormals = false, this.setValues(t2);
      }
      function wl(t2) {
        wi.call(this), this.defines = { TOON: "" }, this.type = "MeshToonMaterial", this.color = new yi(16777215), this.map = null, this.gradientMap = null, this.lightMap = null, this.lightMapIntensity = 1, this.aoMap = null, this.aoMapIntensity = 1, this.emissive = new yi(0), this.emissiveIntensity = 1, this.emissiveMap = null, this.bumpMap = null, this.bumpScale = 1, this.normalMap = null, this.normalMapType = sn, this.normalScale = new Hn(1, 1), this.displacementMap = null, this.displacementScale = 1, this.displacementBias = 0, this.alphaMap = null, this.wireframe = false, this.wireframeLinewidth = 1, this.wireframeLinecap = "round", this.wireframeLinejoin = "round", this.skinning = false, this.morphTargets = false, this.morphNormals = false, this.setValues(t2);
      }
      function _l(t2) {
        wi.call(this), this.type = "MeshNormalMaterial", this.bumpMap = null, this.bumpScale = 1, this.normalMap = null, this.normalMapType = sn, this.normalScale = new Hn(1, 1), this.displacementMap = null, this.displacementScale = 1, this.displacementBias = 0, this.wireframe = false, this.wireframeLinewidth = 1, this.fog = false, this.skinning = false, this.morphTargets = false, this.morphNormals = false, this.setValues(t2);
      }
      function Ml(t2) {
        wi.call(this), this.type = "MeshLambertMaterial", this.color = new yi(16777215), this.map = null, this.lightMap = null, this.lightMapIntensity = 1, this.aoMap = null, this.aoMapIntensity = 1, this.emissive = new yi(0), this.emissiveIntensity = 1, this.emissiveMap = null, this.specularMap = null, this.alphaMap = null, this.envMap = null, this.combine = Z, this.reflectivity = 1, this.refractionRatio = 0.98, this.wireframe = false, this.wireframeLinewidth = 1, this.wireframeLinecap = "round", this.wireframeLinejoin = "round", this.skinning = false, this.morphTargets = false, this.morphNormals = false, this.setValues(t2);
      }
      function Sl(t2) {
        wi.call(this), this.defines = { MATCAP: "" }, this.type = "MeshMatcapMaterial", this.color = new yi(16777215), this.matcap = null, this.map = null, this.bumpMap = null, this.bumpScale = 1, this.normalMap = null, this.normalMapType = sn, this.normalScale = new Hn(1, 1), this.displacementMap = null, this.displacementScale = 1, this.displacementBias = 0, this.alphaMap = null, this.skinning = false, this.morphTargets = false, this.morphNormals = false, this.setValues(t2);
      }
      function Tl(t2) {
        Mc.call(this), this.type = "LineDashedMaterial", this.scale = 1, this.dashSize = 3, this.gapSize = 1, this.setValues(t2);
      }
      gl.prototype = Object.create(wi.prototype), gl.prototype.constructor = gl, gl.prototype.isShadowMaterial = true, gl.prototype.copy = function(t2) {
        return wi.prototype.copy.call(this, t2), this.color.copy(t2.color), this;
      }, vl.prototype = Object.create(xo.prototype), vl.prototype.constructor = vl, vl.prototype.isRawShaderMaterial = true, yl.prototype = Object.create(wi.prototype), yl.prototype.constructor = yl, yl.prototype.isMeshStandardMaterial = true, yl.prototype.copy = function(t2) {
        return wi.prototype.copy.call(this, t2), this.defines = { STANDARD: "" }, this.color.copy(t2.color), this.roughness = t2.roughness, this.metalness = t2.metalness, this.map = t2.map, this.lightMap = t2.lightMap, this.lightMapIntensity = t2.lightMapIntensity, this.aoMap = t2.aoMap, this.aoMapIntensity = t2.aoMapIntensity, this.emissive.copy(t2.emissive), this.emissiveMap = t2.emissiveMap, this.emissiveIntensity = t2.emissiveIntensity, this.bumpMap = t2.bumpMap, this.bumpScale = t2.bumpScale, this.normalMap = t2.normalMap, this.normalMapType = t2.normalMapType, this.normalScale.copy(t2.normalScale), this.displacementMap = t2.displacementMap, this.displacementScale = t2.displacementScale, this.displacementBias = t2.displacementBias, this.roughnessMap = t2.roughnessMap, this.metalnessMap = t2.metalnessMap, this.alphaMap = t2.alphaMap, this.envMap = t2.envMap, this.envMapIntensity = t2.envMapIntensity, this.refractionRatio = t2.refractionRatio, this.wireframe = t2.wireframe, this.wireframeLinewidth = t2.wireframeLinewidth, this.wireframeLinecap = t2.wireframeLinecap, this.wireframeLinejoin = t2.wireframeLinejoin, this.skinning = t2.skinning, this.morphTargets = t2.morphTargets, this.morphNormals = t2.morphNormals, this.vertexTangents = t2.vertexTangents, this;
      }, xl.prototype = Object.create(yl.prototype), xl.prototype.constructor = xl, xl.prototype.isMeshPhysicalMaterial = true, xl.prototype.copy = function(t2) {
        return yl.prototype.copy.call(this, t2), this.defines = { STANDARD: "", PHYSICAL: "" }, this.clearcoat = t2.clearcoat, this.clearcoatMap = t2.clearcoatMap, this.clearcoatRoughness = t2.clearcoatRoughness, this.clearcoatRoughnessMap = t2.clearcoatRoughnessMap, this.clearcoatNormalMap = t2.clearcoatNormalMap, this.clearcoatNormalScale.copy(t2.clearcoatNormalScale), this.reflectivity = t2.reflectivity, t2.sheen ? this.sheen = (this.sheen || new yi()).copy(t2.sheen) : this.sheen = null, this.transmission = t2.transmission, this.transmissionMap = t2.transmissionMap, this;
      }, bl.prototype = Object.create(wi.prototype), bl.prototype.constructor = bl, bl.prototype.isMeshPhongMaterial = true, bl.prototype.copy = function(t2) {
        return wi.prototype.copy.call(this, t2), this.color.copy(t2.color), this.specular.copy(t2.specular), this.shininess = t2.shininess, this.map = t2.map, this.lightMap = t2.lightMap, this.lightMapIntensity = t2.lightMapIntensity, this.aoMap = t2.aoMap, this.aoMapIntensity = t2.aoMapIntensity, this.emissive.copy(t2.emissive), this.emissiveMap = t2.emissiveMap, this.emissiveIntensity = t2.emissiveIntensity, this.bumpMap = t2.bumpMap, this.bumpScale = t2.bumpScale, this.normalMap = t2.normalMap, this.normalMapType = t2.normalMapType, this.normalScale.copy(t2.normalScale), this.displacementMap = t2.displacementMap, this.displacementScale = t2.displacementScale, this.displacementBias = t2.displacementBias, this.specularMap = t2.specularMap, this.alphaMap = t2.alphaMap, this.envMap = t2.envMap, this.combine = t2.combine, this.reflectivity = t2.reflectivity, this.refractionRatio = t2.refractionRatio, this.wireframe = t2.wireframe, this.wireframeLinewidth = t2.wireframeLinewidth, this.wireframeLinecap = t2.wireframeLinecap, this.wireframeLinejoin = t2.wireframeLinejoin, this.skinning = t2.skinning, this.morphTargets = t2.morphTargets, this.morphNormals = t2.morphNormals, this;
      }, wl.prototype = Object.create(wi.prototype), wl.prototype.constructor = wl, wl.prototype.isMeshToonMaterial = true, wl.prototype.copy = function(t2) {
        return wi.prototype.copy.call(this, t2), this.color.copy(t2.color), this.map = t2.map, this.gradientMap = t2.gradientMap, this.lightMap = t2.lightMap, this.lightMapIntensity = t2.lightMapIntensity, this.aoMap = t2.aoMap, this.aoMapIntensity = t2.aoMapIntensity, this.emissive.copy(t2.emissive), this.emissiveMap = t2.emissiveMap, this.emissiveIntensity = t2.emissiveIntensity, this.bumpMap = t2.bumpMap, this.bumpScale = t2.bumpScale, this.normalMap = t2.normalMap, this.normalMapType = t2.normalMapType, this.normalScale.copy(t2.normalScale), this.displacementMap = t2.displacementMap, this.displacementScale = t2.displacementScale, this.displacementBias = t2.displacementBias, this.alphaMap = t2.alphaMap, this.wireframe = t2.wireframe, this.wireframeLinewidth = t2.wireframeLinewidth, this.wireframeLinecap = t2.wireframeLinecap, this.wireframeLinejoin = t2.wireframeLinejoin, this.skinning = t2.skinning, this.morphTargets = t2.morphTargets, this.morphNormals = t2.morphNormals, this;
      }, _l.prototype = Object.create(wi.prototype), _l.prototype.constructor = _l, _l.prototype.isMeshNormalMaterial = true, _l.prototype.copy = function(t2) {
        return wi.prototype.copy.call(this, t2), this.bumpMap = t2.bumpMap, this.bumpScale = t2.bumpScale, this.normalMap = t2.normalMap, this.normalMapType = t2.normalMapType, this.normalScale.copy(t2.normalScale), this.displacementMap = t2.displacementMap, this.displacementScale = t2.displacementScale, this.displacementBias = t2.displacementBias, this.wireframe = t2.wireframe, this.wireframeLinewidth = t2.wireframeLinewidth, this.skinning = t2.skinning, this.morphTargets = t2.morphTargets, this.morphNormals = t2.morphNormals, this;
      }, Ml.prototype = Object.create(wi.prototype), Ml.prototype.constructor = Ml, Ml.prototype.isMeshLambertMaterial = true, Ml.prototype.copy = function(t2) {
        return wi.prototype.copy.call(this, t2), this.color.copy(t2.color), this.map = t2.map, this.lightMap = t2.lightMap, this.lightMapIntensity = t2.lightMapIntensity, this.aoMap = t2.aoMap, this.aoMapIntensity = t2.aoMapIntensity, this.emissive.copy(t2.emissive), this.emissiveMap = t2.emissiveMap, this.emissiveIntensity = t2.emissiveIntensity, this.specularMap = t2.specularMap, this.alphaMap = t2.alphaMap, this.envMap = t2.envMap, this.combine = t2.combine, this.reflectivity = t2.reflectivity, this.refractionRatio = t2.refractionRatio, this.wireframe = t2.wireframe, this.wireframeLinewidth = t2.wireframeLinewidth, this.wireframeLinecap = t2.wireframeLinecap, this.wireframeLinejoin = t2.wireframeLinejoin, this.skinning = t2.skinning, this.morphTargets = t2.morphTargets, this.morphNormals = t2.morphNormals, this;
      }, Sl.prototype = Object.create(wi.prototype), Sl.prototype.constructor = Sl, Sl.prototype.isMeshMatcapMaterial = true, Sl.prototype.copy = function(t2) {
        return wi.prototype.copy.call(this, t2), this.defines = { MATCAP: "" }, this.color.copy(t2.color), this.matcap = t2.matcap, this.map = t2.map, this.bumpMap = t2.bumpMap, this.bumpScale = t2.bumpScale, this.normalMap = t2.normalMap, this.normalMapType = t2.normalMapType, this.normalScale.copy(t2.normalScale), this.displacementMap = t2.displacementMap, this.displacementScale = t2.displacementScale, this.displacementBias = t2.displacementBias, this.alphaMap = t2.alphaMap, this.skinning = t2.skinning, this.morphTargets = t2.morphTargets, this.morphNormals = t2.morphNormals, this;
      }, Tl.prototype = Object.create(Mc.prototype), Tl.prototype.constructor = Tl, Tl.prototype.isLineDashedMaterial = true, Tl.prototype.copy = function(t2) {
        return Mc.prototype.copy.call(this, t2), this.scale = t2.scale, this.dashSize = t2.dashSize, this.gapSize = t2.gapSize, this;
      };
      var El = Object.freeze({ __proto__: null, ShadowMaterial: gl, SpriteMaterial: js, RawShaderMaterial: vl, ShaderMaterial: xo, PointsMaterial: Ic, MeshPhysicalMaterial: xl, MeshStandardMaterial: yl, MeshPhongMaterial: bl, MeshToonMaterial: wl, MeshNormalMaterial: _l, MeshLambertMaterial: Ml, MeshDepthMaterial: Ss, MeshDistanceMaterial: Ts, MeshBasicMaterial: _i, MeshMatcapMaterial: Sl, LineDashedMaterial: Tl, LineBasicMaterial: Mc, Material: wi });
      const Al = { arraySlice: function(t2, e2, n2) {
        return Al.isTypedArray(t2) ? new t2.constructor(t2.subarray(e2, void 0 !== n2 ? n2 : t2.length)) : t2.slice(e2, n2);
      }, convertArray: function(t2, e2, n2) {
        return !t2 || !n2 && t2.constructor === e2 ? t2 : "number" == typeof e2.BYTES_PER_ELEMENT ? new e2(t2) : Array.prototype.slice.call(t2);
      }, isTypedArray: function(t2) {
        return ArrayBuffer.isView(t2) && !(t2 instanceof DataView);
      }, getKeyframeOrder: function(t2) {
        const e2 = t2.length, n2 = new Array(e2);
        for (let t3 = 0; t3 !== e2; ++t3) n2[t3] = t3;
        return n2.sort(function(e3, n3) {
          return t2[e3] - t2[n3];
        }), n2;
      }, sortedArray: function(t2, e2, n2) {
        const r2 = t2.length, i2 = new t2.constructor(r2);
        for (let o2 = 0, a2 = 0; a2 !== r2; ++o2) {
          const r3 = n2[o2] * e2;
          for (let n3 = 0; n3 !== e2; ++n3) i2[a2++] = t2[r3 + n3];
        }
        return i2;
      }, flattenJSON: function(t2, e2, n2, r2) {
        let i2 = 1, o2 = t2[0];
        for (; void 0 !== o2 && void 0 === o2[r2]; ) o2 = t2[i2++];
        if (void 0 === o2) return;
        let a2 = o2[r2];
        if (void 0 !== a2) if (Array.isArray(a2)) do {
          a2 = o2[r2], void 0 !== a2 && (e2.push(o2.time), n2.push.apply(n2, a2)), o2 = t2[i2++];
        } while (void 0 !== o2);
        else if (void 0 !== a2.toArray) do {
          a2 = o2[r2], void 0 !== a2 && (e2.push(o2.time), a2.toArray(n2, n2.length)), o2 = t2[i2++];
        } while (void 0 !== o2);
        else do {
          a2 = o2[r2], void 0 !== a2 && (e2.push(o2.time), n2.push(a2)), o2 = t2[i2++];
        } while (void 0 !== o2);
      }, subclip: function(t2, e2, n2, r2, i2 = 30) {
        const o2 = t2.clone();
        o2.name = e2;
        const a2 = [];
        for (let t3 = 0; t3 < o2.tracks.length; ++t3) {
          const e3 = o2.tracks[t3], s3 = e3.getValueSize(), c2 = [], u2 = [];
          for (let t4 = 0; t4 < e3.times.length; ++t4) {
            const o3 = e3.times[t4] * i2;
            if (!(o3 < n2 || o3 >= r2)) {
              c2.push(e3.times[t4]);
              for (let n3 = 0; n3 < s3; ++n3) u2.push(e3.values[t4 * s3 + n3]);
            }
          }
          0 !== c2.length && (e3.times = Al.convertArray(c2, e3.times.constructor), e3.values = Al.convertArray(u2, e3.values.constructor), a2.push(e3));
        }
        o2.tracks = a2;
        let s2 = 1 / 0;
        for (let t3 = 0; t3 < o2.tracks.length; ++t3) s2 > o2.tracks[t3].times[0] && (s2 = o2.tracks[t3].times[0]);
        for (let t3 = 0; t3 < o2.tracks.length; ++t3) o2.tracks[t3].shift(-1 * s2);
        return o2.resetDuration(), o2;
      }, makeClipAdditive: function(t2, e2 = 0, n2 = t2, r2 = 30) {
        r2 <= 0 && (r2 = 30);
        const i2 = n2.tracks.length, o2 = e2 / r2;
        for (let e3 = 0; e3 < i2; ++e3) {
          const r3 = n2.tracks[e3], i3 = r3.ValueTypeName;
          if ("bool" === i3 || "string" === i3) continue;
          const a2 = t2.tracks.find(function(t3) {
            return t3.name === r3.name && t3.ValueTypeName === i3;
          });
          if (void 0 === a2) continue;
          let s2 = 0;
          const c2 = r3.getValueSize();
          r3.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline && (s2 = c2 / 3);
          let u2 = 0;
          const l2 = a2.getValueSize();
          a2.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline && (u2 = l2 / 3);
          const h2 = r3.times.length - 1;
          let d2;
          if (o2 <= r3.times[0]) {
            const t3 = s2, e4 = c2 - s2;
            d2 = Al.arraySlice(r3.values, t3, e4);
          } else if (o2 >= r3.times[h2]) {
            const t3 = h2 * c2 + s2, e4 = t3 + c2 - s2;
            d2 = Al.arraySlice(r3.values, t3, e4);
          } else {
            const t3 = r3.createInterpolant(), e4 = s2, n3 = c2 - s2;
            t3.evaluate(o2), d2 = Al.arraySlice(t3.resultBuffer, e4, n3);
          }
          if ("quaternion" === i3) {
            new Jn().fromArray(d2).normalize().conjugate().toArray(d2);
          }
          const p2 = a2.times.length;
          for (let t3 = 0; t3 < p2; ++t3) {
            const e4 = t3 * l2 + u2;
            if ("quaternion" === i3) Jn.multiplyQuaternionsFlat(a2.values, e4, d2, 0, a2.values, e4);
            else {
              const t4 = l2 - 2 * u2;
              for (let n3 = 0; n3 < t4; ++n3) a2.values[e4 + n3] -= d2[n3];
            }
          }
        }
        return t2.blendMode = qe, t2;
      } };
      function Cl(t2, e2, n2, r2) {
        this.parameterPositions = t2, this._cachedIndex = 0, this.resultBuffer = void 0 !== r2 ? r2 : new e2.constructor(n2), this.sampleValues = e2, this.valueSize = n2;
      }
      function Ll(t2, e2, n2, r2) {
        Cl.call(this, t2, e2, n2, r2), this._weightPrev = -0, this._offsetPrev = -0, this._weightNext = -0, this._offsetNext = -0;
      }
      function Pl(t2, e2, n2, r2) {
        Cl.call(this, t2, e2, n2, r2);
      }
      function Rl(t2, e2, n2, r2) {
        Cl.call(this, t2, e2, n2, r2);
      }
      function Ol(t2, e2, n2, r2) {
        if (void 0 === t2) throw new Error("THREE.KeyframeTrack: track name is undefined");
        if (void 0 === e2 || 0 === e2.length) throw new Error("THREE.KeyframeTrack: no keyframes in track named " + t2);
        this.name = t2, this.times = Al.convertArray(e2, this.TimeBufferType), this.values = Al.convertArray(n2, this.ValueBufferType), this.setInterpolation(r2 || this.DefaultInterpolation);
      }
      function Dl(t2, e2, n2) {
        Ol.call(this, t2, e2, n2);
      }
      function Il(t2, e2, n2, r2) {
        Ol.call(this, t2, e2, n2, r2);
      }
      function Nl(t2, e2, n2, r2) {
        Ol.call(this, t2, e2, n2, r2);
      }
      function zl(t2, e2, n2, r2) {
        Cl.call(this, t2, e2, n2, r2);
      }
      function kl(t2, e2, n2, r2) {
        Ol.call(this, t2, e2, n2, r2);
      }
      function Fl(t2, e2, n2, r2) {
        Ol.call(this, t2, e2, n2, r2);
      }
      function Bl(t2, e2, n2, r2) {
        Ol.call(this, t2, e2, n2, r2);
      }
      function Hl(t2, e2 = -1, n2, r2 = We) {
        this.name = t2, this.tracks = n2, this.duration = e2, this.blendMode = r2, this.uuid = Bn.generateUUID(), this.duration < 0 && this.resetDuration();
      }
      function Gl(t2) {
        if (void 0 === t2.type) throw new Error("THREE.KeyframeTrack: track type undefined, can not parse");
        const e2 = function(t3) {
          switch (t3.toLowerCase()) {
            case "scalar":
            case "double":
            case "float":
            case "number":
            case "integer":
              return Nl;
            case "vector":
            case "vector2":
            case "vector3":
            case "vector4":
              return Bl;
            case "color":
              return Il;
            case "quaternion":
              return kl;
            case "bool":
            case "boolean":
              return Dl;
            case "string":
              return Fl;
          }
          throw new Error("THREE.KeyframeTrack: Unsupported typeName: " + t3);
        }(t2.type);
        if (void 0 === t2.times) {
          const e3 = [], n2 = [];
          Al.flattenJSON(t2.keys, e3, n2, "value"), t2.times = e3, t2.values = n2;
        }
        return void 0 !== e2.parse ? e2.parse(t2) : new e2(t2.name, t2.times, t2.values, t2.interpolation);
      }
      Object.assign(Cl.prototype, { evaluate: function(t2) {
        const e2 = this.parameterPositions;
        let n2 = this._cachedIndex, r2 = e2[n2], i2 = e2[n2 - 1];
        t: {
          e: {
            let o2;
            n: {
              r: if (!(t2 < r2)) {
                for (let o3 = n2 + 2; ; ) {
                  if (void 0 === r2) {
                    if (t2 < i2) break r;
                    return n2 = e2.length, this._cachedIndex = n2, this.afterEnd_(n2 - 1, t2, i2);
                  }
                  if (n2 === o3) break;
                  if (i2 = r2, r2 = e2[++n2], t2 < r2) break e;
                }
                o2 = e2.length;
                break n;
              }
              if (t2 >= i2) break t;
              {
                const a2 = e2[1];
                t2 < a2 && (n2 = 2, i2 = a2);
                for (let o3 = n2 - 2; ; ) {
                  if (void 0 === i2) return this._cachedIndex = 0, this.beforeStart_(0, t2, r2);
                  if (n2 === o3) break;
                  if (r2 = i2, i2 = e2[--n2 - 1], t2 >= i2) break e;
                }
                o2 = n2, n2 = 0;
              }
            }
            for (; n2 < o2; ) {
              const r3 = n2 + o2 >>> 1;
              t2 < e2[r3] ? o2 = r3 : n2 = r3 + 1;
            }
            if (r2 = e2[n2], i2 = e2[n2 - 1], void 0 === i2) return this._cachedIndex = 0, this.beforeStart_(0, t2, r2);
            if (void 0 === r2) return n2 = e2.length, this._cachedIndex = n2, this.afterEnd_(n2 - 1, i2, t2);
          }
          this._cachedIndex = n2, this.intervalChanged_(n2, i2, r2);
        }
        return this.interpolate_(n2, i2, t2, r2);
      }, settings: null, DefaultSettings_: {}, getSettings_: function() {
        return this.settings || this.DefaultSettings_;
      }, copySampleValue_: function(t2) {
        const e2 = this.resultBuffer, n2 = this.sampleValues, r2 = this.valueSize, i2 = t2 * r2;
        for (let t3 = 0; t3 !== r2; ++t3) e2[t3] = n2[i2 + t3];
        return e2;
      }, interpolate_: function() {
        throw new Error("call to abstract method");
      }, intervalChanged_: function() {
      } }), Object.assign(Cl.prototype, { beforeStart_: Cl.prototype.copySampleValue_, afterEnd_: Cl.prototype.copySampleValue_ }), Ll.prototype = Object.assign(Object.create(Cl.prototype), { constructor: Ll, DefaultSettings_: { endingStart: Ue, endingEnd: Ue }, intervalChanged_: function(t2, e2, n2) {
        const r2 = this.parameterPositions;
        let i2 = t2 - 2, o2 = t2 + 1, a2 = r2[i2], s2 = r2[o2];
        if (void 0 === a2) switch (this.getSettings_().endingStart) {
          case je:
            i2 = t2, a2 = 2 * e2 - n2;
            break;
          case Ve:
            i2 = r2.length - 2, a2 = e2 + r2[i2] - r2[i2 + 1];
            break;
          default:
            i2 = t2, a2 = n2;
        }
        if (void 0 === s2) switch (this.getSettings_().endingEnd) {
          case je:
            o2 = t2, s2 = 2 * n2 - e2;
            break;
          case Ve:
            o2 = 1, s2 = n2 + r2[1] - r2[0];
            break;
          default:
            o2 = t2 - 1, s2 = e2;
        }
        const c2 = 0.5 * (n2 - e2), u2 = this.valueSize;
        this._weightPrev = c2 / (e2 - a2), this._weightNext = c2 / (s2 - n2), this._offsetPrev = i2 * u2, this._offsetNext = o2 * u2;
      }, interpolate_: function(t2, e2, n2, r2) {
        const i2 = this.resultBuffer, o2 = this.sampleValues, a2 = this.valueSize, s2 = t2 * a2, c2 = s2 - a2, u2 = this._offsetPrev, l2 = this._offsetNext, h2 = this._weightPrev, d2 = this._weightNext, p2 = (n2 - e2) / (r2 - e2), f2 = p2 * p2, m2 = f2 * p2, g2 = -h2 * m2 + 2 * h2 * f2 - h2 * p2, v2 = (1 + h2) * m2 + (-1.5 - 2 * h2) * f2 + (-0.5 + h2) * p2 + 1, y2 = (-1 - d2) * m2 + (1.5 + d2) * f2 + 0.5 * p2, x2 = d2 * m2 - d2 * f2;
        for (let t3 = 0; t3 !== a2; ++t3) i2[t3] = g2 * o2[u2 + t3] + v2 * o2[c2 + t3] + y2 * o2[s2 + t3] + x2 * o2[l2 + t3];
        return i2;
      } }), Pl.prototype = Object.assign(Object.create(Cl.prototype), { constructor: Pl, interpolate_: function(t2, e2, n2, r2) {
        const i2 = this.resultBuffer, o2 = this.sampleValues, a2 = this.valueSize, s2 = t2 * a2, c2 = s2 - a2, u2 = (n2 - e2) / (r2 - e2), l2 = 1 - u2;
        for (let t3 = 0; t3 !== a2; ++t3) i2[t3] = o2[c2 + t3] * l2 + o2[s2 + t3] * u2;
        return i2;
      } }), Rl.prototype = Object.assign(Object.create(Cl.prototype), { constructor: Rl, interpolate_: function(t2) {
        return this.copySampleValue_(t2 - 1);
      } }), Object.assign(Ol, { toJSON: function(t2) {
        const e2 = t2.constructor;
        let n2;
        if (void 0 !== e2.toJSON) n2 = e2.toJSON(t2);
        else {
          n2 = { name: t2.name, times: Al.convertArray(t2.times, Array), values: Al.convertArray(t2.values, Array) };
          const e3 = t2.getInterpolation();
          e3 !== t2.DefaultInterpolation && (n2.interpolation = e3);
        }
        return n2.type = t2.ValueTypeName, n2;
      } }), Object.assign(Ol.prototype, { constructor: Ol, TimeBufferType: Float32Array, ValueBufferType: Float32Array, DefaultInterpolation: He, InterpolantFactoryMethodDiscrete: function(t2) {
        return new Rl(this.times, this.values, this.getValueSize(), t2);
      }, InterpolantFactoryMethodLinear: function(t2) {
        return new Pl(this.times, this.values, this.getValueSize(), t2);
      }, InterpolantFactoryMethodSmooth: function(t2) {
        return new Ll(this.times, this.values, this.getValueSize(), t2);
      }, setInterpolation: function(t2) {
        let e2;
        switch (t2) {
          case Be:
            e2 = this.InterpolantFactoryMethodDiscrete;
            break;
          case He:
            e2 = this.InterpolantFactoryMethodLinear;
            break;
          case Ge:
            e2 = this.InterpolantFactoryMethodSmooth;
        }
        if (void 0 === e2) {
          const e3 = "unsupported interpolation for " + this.ValueTypeName + " keyframe track named " + this.name;
          if (void 0 === this.createInterpolant) {
            if (t2 === this.DefaultInterpolation) throw new Error(e3);
            this.setInterpolation(this.DefaultInterpolation);
          }
          return console.warn("THREE.KeyframeTrack:", e3), this;
        }
        return this.createInterpolant = e2, this;
      }, getInterpolation: function() {
        switch (this.createInterpolant) {
          case this.InterpolantFactoryMethodDiscrete:
            return Be;
          case this.InterpolantFactoryMethodLinear:
            return He;
          case this.InterpolantFactoryMethodSmooth:
            return Ge;
        }
      }, getValueSize: function() {
        return this.values.length / this.times.length;
      }, shift: function(t2) {
        if (0 !== t2) {
          const e2 = this.times;
          for (let n2 = 0, r2 = e2.length; n2 !== r2; ++n2) e2[n2] += t2;
        }
        return this;
      }, scale: function(t2) {
        if (1 !== t2) {
          const e2 = this.times;
          for (let n2 = 0, r2 = e2.length; n2 !== r2; ++n2) e2[n2] *= t2;
        }
        return this;
      }, trim: function(t2, e2) {
        const n2 = this.times, r2 = n2.length;
        let i2 = 0, o2 = r2 - 1;
        for (; i2 !== r2 && n2[i2] < t2; ) ++i2;
        for (; -1 !== o2 && n2[o2] > e2; ) --o2;
        if (++o2, 0 !== i2 || o2 !== r2) {
          i2 >= o2 && (o2 = Math.max(o2, 1), i2 = o2 - 1);
          const t3 = this.getValueSize();
          this.times = Al.arraySlice(n2, i2, o2), this.values = Al.arraySlice(this.values, i2 * t3, o2 * t3);
        }
        return this;
      }, validate: function() {
        let t2 = true;
        const e2 = this.getValueSize();
        e2 - Math.floor(e2) != 0 && (console.error("THREE.KeyframeTrack: Invalid value size in track.", this), t2 = false);
        const n2 = this.times, r2 = this.values, i2 = n2.length;
        0 === i2 && (console.error("THREE.KeyframeTrack: Track is empty.", this), t2 = false);
        let o2 = null;
        for (let e3 = 0; e3 !== i2; e3++) {
          const r3 = n2[e3];
          if ("number" == typeof r3 && isNaN(r3)) {
            console.error("THREE.KeyframeTrack: Time is not a valid number.", this, e3, r3), t2 = false;
            break;
          }
          if (null !== o2 && o2 > r3) {
            console.error("THREE.KeyframeTrack: Out of order keys.", this, e3, r3, o2), t2 = false;
            break;
          }
          o2 = r3;
        }
        if (void 0 !== r2 && Al.isTypedArray(r2)) for (let e3 = 0, n3 = r2.length; e3 !== n3; ++e3) {
          const n4 = r2[e3];
          if (isNaN(n4)) {
            console.error("THREE.KeyframeTrack: Value is not a valid number.", this, e3, n4), t2 = false;
            break;
          }
        }
        return t2;
      }, optimize: function() {
        const t2 = Al.arraySlice(this.times), e2 = Al.arraySlice(this.values), n2 = this.getValueSize(), r2 = this.getInterpolation() === Ge, i2 = t2.length - 1;
        let o2 = 1;
        for (let a2 = 1; a2 < i2; ++a2) {
          let i3 = false;
          const s2 = t2[a2];
          if (s2 !== t2[a2 + 1] && (1 !== a2 || s2 !== s2[0])) if (r2) i3 = true;
          else {
            const t3 = a2 * n2, r3 = t3 - n2, o3 = t3 + n2;
            for (let a3 = 0; a3 !== n2; ++a3) {
              const n3 = e2[t3 + a3];
              if (n3 !== e2[r3 + a3] || n3 !== e2[o3 + a3]) {
                i3 = true;
                break;
              }
            }
          }
          if (i3) {
            if (a2 !== o2) {
              t2[o2] = t2[a2];
              const r3 = a2 * n2, i4 = o2 * n2;
              for (let t3 = 0; t3 !== n2; ++t3) e2[i4 + t3] = e2[r3 + t3];
            }
            ++o2;
          }
        }
        if (i2 > 0) {
          t2[o2] = t2[i2];
          for (let t3 = i2 * n2, r3 = o2 * n2, a2 = 0; a2 !== n2; ++a2) e2[r3 + a2] = e2[t3 + a2];
          ++o2;
        }
        return o2 !== t2.length ? (this.times = Al.arraySlice(t2, 0, o2), this.values = Al.arraySlice(e2, 0, o2 * n2)) : (this.times = t2, this.values = e2), this;
      }, clone: function() {
        const t2 = Al.arraySlice(this.times, 0), e2 = Al.arraySlice(this.values, 0), n2 = new (0, this.constructor)(this.name, t2, e2);
        return n2.createInterpolant = this.createInterpolant, n2;
      } }), Dl.prototype = Object.assign(Object.create(Ol.prototype), { constructor: Dl, ValueTypeName: "bool", ValueBufferType: Array, DefaultInterpolation: Be, InterpolantFactoryMethodLinear: void 0, InterpolantFactoryMethodSmooth: void 0 }), Il.prototype = Object.assign(Object.create(Ol.prototype), { constructor: Il, ValueTypeName: "color" }), Nl.prototype = Object.assign(Object.create(Ol.prototype), { constructor: Nl, ValueTypeName: "number" }), zl.prototype = Object.assign(Object.create(Cl.prototype), { constructor: zl, interpolate_: function(t2, e2, n2, r2) {
        const i2 = this.resultBuffer, o2 = this.sampleValues, a2 = this.valueSize, s2 = (n2 - e2) / (r2 - e2);
        let c2 = t2 * a2;
        for (let t3 = c2 + a2; c2 !== t3; c2 += 4) Jn.slerpFlat(i2, 0, o2, c2 - a2, o2, c2, s2);
        return i2;
      } }), kl.prototype = Object.assign(Object.create(Ol.prototype), { constructor: kl, ValueTypeName: "quaternion", DefaultInterpolation: He, InterpolantFactoryMethodLinear: function(t2) {
        return new zl(this.times, this.values, this.getValueSize(), t2);
      }, InterpolantFactoryMethodSmooth: void 0 }), Fl.prototype = Object.assign(Object.create(Ol.prototype), { constructor: Fl, ValueTypeName: "string", ValueBufferType: Array, DefaultInterpolation: Be, InterpolantFactoryMethodLinear: void 0, InterpolantFactoryMethodSmooth: void 0 }), Bl.prototype = Object.assign(Object.create(Ol.prototype), { constructor: Bl, ValueTypeName: "vector" }), Object.assign(Hl, { parse: function(t2) {
        const e2 = [], n2 = t2.tracks, r2 = 1 / (t2.fps || 1);
        for (let t3 = 0, i3 = n2.length; t3 !== i3; ++t3) e2.push(Gl(n2[t3]).scale(r2));
        const i2 = new Hl(t2.name, t2.duration, e2, t2.blendMode);
        return i2.uuid = t2.uuid, i2;
      }, toJSON: function(t2) {
        const e2 = [], n2 = t2.tracks, r2 = { name: t2.name, duration: t2.duration, tracks: e2, uuid: t2.uuid, blendMode: t2.blendMode };
        for (let t3 = 0, r3 = n2.length; t3 !== r3; ++t3) e2.push(Ol.toJSON(n2[t3]));
        return r2;
      }, CreateFromMorphTargetSequence: function(t2, e2, n2, r2) {
        const i2 = e2.length, o2 = [];
        for (let t3 = 0; t3 < i2; t3++) {
          let a2 = [], s2 = [];
          a2.push((t3 + i2 - 1) % i2, t3, (t3 + 1) % i2), s2.push(0, 1, 0);
          const c2 = Al.getKeyframeOrder(a2);
          a2 = Al.sortedArray(a2, 1, c2), s2 = Al.sortedArray(s2, 1, c2), r2 || 0 !== a2[0] || (a2.push(i2), s2.push(s2[0])), o2.push(new Nl(".morphTargetInfluences[" + e2[t3].name + "]", a2, s2).scale(1 / n2));
        }
        return new Hl(t2, -1, o2);
      }, findByName: function(t2, e2) {
        let n2 = t2;
        if (!Array.isArray(t2)) {
          const e3 = t2;
          n2 = e3.geometry && e3.geometry.animations || e3.animations;
        }
        for (let t3 = 0; t3 < n2.length; t3++) if (n2[t3].name === e2) return n2[t3];
        return null;
      }, CreateClipsFromMorphTargetSequences: function(t2, e2, n2) {
        const r2 = {}, i2 = /^([\w-]*?)([\d]+)$/;
        for (let e3 = 0, n3 = t2.length; e3 < n3; e3++) {
          const n4 = t2[e3], o3 = n4.name.match(i2);
          if (o3 && o3.length > 1) {
            const t3 = o3[1];
            let e4 = r2[t3];
            e4 || (r2[t3] = e4 = []), e4.push(n4);
          }
        }
        const o2 = [];
        for (const t3 in r2) o2.push(Hl.CreateFromMorphTargetSequence(t3, r2[t3], e2, n2));
        return o2;
      }, parseAnimation: function(t2, e2) {
        if (!t2) return console.error("THREE.AnimationClip: No animation in JSONLoader data."), null;
        const n2 = function(t3, e3, n3, r3, i3) {
          if (0 !== n3.length) {
            const o3 = [], a3 = [];
            Al.flattenJSON(n3, o3, a3, r3), 0 !== o3.length && i3.push(new t3(e3, o3, a3));
          }
        }, r2 = [], i2 = t2.name || "default", o2 = t2.fps || 30, a2 = t2.blendMode;
        let s2 = t2.length || -1;
        const c2 = t2.hierarchy || [];
        for (let t3 = 0; t3 < c2.length; t3++) {
          const i3 = c2[t3].keys;
          if (i3 && 0 !== i3.length) if (i3[0].morphTargets) {
            const t4 = {};
            let e3;
            for (e3 = 0; e3 < i3.length; e3++) if (i3[e3].morphTargets) for (let n3 = 0; n3 < i3[e3].morphTargets.length; n3++) t4[i3[e3].morphTargets[n3]] = -1;
            for (const n3 in t4) {
              const t5 = [], o3 = [];
              for (let r3 = 0; r3 !== i3[e3].morphTargets.length; ++r3) {
                const r4 = i3[e3];
                t5.push(r4.time), o3.push(r4.morphTarget === n3 ? 1 : 0);
              }
              r2.push(new Nl(".morphTargetInfluence[" + n3 + "]", t5, o3));
            }
            s2 = t4.length * (o2 || 1);
          } else {
            const o3 = ".bones[" + e2[t3].name + "]";
            n2(Bl, o3 + ".position", i3, "pos", r2), n2(kl, o3 + ".quaternion", i3, "rot", r2), n2(Bl, o3 + ".scale", i3, "scl", r2);
          }
        }
        if (0 === r2.length) return null;
        return new Hl(i2, s2, r2, a2);
      } }), Object.assign(Hl.prototype, { resetDuration: function() {
        let t2 = 0;
        for (let e2 = 0, n2 = this.tracks.length; e2 !== n2; ++e2) {
          const n3 = this.tracks[e2];
          t2 = Math.max(t2, n3.times[n3.times.length - 1]);
        }
        return this.duration = t2, this;
      }, trim: function() {
        for (let t2 = 0; t2 < this.tracks.length; t2++) this.tracks[t2].trim(0, this.duration);
        return this;
      }, validate: function() {
        let t2 = true;
        for (let e2 = 0; e2 < this.tracks.length; e2++) t2 = t2 && this.tracks[e2].validate();
        return t2;
      }, optimize: function() {
        for (let t2 = 0; t2 < this.tracks.length; t2++) this.tracks[t2].optimize();
        return this;
      }, clone: function() {
        const t2 = [];
        for (let e2 = 0; e2 < this.tracks.length; e2++) t2.push(this.tracks[e2].clone());
        return new Hl(this.name, this.duration, t2, this.blendMode);
      }, toJSON: function() {
        return Hl.toJSON(this);
      } });
      const Ul = { enabled: false, files: {}, add: function(t2, e2) {
        false !== this.enabled && (this.files[t2] = e2);
      }, get: function(t2) {
        if (false !== this.enabled) return this.files[t2];
      }, remove: function(t2) {
        delete this.files[t2];
      }, clear: function() {
        this.files = {};
      } };
      function jl(t2, e2, n2) {
        const r2 = this;
        let i2 = false, o2 = 0, a2 = 0, s2 = void 0;
        const c2 = [];
        this.onStart = void 0, this.onLoad = t2, this.onProgress = e2, this.onError = n2, this.itemStart = function(t3) {
          a2++, false === i2 && void 0 !== r2.onStart && r2.onStart(t3, o2, a2), i2 = true;
        }, this.itemEnd = function(t3) {
          o2++, void 0 !== r2.onProgress && r2.onProgress(t3, o2, a2), o2 === a2 && (i2 = false, void 0 !== r2.onLoad && r2.onLoad());
        }, this.itemError = function(t3) {
          void 0 !== r2.onError && r2.onError(t3);
        }, this.resolveURL = function(t3) {
          return s2 ? s2(t3) : t3;
        }, this.setURLModifier = function(t3) {
          return s2 = t3, this;
        }, this.addHandler = function(t3, e3) {
          return c2.push(t3, e3), this;
        }, this.removeHandler = function(t3) {
          const e3 = c2.indexOf(t3);
          return -1 !== e3 && c2.splice(e3, 2), this;
        }, this.getHandler = function(t3) {
          for (let e3 = 0, n3 = c2.length; e3 < n3; e3 += 2) {
            const n4 = c2[e3], r3 = c2[e3 + 1];
            if (n4.global && (n4.lastIndex = 0), n4.test(t3)) return r3;
          }
          return null;
        };
      }
      const Vl = new jl();
      function Wl(t2) {
        this.manager = void 0 !== t2 ? t2 : Vl, this.crossOrigin = "anonymous", this.withCredentials = false, this.path = "", this.resourcePath = "", this.requestHeader = {};
      }
      Object.assign(Wl.prototype, { load: function() {
      }, loadAsync: function(t2, e2) {
        const n2 = this;
        return new Promise(function(r2, i2) {
          n2.load(t2, r2, e2, i2);
        });
      }, parse: function() {
      }, setCrossOrigin: function(t2) {
        return this.crossOrigin = t2, this;
      }, setWithCredentials: function(t2) {
        return this.withCredentials = t2, this;
      }, setPath: function(t2) {
        return this.path = t2, this;
      }, setResourcePath: function(t2) {
        return this.resourcePath = t2, this;
      }, setRequestHeader: function(t2) {
        return this.requestHeader = t2, this;
      } });
      const ql = {};
      function Xl(t2) {
        Wl.call(this, t2);
      }
      function Yl(t2) {
        Wl.call(this, t2);
      }
      function Zl(t2) {
        Wl.call(this, t2);
      }
      function Jl(t2) {
        Wl.call(this, t2);
      }
      function $l(t2) {
        Wl.call(this, t2);
      }
      function Ql(t2) {
        Wl.call(this, t2);
      }
      function Kl(t2) {
        Wl.call(this, t2);
      }
      function th() {
        this.type = "Curve", this.arcLengthDivisions = 200;
      }
      function eh(t2, e2, n2, r2, i2, o2, a2, s2) {
        th.call(this), this.type = "EllipseCurve", this.aX = t2 || 0, this.aY = e2 || 0, this.xRadius = n2 || 1, this.yRadius = r2 || 1, this.aStartAngle = i2 || 0, this.aEndAngle = o2 || 2 * Math.PI, this.aClockwise = a2 || false, this.aRotation = s2 || 0;
      }
      function nh(t2, e2, n2, r2, i2, o2) {
        eh.call(this, t2, e2, n2, n2, r2, i2, o2), this.type = "ArcCurve";
      }
      function rh() {
        let t2 = 0, e2 = 0, n2 = 0, r2 = 0;
        function i2(i3, o2, a2, s2) {
          t2 = i3, e2 = a2, n2 = -3 * i3 + 3 * o2 - 2 * a2 - s2, r2 = 2 * i3 - 2 * o2 + a2 + s2;
        }
        return { initCatmullRom: function(t3, e3, n3, r3, o2) {
          i2(e3, n3, o2 * (n3 - t3), o2 * (r3 - e3));
        }, initNonuniformCatmullRom: function(t3, e3, n3, r3, o2, a2, s2) {
          let c2 = (e3 - t3) / o2 - (n3 - t3) / (o2 + a2) + (n3 - e3) / a2, u2 = (n3 - e3) / a2 - (r3 - e3) / (a2 + s2) + (r3 - n3) / s2;
          c2 *= a2, u2 *= a2, i2(e3, n3, c2, u2);
        }, calc: function(i3) {
          const o2 = i3 * i3;
          return t2 + e2 * i3 + n2 * o2 + r2 * (o2 * i3);
        } };
      }
      Xl.prototype = Object.assign(Object.create(Wl.prototype), { constructor: Xl, load: function(t2, e2, n2, r2) {
        void 0 === t2 && (t2 = ""), void 0 !== this.path && (t2 = this.path + t2), t2 = this.manager.resolveURL(t2);
        const i2 = this, o2 = Ul.get(t2);
        if (void 0 !== o2) return i2.manager.itemStart(t2), setTimeout(function() {
          e2 && e2(o2), i2.manager.itemEnd(t2);
        }, 0), o2;
        if (void 0 !== ql[t2]) return void ql[t2].push({ onLoad: e2, onProgress: n2, onError: r2 });
        const a2 = t2.match(/^data:(.*?)(;base64)?,(.*)$/);
        let s2;
        if (a2) {
          const n3 = a2[1], o3 = !!a2[2];
          let s3 = a2[3];
          s3 = decodeURIComponent(s3), o3 && (s3 = atob(s3));
          try {
            let r3;
            const o4 = (this.responseType || "").toLowerCase();
            switch (o4) {
              case "arraybuffer":
              case "blob":
                const t3 = new Uint8Array(s3.length);
                for (let e4 = 0; e4 < s3.length; e4++) t3[e4] = s3.charCodeAt(e4);
                r3 = "blob" === o4 ? new Blob([t3.buffer], { type: n3 }) : t3.buffer;
                break;
              case "document":
                const e3 = new DOMParser();
                r3 = e3.parseFromString(s3, n3);
                break;
              case "json":
                r3 = JSON.parse(s3);
                break;
              default:
                r3 = s3;
            }
            setTimeout(function() {
              e2 && e2(r3), i2.manager.itemEnd(t2);
            }, 0);
          } catch (e3) {
            setTimeout(function() {
              r2 && r2(e3), i2.manager.itemError(t2), i2.manager.itemEnd(t2);
            }, 0);
          }
        } else {
          ql[t2] = [], ql[t2].push({ onLoad: e2, onProgress: n2, onError: r2 }), s2 = new XMLHttpRequest(), s2.open("GET", t2, true), s2.addEventListener("load", function(e3) {
            const n3 = this.response, r3 = ql[t2];
            if (delete ql[t2], 200 === this.status || 0 === this.status) {
              0 === this.status && console.warn("THREE.FileLoader: HTTP Status 0 received."), Ul.add(t2, n3);
              for (let t3 = 0, e4 = r3.length; t3 < e4; t3++) {
                const e5 = r3[t3];
                e5.onLoad && e5.onLoad(n3);
              }
              i2.manager.itemEnd(t2);
            } else {
              for (let t3 = 0, n4 = r3.length; t3 < n4; t3++) {
                const n5 = r3[t3];
                n5.onError && n5.onError(e3);
              }
              i2.manager.itemError(t2), i2.manager.itemEnd(t2);
            }
          }, false), s2.addEventListener("progress", function(e3) {
            const n3 = ql[t2];
            for (let t3 = 0, r3 = n3.length; t3 < r3; t3++) {
              const r4 = n3[t3];
              r4.onProgress && r4.onProgress(e3);
            }
          }, false), s2.addEventListener("error", function(e3) {
            const n3 = ql[t2];
            delete ql[t2];
            for (let t3 = 0, r3 = n3.length; t3 < r3; t3++) {
              const r4 = n3[t3];
              r4.onError && r4.onError(e3);
            }
            i2.manager.itemError(t2), i2.manager.itemEnd(t2);
          }, false), s2.addEventListener("abort", function(e3) {
            const n3 = ql[t2];
            delete ql[t2];
            for (let t3 = 0, r3 = n3.length; t3 < r3; t3++) {
              const r4 = n3[t3];
              r4.onError && r4.onError(e3);
            }
            i2.manager.itemError(t2), i2.manager.itemEnd(t2);
          }, false), void 0 !== this.responseType && (s2.responseType = this.responseType), void 0 !== this.withCredentials && (s2.withCredentials = this.withCredentials), s2.overrideMimeType && s2.overrideMimeType(void 0 !== this.mimeType ? this.mimeType : "text/plain");
          for (const t3 in this.requestHeader) s2.setRequestHeader(t3, this.requestHeader[t3]);
          s2.send(null);
        }
        return i2.manager.itemStart(t2), s2;
      }, setResponseType: function(t2) {
        return this.responseType = t2, this;
      }, setMimeType: function(t2) {
        return this.mimeType = t2, this;
      } }), Yl.prototype = Object.assign(Object.create(Wl.prototype), { constructor: Yl, load: function(t2, e2, n2, r2) {
        const i2 = this, o2 = new Xl(i2.manager);
        o2.setPath(i2.path), o2.setRequestHeader(i2.requestHeader), o2.setWithCredentials(i2.withCredentials), o2.load(t2, function(n3) {
          try {
            e2(i2.parse(JSON.parse(n3)));
          } catch (e3) {
            r2 ? r2(e3) : console.error(e3), i2.manager.itemError(t2);
          }
        }, n2, r2);
      }, parse: function(t2) {
        const e2 = [];
        for (let n2 = 0; n2 < t2.length; n2++) {
          const r2 = Hl.parse(t2[n2]);
          e2.push(r2);
        }
        return e2;
      } }), Zl.prototype = Object.assign(Object.create(Wl.prototype), { constructor: Zl, load: function(t2, e2, n2, r2) {
        const i2 = this, o2 = [], a2 = new Uc(), s2 = new Xl(this.manager);
        s2.setPath(this.path), s2.setResponseType("arraybuffer"), s2.setRequestHeader(this.requestHeader), s2.setWithCredentials(i2.withCredentials);
        let c2 = 0;
        function u2(u3) {
          s2.load(t2[u3], function(t3) {
            const n3 = i2.parse(t3, true);
            o2[u3] = { width: n3.width, height: n3.height, format: n3.format, mipmaps: n3.mipmaps }, c2 += 1, 6 === c2 && (1 === n3.mipmapCount && (a2.minFilter = xt), a2.image = o2, a2.format = n3.format, a2.needsUpdate = true, e2 && e2(a2));
          }, n2, r2);
        }
        if (Array.isArray(t2)) for (let e3 = 0, n3 = t2.length; e3 < n3; ++e3) u2(e3);
        else s2.load(t2, function(t3) {
          const n3 = i2.parse(t3, true);
          if (n3.isCubemap) {
            const t4 = n3.mipmaps.length / n3.mipmapCount;
            for (let e3 = 0; e3 < t4; e3++) {
              o2[e3] = { mipmaps: [] };
              for (let t5 = 0; t5 < n3.mipmapCount; t5++) o2[e3].mipmaps.push(n3.mipmaps[e3 * n3.mipmapCount + t5]), o2[e3].format = n3.format, o2[e3].width = n3.width, o2[e3].height = n3.height;
            }
            a2.image = o2;
          } else a2.image.width = n3.width, a2.image.height = n3.height, a2.mipmaps = n3.mipmaps;
          1 === n3.mipmapCount && (a2.minFilter = xt), a2.format = n3.format, a2.needsUpdate = true, e2 && e2(a2);
        }, n2, r2);
        return a2;
      } }), Jl.prototype = Object.assign(Object.create(Wl.prototype), { constructor: Jl, load: function(t2, e2, n2, r2) {
        void 0 !== this.path && (t2 = this.path + t2), t2 = this.manager.resolveURL(t2);
        const i2 = this, o2 = Ul.get(t2);
        if (void 0 !== o2) return i2.manager.itemStart(t2), setTimeout(function() {
          e2 && e2(o2), i2.manager.itemEnd(t2);
        }, 0), o2;
        const a2 = document.createElementNS("http://www.w3.org/1999/xhtml", "img");
        function s2() {
          a2.removeEventListener("load", s2, false), a2.removeEventListener("error", c2, false), Ul.add(t2, this), e2 && e2(this), i2.manager.itemEnd(t2);
        }
        function c2(e3) {
          a2.removeEventListener("load", s2, false), a2.removeEventListener("error", c2, false), r2 && r2(e3), i2.manager.itemError(t2), i2.manager.itemEnd(t2);
        }
        return a2.addEventListener("load", s2, false), a2.addEventListener("error", c2, false), "data:" !== t2.substr(0, 5) && void 0 !== this.crossOrigin && (a2.crossOrigin = this.crossOrigin), i2.manager.itemStart(t2), a2.src = t2, a2;
      } }), $l.prototype = Object.assign(Object.create(Wl.prototype), { constructor: $l, load: function(t2, e2, n2, r2) {
        const i2 = new Mo(), o2 = new Jl(this.manager);
        o2.setCrossOrigin(this.crossOrigin), o2.setPath(this.path);
        let a2 = 0;
        function s2(n3) {
          o2.load(t2[n3], function(t3) {
            i2.images[n3] = t3, a2++, 6 === a2 && (i2.needsUpdate = true, e2 && e2(i2));
          }, void 0, r2);
        }
        for (let e3 = 0; e3 < t2.length; ++e3) s2(e3);
        return i2;
      } }), Ql.prototype = Object.assign(Object.create(Wl.prototype), { constructor: Ql, load: function(t2, e2, n2, r2) {
        const i2 = this, o2 = new To(), a2 = new Xl(this.manager);
        return a2.setResponseType("arraybuffer"), a2.setRequestHeader(this.requestHeader), a2.setPath(this.path), a2.setWithCredentials(i2.withCredentials), a2.load(t2, function(t3) {
          const n3 = i2.parse(t3);
          n3 && (void 0 !== n3.image ? o2.image = n3.image : void 0 !== n3.data && (o2.image.width = n3.width, o2.image.height = n3.height, o2.image.data = n3.data), o2.wrapS = void 0 !== n3.wrapS ? n3.wrapS : dt, o2.wrapT = void 0 !== n3.wrapT ? n3.wrapT : dt, o2.magFilter = void 0 !== n3.magFilter ? n3.magFilter : xt, o2.minFilter = void 0 !== n3.minFilter ? n3.minFilter : xt, o2.anisotropy = void 0 !== n3.anisotropy ? n3.anisotropy : 1, void 0 !== n3.format && (o2.format = n3.format), void 0 !== n3.type && (o2.type = n3.type), void 0 !== n3.mipmaps && (o2.mipmaps = n3.mipmaps, o2.minFilter = _t), 1 === n3.mipmapCount && (o2.minFilter = xt), o2.needsUpdate = true, e2 && e2(o2, n3));
        }, n2, r2), o2;
      } }), Kl.prototype = Object.assign(Object.create(Wl.prototype), { constructor: Kl, load: function(t2, e2, n2, r2) {
        const i2 = new Wn(), o2 = new Jl(this.manager);
        return o2.setCrossOrigin(this.crossOrigin), o2.setPath(this.path), o2.load(t2, function(n3) {
          i2.image = n3;
          const r3 = t2.search(/\.jpe?g($|\?)/i) > 0 || 0 === t2.search(/^data\:image\/jpeg/);
          i2.format = r3 ? kt : Ft, i2.needsUpdate = true, void 0 !== e2 && e2(i2);
        }, n2, r2), i2;
      } }), Object.assign(th.prototype, { getPoint: function() {
        return console.warn("THREE.Curve: .getPoint() not implemented."), null;
      }, getPointAt: function(t2, e2) {
        const n2 = this.getUtoTmapping(t2);
        return this.getPoint(n2, e2);
      }, getPoints: function(t2 = 5) {
        const e2 = [];
        for (let n2 = 0; n2 <= t2; n2++) e2.push(this.getPoint(n2 / t2));
        return e2;
      }, getSpacedPoints: function(t2 = 5) {
        const e2 = [];
        for (let n2 = 0; n2 <= t2; n2++) e2.push(this.getPointAt(n2 / t2));
        return e2;
      }, getLength: function() {
        const t2 = this.getLengths();
        return t2[t2.length - 1];
      }, getLengths: function(t2) {
        if (void 0 === t2 && (t2 = this.arcLengthDivisions), this.cacheArcLengths && this.cacheArcLengths.length === t2 + 1 && !this.needsUpdate) return this.cacheArcLengths;
        this.needsUpdate = false;
        const e2 = [];
        let n2, r2 = this.getPoint(0), i2 = 0;
        e2.push(0);
        for (let o2 = 1; o2 <= t2; o2++) n2 = this.getPoint(o2 / t2), i2 += n2.distanceTo(r2), e2.push(i2), r2 = n2;
        return this.cacheArcLengths = e2, e2;
      }, updateArcLengths: function() {
        this.needsUpdate = true, this.getLengths();
      }, getUtoTmapping: function(t2, e2) {
        const n2 = this.getLengths();
        let r2 = 0;
        const i2 = n2.length;
        let o2;
        o2 = e2 || t2 * n2[i2 - 1];
        let a2, s2 = 0, c2 = i2 - 1;
        for (; s2 <= c2; ) if (r2 = Math.floor(s2 + (c2 - s2) / 2), a2 = n2[r2] - o2, a2 < 0) s2 = r2 + 1;
        else {
          if (!(a2 > 0)) {
            c2 = r2;
            break;
          }
          c2 = r2 - 1;
        }
        if (r2 = c2, n2[r2] === o2) return r2 / (i2 - 1);
        const u2 = n2[r2];
        return (r2 + (o2 - u2) / (n2[r2 + 1] - u2)) / (i2 - 1);
      }, getTangent: function(t2, e2) {
        let n2 = t2 - 1e-4, r2 = t2 + 1e-4;
        n2 < 0 && (n2 = 0), r2 > 1 && (r2 = 1);
        const i2 = this.getPoint(n2), o2 = this.getPoint(r2), a2 = e2 || (i2.isVector2 ? new Hn() : new $n());
        return a2.copy(o2).sub(i2).normalize(), a2;
      }, getTangentAt: function(t2, e2) {
        const n2 = this.getUtoTmapping(t2);
        return this.getTangent(n2, e2);
      }, computeFrenetFrames: function(t2, e2) {
        const n2 = new $n(), r2 = [], i2 = [], o2 = [], a2 = new $n(), s2 = new Tr();
        for (let e3 = 0; e3 <= t2; e3++) {
          const n3 = e3 / t2;
          r2[e3] = this.getTangentAt(n3, new $n()), r2[e3].normalize();
        }
        i2[0] = new $n(), o2[0] = new $n();
        let c2 = Number.MAX_VALUE;
        const u2 = Math.abs(r2[0].x), l2 = Math.abs(r2[0].y), h2 = Math.abs(r2[0].z);
        u2 <= c2 && (c2 = u2, n2.set(1, 0, 0)), l2 <= c2 && (c2 = l2, n2.set(0, 1, 0)), h2 <= c2 && n2.set(0, 0, 1), a2.crossVectors(r2[0], n2).normalize(), i2[0].crossVectors(r2[0], a2), o2[0].crossVectors(r2[0], i2[0]);
        for (let e3 = 1; e3 <= t2; e3++) {
          if (i2[e3] = i2[e3 - 1].clone(), o2[e3] = o2[e3 - 1].clone(), a2.crossVectors(r2[e3 - 1], r2[e3]), a2.length() > Number.EPSILON) {
            a2.normalize();
            const t3 = Math.acos(Bn.clamp(r2[e3 - 1].dot(r2[e3]), -1, 1));
            i2[e3].applyMatrix4(s2.makeRotationAxis(a2, t3));
          }
          o2[e3].crossVectors(r2[e3], i2[e3]);
        }
        if (true === e2) {
          let e3 = Math.acos(Bn.clamp(i2[0].dot(i2[t2]), -1, 1));
          e3 /= t2, r2[0].dot(a2.crossVectors(i2[0], i2[t2])) > 0 && (e3 = -e3);
          for (let n3 = 1; n3 <= t2; n3++) i2[n3].applyMatrix4(s2.makeRotationAxis(r2[n3], e3 * n3)), o2[n3].crossVectors(r2[n3], i2[n3]);
        }
        return { tangents: r2, normals: i2, binormals: o2 };
      }, clone: function() {
        return new this.constructor().copy(this);
      }, copy: function(t2) {
        return this.arcLengthDivisions = t2.arcLengthDivisions, this;
      }, toJSON: function() {
        const t2 = { metadata: { version: 4.5, type: "Curve", generator: "Curve.toJSON" } };
        return t2.arcLengthDivisions = this.arcLengthDivisions, t2.type = this.type, t2;
      }, fromJSON: function(t2) {
        return this.arcLengthDivisions = t2.arcLengthDivisions, this;
      } }), eh.prototype = Object.create(th.prototype), eh.prototype.constructor = eh, eh.prototype.isEllipseCurve = true, eh.prototype.getPoint = function(t2, e2) {
        const n2 = e2 || new Hn(), r2 = 2 * Math.PI;
        let i2 = this.aEndAngle - this.aStartAngle;
        const o2 = Math.abs(i2) < Number.EPSILON;
        for (; i2 < 0; ) i2 += r2;
        for (; i2 > r2; ) i2 -= r2;
        i2 < Number.EPSILON && (i2 = o2 ? 0 : r2), true !== this.aClockwise || o2 || (i2 === r2 ? i2 = -r2 : i2 -= r2);
        const a2 = this.aStartAngle + t2 * i2;
        let s2 = this.aX + this.xRadius * Math.cos(a2), c2 = this.aY + this.yRadius * Math.sin(a2);
        if (0 !== this.aRotation) {
          const t3 = Math.cos(this.aRotation), e3 = Math.sin(this.aRotation), n3 = s2 - this.aX, r3 = c2 - this.aY;
          s2 = n3 * t3 - r3 * e3 + this.aX, c2 = n3 * e3 + r3 * t3 + this.aY;
        }
        return n2.set(s2, c2);
      }, eh.prototype.copy = function(t2) {
        return th.prototype.copy.call(this, t2), this.aX = t2.aX, this.aY = t2.aY, this.xRadius = t2.xRadius, this.yRadius = t2.yRadius, this.aStartAngle = t2.aStartAngle, this.aEndAngle = t2.aEndAngle, this.aClockwise = t2.aClockwise, this.aRotation = t2.aRotation, this;
      }, eh.prototype.toJSON = function() {
        const t2 = th.prototype.toJSON.call(this);
        return t2.aX = this.aX, t2.aY = this.aY, t2.xRadius = this.xRadius, t2.yRadius = this.yRadius, t2.aStartAngle = this.aStartAngle, t2.aEndAngle = this.aEndAngle, t2.aClockwise = this.aClockwise, t2.aRotation = this.aRotation, t2;
      }, eh.prototype.fromJSON = function(t2) {
        return th.prototype.fromJSON.call(this, t2), this.aX = t2.aX, this.aY = t2.aY, this.xRadius = t2.xRadius, this.yRadius = t2.yRadius, this.aStartAngle = t2.aStartAngle, this.aEndAngle = t2.aEndAngle, this.aClockwise = t2.aClockwise, this.aRotation = t2.aRotation, this;
      }, nh.prototype = Object.create(eh.prototype), nh.prototype.constructor = nh, nh.prototype.isArcCurve = true;
      const ih = new $n(), oh = new rh(), ah = new rh(), sh = new rh();
      function ch(t2 = [], e2 = false, n2 = "centripetal", r2 = 0.5) {
        th.call(this), this.type = "CatmullRomCurve3", this.points = t2, this.closed = e2, this.curveType = n2, this.tension = r2;
      }
      function uh(t2, e2, n2, r2, i2) {
        const o2 = 0.5 * (r2 - e2), a2 = 0.5 * (i2 - n2), s2 = t2 * t2;
        return (2 * n2 - 2 * r2 + o2 + a2) * (t2 * s2) + (-3 * n2 + 3 * r2 - 2 * o2 - a2) * s2 + o2 * t2 + n2;
      }
      function lh(t2, e2, n2, r2) {
        return function(t3, e3) {
          const n3 = 1 - t3;
          return n3 * n3 * e3;
        }(t2, e2) + function(t3, e3) {
          return 2 * (1 - t3) * t3 * e3;
        }(t2, n2) + function(t3, e3) {
          return t3 * t3 * e3;
        }(t2, r2);
      }
      function hh(t2, e2, n2, r2, i2) {
        return function(t3, e3) {
          const n3 = 1 - t3;
          return n3 * n3 * n3 * e3;
        }(t2, e2) + function(t3, e3) {
          const n3 = 1 - t3;
          return 3 * n3 * n3 * t3 * e3;
        }(t2, n2) + function(t3, e3) {
          return 3 * (1 - t3) * t3 * t3 * e3;
        }(t2, r2) + function(t3, e3) {
          return t3 * t3 * t3 * e3;
        }(t2, i2);
      }
      function dh(t2 = new Hn(), e2 = new Hn(), n2 = new Hn(), r2 = new Hn()) {
        th.call(this), this.type = "CubicBezierCurve", this.v0 = t2, this.v1 = e2, this.v2 = n2, this.v3 = r2;
      }
      function ph(t2 = new $n(), e2 = new $n(), n2 = new $n(), r2 = new $n()) {
        th.call(this), this.type = "CubicBezierCurve3", this.v0 = t2, this.v1 = e2, this.v2 = n2, this.v3 = r2;
      }
      function fh(t2 = new Hn(), e2 = new Hn()) {
        th.call(this), this.type = "LineCurve", this.v1 = t2, this.v2 = e2;
      }
      function mh(t2 = new $n(), e2 = new $n()) {
        th.call(this), this.type = "LineCurve3", this.v1 = t2, this.v2 = e2;
      }
      function gh(t2 = new Hn(), e2 = new Hn(), n2 = new Hn()) {
        th.call(this), this.type = "QuadraticBezierCurve", this.v0 = t2, this.v1 = e2, this.v2 = n2;
      }
      function vh(t2 = new $n(), e2 = new $n(), n2 = new $n()) {
        th.call(this), this.type = "QuadraticBezierCurve3", this.v0 = t2, this.v1 = e2, this.v2 = n2;
      }
      function yh(t2 = []) {
        th.call(this), this.type = "SplineCurve", this.points = t2;
      }
      ch.prototype = Object.create(th.prototype), ch.prototype.constructor = ch, ch.prototype.isCatmullRomCurve3 = true, ch.prototype.getPoint = function(t2, e2 = new $n()) {
        const n2 = e2, r2 = this.points, i2 = r2.length, o2 = (i2 - (this.closed ? 0 : 1)) * t2;
        let a2, s2, c2 = Math.floor(o2), u2 = o2 - c2;
        this.closed ? c2 += c2 > 0 ? 0 : (Math.floor(Math.abs(c2) / i2) + 1) * i2 : 0 === u2 && c2 === i2 - 1 && (c2 = i2 - 2, u2 = 1), this.closed || c2 > 0 ? a2 = r2[(c2 - 1) % i2] : (ih.subVectors(r2[0], r2[1]).add(r2[0]), a2 = ih);
        const l2 = r2[c2 % i2], h2 = r2[(c2 + 1) % i2];
        if (this.closed || c2 + 2 < i2 ? s2 = r2[(c2 + 2) % i2] : (ih.subVectors(r2[i2 - 1], r2[i2 - 2]).add(r2[i2 - 1]), s2 = ih), "centripetal" === this.curveType || "chordal" === this.curveType) {
          const t3 = "chordal" === this.curveType ? 0.5 : 0.25;
          let e3 = Math.pow(a2.distanceToSquared(l2), t3), n3 = Math.pow(l2.distanceToSquared(h2), t3), r3 = Math.pow(h2.distanceToSquared(s2), t3);
          n3 < 1e-4 && (n3 = 1), e3 < 1e-4 && (e3 = n3), r3 < 1e-4 && (r3 = n3), oh.initNonuniformCatmullRom(a2.x, l2.x, h2.x, s2.x, e3, n3, r3), ah.initNonuniformCatmullRom(a2.y, l2.y, h2.y, s2.y, e3, n3, r3), sh.initNonuniformCatmullRom(a2.z, l2.z, h2.z, s2.z, e3, n3, r3);
        } else "catmullrom" === this.curveType && (oh.initCatmullRom(a2.x, l2.x, h2.x, s2.x, this.tension), ah.initCatmullRom(a2.y, l2.y, h2.y, s2.y, this.tension), sh.initCatmullRom(a2.z, l2.z, h2.z, s2.z, this.tension));
        return n2.set(oh.calc(u2), ah.calc(u2), sh.calc(u2)), n2;
      }, ch.prototype.copy = function(t2) {
        th.prototype.copy.call(this, t2), this.points = [];
        for (let e2 = 0, n2 = t2.points.length; e2 < n2; e2++) {
          const n3 = t2.points[e2];
          this.points.push(n3.clone());
        }
        return this.closed = t2.closed, this.curveType = t2.curveType, this.tension = t2.tension, this;
      }, ch.prototype.toJSON = function() {
        const t2 = th.prototype.toJSON.call(this);
        t2.points = [];
        for (let e2 = 0, n2 = this.points.length; e2 < n2; e2++) {
          const n3 = this.points[e2];
          t2.points.push(n3.toArray());
        }
        return t2.closed = this.closed, t2.curveType = this.curveType, t2.tension = this.tension, t2;
      }, ch.prototype.fromJSON = function(t2) {
        th.prototype.fromJSON.call(this, t2), this.points = [];
        for (let e2 = 0, n2 = t2.points.length; e2 < n2; e2++) {
          const n3 = t2.points[e2];
          this.points.push(new $n().fromArray(n3));
        }
        return this.closed = t2.closed, this.curveType = t2.curveType, this.tension = t2.tension, this;
      }, dh.prototype = Object.create(th.prototype), dh.prototype.constructor = dh, dh.prototype.isCubicBezierCurve = true, dh.prototype.getPoint = function(t2, e2 = new Hn()) {
        const n2 = e2, r2 = this.v0, i2 = this.v1, o2 = this.v2, a2 = this.v3;
        return n2.set(hh(t2, r2.x, i2.x, o2.x, a2.x), hh(t2, r2.y, i2.y, o2.y, a2.y)), n2;
      }, dh.prototype.copy = function(t2) {
        return th.prototype.copy.call(this, t2), this.v0.copy(t2.v0), this.v1.copy(t2.v1), this.v2.copy(t2.v2), this.v3.copy(t2.v3), this;
      }, dh.prototype.toJSON = function() {
        const t2 = th.prototype.toJSON.call(this);
        return t2.v0 = this.v0.toArray(), t2.v1 = this.v1.toArray(), t2.v2 = this.v2.toArray(), t2.v3 = this.v3.toArray(), t2;
      }, dh.prototype.fromJSON = function(t2) {
        return th.prototype.fromJSON.call(this, t2), this.v0.fromArray(t2.v0), this.v1.fromArray(t2.v1), this.v2.fromArray(t2.v2), this.v3.fromArray(t2.v3), this;
      }, ph.prototype = Object.create(th.prototype), ph.prototype.constructor = ph, ph.prototype.isCubicBezierCurve3 = true, ph.prototype.getPoint = function(t2, e2 = new $n()) {
        const n2 = e2, r2 = this.v0, i2 = this.v1, o2 = this.v2, a2 = this.v3;
        return n2.set(hh(t2, r2.x, i2.x, o2.x, a2.x), hh(t2, r2.y, i2.y, o2.y, a2.y), hh(t2, r2.z, i2.z, o2.z, a2.z)), n2;
      }, ph.prototype.copy = function(t2) {
        return th.prototype.copy.call(this, t2), this.v0.copy(t2.v0), this.v1.copy(t2.v1), this.v2.copy(t2.v2), this.v3.copy(t2.v3), this;
      }, ph.prototype.toJSON = function() {
        const t2 = th.prototype.toJSON.call(this);
        return t2.v0 = this.v0.toArray(), t2.v1 = this.v1.toArray(), t2.v2 = this.v2.toArray(), t2.v3 = this.v3.toArray(), t2;
      }, ph.prototype.fromJSON = function(t2) {
        return th.prototype.fromJSON.call(this, t2), this.v0.fromArray(t2.v0), this.v1.fromArray(t2.v1), this.v2.fromArray(t2.v2), this.v3.fromArray(t2.v3), this;
      }, fh.prototype = Object.create(th.prototype), fh.prototype.constructor = fh, fh.prototype.isLineCurve = true, fh.prototype.getPoint = function(t2, e2 = new Hn()) {
        const n2 = e2;
        return 1 === t2 ? n2.copy(this.v2) : (n2.copy(this.v2).sub(this.v1), n2.multiplyScalar(t2).add(this.v1)), n2;
      }, fh.prototype.getPointAt = function(t2, e2) {
        return this.getPoint(t2, e2);
      }, fh.prototype.getTangent = function(t2, e2) {
        const n2 = e2 || new Hn();
        return n2.copy(this.v2).sub(this.v1).normalize(), n2;
      }, fh.prototype.copy = function(t2) {
        return th.prototype.copy.call(this, t2), this.v1.copy(t2.v1), this.v2.copy(t2.v2), this;
      }, fh.prototype.toJSON = function() {
        const t2 = th.prototype.toJSON.call(this);
        return t2.v1 = this.v1.toArray(), t2.v2 = this.v2.toArray(), t2;
      }, fh.prototype.fromJSON = function(t2) {
        return th.prototype.fromJSON.call(this, t2), this.v1.fromArray(t2.v1), this.v2.fromArray(t2.v2), this;
      }, mh.prototype = Object.create(th.prototype), mh.prototype.constructor = mh, mh.prototype.isLineCurve3 = true, mh.prototype.getPoint = function(t2, e2 = new $n()) {
        const n2 = e2;
        return 1 === t2 ? n2.copy(this.v2) : (n2.copy(this.v2).sub(this.v1), n2.multiplyScalar(t2).add(this.v1)), n2;
      }, mh.prototype.getPointAt = function(t2, e2) {
        return this.getPoint(t2, e2);
      }, mh.prototype.copy = function(t2) {
        return th.prototype.copy.call(this, t2), this.v1.copy(t2.v1), this.v2.copy(t2.v2), this;
      }, mh.prototype.toJSON = function() {
        const t2 = th.prototype.toJSON.call(this);
        return t2.v1 = this.v1.toArray(), t2.v2 = this.v2.toArray(), t2;
      }, mh.prototype.fromJSON = function(t2) {
        return th.prototype.fromJSON.call(this, t2), this.v1.fromArray(t2.v1), this.v2.fromArray(t2.v2), this;
      }, gh.prototype = Object.create(th.prototype), gh.prototype.constructor = gh, gh.prototype.isQuadraticBezierCurve = true, gh.prototype.getPoint = function(t2, e2 = new Hn()) {
        const n2 = e2, r2 = this.v0, i2 = this.v1, o2 = this.v2;
        return n2.set(lh(t2, r2.x, i2.x, o2.x), lh(t2, r2.y, i2.y, o2.y)), n2;
      }, gh.prototype.copy = function(t2) {
        return th.prototype.copy.call(this, t2), this.v0.copy(t2.v0), this.v1.copy(t2.v1), this.v2.copy(t2.v2), this;
      }, gh.prototype.toJSON = function() {
        const t2 = th.prototype.toJSON.call(this);
        return t2.v0 = this.v0.toArray(), t2.v1 = this.v1.toArray(), t2.v2 = this.v2.toArray(), t2;
      }, gh.prototype.fromJSON = function(t2) {
        return th.prototype.fromJSON.call(this, t2), this.v0.fromArray(t2.v0), this.v1.fromArray(t2.v1), this.v2.fromArray(t2.v2), this;
      }, vh.prototype = Object.create(th.prototype), vh.prototype.constructor = vh, vh.prototype.isQuadraticBezierCurve3 = true, vh.prototype.getPoint = function(t2, e2 = new $n()) {
        const n2 = e2, r2 = this.v0, i2 = this.v1, o2 = this.v2;
        return n2.set(lh(t2, r2.x, i2.x, o2.x), lh(t2, r2.y, i2.y, o2.y), lh(t2, r2.z, i2.z, o2.z)), n2;
      }, vh.prototype.copy = function(t2) {
        return th.prototype.copy.call(this, t2), this.v0.copy(t2.v0), this.v1.copy(t2.v1), this.v2.copy(t2.v2), this;
      }, vh.prototype.toJSON = function() {
        const t2 = th.prototype.toJSON.call(this);
        return t2.v0 = this.v0.toArray(), t2.v1 = this.v1.toArray(), t2.v2 = this.v2.toArray(), t2;
      }, vh.prototype.fromJSON = function(t2) {
        return th.prototype.fromJSON.call(this, t2), this.v0.fromArray(t2.v0), this.v1.fromArray(t2.v1), this.v2.fromArray(t2.v2), this;
      }, yh.prototype = Object.create(th.prototype), yh.prototype.constructor = yh, yh.prototype.isSplineCurve = true, yh.prototype.getPoint = function(t2, e2 = new Hn()) {
        const n2 = e2, r2 = this.points, i2 = (r2.length - 1) * t2, o2 = Math.floor(i2), a2 = i2 - o2, s2 = r2[0 === o2 ? o2 : o2 - 1], c2 = r2[o2], u2 = r2[o2 > r2.length - 2 ? r2.length - 1 : o2 + 1], l2 = r2[o2 > r2.length - 3 ? r2.length - 1 : o2 + 2];
        return n2.set(uh(a2, s2.x, c2.x, u2.x, l2.x), uh(a2, s2.y, c2.y, u2.y, l2.y)), n2;
      }, yh.prototype.copy = function(t2) {
        th.prototype.copy.call(this, t2), this.points = [];
        for (let e2 = 0, n2 = t2.points.length; e2 < n2; e2++) {
          const n3 = t2.points[e2];
          this.points.push(n3.clone());
        }
        return this;
      }, yh.prototype.toJSON = function() {
        const t2 = th.prototype.toJSON.call(this);
        t2.points = [];
        for (let e2 = 0, n2 = this.points.length; e2 < n2; e2++) {
          const n3 = this.points[e2];
          t2.points.push(n3.toArray());
        }
        return t2;
      }, yh.prototype.fromJSON = function(t2) {
        th.prototype.fromJSON.call(this, t2), this.points = [];
        for (let e2 = 0, n2 = t2.points.length; e2 < n2; e2++) {
          const n3 = t2.points[e2];
          this.points.push(new Hn().fromArray(n3));
        }
        return this;
      };
      var xh = Object.freeze({ __proto__: null, ArcCurve: nh, CatmullRomCurve3: ch, CubicBezierCurve: dh, CubicBezierCurve3: ph, EllipseCurve: eh, LineCurve: fh, LineCurve3: mh, QuadraticBezierCurve: gh, QuadraticBezierCurve3: vh, SplineCurve: yh });
      function bh() {
        th.call(this), this.type = "CurvePath", this.curves = [], this.autoClose = false;
      }
      function wh(t2) {
        bh.call(this), this.type = "Path", this.currentPoint = new Hn(), t2 && this.setFromPoints(t2);
      }
      function _h(t2) {
        wh.call(this, t2), this.uuid = Bn.generateUUID(), this.type = "Shape", this.holes = [];
      }
      function Mh(t2, e2 = 1) {
        Jr.call(this), this.type = "Light", this.color = new yi(t2), this.intensity = e2;
      }
      function Sh(t2, e2, n2) {
        Mh.call(this, t2, n2), this.type = "HemisphereLight", this.position.copy(Jr.DefaultUp), this.updateMatrix(), this.groundColor = new yi(e2);
      }
      function Th(t2) {
        this.camera = t2, this.bias = 0, this.normalBias = 0, this.radius = 1, this.mapSize = new Hn(512, 512), this.map = null, this.mapPass = null, this.matrix = new Tr(), this.autoUpdate = true, this.needsUpdate = false, this._frustum = new Co(), this._frameExtents = new Hn(1, 1), this._viewportCount = 1, this._viewports = [new Xn(0, 0, 1, 1)];
      }
      function Eh() {
        Th.call(this, new wo(50, 1, 0.5, 500)), this.focus = 1;
      }
      function Ah(t2, e2, n2, r2, i2, o2) {
        Mh.call(this, t2, e2), this.type = "SpotLight", this.position.copy(Jr.DefaultUp), this.updateMatrix(), this.target = new Jr(), Object.defineProperty(this, "power", { get: function() {
          return this.intensity * Math.PI;
        }, set: function(t3) {
          this.intensity = t3 / Math.PI;
        } }), this.distance = void 0 !== n2 ? n2 : 0, this.angle = void 0 !== r2 ? r2 : Math.PI / 3, this.penumbra = void 0 !== i2 ? i2 : 0, this.decay = void 0 !== o2 ? o2 : 1, this.shadow = new Eh();
      }
      function Ch() {
        Th.call(this, new wo(90, 1, 0.5, 500)), this._frameExtents = new Hn(4, 2), this._viewportCount = 6, this._viewports = [new Xn(2, 1, 1, 1), new Xn(0, 1, 1, 1), new Xn(3, 1, 1, 1), new Xn(1, 1, 1, 1), new Xn(3, 0, 1, 1), new Xn(1, 0, 1, 1)], this._cubeDirections = [new $n(1, 0, 0), new $n(-1, 0, 0), new $n(0, 0, 1), new $n(0, 0, -1), new $n(0, 1, 0), new $n(0, -1, 0)], this._cubeUps = [new $n(0, 1, 0), new $n(0, 1, 0), new $n(0, 1, 0), new $n(0, 1, 0), new $n(0, 0, 1), new $n(0, 0, -1)];
      }
      function Lh(t2, e2, n2, r2) {
        Mh.call(this, t2, e2), this.type = "PointLight", Object.defineProperty(this, "power", { get: function() {
          return 4 * this.intensity * Math.PI;
        }, set: function(t3) {
          this.intensity = t3 / (4 * Math.PI);
        } }), this.distance = void 0 !== n2 ? n2 : 0, this.decay = void 0 !== r2 ? r2 : 1, this.shadow = new Ch();
      }
      function Ph(t2 = -1, e2 = 1, n2 = 1, r2 = -1, i2 = 0.1, o2 = 2e3) {
        bo.call(this), this.type = "OrthographicCamera", this.zoom = 1, this.view = null, this.left = t2, this.right = e2, this.top = n2, this.bottom = r2, this.near = i2, this.far = o2, this.updateProjectionMatrix();
      }
      function Rh() {
        Th.call(this, new Ph(-5, 5, 5, -5, 0.5, 500));
      }
      function Oh(t2, e2) {
        Mh.call(this, t2, e2), this.type = "DirectionalLight", this.position.copy(Jr.DefaultUp), this.updateMatrix(), this.target = new Jr(), this.shadow = new Rh();
      }
      function Dh(t2, e2) {
        Mh.call(this, t2, e2), this.type = "AmbientLight";
      }
      function Ih(t2, e2, n2, r2) {
        Mh.call(this, t2, e2), this.type = "RectAreaLight", this.width = void 0 !== n2 ? n2 : 10, this.height = void 0 !== r2 ? r2 : 10;
      }
      bh.prototype = Object.assign(Object.create(th.prototype), { constructor: bh, add: function(t2) {
        this.curves.push(t2);
      }, closePath: function() {
        const t2 = this.curves[0].getPoint(0), e2 = this.curves[this.curves.length - 1].getPoint(1);
        t2.equals(e2) || this.curves.push(new fh(e2, t2));
      }, getPoint: function(t2) {
        const e2 = t2 * this.getLength(), n2 = this.getCurveLengths();
        let r2 = 0;
        for (; r2 < n2.length; ) {
          if (n2[r2] >= e2) {
            const t3 = n2[r2] - e2, i2 = this.curves[r2], o2 = i2.getLength(), a2 = 0 === o2 ? 0 : 1 - t3 / o2;
            return i2.getPointAt(a2);
          }
          r2++;
        }
        return null;
      }, getLength: function() {
        const t2 = this.getCurveLengths();
        return t2[t2.length - 1];
      }, updateArcLengths: function() {
        this.needsUpdate = true, this.cacheLengths = null, this.getCurveLengths();
      }, getCurveLengths: function() {
        if (this.cacheLengths && this.cacheLengths.length === this.curves.length) return this.cacheLengths;
        const t2 = [];
        let e2 = 0;
        for (let n2 = 0, r2 = this.curves.length; n2 < r2; n2++) e2 += this.curves[n2].getLength(), t2.push(e2);
        return this.cacheLengths = t2, t2;
      }, getSpacedPoints: function(t2 = 40) {
        const e2 = [];
        for (let n2 = 0; n2 <= t2; n2++) e2.push(this.getPoint(n2 / t2));
        return this.autoClose && e2.push(e2[0]), e2;
      }, getPoints: function(t2 = 12) {
        const e2 = [];
        let n2;
        for (let r2 = 0, i2 = this.curves; r2 < i2.length; r2++) {
          const o2 = i2[r2], a2 = o2 && o2.isEllipseCurve ? 2 * t2 : o2 && (o2.isLineCurve || o2.isLineCurve3) ? 1 : o2 && o2.isSplineCurve ? t2 * o2.points.length : t2, s2 = o2.getPoints(a2);
          for (let t3 = 0; t3 < s2.length; t3++) {
            const r3 = s2[t3];
            n2 && n2.equals(r3) || (e2.push(r3), n2 = r3);
          }
        }
        return this.autoClose && e2.length > 1 && !e2[e2.length - 1].equals(e2[0]) && e2.push(e2[0]), e2;
      }, copy: function(t2) {
        th.prototype.copy.call(this, t2), this.curves = [];
        for (let e2 = 0, n2 = t2.curves.length; e2 < n2; e2++) {
          const n3 = t2.curves[e2];
          this.curves.push(n3.clone());
        }
        return this.autoClose = t2.autoClose, this;
      }, toJSON: function() {
        const t2 = th.prototype.toJSON.call(this);
        t2.autoClose = this.autoClose, t2.curves = [];
        for (let e2 = 0, n2 = this.curves.length; e2 < n2; e2++) {
          const n3 = this.curves[e2];
          t2.curves.push(n3.toJSON());
        }
        return t2;
      }, fromJSON: function(t2) {
        th.prototype.fromJSON.call(this, t2), this.autoClose = t2.autoClose, this.curves = [];
        for (let e2 = 0, n2 = t2.curves.length; e2 < n2; e2++) {
          const n3 = t2.curves[e2];
          this.curves.push(new xh[n3.type]().fromJSON(n3));
        }
        return this;
      } }), wh.prototype = Object.assign(Object.create(bh.prototype), { constructor: wh, setFromPoints: function(t2) {
        this.moveTo(t2[0].x, t2[0].y);
        for (let e2 = 1, n2 = t2.length; e2 < n2; e2++) this.lineTo(t2[e2].x, t2[e2].y);
        return this;
      }, moveTo: function(t2, e2) {
        return this.currentPoint.set(t2, e2), this;
      }, lineTo: function(t2, e2) {
        const n2 = new fh(this.currentPoint.clone(), new Hn(t2, e2));
        return this.curves.push(n2), this.currentPoint.set(t2, e2), this;
      }, quadraticCurveTo: function(t2, e2, n2, r2) {
        const i2 = new gh(this.currentPoint.clone(), new Hn(t2, e2), new Hn(n2, r2));
        return this.curves.push(i2), this.currentPoint.set(n2, r2), this;
      }, bezierCurveTo: function(t2, e2, n2, r2, i2, o2) {
        const a2 = new dh(this.currentPoint.clone(), new Hn(t2, e2), new Hn(n2, r2), new Hn(i2, o2));
        return this.curves.push(a2), this.currentPoint.set(i2, o2), this;
      }, splineThru: function(t2) {
        const e2 = new yh([this.currentPoint.clone()].concat(t2));
        return this.curves.push(e2), this.currentPoint.copy(t2[t2.length - 1]), this;
      }, arc: function(t2, e2, n2, r2, i2, o2) {
        const a2 = this.currentPoint.x, s2 = this.currentPoint.y;
        return this.absarc(t2 + a2, e2 + s2, n2, r2, i2, o2), this;
      }, absarc: function(t2, e2, n2, r2, i2, o2) {
        return this.absellipse(t2, e2, n2, n2, r2, i2, o2), this;
      }, ellipse: function(t2, e2, n2, r2, i2, o2, a2, s2) {
        const c2 = this.currentPoint.x, u2 = this.currentPoint.y;
        return this.absellipse(t2 + c2, e2 + u2, n2, r2, i2, o2, a2, s2), this;
      }, absellipse: function(t2, e2, n2, r2, i2, o2, a2, s2) {
        const c2 = new eh(t2, e2, n2, r2, i2, o2, a2, s2);
        if (this.curves.length > 0) {
          const t3 = c2.getPoint(0);
          t3.equals(this.currentPoint) || this.lineTo(t3.x, t3.y);
        }
        this.curves.push(c2);
        const u2 = c2.getPoint(1);
        return this.currentPoint.copy(u2), this;
      }, copy: function(t2) {
        return bh.prototype.copy.call(this, t2), this.currentPoint.copy(t2.currentPoint), this;
      }, toJSON: function() {
        const t2 = bh.prototype.toJSON.call(this);
        return t2.currentPoint = this.currentPoint.toArray(), t2;
      }, fromJSON: function(t2) {
        return bh.prototype.fromJSON.call(this, t2), this.currentPoint.fromArray(t2.currentPoint), this;
      } }), _h.prototype = Object.assign(Object.create(wh.prototype), { constructor: _h, getPointsHoles: function(t2) {
        const e2 = [];
        for (let n2 = 0, r2 = this.holes.length; n2 < r2; n2++) e2[n2] = this.holes[n2].getPoints(t2);
        return e2;
      }, extractPoints: function(t2) {
        return { shape: this.getPoints(t2), holes: this.getPointsHoles(t2) };
      }, copy: function(t2) {
        wh.prototype.copy.call(this, t2), this.holes = [];
        for (let e2 = 0, n2 = t2.holes.length; e2 < n2; e2++) {
          const n3 = t2.holes[e2];
          this.holes.push(n3.clone());
        }
        return this;
      }, toJSON: function() {
        const t2 = wh.prototype.toJSON.call(this);
        t2.uuid = this.uuid, t2.holes = [];
        for (let e2 = 0, n2 = this.holes.length; e2 < n2; e2++) {
          const n3 = this.holes[e2];
          t2.holes.push(n3.toJSON());
        }
        return t2;
      }, fromJSON: function(t2) {
        wh.prototype.fromJSON.call(this, t2), this.uuid = t2.uuid, this.holes = [];
        for (let e2 = 0, n2 = t2.holes.length; e2 < n2; e2++) {
          const n3 = t2.holes[e2];
          this.holes.push(new wh().fromJSON(n3));
        }
        return this;
      } }), Mh.prototype = Object.assign(Object.create(Jr.prototype), { constructor: Mh, isLight: true, copy: function(t2) {
        return Jr.prototype.copy.call(this, t2), this.color.copy(t2.color), this.intensity = t2.intensity, this;
      }, toJSON: function(t2) {
        const e2 = Jr.prototype.toJSON.call(this, t2);
        return e2.object.color = this.color.getHex(), e2.object.intensity = this.intensity, void 0 !== this.groundColor && (e2.object.groundColor = this.groundColor.getHex()), void 0 !== this.distance && (e2.object.distance = this.distance), void 0 !== this.angle && (e2.object.angle = this.angle), void 0 !== this.decay && (e2.object.decay = this.decay), void 0 !== this.penumbra && (e2.object.penumbra = this.penumbra), void 0 !== this.shadow && (e2.object.shadow = this.shadow.toJSON()), e2;
      } }), Sh.prototype = Object.assign(Object.create(Mh.prototype), { constructor: Sh, isHemisphereLight: true, copy: function(t2) {
        return Mh.prototype.copy.call(this, t2), this.groundColor.copy(t2.groundColor), this;
      } }), Object.assign(Th.prototype, { _projScreenMatrix: new Tr(), _lightPositionWorld: new $n(), _lookTarget: new $n(), getViewportCount: function() {
        return this._viewportCount;
      }, getFrustum: function() {
        return this._frustum;
      }, updateMatrices: function(t2) {
        const e2 = this.camera, n2 = this.matrix, r2 = this._projScreenMatrix, i2 = this._lookTarget, o2 = this._lightPositionWorld;
        o2.setFromMatrixPosition(t2.matrixWorld), e2.position.copy(o2), i2.setFromMatrixPosition(t2.target.matrixWorld), e2.lookAt(i2), e2.updateMatrixWorld(), r2.multiplyMatrices(e2.projectionMatrix, e2.matrixWorldInverse), this._frustum.setFromProjectionMatrix(r2), n2.set(0.5, 0, 0, 0.5, 0, 0.5, 0, 0.5, 0, 0, 0.5, 0.5, 0, 0, 0, 1), n2.multiply(e2.projectionMatrix), n2.multiply(e2.matrixWorldInverse);
      }, getViewport: function(t2) {
        return this._viewports[t2];
      }, getFrameExtents: function() {
        return this._frameExtents;
      }, copy: function(t2) {
        return this.camera = t2.camera.clone(), this.bias = t2.bias, this.radius = t2.radius, this.mapSize.copy(t2.mapSize), this;
      }, clone: function() {
        return new this.constructor().copy(this);
      }, toJSON: function() {
        const t2 = {};
        return 0 !== this.bias && (t2.bias = this.bias), 0 !== this.normalBias && (t2.normalBias = this.normalBias), 1 !== this.radius && (t2.radius = this.radius), 512 === this.mapSize.x && 512 === this.mapSize.y || (t2.mapSize = this.mapSize.toArray()), t2.camera = this.camera.toJSON(false).object, delete t2.camera.matrix, t2;
      } }), Eh.prototype = Object.assign(Object.create(Th.prototype), { constructor: Eh, isSpotLightShadow: true, updateMatrices: function(t2) {
        const e2 = this.camera, n2 = 2 * Bn.RAD2DEG * t2.angle * this.focus, r2 = this.mapSize.width / this.mapSize.height, i2 = t2.distance || e2.far;
        n2 === e2.fov && r2 === e2.aspect && i2 === e2.far || (e2.fov = n2, e2.aspect = r2, e2.far = i2, e2.updateProjectionMatrix()), Th.prototype.updateMatrices.call(this, t2);
      } }), Ah.prototype = Object.assign(Object.create(Mh.prototype), { constructor: Ah, isSpotLight: true, copy: function(t2) {
        return Mh.prototype.copy.call(this, t2), this.distance = t2.distance, this.angle = t2.angle, this.penumbra = t2.penumbra, this.decay = t2.decay, this.target = t2.target.clone(), this.shadow = t2.shadow.clone(), this;
      } }), Ch.prototype = Object.assign(Object.create(Th.prototype), { constructor: Ch, isPointLightShadow: true, updateMatrices: function(t2, e2 = 0) {
        const n2 = this.camera, r2 = this.matrix, i2 = this._lightPositionWorld, o2 = this._lookTarget, a2 = this._projScreenMatrix;
        i2.setFromMatrixPosition(t2.matrixWorld), n2.position.copy(i2), o2.copy(n2.position), o2.add(this._cubeDirections[e2]), n2.up.copy(this._cubeUps[e2]), n2.lookAt(o2), n2.updateMatrixWorld(), r2.makeTranslation(-i2.x, -i2.y, -i2.z), a2.multiplyMatrices(n2.projectionMatrix, n2.matrixWorldInverse), this._frustum.setFromProjectionMatrix(a2);
      } }), Lh.prototype = Object.assign(Object.create(Mh.prototype), { constructor: Lh, isPointLight: true, copy: function(t2) {
        return Mh.prototype.copy.call(this, t2), this.distance = t2.distance, this.decay = t2.decay, this.shadow = t2.shadow.clone(), this;
      } }), Ph.prototype = Object.assign(Object.create(bo.prototype), { constructor: Ph, isOrthographicCamera: true, copy: function(t2, e2) {
        return bo.prototype.copy.call(this, t2, e2), this.left = t2.left, this.right = t2.right, this.top = t2.top, this.bottom = t2.bottom, this.near = t2.near, this.far = t2.far, this.zoom = t2.zoom, this.view = null === t2.view ? null : Object.assign({}, t2.view), this;
      }, setViewOffset: function(t2, e2, n2, r2, i2, o2) {
        null === this.view && (this.view = { enabled: true, fullWidth: 1, fullHeight: 1, offsetX: 0, offsetY: 0, width: 1, height: 1 }), this.view.enabled = true, this.view.fullWidth = t2, this.view.fullHeight = e2, this.view.offsetX = n2, this.view.offsetY = r2, this.view.width = i2, this.view.height = o2, this.updateProjectionMatrix();
      }, clearViewOffset: function() {
        null !== this.view && (this.view.enabled = false), this.updateProjectionMatrix();
      }, updateProjectionMatrix: function() {
        const t2 = (this.right - this.left) / (2 * this.zoom), e2 = (this.top - this.bottom) / (2 * this.zoom), n2 = (this.right + this.left) / 2, r2 = (this.top + this.bottom) / 2;
        let i2 = n2 - t2, o2 = n2 + t2, a2 = r2 + e2, s2 = r2 - e2;
        if (null !== this.view && this.view.enabled) {
          const t3 = (this.right - this.left) / this.view.fullWidth / this.zoom, e3 = (this.top - this.bottom) / this.view.fullHeight / this.zoom;
          i2 += t3 * this.view.offsetX, o2 = i2 + t3 * this.view.width, a2 -= e3 * this.view.offsetY, s2 = a2 - e3 * this.view.height;
        }
        this.projectionMatrix.makeOrthographic(i2, o2, a2, s2, this.near, this.far), this.projectionMatrixInverse.copy(this.projectionMatrix).invert();
      }, toJSON: function(t2) {
        const e2 = Jr.prototype.toJSON.call(this, t2);
        return e2.object.zoom = this.zoom, e2.object.left = this.left, e2.object.right = this.right, e2.object.top = this.top, e2.object.bottom = this.bottom, e2.object.near = this.near, e2.object.far = this.far, null !== this.view && (e2.object.view = Object.assign({}, this.view)), e2;
      } }), Rh.prototype = Object.assign(Object.create(Th.prototype), { constructor: Rh, isDirectionalLightShadow: true, updateMatrices: function(t2) {
        Th.prototype.updateMatrices.call(this, t2);
      } }), Oh.prototype = Object.assign(Object.create(Mh.prototype), { constructor: Oh, isDirectionalLight: true, copy: function(t2) {
        return Mh.prototype.copy.call(this, t2), this.target = t2.target.clone(), this.shadow = t2.shadow.clone(), this;
      } }), Dh.prototype = Object.assign(Object.create(Mh.prototype), { constructor: Dh, isAmbientLight: true }), Ih.prototype = Object.assign(Object.create(Mh.prototype), { constructor: Ih, isRectAreaLight: true, copy: function(t2) {
        return Mh.prototype.copy.call(this, t2), this.width = t2.width, this.height = t2.height, this;
      }, toJSON: function(t2) {
        const e2 = Mh.prototype.toJSON.call(this, t2);
        return e2.object.width = this.width, e2.object.height = this.height, e2;
      } });
      class Nh {
        constructor() {
          Object.defineProperty(this, "isSphericalHarmonics3", { value: true }), this.coefficients = [];
          for (let t2 = 0; t2 < 9; t2++) this.coefficients.push(new $n());
        }
        set(t2) {
          for (let e2 = 0; e2 < 9; e2++) this.coefficients[e2].copy(t2[e2]);
          return this;
        }
        zero() {
          for (let t2 = 0; t2 < 9; t2++) this.coefficients[t2].set(0, 0, 0);
          return this;
        }
        getAt(t2, e2) {
          const n2 = t2.x, r2 = t2.y, i2 = t2.z, o2 = this.coefficients;
          return e2.copy(o2[0]).multiplyScalar(0.282095), e2.addScaledVector(o2[1], 0.488603 * r2), e2.addScaledVector(o2[2], 0.488603 * i2), e2.addScaledVector(o2[3], 0.488603 * n2), e2.addScaledVector(o2[4], n2 * r2 * 1.092548), e2.addScaledVector(o2[5], r2 * i2 * 1.092548), e2.addScaledVector(o2[6], 0.315392 * (3 * i2 * i2 - 1)), e2.addScaledVector(o2[7], n2 * i2 * 1.092548), e2.addScaledVector(o2[8], 0.546274 * (n2 * n2 - r2 * r2)), e2;
        }
        getIrradianceAt(t2, e2) {
          const n2 = t2.x, r2 = t2.y, i2 = t2.z, o2 = this.coefficients;
          return e2.copy(o2[0]).multiplyScalar(0.886227), e2.addScaledVector(o2[1], 1.023328 * r2), e2.addScaledVector(o2[2], 1.023328 * i2), e2.addScaledVector(o2[3], 1.023328 * n2), e2.addScaledVector(o2[4], 0.858086 * n2 * r2), e2.addScaledVector(o2[5], 0.858086 * r2 * i2), e2.addScaledVector(o2[6], 0.743125 * i2 * i2 - 0.247708), e2.addScaledVector(o2[7], 0.858086 * n2 * i2), e2.addScaledVector(o2[8], 0.429043 * (n2 * n2 - r2 * r2)), e2;
        }
        add(t2) {
          for (let e2 = 0; e2 < 9; e2++) this.coefficients[e2].add(t2.coefficients[e2]);
          return this;
        }
        addScaledSH(t2, e2) {
          for (let n2 = 0; n2 < 9; n2++) this.coefficients[n2].addScaledVector(t2.coefficients[n2], e2);
          return this;
        }
        scale(t2) {
          for (let e2 = 0; e2 < 9; e2++) this.coefficients[e2].multiplyScalar(t2);
          return this;
        }
        lerp(t2, e2) {
          for (let n2 = 0; n2 < 9; n2++) this.coefficients[n2].lerp(t2.coefficients[n2], e2);
          return this;
        }
        equals(t2) {
          for (let e2 = 0; e2 < 9; e2++) if (!this.coefficients[e2].equals(t2.coefficients[e2])) return false;
          return true;
        }
        copy(t2) {
          return this.set(t2.coefficients);
        }
        clone() {
          return new this.constructor().copy(this);
        }
        fromArray(t2, e2 = 0) {
          const n2 = this.coefficients;
          for (let r2 = 0; r2 < 9; r2++) n2[r2].fromArray(t2, e2 + 3 * r2);
          return this;
        }
        toArray(t2 = [], e2 = 0) {
          const n2 = this.coefficients;
          for (let r2 = 0; r2 < 9; r2++) n2[r2].toArray(t2, e2 + 3 * r2);
          return t2;
        }
        static getBasisAt(t2, e2) {
          const n2 = t2.x, r2 = t2.y, i2 = t2.z;
          e2[0] = 0.282095, e2[1] = 0.488603 * r2, e2[2] = 0.488603 * i2, e2[3] = 0.488603 * n2, e2[4] = 1.092548 * n2 * r2, e2[5] = 1.092548 * r2 * i2, e2[6] = 0.315392 * (3 * i2 * i2 - 1), e2[7] = 1.092548 * n2 * i2, e2[8] = 0.546274 * (n2 * n2 - r2 * r2);
        }
      }
      function zh(t2, e2) {
        Mh.call(this, void 0, e2), this.type = "LightProbe", this.sh = void 0 !== t2 ? t2 : new Nh();
      }
      function kh(t2) {
        Wl.call(this, t2), this.textures = {};
      }
      zh.prototype = Object.assign(Object.create(Mh.prototype), { constructor: zh, isLightProbe: true, copy: function(t2) {
        return Mh.prototype.copy.call(this, t2), this.sh.copy(t2.sh), this;
      }, fromJSON: function(t2) {
        return this.intensity = t2.intensity, this.sh.fromArray(t2.sh), this;
      }, toJSON: function(t2) {
        const e2 = Mh.prototype.toJSON.call(this, t2);
        return e2.object.sh = this.sh.toArray(), e2;
      } }), kh.prototype = Object.assign(Object.create(Wl.prototype), { constructor: kh, load: function(t2, e2, n2, r2) {
        const i2 = this, o2 = new Xl(i2.manager);
        o2.setPath(i2.path), o2.setRequestHeader(i2.requestHeader), o2.setWithCredentials(i2.withCredentials), o2.load(t2, function(n3) {
          try {
            e2(i2.parse(JSON.parse(n3)));
          } catch (e3) {
            r2 ? r2(e3) : console.error(e3), i2.manager.itemError(t2);
          }
        }, n2, r2);
      }, parse: function(t2) {
        const e2 = this.textures;
        function n2(t3) {
          return void 0 === e2[t3] && console.warn("THREE.MaterialLoader: Undefined texture", t3), e2[t3];
        }
        const r2 = new El[t2.type]();
        if (void 0 !== t2.uuid && (r2.uuid = t2.uuid), void 0 !== t2.name && (r2.name = t2.name), void 0 !== t2.color && void 0 !== r2.color && r2.color.setHex(t2.color), void 0 !== t2.roughness && (r2.roughness = t2.roughness), void 0 !== t2.metalness && (r2.metalness = t2.metalness), void 0 !== t2.sheen && (r2.sheen = new yi().setHex(t2.sheen)), void 0 !== t2.emissive && void 0 !== r2.emissive && r2.emissive.setHex(t2.emissive), void 0 !== t2.specular && void 0 !== r2.specular && r2.specular.setHex(t2.specular), void 0 !== t2.shininess && (r2.shininess = t2.shininess), void 0 !== t2.clearcoat && (r2.clearcoat = t2.clearcoat), void 0 !== t2.clearcoatRoughness && (r2.clearcoatRoughness = t2.clearcoatRoughness), void 0 !== t2.fog && (r2.fog = t2.fog), void 0 !== t2.flatShading && (r2.flatShading = t2.flatShading), void 0 !== t2.blending && (r2.blending = t2.blending), void 0 !== t2.combine && (r2.combine = t2.combine), void 0 !== t2.side && (r2.side = t2.side), void 0 !== t2.opacity && (r2.opacity = t2.opacity), void 0 !== t2.transparent && (r2.transparent = t2.transparent), void 0 !== t2.alphaTest && (r2.alphaTest = t2.alphaTest), void 0 !== t2.depthTest && (r2.depthTest = t2.depthTest), void 0 !== t2.depthWrite && (r2.depthWrite = t2.depthWrite), void 0 !== t2.colorWrite && (r2.colorWrite = t2.colorWrite), void 0 !== t2.stencilWrite && (r2.stencilWrite = t2.stencilWrite), void 0 !== t2.stencilWriteMask && (r2.stencilWriteMask = t2.stencilWriteMask), void 0 !== t2.stencilFunc && (r2.stencilFunc = t2.stencilFunc), void 0 !== t2.stencilRef && (r2.stencilRef = t2.stencilRef), void 0 !== t2.stencilFuncMask && (r2.stencilFuncMask = t2.stencilFuncMask), void 0 !== t2.stencilFail && (r2.stencilFail = t2.stencilFail), void 0 !== t2.stencilZFail && (r2.stencilZFail = t2.stencilZFail), void 0 !== t2.stencilZPass && (r2.stencilZPass = t2.stencilZPass), void 0 !== t2.wireframe && (r2.wireframe = t2.wireframe), void 0 !== t2.wireframeLinewidth && (r2.wireframeLinewidth = t2.wireframeLinewidth), void 0 !== t2.wireframeLinecap && (r2.wireframeLinecap = t2.wireframeLinecap), void 0 !== t2.wireframeLinejoin && (r2.wireframeLinejoin = t2.wireframeLinejoin), void 0 !== t2.rotation && (r2.rotation = t2.rotation), 1 !== t2.linewidth && (r2.linewidth = t2.linewidth), void 0 !== t2.dashSize && (r2.dashSize = t2.dashSize), void 0 !== t2.gapSize && (r2.gapSize = t2.gapSize), void 0 !== t2.scale && (r2.scale = t2.scale), void 0 !== t2.polygonOffset && (r2.polygonOffset = t2.polygonOffset), void 0 !== t2.polygonOffsetFactor && (r2.polygonOffsetFactor = t2.polygonOffsetFactor), void 0 !== t2.polygonOffsetUnits && (r2.polygonOffsetUnits = t2.polygonOffsetUnits), void 0 !== t2.skinning && (r2.skinning = t2.skinning), void 0 !== t2.morphTargets && (r2.morphTargets = t2.morphTargets), void 0 !== t2.morphNormals && (r2.morphNormals = t2.morphNormals), void 0 !== t2.dithering && (r2.dithering = t2.dithering), void 0 !== t2.vertexTangents && (r2.vertexTangents = t2.vertexTangents), void 0 !== t2.visible && (r2.visible = t2.visible), void 0 !== t2.toneMapped && (r2.toneMapped = t2.toneMapped), void 0 !== t2.userData && (r2.userData = t2.userData), void 0 !== t2.vertexColors && ("number" == typeof t2.vertexColors ? r2.vertexColors = t2.vertexColors > 0 : r2.vertexColors = t2.vertexColors), void 0 !== t2.uniforms) for (const e3 in t2.uniforms) {
          const i2 = t2.uniforms[e3];
          switch (r2.uniforms[e3] = {}, i2.type) {
            case "t":
              r2.uniforms[e3].value = n2(i2.value);
              break;
            case "c":
              r2.uniforms[e3].value = new yi().setHex(i2.value);
              break;
            case "v2":
              r2.uniforms[e3].value = new Hn().fromArray(i2.value);
              break;
            case "v3":
              r2.uniforms[e3].value = new $n().fromArray(i2.value);
              break;
            case "v4":
              r2.uniforms[e3].value = new Xn().fromArray(i2.value);
              break;
            case "m3":
              r2.uniforms[e3].value = new Gn().fromArray(i2.value);
              break;
            case "m4":
              r2.uniforms[e3].value = new Tr().fromArray(i2.value);
              break;
            default:
              r2.uniforms[e3].value = i2.value;
          }
        }
        if (void 0 !== t2.defines && (r2.defines = t2.defines), void 0 !== t2.vertexShader && (r2.vertexShader = t2.vertexShader), void 0 !== t2.fragmentShader && (r2.fragmentShader = t2.fragmentShader), void 0 !== t2.extensions) for (const e3 in t2.extensions) r2.extensions[e3] = t2.extensions[e3];
        if (void 0 !== t2.shading && (r2.flatShading = 1 === t2.shading), void 0 !== t2.size && (r2.size = t2.size), void 0 !== t2.sizeAttenuation && (r2.sizeAttenuation = t2.sizeAttenuation), void 0 !== t2.map && (r2.map = n2(t2.map)), void 0 !== t2.matcap && (r2.matcap = n2(t2.matcap)), void 0 !== t2.alphaMap && (r2.alphaMap = n2(t2.alphaMap)), void 0 !== t2.bumpMap && (r2.bumpMap = n2(t2.bumpMap)), void 0 !== t2.bumpScale && (r2.bumpScale = t2.bumpScale), void 0 !== t2.normalMap && (r2.normalMap = n2(t2.normalMap)), void 0 !== t2.normalMapType && (r2.normalMapType = t2.normalMapType), void 0 !== t2.normalScale) {
          let e3 = t2.normalScale;
          false === Array.isArray(e3) && (e3 = [e3, e3]), r2.normalScale = new Hn().fromArray(e3);
        }
        return void 0 !== t2.displacementMap && (r2.displacementMap = n2(t2.displacementMap)), void 0 !== t2.displacementScale && (r2.displacementScale = t2.displacementScale), void 0 !== t2.displacementBias && (r2.displacementBias = t2.displacementBias), void 0 !== t2.roughnessMap && (r2.roughnessMap = n2(t2.roughnessMap)), void 0 !== t2.metalnessMap && (r2.metalnessMap = n2(t2.metalnessMap)), void 0 !== t2.emissiveMap && (r2.emissiveMap = n2(t2.emissiveMap)), void 0 !== t2.emissiveIntensity && (r2.emissiveIntensity = t2.emissiveIntensity), void 0 !== t2.specularMap && (r2.specularMap = n2(t2.specularMap)), void 0 !== t2.envMap && (r2.envMap = n2(t2.envMap)), void 0 !== t2.envMapIntensity && (r2.envMapIntensity = t2.envMapIntensity), void 0 !== t2.reflectivity && (r2.reflectivity = t2.reflectivity), void 0 !== t2.refractionRatio && (r2.refractionRatio = t2.refractionRatio), void 0 !== t2.lightMap && (r2.lightMap = n2(t2.lightMap)), void 0 !== t2.lightMapIntensity && (r2.lightMapIntensity = t2.lightMapIntensity), void 0 !== t2.aoMap && (r2.aoMap = n2(t2.aoMap)), void 0 !== t2.aoMapIntensity && (r2.aoMapIntensity = t2.aoMapIntensity), void 0 !== t2.gradientMap && (r2.gradientMap = n2(t2.gradientMap)), void 0 !== t2.clearcoatMap && (r2.clearcoatMap = n2(t2.clearcoatMap)), void 0 !== t2.clearcoatRoughnessMap && (r2.clearcoatRoughnessMap = n2(t2.clearcoatRoughnessMap)), void 0 !== t2.clearcoatNormalMap && (r2.clearcoatNormalMap = n2(t2.clearcoatNormalMap)), void 0 !== t2.clearcoatNormalScale && (r2.clearcoatNormalScale = new Hn().fromArray(t2.clearcoatNormalScale)), void 0 !== t2.transmission && (r2.transmission = t2.transmission), void 0 !== t2.transmissionMap && (r2.transmissionMap = n2(t2.transmissionMap)), r2;
      }, setTextures: function(t2) {
        return this.textures = t2, this;
      } });
      const Fh = { decodeText: function(t2) {
        if ("undefined" != typeof TextDecoder) return new TextDecoder().decode(t2);
        let e2 = "";
        for (let n2 = 0, r2 = t2.length; n2 < r2; n2++) e2 += String.fromCharCode(t2[n2]);
        try {
          return decodeURIComponent(escape(e2));
        } catch (t3) {
          return e2;
        }
      }, extractUrlBase: function(t2) {
        const e2 = t2.lastIndexOf("/");
        return -1 === e2 ? "./" : t2.substr(0, e2 + 1);
      } };
      function Bh() {
        Xi.call(this), this.type = "InstancedBufferGeometry", this.instanceCount = 1 / 0;
      }
      function Hh(t2, e2, n2, r2) {
        "number" == typeof n2 && (r2 = n2, n2 = false, console.error("THREE.InstancedBufferAttribute: The constructor now expects normalized as the third argument.")), Ti.call(this, t2, e2, n2), this.meshPerAttribute = r2 || 1;
      }
      function Gh(t2) {
        Wl.call(this, t2);
      }
      Bh.prototype = Object.assign(Object.create(Xi.prototype), { constructor: Bh, isInstancedBufferGeometry: true, copy: function(t2) {
        return Xi.prototype.copy.call(this, t2), this.instanceCount = t2.instanceCount, this;
      }, clone: function() {
        return new this.constructor().copy(this);
      }, toJSON: function() {
        const t2 = Xi.prototype.toJSON.call(this);
        return t2.instanceCount = this.instanceCount, t2.isInstancedBufferGeometry = true, t2;
      } }), Hh.prototype = Object.assign(Object.create(Ti.prototype), { constructor: Hh, isInstancedBufferAttribute: true, copy: function(t2) {
        return Ti.prototype.copy.call(this, t2), this.meshPerAttribute = t2.meshPerAttribute, this;
      }, toJSON: function() {
        const t2 = Ti.prototype.toJSON.call(this);
        return t2.meshPerAttribute = this.meshPerAttribute, t2.isInstancedBufferAttribute = true, t2;
      } }), Gh.prototype = Object.assign(Object.create(Wl.prototype), { constructor: Gh, load: function(t2, e2, n2, r2) {
        const i2 = this, o2 = new Xl(i2.manager);
        o2.setPath(i2.path), o2.setRequestHeader(i2.requestHeader), o2.setWithCredentials(i2.withCredentials), o2.load(t2, function(n3) {
          try {
            e2(i2.parse(JSON.parse(n3)));
          } catch (e3) {
            r2 ? r2(e3) : console.error(e3), i2.manager.itemError(t2);
          }
        }, n2, r2);
      }, parse: function(t2) {
        const e2 = {}, n2 = {};
        function r2(t3, r3) {
          if (void 0 !== e2[r3]) return e2[r3];
          const i3 = t3.interleavedBuffers[r3], o3 = function(t4, e3) {
            if (void 0 !== n2[e3]) return n2[e3];
            const r4 = t4.arrayBuffers[e3], i4 = new Uint32Array(r4).buffer;
            return n2[e3] = i4, i4;
          }(t3, i3.buffer), a3 = new Hs(Bi(i3.type, o3), i3.stride);
          return a3.uuid = i3.uuid, e2[r3] = a3, a3;
        }
        const i2 = t2.isInstancedBufferGeometry ? new Bh() : new Xi(), o2 = t2.data.index;
        if (void 0 !== o2) {
          const t3 = Bi(o2.type, o2.array);
          i2.setIndex(new Ti(t3, 1));
        }
        const a2 = t2.data.attributes;
        for (const e3 in a2) {
          const n3 = a2[e3];
          let o3;
          if (n3.isInterleavedBufferAttribute) {
            o3 = new Us(r2(t2.data, n3.data), n3.itemSize, n3.offset, n3.normalized);
          } else {
            const t3 = Bi(n3.type, n3.array);
            o3 = new (n3.isInstancedBufferAttribute ? Hh : Ti)(t3, n3.itemSize, n3.normalized);
          }
          void 0 !== n3.name && (o3.name = n3.name), i2.setAttribute(e3, o3);
        }
        const s2 = t2.data.morphAttributes;
        if (s2) for (const e3 in s2) {
          const n3 = s2[e3], o3 = [];
          for (let e4 = 0, i3 = n3.length; e4 < i3; e4++) {
            const i4 = n3[e4];
            let a3;
            if (i4.isInterleavedBufferAttribute) {
              a3 = new Us(r2(t2.data, i4.data), i4.itemSize, i4.offset, i4.normalized);
            } else {
              a3 = new Ti(Bi(i4.type, i4.array), i4.itemSize, i4.normalized);
            }
            void 0 !== i4.name && (a3.name = i4.name), o3.push(a3);
          }
          i2.morphAttributes[e3] = o3;
        }
        t2.data.morphTargetsRelative && (i2.morphTargetsRelative = true);
        const c2 = t2.data.groups || t2.data.drawcalls || t2.data.offsets;
        if (void 0 !== c2) for (let t3 = 0, e3 = c2.length; t3 !== e3; ++t3) {
          const e4 = c2[t3];
          i2.addGroup(e4.start, e4.count, e4.materialIndex);
        }
        const u2 = t2.data.boundingSphere;
        if (void 0 !== u2) {
          const t3 = new $n();
          void 0 !== u2.center && t3.fromArray(u2.center), i2.boundingSphere = new gr(t3, u2.radius);
        }
        return t2.name && (i2.name = t2.name), t2.userData && (i2.userData = t2.userData), i2;
      } });
      class Uh extends Wl {
        constructor(t2) {
          super(t2);
        }
        load(t2, e2, n2, r2) {
          const i2 = this, o2 = "" === this.path ? Fh.extractUrlBase(t2) : this.path;
          this.resourcePath = this.resourcePath || o2;
          const a2 = new Xl(this.manager);
          a2.setPath(this.path), a2.setRequestHeader(this.requestHeader), a2.setWithCredentials(this.withCredentials), a2.load(t2, function(n3) {
            let o3 = null;
            try {
              o3 = JSON.parse(n3);
            } catch (e3) {
              return void 0 !== r2 && r2(e3), void console.error("THREE:ObjectLoader: Can't parse " + t2 + ".", e3.message);
            }
            const a3 = o3.metadata;
            void 0 !== a3 && void 0 !== a3.type && "geometry" !== a3.type.toLowerCase() ? i2.parse(o3, e2) : console.error("THREE.ObjectLoader: Can't load " + t2);
          }, n2, r2);
        }
        parse(t2, e2) {
          const n2 = this.parseAnimations(t2.animations), r2 = this.parseShapes(t2.shapes), i2 = this.parseGeometries(t2.geometries, r2), o2 = this.parseImages(t2.images, function() {
            void 0 !== e2 && e2(c2);
          }), a2 = this.parseTextures(t2.textures, o2), s2 = this.parseMaterials(t2.materials, a2), c2 = this.parseObject(t2.object, i2, s2, n2), u2 = this.parseSkeletons(t2.skeletons, c2);
          if (this.bindSkeletons(c2, u2), void 0 !== e2) {
            let t3 = false;
            for (const e3 in o2) if (o2[e3] instanceof HTMLImageElement) {
              t3 = true;
              break;
            }
            false === t3 && e2(c2);
          }
          return c2;
        }
        parseShapes(t2) {
          const e2 = {};
          if (void 0 !== t2) for (let n2 = 0, r2 = t2.length; n2 < r2; n2++) {
            const r3 = new _h().fromJSON(t2[n2]);
            e2[r3.uuid] = r3;
          }
          return e2;
        }
        parseSkeletons(t2, e2) {
          const n2 = {}, r2 = {};
          if (e2.traverse(function(t3) {
            t3.isBone && (r2[t3.uuid] = t3);
          }), void 0 !== t2) for (let e3 = 0, i2 = t2.length; e3 < i2; e3++) {
            const i3 = new vc().fromJSON(t2[e3], r2);
            n2[i3.uuid] = i3;
          }
          return n2;
        }
        parseGeometries(t2, e2) {
          const n2 = {};
          let r2;
          if (void 0 !== t2) {
            const i2 = new Gh();
            for (let o2 = 0, a2 = t2.length; o2 < a2; o2++) {
              let a3;
              const s2 = t2[o2];
              switch (s2.type) {
                case "PlaneGeometry":
                case "PlaneBufferGeometry":
                  a3 = new ml[s2.type](s2.width, s2.height, s2.widthSegments, s2.heightSegments);
                  break;
                case "BoxGeometry":
                case "BoxBufferGeometry":
                case "CubeGeometry":
                  a3 = new ml[s2.type](s2.width, s2.height, s2.depth, s2.widthSegments, s2.heightSegments, s2.depthSegments);
                  break;
                case "CircleGeometry":
                case "CircleBufferGeometry":
                  a3 = new ml[s2.type](s2.radius, s2.segments, s2.thetaStart, s2.thetaLength);
                  break;
                case "CylinderGeometry":
                case "CylinderBufferGeometry":
                  a3 = new ml[s2.type](s2.radiusTop, s2.radiusBottom, s2.height, s2.radialSegments, s2.heightSegments, s2.openEnded, s2.thetaStart, s2.thetaLength);
                  break;
                case "ConeGeometry":
                case "ConeBufferGeometry":
                  a3 = new ml[s2.type](s2.radius, s2.height, s2.radialSegments, s2.heightSegments, s2.openEnded, s2.thetaStart, s2.thetaLength);
                  break;
                case "SphereGeometry":
                case "SphereBufferGeometry":
                  a3 = new ml[s2.type](s2.radius, s2.widthSegments, s2.heightSegments, s2.phiStart, s2.phiLength, s2.thetaStart, s2.thetaLength);
                  break;
                case "DodecahedronGeometry":
                case "DodecahedronBufferGeometry":
                case "IcosahedronGeometry":
                case "IcosahedronBufferGeometry":
                case "OctahedronGeometry":
                case "OctahedronBufferGeometry":
                case "TetrahedronGeometry":
                case "TetrahedronBufferGeometry":
                  a3 = new ml[s2.type](s2.radius, s2.detail);
                  break;
                case "RingGeometry":
                case "RingBufferGeometry":
                  a3 = new ml[s2.type](s2.innerRadius, s2.outerRadius, s2.thetaSegments, s2.phiSegments, s2.thetaStart, s2.thetaLength);
                  break;
                case "TorusGeometry":
                case "TorusBufferGeometry":
                  a3 = new ml[s2.type](s2.radius, s2.tube, s2.radialSegments, s2.tubularSegments, s2.arc);
                  break;
                case "TorusKnotGeometry":
                case "TorusKnotBufferGeometry":
                  a3 = new ml[s2.type](s2.radius, s2.tube, s2.tubularSegments, s2.radialSegments, s2.p, s2.q);
                  break;
                case "TubeGeometry":
                case "TubeBufferGeometry":
                  a3 = new ml[s2.type](new xh[s2.path.type]().fromJSON(s2.path), s2.tubularSegments, s2.radius, s2.radialSegments, s2.closed);
                  break;
                case "LatheGeometry":
                case "LatheBufferGeometry":
                  a3 = new ml[s2.type](s2.points, s2.segments, s2.phiStart, s2.phiLength);
                  break;
                case "PolyhedronGeometry":
                case "PolyhedronBufferGeometry":
                  a3 = new ml[s2.type](s2.vertices, s2.indices, s2.radius, s2.details);
                  break;
                case "ShapeGeometry":
                case "ShapeBufferGeometry":
                  r2 = [];
                  for (let t4 = 0, n3 = s2.shapes.length; t4 < n3; t4++) {
                    const n4 = e2[s2.shapes[t4]];
                    r2.push(n4);
                  }
                  a3 = new ml[s2.type](r2, s2.curveSegments);
                  break;
                case "ExtrudeGeometry":
                case "ExtrudeBufferGeometry":
                  r2 = [];
                  for (let t4 = 0, n3 = s2.shapes.length; t4 < n3; t4++) {
                    const n4 = e2[s2.shapes[t4]];
                    r2.push(n4);
                  }
                  const t3 = s2.options.extrudePath;
                  void 0 !== t3 && (s2.options.extrudePath = new xh[t3.type]().fromJSON(t3)), a3 = new ml[s2.type](r2, s2.options);
                  break;
                case "BufferGeometry":
                case "InstancedBufferGeometry":
                  a3 = i2.parse(s2);
                  break;
                case "Geometry":
                  console.error('THREE.ObjectLoader: Loading "Geometry" is not supported anymore.');
                  break;
                default:
                  console.warn('THREE.ObjectLoader: Unsupported geometry type "' + s2.type + '"');
                  continue;
              }
              a3.uuid = s2.uuid, void 0 !== s2.name && (a3.name = s2.name), true === a3.isBufferGeometry && void 0 !== s2.userData && (a3.userData = s2.userData), n2[s2.uuid] = a3;
            }
          }
          return n2;
        }
        parseMaterials(t2, e2) {
          const n2 = {}, r2 = {};
          if (void 0 !== t2) {
            const i2 = new kh();
            i2.setTextures(e2);
            for (let e3 = 0, o2 = t2.length; e3 < o2; e3++) {
              const o3 = t2[e3];
              if ("MultiMaterial" === o3.type) {
                const t3 = [];
                for (let e4 = 0; e4 < o3.materials.length; e4++) {
                  const r3 = o3.materials[e4];
                  void 0 === n2[r3.uuid] && (n2[r3.uuid] = i2.parse(r3)), t3.push(n2[r3.uuid]);
                }
                r2[o3.uuid] = t3;
              } else void 0 === n2[o3.uuid] && (n2[o3.uuid] = i2.parse(o3)), r2[o3.uuid] = n2[o3.uuid];
            }
          }
          return r2;
        }
        parseAnimations(t2) {
          const e2 = {};
          if (void 0 !== t2) for (let n2 = 0; n2 < t2.length; n2++) {
            const r2 = t2[n2], i2 = Hl.parse(r2);
            e2[i2.uuid] = i2;
          }
          return e2;
        }
        parseImages(t2, e2) {
          const n2 = this, r2 = {};
          let i2;
          function o2(t3) {
            if ("string" == typeof t3) {
              const e3 = t3;
              return function(t4) {
                return n2.manager.itemStart(t4), i2.load(t4, function() {
                  n2.manager.itemEnd(t4);
                }, void 0, function() {
                  n2.manager.itemError(t4), n2.manager.itemEnd(t4);
                });
              }(/^(\/\/)|([a-z]+:(\/\/)?)/i.test(e3) ? e3 : n2.resourcePath + e3);
            }
            return t3.data ? { data: Bi(t3.type, t3.data), width: t3.width, height: t3.height } : null;
          }
          if (void 0 !== t2 && t2.length > 0) {
            const n3 = new jl(e2);
            i2 = new Jl(n3), i2.setCrossOrigin(this.crossOrigin);
            for (let e3 = 0, n4 = t2.length; e3 < n4; e3++) {
              const n5 = t2[e3], i3 = n5.url;
              if (Array.isArray(i3)) {
                r2[n5.uuid] = [];
                for (let t3 = 0, e4 = i3.length; t3 < e4; t3++) {
                  const e5 = o2(i3[t3]);
                  null !== e5 && (e5 instanceof HTMLImageElement ? r2[n5.uuid].push(e5) : r2[n5.uuid].push(new To(e5.data, e5.width, e5.height)));
                }
              } else {
                const t3 = o2(n5.url);
                null !== t3 && (r2[n5.uuid] = t3);
              }
            }
          }
          return r2;
        }
        parseTextures(t2, e2) {
          function n2(t3, e3) {
            return "number" == typeof t3 ? t3 : (console.warn("THREE.ObjectLoader.parseTexture: Constant should be in numeric form.", t3), e3[t3]);
          }
          const r2 = {};
          if (void 0 !== t2) for (let i2 = 0, o2 = t2.length; i2 < o2; i2++) {
            const o3 = t2[i2];
            let a2;
            void 0 === o3.image && console.warn('THREE.ObjectLoader: No "image" specified for', o3.uuid), void 0 === e2[o3.image] && console.warn("THREE.ObjectLoader: Undefined image", o3.image);
            const s2 = e2[o3.image];
            Array.isArray(s2) ? (a2 = new Mo(s2), 6 === s2.length && (a2.needsUpdate = true)) : (a2 = s2 && s2.data ? new To(s2.data, s2.width, s2.height) : new Wn(s2), s2 && (a2.needsUpdate = true)), a2.uuid = o3.uuid, void 0 !== o3.name && (a2.name = o3.name), void 0 !== o3.mapping && (a2.mapping = n2(o3.mapping, jh)), void 0 !== o3.offset && a2.offset.fromArray(o3.offset), void 0 !== o3.repeat && a2.repeat.fromArray(o3.repeat), void 0 !== o3.center && a2.center.fromArray(o3.center), void 0 !== o3.rotation && (a2.rotation = o3.rotation), void 0 !== o3.wrap && (a2.wrapS = n2(o3.wrap[0], Vh), a2.wrapT = n2(o3.wrap[1], Vh)), void 0 !== o3.format && (a2.format = o3.format), void 0 !== o3.type && (a2.type = o3.type), void 0 !== o3.encoding && (a2.encoding = o3.encoding), void 0 !== o3.minFilter && (a2.minFilter = n2(o3.minFilter, Wh)), void 0 !== o3.magFilter && (a2.magFilter = n2(o3.magFilter, Wh)), void 0 !== o3.anisotropy && (a2.anisotropy = o3.anisotropy), void 0 !== o3.flipY && (a2.flipY = o3.flipY), void 0 !== o3.premultiplyAlpha && (a2.premultiplyAlpha = o3.premultiplyAlpha), void 0 !== o3.unpackAlignment && (a2.unpackAlignment = o3.unpackAlignment), r2[o3.uuid] = a2;
          }
          return r2;
        }
        parseObject(t2, e2, n2, r2) {
          let i2, o2, a2;
          function s2(t3) {
            return void 0 === e2[t3] && console.warn("THREE.ObjectLoader: Undefined geometry", t3), e2[t3];
          }
          function c2(t3) {
            if (void 0 !== t3) {
              if (Array.isArray(t3)) {
                const e3 = [];
                for (let r3 = 0, i3 = t3.length; r3 < i3; r3++) {
                  const i4 = t3[r3];
                  void 0 === n2[i4] && console.warn("THREE.ObjectLoader: Undefined material", i4), e3.push(n2[i4]);
                }
                return e3;
              }
              return void 0 === n2[t3] && console.warn("THREE.ObjectLoader: Undefined material", t3), n2[t3];
            }
          }
          switch (t2.type) {
            case "Scene":
              i2 = new Bs(), void 0 !== t2.background && Number.isInteger(t2.background) && (i2.background = new yi(t2.background)), void 0 !== t2.fog && ("Fog" === t2.fog.type ? i2.fog = new Fs(t2.fog.color, t2.fog.near, t2.fog.far) : "FogExp2" === t2.fog.type && (i2.fog = new ks(t2.fog.color, t2.fog.density)));
              break;
            case "PerspectiveCamera":
              i2 = new wo(t2.fov, t2.aspect, t2.near, t2.far), void 0 !== t2.focus && (i2.focus = t2.focus), void 0 !== t2.zoom && (i2.zoom = t2.zoom), void 0 !== t2.filmGauge && (i2.filmGauge = t2.filmGauge), void 0 !== t2.filmOffset && (i2.filmOffset = t2.filmOffset), void 0 !== t2.view && (i2.view = Object.assign({}, t2.view));
              break;
            case "OrthographicCamera":
              i2 = new Ph(t2.left, t2.right, t2.top, t2.bottom, t2.near, t2.far), void 0 !== t2.zoom && (i2.zoom = t2.zoom), void 0 !== t2.view && (i2.view = Object.assign({}, t2.view));
              break;
            case "AmbientLight":
              i2 = new Dh(t2.color, t2.intensity);
              break;
            case "DirectionalLight":
              i2 = new Oh(t2.color, t2.intensity);
              break;
            case "PointLight":
              i2 = new Lh(t2.color, t2.intensity, t2.distance, t2.decay);
              break;
            case "RectAreaLight":
              i2 = new Ih(t2.color, t2.intensity, t2.width, t2.height);
              break;
            case "SpotLight":
              i2 = new Ah(t2.color, t2.intensity, t2.distance, t2.angle, t2.penumbra, t2.decay);
              break;
            case "HemisphereLight":
              i2 = new Sh(t2.color, t2.groundColor, t2.intensity);
              break;
            case "LightProbe":
              i2 = new zh().fromJSON(t2);
              break;
            case "SkinnedMesh":
              o2 = s2(t2.geometry), a2 = c2(t2.material), i2 = new pc(o2, a2), void 0 !== t2.bindMode && (i2.bindMode = t2.bindMode), void 0 !== t2.bindMatrix && i2.bindMatrix.fromArray(t2.bindMatrix), void 0 !== t2.skeleton && (i2.skeleton = t2.skeleton);
              break;
            case "Mesh":
              o2 = s2(t2.geometry), a2 = c2(t2.material), i2 = new ho(o2, a2);
              break;
            case "InstancedMesh":
              o2 = s2(t2.geometry), a2 = c2(t2.material);
              const e3 = t2.count, n3 = t2.instanceMatrix;
              i2 = new _c(o2, a2, e3), i2.instanceMatrix = new Ti(new Float32Array(n3.array), 16);
              break;
            case "LOD":
              i2 = new sc();
              break;
            case "Line":
              i2 = new Lc(s2(t2.geometry), c2(t2.material));
              break;
            case "LineLoop":
              i2 = new Dc(s2(t2.geometry), c2(t2.material));
              break;
            case "LineSegments":
              i2 = new Oc(s2(t2.geometry), c2(t2.material));
              break;
            case "PointCloud":
            case "Points":
              i2 = new Bc(s2(t2.geometry), c2(t2.material));
              break;
            case "Sprite":
              i2 = new rc(c2(t2.material));
              break;
            case "Group":
              i2 = new Rs();
              break;
            case "Bone":
              i2 = new fc();
              break;
            default:
              i2 = new Jr();
          }
          if (i2.uuid = t2.uuid, void 0 !== t2.name && (i2.name = t2.name), void 0 !== t2.matrix ? (i2.matrix.fromArray(t2.matrix), void 0 !== t2.matrixAutoUpdate && (i2.matrixAutoUpdate = t2.matrixAutoUpdate), i2.matrixAutoUpdate && i2.matrix.decompose(i2.position, i2.quaternion, i2.scale)) : (void 0 !== t2.position && i2.position.fromArray(t2.position), void 0 !== t2.rotation && i2.rotation.fromArray(t2.rotation), void 0 !== t2.quaternion && i2.quaternion.fromArray(t2.quaternion), void 0 !== t2.scale && i2.scale.fromArray(t2.scale)), void 0 !== t2.castShadow && (i2.castShadow = t2.castShadow), void 0 !== t2.receiveShadow && (i2.receiveShadow = t2.receiveShadow), t2.shadow && (void 0 !== t2.shadow.bias && (i2.shadow.bias = t2.shadow.bias), void 0 !== t2.shadow.normalBias && (i2.shadow.normalBias = t2.shadow.normalBias), void 0 !== t2.shadow.radius && (i2.shadow.radius = t2.shadow.radius), void 0 !== t2.shadow.mapSize && i2.shadow.mapSize.fromArray(t2.shadow.mapSize), void 0 !== t2.shadow.camera && (i2.shadow.camera = this.parseObject(t2.shadow.camera))), void 0 !== t2.visible && (i2.visible = t2.visible), void 0 !== t2.frustumCulled && (i2.frustumCulled = t2.frustumCulled), void 0 !== t2.renderOrder && (i2.renderOrder = t2.renderOrder), void 0 !== t2.userData && (i2.userData = t2.userData), void 0 !== t2.layers && (i2.layers.mask = t2.layers), void 0 !== t2.children) {
            const o3 = t2.children;
            for (let t3 = 0; t3 < o3.length; t3++) i2.add(this.parseObject(o3[t3], e2, n2, r2));
          }
          if (void 0 !== t2.animations) {
            const e3 = t2.animations;
            for (let t3 = 0; t3 < e3.length; t3++) {
              const n3 = e3[t3];
              i2.animations.push(r2[n3]);
            }
          }
          if ("LOD" === t2.type) {
            void 0 !== t2.autoUpdate && (i2.autoUpdate = t2.autoUpdate);
            const e3 = t2.levels;
            for (let t3 = 0; t3 < e3.length; t3++) {
              const n3 = e3[t3], r3 = i2.getObjectByProperty("uuid", n3.object);
              void 0 !== r3 && i2.addLevel(r3, n3.distance);
            }
          }
          return i2;
        }
        bindSkeletons(t2, e2) {
          0 !== Object.keys(e2).length && t2.traverse(function(t3) {
            if (true === t3.isSkinnedMesh && void 0 !== t3.skeleton) {
              const n2 = e2[t3.skeleton];
              void 0 === n2 ? console.warn("THREE.ObjectLoader: No skeleton found with UUID:", t3.skeleton) : t3.bind(n2, t3.bindMatrix);
            }
          });
        }
        setTexturePath(t2) {
          return console.warn("THREE.ObjectLoader: .setTexturePath() has been renamed to .setResourcePath()."), this.setResourcePath(t2);
        }
      }
      const jh = { UVMapping: it, CubeReflectionMapping: ot, CubeRefractionMapping: at, EquirectangularReflectionMapping: st, EquirectangularRefractionMapping: ct, CubeUVReflectionMapping: ut, CubeUVRefractionMapping: lt }, Vh = { RepeatWrapping: ht, ClampToEdgeWrapping: dt, MirroredRepeatWrapping: pt }, Wh = { NearestFilter: ft, NearestMipmapNearestFilter: mt, NearestMipmapLinearFilter: vt, LinearFilter: xt, LinearMipmapNearestFilter: bt, LinearMipmapLinearFilter: _t };
      function qh(t2) {
        "undefined" == typeof createImageBitmap && console.warn("THREE.ImageBitmapLoader: createImageBitmap() not supported."), "undefined" == typeof fetch && console.warn("THREE.ImageBitmapLoader: fetch() not supported."), Wl.call(this, t2), this.options = { premultiplyAlpha: "none" };
      }
      function Xh() {
        this.type = "ShapePath", this.color = new yi(), this.subPaths = [], this.currentPath = null;
      }
      function Yh(t2) {
        this.type = "Font", this.data = t2;
      }
      function Zh(t2, e2, n2, r2, i2) {
        const o2 = i2.glyphs[t2] || i2.glyphs["?"];
        if (!o2) return void console.error('THREE.Font: character "' + t2 + '" does not exists in font family ' + i2.familyName + ".");
        const a2 = new Xh();
        let s2, c2, u2, l2, h2, d2, p2, f2;
        if (o2.o) {
          const t3 = o2._cachedOutline || (o2._cachedOutline = o2.o.split(" "));
          for (let i3 = 0, o3 = t3.length; i3 < o3; ) {
            switch (t3[i3++]) {
              case "m":
                s2 = t3[i3++] * e2 + n2, c2 = t3[i3++] * e2 + r2, a2.moveTo(s2, c2);
                break;
              case "l":
                s2 = t3[i3++] * e2 + n2, c2 = t3[i3++] * e2 + r2, a2.lineTo(s2, c2);
                break;
              case "q":
                u2 = t3[i3++] * e2 + n2, l2 = t3[i3++] * e2 + r2, h2 = t3[i3++] * e2 + n2, d2 = t3[i3++] * e2 + r2, a2.quadraticCurveTo(h2, d2, u2, l2);
                break;
              case "b":
                u2 = t3[i3++] * e2 + n2, l2 = t3[i3++] * e2 + r2, h2 = t3[i3++] * e2 + n2, d2 = t3[i3++] * e2 + r2, p2 = t3[i3++] * e2 + n2, f2 = t3[i3++] * e2 + r2, a2.bezierCurveTo(h2, d2, p2, f2, u2, l2);
            }
          }
        }
        return { offsetX: o2.ha * e2, path: a2 };
      }
      function Jh(t2) {
        Wl.call(this, t2);
      }
      let $h;
      qh.prototype = Object.assign(Object.create(Wl.prototype), { constructor: qh, isImageBitmapLoader: true, setOptions: function(t2) {
        return this.options = t2, this;
      }, load: function(t2, e2, n2, r2) {
        void 0 === t2 && (t2 = ""), void 0 !== this.path && (t2 = this.path + t2), t2 = this.manager.resolveURL(t2);
        const i2 = this, o2 = Ul.get(t2);
        if (void 0 !== o2) return i2.manager.itemStart(t2), setTimeout(function() {
          e2 && e2(o2), i2.manager.itemEnd(t2);
        }, 0), o2;
        const a2 = {};
        a2.credentials = "anonymous" === this.crossOrigin ? "same-origin" : "include", fetch(t2, a2).then(function(t3) {
          return t3.blob();
        }).then(function(t3) {
          return createImageBitmap(t3, i2.options);
        }).then(function(n3) {
          Ul.add(t2, n3), e2 && e2(n3), i2.manager.itemEnd(t2);
        }).catch(function(e3) {
          r2 && r2(e3), i2.manager.itemError(t2), i2.manager.itemEnd(t2);
        }), i2.manager.itemStart(t2);
      } }), Object.assign(Xh.prototype, { moveTo: function(t2, e2) {
        return this.currentPath = new wh(), this.subPaths.push(this.currentPath), this.currentPath.moveTo(t2, e2), this;
      }, lineTo: function(t2, e2) {
        return this.currentPath.lineTo(t2, e2), this;
      }, quadraticCurveTo: function(t2, e2, n2, r2) {
        return this.currentPath.quadraticCurveTo(t2, e2, n2, r2), this;
      }, bezierCurveTo: function(t2, e2, n2, r2, i2, o2) {
        return this.currentPath.bezierCurveTo(t2, e2, n2, r2, i2, o2), this;
      }, splineThru: function(t2) {
        return this.currentPath.splineThru(t2), this;
      }, toShapes: function(t2, e2) {
        function n2(t3) {
          const e3 = [];
          for (let n3 = 0, r3 = t3.length; n3 < r3; n3++) {
            const r4 = t3[n3], i3 = new _h();
            i3.curves = r4.curves, e3.push(i3);
          }
          return e3;
        }
        function r2(t3, e3) {
          const n3 = e3.length;
          let r3 = false;
          for (let i3 = n3 - 1, o3 = 0; o3 < n3; i3 = o3++) {
            let n4 = e3[i3], a3 = e3[o3], s3 = a3.x - n4.x, c3 = a3.y - n4.y;
            if (Math.abs(c3) > Number.EPSILON) {
              if (c3 < 0 && (n4 = e3[o3], s3 = -s3, a3 = e3[i3], c3 = -c3), t3.y < n4.y || t3.y > a3.y) continue;
              if (t3.y === n4.y) {
                if (t3.x === n4.x) return true;
              } else {
                const e4 = c3 * (t3.x - n4.x) - s3 * (t3.y - n4.y);
                if (0 === e4) return true;
                if (e4 < 0) continue;
                r3 = !r3;
              }
            } else {
              if (t3.y !== n4.y) continue;
              if (a3.x <= t3.x && t3.x <= n4.x || n4.x <= t3.x && t3.x <= a3.x) return true;
            }
          }
          return r3;
        }
        const i2 = zu.isClockWise, o2 = this.subPaths;
        if (0 === o2.length) return [];
        if (true === e2) return n2(o2);
        let a2, s2, c2;
        const u2 = [];
        if (1 === o2.length) return s2 = o2[0], c2 = new _h(), c2.curves = s2.curves, u2.push(c2), u2;
        let l2 = !i2(o2[0].getPoints());
        l2 = t2 ? !l2 : l2;
        const h2 = [], d2 = [];
        let p2, f2, m2 = [], g2 = 0;
        d2[g2] = void 0, m2[g2] = [];
        for (let e3 = 0, n3 = o2.length; e3 < n3; e3++) s2 = o2[e3], p2 = s2.getPoints(), a2 = i2(p2), a2 = t2 ? !a2 : a2, a2 ? (!l2 && d2[g2] && g2++, d2[g2] = { s: new _h(), p: p2 }, d2[g2].s.curves = s2.curves, l2 && g2++, m2[g2] = []) : m2[g2].push({ h: s2, p: p2[0] });
        if (!d2[0]) return n2(o2);
        if (d2.length > 1) {
          let t3 = false;
          const e3 = [];
          for (let t4 = 0, e4 = d2.length; t4 < e4; t4++) h2[t4] = [];
          for (let n3 = 0, i3 = d2.length; n3 < i3; n3++) {
            const i4 = m2[n3];
            for (let o3 = 0; o3 < i4.length; o3++) {
              const a3 = i4[o3];
              let s3 = true;
              for (let i5 = 0; i5 < d2.length; i5++) r2(a3.p, d2[i5].p) && (n3 !== i5 && e3.push({ froms: n3, tos: i5, hole: o3 }), s3 ? (s3 = false, h2[i5].push(a3)) : t3 = true);
              s3 && h2[n3].push(a3);
            }
          }
          e3.length > 0 && (t3 || (m2 = h2));
        }
        for (let t3 = 0, e3 = d2.length; t3 < e3; t3++) {
          c2 = d2[t3].s, u2.push(c2), f2 = m2[t3];
          for (let t4 = 0, e4 = f2.length; t4 < e4; t4++) c2.holes.push(f2[t4].h);
        }
        return u2;
      } }), Object.assign(Yh.prototype, { isFont: true, generateShapes: function(t2, e2 = 100) {
        const n2 = [], r2 = function(t3, e3, n3) {
          const r3 = Array.from ? Array.from(t3) : String(t3).split(""), i2 = e3 / n3.resolution, o2 = (n3.boundingBox.yMax - n3.boundingBox.yMin + n3.underlineThickness) * i2, a2 = [];
          let s2 = 0, c2 = 0;
          for (let t4 = 0; t4 < r3.length; t4++) {
            const e4 = r3[t4];
            if ("\n" === e4) s2 = 0, c2 -= o2;
            else {
              const t5 = Zh(e4, i2, s2, c2, n3);
              s2 += t5.offsetX, a2.push(t5.path);
            }
          }
          return a2;
        }(t2, e2, this.data);
        for (let t3 = 0, e3 = r2.length; t3 < e3; t3++) Array.prototype.push.apply(n2, r2[t3].toShapes());
        return n2;
      } }), Jh.prototype = Object.assign(Object.create(Wl.prototype), { constructor: Jh, load: function(t2, e2, n2, r2) {
        const i2 = this, o2 = new Xl(this.manager);
        o2.setPath(this.path), o2.setRequestHeader(this.requestHeader), o2.setWithCredentials(i2.withCredentials), o2.load(t2, function(t3) {
          let n3;
          try {
            n3 = JSON.parse(t3);
          } catch (e3) {
            console.warn("THREE.FontLoader: typeface.js support is being deprecated. Use typeface.json instead."), n3 = JSON.parse(t3.substring(65, t3.length - 2));
          }
          const r3 = i2.parse(n3);
          e2 && e2(r3);
        }, n2, r2);
      }, parse: function(t2) {
        return new Yh(t2);
      } });
      const Qh = { getContext: function() {
        return void 0 === $h && ($h = new (window.AudioContext || window.webkitAudioContext)()), $h;
      }, setContext: function(t2) {
        $h = t2;
      } };
      function Kh(t2) {
        Wl.call(this, t2);
      }
      function td(t2, e2, n2) {
        zh.call(this, void 0, n2);
        const r2 = new yi().set(t2), i2 = new yi().set(e2), o2 = new $n(r2.r, r2.g, r2.b), a2 = new $n(i2.r, i2.g, i2.b), s2 = Math.sqrt(Math.PI), c2 = s2 * Math.sqrt(0.75);
        this.sh.coefficients[0].copy(o2).add(a2).multiplyScalar(s2), this.sh.coefficients[1].copy(o2).sub(a2).multiplyScalar(c2);
      }
      function ed(t2, e2) {
        zh.call(this, void 0, e2);
        const n2 = new yi().set(t2);
        this.sh.coefficients[0].set(n2.r, n2.g, n2.b).multiplyScalar(2 * Math.sqrt(Math.PI));
      }
      Kh.prototype = Object.assign(Object.create(Wl.prototype), { constructor: Kh, load: function(t2, e2, n2, r2) {
        const i2 = this, o2 = new Xl(i2.manager);
        o2.setResponseType("arraybuffer"), o2.setPath(i2.path), o2.setRequestHeader(i2.requestHeader), o2.setWithCredentials(i2.withCredentials), o2.load(t2, function(n3) {
          try {
            const t3 = n3.slice(0);
            Qh.getContext().decodeAudioData(t3, function(t4) {
              e2(t4);
            });
          } catch (e3) {
            r2 ? r2(e3) : console.error(e3), i2.manager.itemError(t2);
          }
        }, n2, r2);
      } }), td.prototype = Object.assign(Object.create(zh.prototype), { constructor: td, isHemisphereLightProbe: true, copy: function(t2) {
        return zh.prototype.copy.call(this, t2), this;
      }, toJSON: function(t2) {
        return zh.prototype.toJSON.call(this, t2);
      } }), ed.prototype = Object.assign(Object.create(zh.prototype), { constructor: ed, isAmbientLightProbe: true, copy: function(t2) {
        return zh.prototype.copy.call(this, t2), this;
      }, toJSON: function(t2) {
        return zh.prototype.toJSON.call(this, t2);
      } });
      const nd = new Tr(), rd = new Tr();
      function id() {
        this.type = "StereoCamera", this.aspect = 1, this.eyeSep = 0.064, this.cameraL = new wo(), this.cameraL.layers.enable(1), this.cameraL.matrixAutoUpdate = false, this.cameraR = new wo(), this.cameraR.layers.enable(2), this.cameraR.matrixAutoUpdate = false, this._cache = { focus: null, fov: null, aspect: null, near: null, far: null, zoom: null, eyeSep: null };
      }
      Object.assign(id.prototype, { update: function(t2) {
        const e2 = this._cache;
        if (e2.focus !== t2.focus || e2.fov !== t2.fov || e2.aspect !== t2.aspect * this.aspect || e2.near !== t2.near || e2.far !== t2.far || e2.zoom !== t2.zoom || e2.eyeSep !== this.eyeSep) {
          e2.focus = t2.focus, e2.fov = t2.fov, e2.aspect = t2.aspect * this.aspect, e2.near = t2.near, e2.far = t2.far, e2.zoom = t2.zoom, e2.eyeSep = this.eyeSep;
          const n2 = t2.projectionMatrix.clone(), r2 = e2.eyeSep / 2, i2 = r2 * e2.near / e2.focus, o2 = e2.near * Math.tan(Bn.DEG2RAD * e2.fov * 0.5) / e2.zoom;
          let a2, s2;
          rd.elements[12] = -r2, nd.elements[12] = r2, a2 = -o2 * e2.aspect + i2, s2 = o2 * e2.aspect + i2, n2.elements[0] = 2 * e2.near / (s2 - a2), n2.elements[8] = (s2 + a2) / (s2 - a2), this.cameraL.projectionMatrix.copy(n2), a2 = -o2 * e2.aspect - i2, s2 = o2 * e2.aspect - i2, n2.elements[0] = 2 * e2.near / (s2 - a2), n2.elements[8] = (s2 + a2) / (s2 - a2), this.cameraR.projectionMatrix.copy(n2);
        }
        this.cameraL.matrixWorld.copy(t2.matrixWorld).multiply(rd), this.cameraR.matrixWorld.copy(t2.matrixWorld).multiply(nd);
      } });
      class od {
        constructor(t2) {
          this.autoStart = void 0 === t2 || t2, this.startTime = 0, this.oldTime = 0, this.elapsedTime = 0, this.running = false;
        }
        start() {
          this.startTime = ad(), this.oldTime = this.startTime, this.elapsedTime = 0, this.running = true;
        }
        stop() {
          this.getElapsedTime(), this.running = false, this.autoStart = false;
        }
        getElapsedTime() {
          return this.getDelta(), this.elapsedTime;
        }
        getDelta() {
          let t2 = 0;
          if (this.autoStart && !this.running) return this.start(), 0;
          if (this.running) {
            const e2 = ad();
            t2 = (e2 - this.oldTime) / 1e3, this.oldTime = e2, this.elapsedTime += t2;
          }
          return t2;
        }
      }
      function ad() {
        return ("undefined" == typeof performance ? Date : performance).now();
      }
      const sd = new $n(), cd = new Jn(), ud = new $n(), ld = new $n();
      class hd extends Jr {
        constructor() {
          super(), this.type = "AudioListener", this.context = Qh.getContext(), this.gain = this.context.createGain(), this.gain.connect(this.context.destination), this.filter = null, this.timeDelta = 0, this._clock = new od();
        }
        getInput() {
          return this.gain;
        }
        removeFilter() {
          return null !== this.filter && (this.gain.disconnect(this.filter), this.filter.disconnect(this.context.destination), this.gain.connect(this.context.destination), this.filter = null), this;
        }
        getFilter() {
          return this.filter;
        }
        setFilter(t2) {
          return null !== this.filter ? (this.gain.disconnect(this.filter), this.filter.disconnect(this.context.destination)) : this.gain.disconnect(this.context.destination), this.filter = t2, this.gain.connect(this.filter), this.filter.connect(this.context.destination), this;
        }
        getMasterVolume() {
          return this.gain.gain.value;
        }
        setMasterVolume(t2) {
          return this.gain.gain.setTargetAtTime(t2, this.context.currentTime, 0.01), this;
        }
        updateMatrixWorld(t2) {
          super.updateMatrixWorld(t2);
          const e2 = this.context.listener, n2 = this.up;
          if (this.timeDelta = this._clock.getDelta(), this.matrixWorld.decompose(sd, cd, ud), ld.set(0, 0, -1).applyQuaternion(cd), e2.positionX) {
            const t3 = this.context.currentTime + this.timeDelta;
            e2.positionX.linearRampToValueAtTime(sd.x, t3), e2.positionY.linearRampToValueAtTime(sd.y, t3), e2.positionZ.linearRampToValueAtTime(sd.z, t3), e2.forwardX.linearRampToValueAtTime(ld.x, t3), e2.forwardY.linearRampToValueAtTime(ld.y, t3), e2.forwardZ.linearRampToValueAtTime(ld.z, t3), e2.upX.linearRampToValueAtTime(n2.x, t3), e2.upY.linearRampToValueAtTime(n2.y, t3), e2.upZ.linearRampToValueAtTime(n2.z, t3);
          } else e2.setPosition(sd.x, sd.y, sd.z), e2.setOrientation(ld.x, ld.y, ld.z, n2.x, n2.y, n2.z);
        }
      }
      class dd extends Jr {
        constructor(t2) {
          super(), this.type = "Audio", this.listener = t2, this.context = t2.context, this.gain = this.context.createGain(), this.gain.connect(t2.getInput()), this.autoplay = false, this.buffer = null, this.detune = 0, this.loop = false, this.loopStart = 0, this.loopEnd = 0, this.offset = 0, this.duration = void 0, this.playbackRate = 1, this.isPlaying = false, this.hasPlaybackControl = true, this.source = null, this.sourceType = "empty", this._startedAt = 0, this._progress = 0, this._connected = false, this.filters = [];
        }
        getOutput() {
          return this.gain;
        }
        setNodeSource(t2) {
          return this.hasPlaybackControl = false, this.sourceType = "audioNode", this.source = t2, this.connect(), this;
        }
        setMediaElementSource(t2) {
          return this.hasPlaybackControl = false, this.sourceType = "mediaNode", this.source = this.context.createMediaElementSource(t2), this.connect(), this;
        }
        setMediaStreamSource(t2) {
          return this.hasPlaybackControl = false, this.sourceType = "mediaStreamNode", this.source = this.context.createMediaStreamSource(t2), this.connect(), this;
        }
        setBuffer(t2) {
          return this.buffer = t2, this.sourceType = "buffer", this.autoplay && this.play(), this;
        }
        play(t2 = 0) {
          if (true === this.isPlaying) return void console.warn("THREE.Audio: Audio is already playing.");
          if (false === this.hasPlaybackControl) return void console.warn("THREE.Audio: this Audio has no playback control.");
          this._startedAt = this.context.currentTime + t2;
          const e2 = this.context.createBufferSource();
          return e2.buffer = this.buffer, e2.loop = this.loop, e2.loopStart = this.loopStart, e2.loopEnd = this.loopEnd, e2.onended = this.onEnded.bind(this), e2.start(this._startedAt, this._progress + this.offset, this.duration), this.isPlaying = true, this.source = e2, this.setDetune(this.detune), this.setPlaybackRate(this.playbackRate), this.connect();
        }
        pause() {
          if (false !== this.hasPlaybackControl) return true === this.isPlaying && (this._progress += Math.max(this.context.currentTime - this._startedAt, 0) * this.playbackRate, true === this.loop && (this._progress = this._progress % (this.duration || this.buffer.duration)), this.source.stop(), this.source.onended = null, this.isPlaying = false), this;
          console.warn("THREE.Audio: this Audio has no playback control.");
        }
        stop() {
          if (false !== this.hasPlaybackControl) return this._progress = 0, this.source.stop(), this.source.onended = null, this.isPlaying = false, this;
          console.warn("THREE.Audio: this Audio has no playback control.");
        }
        connect() {
          if (this.filters.length > 0) {
            this.source.connect(this.filters[0]);
            for (let t2 = 1, e2 = this.filters.length; t2 < e2; t2++) this.filters[t2 - 1].connect(this.filters[t2]);
            this.filters[this.filters.length - 1].connect(this.getOutput());
          } else this.source.connect(this.getOutput());
          return this._connected = true, this;
        }
        disconnect() {
          if (this.filters.length > 0) {
            this.source.disconnect(this.filters[0]);
            for (let t2 = 1, e2 = this.filters.length; t2 < e2; t2++) this.filters[t2 - 1].disconnect(this.filters[t2]);
            this.filters[this.filters.length - 1].disconnect(this.getOutput());
          } else this.source.disconnect(this.getOutput());
          return this._connected = false, this;
        }
        getFilters() {
          return this.filters;
        }
        setFilters(t2) {
          return t2 || (t2 = []), true === this._connected ? (this.disconnect(), this.filters = t2.slice(), this.connect()) : this.filters = t2.slice(), this;
        }
        setDetune(t2) {
          if (this.detune = t2, void 0 !== this.source.detune) return true === this.isPlaying && this.source.detune.setTargetAtTime(this.detune, this.context.currentTime, 0.01), this;
        }
        getDetune() {
          return this.detune;
        }
        getFilter() {
          return this.getFilters()[0];
        }
        setFilter(t2) {
          return this.setFilters(t2 ? [t2] : []);
        }
        setPlaybackRate(t2) {
          if (false !== this.hasPlaybackControl) return this.playbackRate = t2, true === this.isPlaying && this.source.playbackRate.setTargetAtTime(this.playbackRate, this.context.currentTime, 0.01), this;
          console.warn("THREE.Audio: this Audio has no playback control.");
        }
        getPlaybackRate() {
          return this.playbackRate;
        }
        onEnded() {
          this.isPlaying = false;
        }
        getLoop() {
          return false === this.hasPlaybackControl ? (console.warn("THREE.Audio: this Audio has no playback control."), false) : this.loop;
        }
        setLoop(t2) {
          if (false !== this.hasPlaybackControl) return this.loop = t2, true === this.isPlaying && (this.source.loop = this.loop), this;
          console.warn("THREE.Audio: this Audio has no playback control.");
        }
        setLoopStart(t2) {
          return this.loopStart = t2, this;
        }
        setLoopEnd(t2) {
          return this.loopEnd = t2, this;
        }
        getVolume() {
          return this.gain.gain.value;
        }
        setVolume(t2) {
          return this.gain.gain.setTargetAtTime(t2, this.context.currentTime, 0.01), this;
        }
      }
      const pd = new $n(), fd = new Jn(), md = new $n(), gd = new $n();
      class vd extends dd {
        constructor(t2) {
          super(t2), this.panner = this.context.createPanner(), this.panner.panningModel = "HRTF", this.panner.connect(this.gain);
        }
        getOutput() {
          return this.panner;
        }
        getRefDistance() {
          return this.panner.refDistance;
        }
        setRefDistance(t2) {
          return this.panner.refDistance = t2, this;
        }
        getRolloffFactor() {
          return this.panner.rolloffFactor;
        }
        setRolloffFactor(t2) {
          return this.panner.rolloffFactor = t2, this;
        }
        getDistanceModel() {
          return this.panner.distanceModel;
        }
        setDistanceModel(t2) {
          return this.panner.distanceModel = t2, this;
        }
        getMaxDistance() {
          return this.panner.maxDistance;
        }
        setMaxDistance(t2) {
          return this.panner.maxDistance = t2, this;
        }
        setDirectionalCone(t2, e2, n2) {
          return this.panner.coneInnerAngle = t2, this.panner.coneOuterAngle = e2, this.panner.coneOuterGain = n2, this;
        }
        updateMatrixWorld(t2) {
          if (super.updateMatrixWorld(t2), true === this.hasPlaybackControl && false === this.isPlaying) return;
          this.matrixWorld.decompose(pd, fd, md), gd.set(0, 0, 1).applyQuaternion(fd);
          const e2 = this.panner;
          if (e2.positionX) {
            const t3 = this.context.currentTime + this.listener.timeDelta;
            e2.positionX.linearRampToValueAtTime(pd.x, t3), e2.positionY.linearRampToValueAtTime(pd.y, t3), e2.positionZ.linearRampToValueAtTime(pd.z, t3), e2.orientationX.linearRampToValueAtTime(gd.x, t3), e2.orientationY.linearRampToValueAtTime(gd.y, t3), e2.orientationZ.linearRampToValueAtTime(gd.z, t3);
          } else e2.setPosition(pd.x, pd.y, pd.z), e2.setOrientation(gd.x, gd.y, gd.z);
        }
      }
      class yd {
        constructor(t2, e2 = 2048) {
          this.analyser = t2.context.createAnalyser(), this.analyser.fftSize = e2, this.data = new Uint8Array(this.analyser.frequencyBinCount), t2.getOutput().connect(this.analyser);
        }
        getFrequencyData() {
          return this.analyser.getByteFrequencyData(this.data), this.data;
        }
        getAverageFrequency() {
          let t2 = 0;
          const e2 = this.getFrequencyData();
          for (let n2 = 0; n2 < e2.length; n2++) t2 += e2[n2];
          return t2 / e2.length;
        }
      }
      function xd(t2, e2, n2) {
        let r2, i2, o2;
        switch (this.binding = t2, this.valueSize = n2, e2) {
          case "quaternion":
            r2 = this._slerp, i2 = this._slerpAdditive, o2 = this._setAdditiveIdentityQuaternion, this.buffer = new Float64Array(6 * n2), this._workIndex = 5;
            break;
          case "string":
          case "bool":
            r2 = this._select, i2 = this._select, o2 = this._setAdditiveIdentityOther, this.buffer = new Array(5 * n2);
            break;
          default:
            r2 = this._lerp, i2 = this._lerpAdditive, o2 = this._setAdditiveIdentityNumeric, this.buffer = new Float64Array(5 * n2);
        }
        this._mixBufferRegion = r2, this._mixBufferRegionAdditive = i2, this._setIdentity = o2, this._origIndex = 3, this._addIndex = 4, this.cumulativeWeight = 0, this.cumulativeWeightAdditive = 0, this.useCount = 0, this.referenceCount = 0;
      }
      Object.assign(xd.prototype, { accumulate: function(t2, e2) {
        const n2 = this.buffer, r2 = this.valueSize, i2 = t2 * r2 + r2;
        let o2 = this.cumulativeWeight;
        if (0 === o2) {
          for (let t3 = 0; t3 !== r2; ++t3) n2[i2 + t3] = n2[t3];
          o2 = e2;
        } else {
          o2 += e2;
          const t3 = e2 / o2;
          this._mixBufferRegion(n2, i2, 0, t3, r2);
        }
        this.cumulativeWeight = o2;
      }, accumulateAdditive: function(t2) {
        const e2 = this.buffer, n2 = this.valueSize, r2 = n2 * this._addIndex;
        0 === this.cumulativeWeightAdditive && this._setIdentity(), this._mixBufferRegionAdditive(e2, r2, 0, t2, n2), this.cumulativeWeightAdditive += t2;
      }, apply: function(t2) {
        const e2 = this.valueSize, n2 = this.buffer, r2 = t2 * e2 + e2, i2 = this.cumulativeWeight, o2 = this.cumulativeWeightAdditive, a2 = this.binding;
        if (this.cumulativeWeight = 0, this.cumulativeWeightAdditive = 0, i2 < 1) {
          const t3 = e2 * this._origIndex;
          this._mixBufferRegion(n2, r2, t3, 1 - i2, e2);
        }
        o2 > 0 && this._mixBufferRegionAdditive(n2, r2, this._addIndex * e2, 1, e2);
        for (let t3 = e2, i3 = e2 + e2; t3 !== i3; ++t3) if (n2[t3] !== n2[t3 + e2]) {
          a2.setValue(n2, r2);
          break;
        }
      }, saveOriginalState: function() {
        const t2 = this.binding, e2 = this.buffer, n2 = this.valueSize, r2 = n2 * this._origIndex;
        t2.getValue(e2, r2);
        for (let t3 = n2, i2 = r2; t3 !== i2; ++t3) e2[t3] = e2[r2 + t3 % n2];
        this._setIdentity(), this.cumulativeWeight = 0, this.cumulativeWeightAdditive = 0;
      }, restoreOriginalState: function() {
        const t2 = 3 * this.valueSize;
        this.binding.setValue(this.buffer, t2);
      }, _setAdditiveIdentityNumeric: function() {
        const t2 = this._addIndex * this.valueSize, e2 = t2 + this.valueSize;
        for (let n2 = t2; n2 < e2; n2++) this.buffer[n2] = 0;
      }, _setAdditiveIdentityQuaternion: function() {
        this._setAdditiveIdentityNumeric(), this.buffer[this._addIndex * this.valueSize + 3] = 1;
      }, _setAdditiveIdentityOther: function() {
        const t2 = this._origIndex * this.valueSize, e2 = this._addIndex * this.valueSize;
        for (let n2 = 0; n2 < this.valueSize; n2++) this.buffer[e2 + n2] = this.buffer[t2 + n2];
      }, _select: function(t2, e2, n2, r2, i2) {
        if (r2 >= 0.5) for (let r3 = 0; r3 !== i2; ++r3) t2[e2 + r3] = t2[n2 + r3];
      }, _slerp: function(t2, e2, n2, r2) {
        Jn.slerpFlat(t2, e2, t2, e2, t2, n2, r2);
      }, _slerpAdditive: function(t2, e2, n2, r2, i2) {
        const o2 = this._workIndex * i2;
        Jn.multiplyQuaternionsFlat(t2, o2, t2, e2, t2, n2), Jn.slerpFlat(t2, e2, t2, e2, t2, o2, r2);
      }, _lerp: function(t2, e2, n2, r2, i2) {
        const o2 = 1 - r2;
        for (let a2 = 0; a2 !== i2; ++a2) {
          const i3 = e2 + a2;
          t2[i3] = t2[i3] * o2 + t2[n2 + a2] * r2;
        }
      }, _lerpAdditive: function(t2, e2, n2, r2, i2) {
        for (let o2 = 0; o2 !== i2; ++o2) {
          const i3 = e2 + o2;
          t2[i3] = t2[i3] + t2[n2 + o2] * r2;
        }
      } });
      const bd = new RegExp("[\\[\\]\\.:\\/]", "g"), wd = "[^" + "\\[\\]\\.:\\/".replace("\\.", "") + "]", _d = /((?:WC+[\/:])*)/.source.replace("WC", "[^\\[\\]\\.:\\/]"), Md = /(WCOD+)?/.source.replace("WCOD", wd), Sd = /(?:\.(WC+)(?:\[(.+)\])?)?/.source.replace("WC", "[^\\[\\]\\.:\\/]"), Td = /\.(WC+)(?:\[(.+)\])?/.source.replace("WC", "[^\\[\\]\\.:\\/]"), Ed = new RegExp("^" + _d + Md + Sd + Td + "$"), Ad = ["material", "materials", "bones"];
      function Cd(t2, e2, n2) {
        const r2 = n2 || Ld.parseTrackName(e2);
        this._targetGroup = t2, this._bindings = t2.subscribe_(e2, r2);
      }
      function Ld(t2, e2, n2) {
        this.path = e2, this.parsedPath = n2 || Ld.parseTrackName(e2), this.node = Ld.findNode(t2, this.parsedPath.nodeName) || t2, this.rootNode = t2;
      }
      function Pd() {
        this.uuid = Bn.generateUUID(), this._objects = Array.prototype.slice.call(arguments), this.nCachedObjects_ = 0;
        const t2 = {};
        this._indicesByUUID = t2;
        for (let e3 = 0, n2 = arguments.length; e3 !== n2; ++e3) t2[arguments[e3].uuid] = e3;
        this._paths = [], this._parsedPaths = [], this._bindings = [], this._bindingsIndicesByPath = {};
        const e2 = this;
        this.stats = { objects: { get total() {
          return e2._objects.length;
        }, get inUse() {
          return this.total - e2.nCachedObjects_;
        } }, get bindingsPerObject() {
          return e2._bindings.length;
        } };
      }
      Object.assign(Cd.prototype, { getValue: function(t2, e2) {
        this.bind();
        const n2 = this._targetGroup.nCachedObjects_, r2 = this._bindings[n2];
        void 0 !== r2 && r2.getValue(t2, e2);
      }, setValue: function(t2, e2) {
        const n2 = this._bindings;
        for (let r2 = this._targetGroup.nCachedObjects_, i2 = n2.length; r2 !== i2; ++r2) n2[r2].setValue(t2, e2);
      }, bind: function() {
        const t2 = this._bindings;
        for (let e2 = this._targetGroup.nCachedObjects_, n2 = t2.length; e2 !== n2; ++e2) t2[e2].bind();
      }, unbind: function() {
        const t2 = this._bindings;
        for (let e2 = this._targetGroup.nCachedObjects_, n2 = t2.length; e2 !== n2; ++e2) t2[e2].unbind();
      } }), Object.assign(Ld, { Composite: Cd, create: function(t2, e2, n2) {
        return t2 && t2.isAnimationObjectGroup ? new Ld.Composite(t2, e2, n2) : new Ld(t2, e2, n2);
      }, sanitizeNodeName: function(t2) {
        return t2.replace(/\s/g, "_").replace(bd, "");
      }, parseTrackName: function(t2) {
        const e2 = Ed.exec(t2);
        if (!e2) throw new Error("PropertyBinding: Cannot parse trackName: " + t2);
        const n2 = { nodeName: e2[2], objectName: e2[3], objectIndex: e2[4], propertyName: e2[5], propertyIndex: e2[6] }, r2 = n2.nodeName && n2.nodeName.lastIndexOf(".");
        if (void 0 !== r2 && -1 !== r2) {
          const t3 = n2.nodeName.substring(r2 + 1);
          -1 !== Ad.indexOf(t3) && (n2.nodeName = n2.nodeName.substring(0, r2), n2.objectName = t3);
        }
        if (null === n2.propertyName || 0 === n2.propertyName.length) throw new Error("PropertyBinding: can not parse propertyName from trackName: " + t2);
        return n2;
      }, findNode: function(t2, e2) {
        if (!e2 || "" === e2 || "." === e2 || -1 === e2 || e2 === t2.name || e2 === t2.uuid) return t2;
        if (t2.skeleton) {
          const n2 = t2.skeleton.getBoneByName(e2);
          if (void 0 !== n2) return n2;
        }
        if (t2.children) {
          const n2 = function(t3) {
            for (let r3 = 0; r3 < t3.length; r3++) {
              const i2 = t3[r3];
              if (i2.name === e2 || i2.uuid === e2) return i2;
              const o2 = n2(i2.children);
              if (o2) return o2;
            }
            return null;
          }, r2 = n2(t2.children);
          if (r2) return r2;
        }
        return null;
      } }), Object.assign(Ld.prototype, { _getValue_unavailable: function() {
      }, _setValue_unavailable: function() {
      }, BindingType: { Direct: 0, EntireArray: 1, ArrayElement: 2, HasFromToArray: 3 }, Versioning: { None: 0, NeedsUpdate: 1, MatrixWorldNeedsUpdate: 2 }, GetterByBindingType: [function(t2, e2) {
        t2[e2] = this.node[this.propertyName];
      }, function(t2, e2) {
        const n2 = this.resolvedProperty;
        for (let r2 = 0, i2 = n2.length; r2 !== i2; ++r2) t2[e2++] = n2[r2];
      }, function(t2, e2) {
        t2[e2] = this.resolvedProperty[this.propertyIndex];
      }, function(t2, e2) {
        this.resolvedProperty.toArray(t2, e2);
      }], SetterByBindingTypeAndVersioning: [[function(t2, e2) {
        this.targetObject[this.propertyName] = t2[e2];
      }, function(t2, e2) {
        this.targetObject[this.propertyName] = t2[e2], this.targetObject.needsUpdate = true;
      }, function(t2, e2) {
        this.targetObject[this.propertyName] = t2[e2], this.targetObject.matrixWorldNeedsUpdate = true;
      }], [function(t2, e2) {
        const n2 = this.resolvedProperty;
        for (let r2 = 0, i2 = n2.length; r2 !== i2; ++r2) n2[r2] = t2[e2++];
      }, function(t2, e2) {
        const n2 = this.resolvedProperty;
        for (let r2 = 0, i2 = n2.length; r2 !== i2; ++r2) n2[r2] = t2[e2++];
        this.targetObject.needsUpdate = true;
      }, function(t2, e2) {
        const n2 = this.resolvedProperty;
        for (let r2 = 0, i2 = n2.length; r2 !== i2; ++r2) n2[r2] = t2[e2++];
        this.targetObject.matrixWorldNeedsUpdate = true;
      }], [function(t2, e2) {
        this.resolvedProperty[this.propertyIndex] = t2[e2];
      }, function(t2, e2) {
        this.resolvedProperty[this.propertyIndex] = t2[e2], this.targetObject.needsUpdate = true;
      }, function(t2, e2) {
        this.resolvedProperty[this.propertyIndex] = t2[e2], this.targetObject.matrixWorldNeedsUpdate = true;
      }], [function(t2, e2) {
        this.resolvedProperty.fromArray(t2, e2);
      }, function(t2, e2) {
        this.resolvedProperty.fromArray(t2, e2), this.targetObject.needsUpdate = true;
      }, function(t2, e2) {
        this.resolvedProperty.fromArray(t2, e2), this.targetObject.matrixWorldNeedsUpdate = true;
      }]], getValue: function(t2, e2) {
        this.bind(), this.getValue(t2, e2);
      }, setValue: function(t2, e2) {
        this.bind(), this.setValue(t2, e2);
      }, bind: function() {
        let t2 = this.node;
        const e2 = this.parsedPath, n2 = e2.objectName, r2 = e2.propertyName;
        let i2 = e2.propertyIndex;
        if (t2 || (t2 = Ld.findNode(this.rootNode, e2.nodeName) || this.rootNode, this.node = t2), this.getValue = this._getValue_unavailable, this.setValue = this._setValue_unavailable, !t2) return void console.error("THREE.PropertyBinding: Trying to update node for track: " + this.path + " but it wasn't found.");
        if (n2) {
          let r3 = e2.objectIndex;
          switch (n2) {
            case "materials":
              if (!t2.material) return void console.error("THREE.PropertyBinding: Can not bind to material as node does not have a material.", this);
              if (!t2.material.materials) return void console.error("THREE.PropertyBinding: Can not bind to material.materials as node.material does not have a materials array.", this);
              t2 = t2.material.materials;
              break;
            case "bones":
              if (!t2.skeleton) return void console.error("THREE.PropertyBinding: Can not bind to bones as node does not have a skeleton.", this);
              t2 = t2.skeleton.bones;
              for (let e3 = 0; e3 < t2.length; e3++) if (t2[e3].name === r3) {
                r3 = e3;
                break;
              }
              break;
            default:
              if (void 0 === t2[n2]) return void console.error("THREE.PropertyBinding: Can not bind to objectName of node undefined.", this);
              t2 = t2[n2];
          }
          if (void 0 !== r3) {
            if (void 0 === t2[r3]) return void console.error("THREE.PropertyBinding: Trying to bind to objectIndex of objectName, but is undefined.", this, t2);
            t2 = t2[r3];
          }
        }
        const o2 = t2[r2];
        if (void 0 === o2) {
          const n3 = e2.nodeName;
          return void console.error("THREE.PropertyBinding: Trying to update property for track: " + n3 + "." + r2 + " but it wasn't found.", t2);
        }
        let a2 = this.Versioning.None;
        this.targetObject = t2, void 0 !== t2.needsUpdate ? a2 = this.Versioning.NeedsUpdate : void 0 !== t2.matrixWorldNeedsUpdate && (a2 = this.Versioning.MatrixWorldNeedsUpdate);
        let s2 = this.BindingType.Direct;
        if (void 0 !== i2) {
          if ("morphTargetInfluences" === r2) {
            if (!t2.geometry) return void console.error("THREE.PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.", this);
            if (!t2.geometry.isBufferGeometry) return void console.error("THREE.PropertyBinding: Can not bind to morphTargetInfluences on THREE.Geometry. Use THREE.BufferGeometry instead.", this);
            if (!t2.geometry.morphAttributes) return void console.error("THREE.PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.morphAttributes.", this);
            void 0 !== t2.morphTargetDictionary[i2] && (i2 = t2.morphTargetDictionary[i2]);
          }
          s2 = this.BindingType.ArrayElement, this.resolvedProperty = o2, this.propertyIndex = i2;
        } else void 0 !== o2.fromArray && void 0 !== o2.toArray ? (s2 = this.BindingType.HasFromToArray, this.resolvedProperty = o2) : Array.isArray(o2) ? (s2 = this.BindingType.EntireArray, this.resolvedProperty = o2) : this.propertyName = r2;
        this.getValue = this.GetterByBindingType[s2], this.setValue = this.SetterByBindingTypeAndVersioning[s2][a2];
      }, unbind: function() {
        this.node = null, this.getValue = this._getValue_unbound, this.setValue = this._setValue_unbound;
      } }), Object.assign(Ld.prototype, { _getValue_unbound: Ld.prototype.getValue, _setValue_unbound: Ld.prototype.setValue }), Object.assign(Pd.prototype, { isAnimationObjectGroup: true, add: function() {
        const t2 = this._objects, e2 = this._indicesByUUID, n2 = this._paths, r2 = this._parsedPaths, i2 = this._bindings, o2 = i2.length;
        let a2 = void 0, s2 = t2.length, c2 = this.nCachedObjects_;
        for (let u2 = 0, l2 = arguments.length; u2 !== l2; ++u2) {
          const l3 = arguments[u2], h2 = l3.uuid;
          let d2 = e2[h2];
          if (void 0 === d2) {
            d2 = s2++, e2[h2] = d2, t2.push(l3);
            for (let t3 = 0, e3 = o2; t3 !== e3; ++t3) i2[t3].push(new Ld(l3, n2[t3], r2[t3]));
          } else if (d2 < c2) {
            a2 = t2[d2];
            const s3 = --c2, u3 = t2[s3];
            e2[u3.uuid] = d2, t2[d2] = u3, e2[h2] = s3, t2[s3] = l3;
            for (let t3 = 0, e3 = o2; t3 !== e3; ++t3) {
              const e4 = i2[t3], o3 = e4[s3];
              let a3 = e4[d2];
              e4[d2] = o3, void 0 === a3 && (a3 = new Ld(l3, n2[t3], r2[t3])), e4[s3] = a3;
            }
          } else t2[d2] !== a2 && console.error("THREE.AnimationObjectGroup: Different objects with the same UUID detected. Clean the caches or recreate your infrastructure when reloading scenes.");
        }
        this.nCachedObjects_ = c2;
      }, remove: function() {
        const t2 = this._objects, e2 = this._indicesByUUID, n2 = this._bindings, r2 = n2.length;
        let i2 = this.nCachedObjects_;
        for (let o2 = 0, a2 = arguments.length; o2 !== a2; ++o2) {
          const a3 = arguments[o2], s2 = a3.uuid, c2 = e2[s2];
          if (void 0 !== c2 && c2 >= i2) {
            const o3 = i2++, u2 = t2[o3];
            e2[u2.uuid] = c2, t2[c2] = u2, e2[s2] = o3, t2[o3] = a3;
            for (let t3 = 0, e3 = r2; t3 !== e3; ++t3) {
              const e4 = n2[t3], r3 = e4[o3], i3 = e4[c2];
              e4[c2] = r3, e4[o3] = i3;
            }
          }
        }
        this.nCachedObjects_ = i2;
      }, uncache: function() {
        const t2 = this._objects, e2 = this._indicesByUUID, n2 = this._bindings, r2 = n2.length;
        let i2 = this.nCachedObjects_, o2 = t2.length;
        for (let a2 = 0, s2 = arguments.length; a2 !== s2; ++a2) {
          const s3 = arguments[a2].uuid, c2 = e2[s3];
          if (void 0 !== c2) if (delete e2[s3], c2 < i2) {
            const a3 = --i2, s4 = t2[a3], u2 = --o2, l2 = t2[u2];
            e2[s4.uuid] = c2, t2[c2] = s4, e2[l2.uuid] = a3, t2[a3] = l2, t2.pop();
            for (let t3 = 0, e3 = r2; t3 !== e3; ++t3) {
              const e4 = n2[t3], r3 = e4[a3], i3 = e4[u2];
              e4[c2] = r3, e4[a3] = i3, e4.pop();
            }
          } else {
            const i3 = --o2, a3 = t2[i3];
            i3 > 0 && (e2[a3.uuid] = c2), t2[c2] = a3, t2.pop();
            for (let t3 = 0, e3 = r2; t3 !== e3; ++t3) {
              const e4 = n2[t3];
              e4[c2] = e4[i3], e4.pop();
            }
          }
        }
        this.nCachedObjects_ = i2;
      }, subscribe_: function(t2, e2) {
        const n2 = this._bindingsIndicesByPath;
        let r2 = n2[t2];
        const i2 = this._bindings;
        if (void 0 !== r2) return i2[r2];
        const o2 = this._paths, a2 = this._parsedPaths, s2 = this._objects, c2 = s2.length, u2 = this.nCachedObjects_, l2 = new Array(c2);
        r2 = i2.length, n2[t2] = r2, o2.push(t2), a2.push(e2), i2.push(l2);
        for (let n3 = u2, r3 = s2.length; n3 !== r3; ++n3) {
          const r4 = s2[n3];
          l2[n3] = new Ld(r4, t2, e2);
        }
        return l2;
      }, unsubscribe_: function(t2) {
        const e2 = this._bindingsIndicesByPath, n2 = e2[t2];
        if (void 0 !== n2) {
          const r2 = this._paths, i2 = this._parsedPaths, o2 = this._bindings, a2 = o2.length - 1, s2 = o2[a2];
          e2[t2[a2]] = n2, o2[n2] = s2, o2.pop(), i2[n2] = i2[a2], i2.pop(), r2[n2] = r2[a2], r2.pop();
        }
      } });
      class Rd {
        constructor(t2, e2, n2 = null, r2 = e2.blendMode) {
          this._mixer = t2, this._clip = e2, this._localRoot = n2, this.blendMode = r2;
          const i2 = e2.tracks, o2 = i2.length, a2 = new Array(o2), s2 = { endingStart: Ue, endingEnd: Ue };
          for (let t3 = 0; t3 !== o2; ++t3) {
            const e3 = i2[t3].createInterpolant(null);
            a2[t3] = e3, e3.settings = s2;
          }
          this._interpolantSettings = s2, this._interpolants = a2, this._propertyBindings = new Array(o2), this._cacheIndex = null, this._byClipCacheIndex = null, this._timeScaleInterpolant = null, this._weightInterpolant = null, this.loop = ke, this._loopCount = -1, this._startTime = null, this.time = 0, this.timeScale = 1, this._effectiveTimeScale = 1, this.weight = 1, this._effectiveWeight = 1, this.repetitions = 1 / 0, this.paused = false, this.enabled = true, this.clampWhenFinished = false, this.zeroSlopeAtStart = true, this.zeroSlopeAtEnd = true;
        }
        play() {
          return this._mixer._activateAction(this), this;
        }
        stop() {
          return this._mixer._deactivateAction(this), this.reset();
        }
        reset() {
          return this.paused = false, this.enabled = true, this.time = 0, this._loopCount = -1, this._startTime = null, this.stopFading().stopWarping();
        }
        isRunning() {
          return this.enabled && !this.paused && 0 !== this.timeScale && null === this._startTime && this._mixer._isActiveAction(this);
        }
        isScheduled() {
          return this._mixer._isActiveAction(this);
        }
        startAt(t2) {
          return this._startTime = t2, this;
        }
        setLoop(t2, e2) {
          return this.loop = t2, this.repetitions = e2, this;
        }
        setEffectiveWeight(t2) {
          return this.weight = t2, this._effectiveWeight = this.enabled ? t2 : 0, this.stopFading();
        }
        getEffectiveWeight() {
          return this._effectiveWeight;
        }
        fadeIn(t2) {
          return this._scheduleFading(t2, 0, 1);
        }
        fadeOut(t2) {
          return this._scheduleFading(t2, 1, 0);
        }
        crossFadeFrom(t2, e2, n2) {
          if (t2.fadeOut(e2), this.fadeIn(e2), n2) {
            const n3 = this._clip.duration, r2 = t2._clip.duration, i2 = r2 / n3, o2 = n3 / r2;
            t2.warp(1, i2, e2), this.warp(o2, 1, e2);
          }
          return this;
        }
        crossFadeTo(t2, e2, n2) {
          return t2.crossFadeFrom(this, e2, n2);
        }
        stopFading() {
          const t2 = this._weightInterpolant;
          return null !== t2 && (this._weightInterpolant = null, this._mixer._takeBackControlInterpolant(t2)), this;
        }
        setEffectiveTimeScale(t2) {
          return this.timeScale = t2, this._effectiveTimeScale = this.paused ? 0 : t2, this.stopWarping();
        }
        getEffectiveTimeScale() {
          return this._effectiveTimeScale;
        }
        setDuration(t2) {
          return this.timeScale = this._clip.duration / t2, this.stopWarping();
        }
        syncWith(t2) {
          return this.time = t2.time, this.timeScale = t2.timeScale, this.stopWarping();
        }
        halt(t2) {
          return this.warp(this._effectiveTimeScale, 0, t2);
        }
        warp(t2, e2, n2) {
          const r2 = this._mixer, i2 = r2.time, o2 = this.timeScale;
          let a2 = this._timeScaleInterpolant;
          null === a2 && (a2 = r2._lendControlInterpolant(), this._timeScaleInterpolant = a2);
          const s2 = a2.parameterPositions, c2 = a2.sampleValues;
          return s2[0] = i2, s2[1] = i2 + n2, c2[0] = t2 / o2, c2[1] = e2 / o2, this;
        }
        stopWarping() {
          const t2 = this._timeScaleInterpolant;
          return null !== t2 && (this._timeScaleInterpolant = null, this._mixer._takeBackControlInterpolant(t2)), this;
        }
        getMixer() {
          return this._mixer;
        }
        getClip() {
          return this._clip;
        }
        getRoot() {
          return this._localRoot || this._mixer._root;
        }
        _update(t2, e2, n2, r2) {
          if (!this.enabled) return void this._updateWeight(t2);
          const i2 = this._startTime;
          if (null !== i2) {
            const r3 = (t2 - i2) * n2;
            if (r3 < 0 || 0 === n2) return;
            this._startTime = null, e2 = n2 * r3;
          }
          e2 *= this._updateTimeScale(t2);
          const o2 = this._updateTime(e2), a2 = this._updateWeight(t2);
          if (a2 > 0) {
            const t3 = this._interpolants, e3 = this._propertyBindings;
            switch (this.blendMode) {
              case qe:
                for (let n3 = 0, r3 = t3.length; n3 !== r3; ++n3) t3[n3].evaluate(o2), e3[n3].accumulateAdditive(a2);
                break;
              case We:
              default:
                for (let n3 = 0, i3 = t3.length; n3 !== i3; ++n3) t3[n3].evaluate(o2), e3[n3].accumulate(r2, a2);
            }
          }
        }
        _updateWeight(t2) {
          let e2 = 0;
          if (this.enabled) {
            e2 = this.weight;
            const n2 = this._weightInterpolant;
            if (null !== n2) {
              const r2 = n2.evaluate(t2)[0];
              e2 *= r2, t2 > n2.parameterPositions[1] && (this.stopFading(), 0 === r2 && (this.enabled = false));
            }
          }
          return this._effectiveWeight = e2, e2;
        }
        _updateTimeScale(t2) {
          let e2 = 0;
          if (!this.paused) {
            e2 = this.timeScale;
            const n2 = this._timeScaleInterpolant;
            if (null !== n2) {
              e2 *= n2.evaluate(t2)[0], t2 > n2.parameterPositions[1] && (this.stopWarping(), 0 === e2 ? this.paused = true : this.timeScale = e2);
            }
          }
          return this._effectiveTimeScale = e2, e2;
        }
        _updateTime(t2) {
          const e2 = this._clip.duration, n2 = this.loop;
          let r2 = this.time + t2, i2 = this._loopCount;
          const o2 = n2 === Fe;
          if (0 === t2) return -1 === i2 ? r2 : o2 && 1 == (1 & i2) ? e2 - r2 : r2;
          if (n2 === ze) {
            -1 === i2 && (this._loopCount = 0, this._setEndings(true, true, false));
            t: {
              if (r2 >= e2) r2 = e2;
              else {
                if (!(r2 < 0)) {
                  this.time = r2;
                  break t;
                }
                r2 = 0;
              }
              this.clampWhenFinished ? this.paused = true : this.enabled = false, this.time = r2, this._mixer.dispatchEvent({ type: "finished", action: this, direction: t2 < 0 ? -1 : 1 });
            }
          } else {
            if (-1 === i2 && (t2 >= 0 ? (i2 = 0, this._setEndings(true, 0 === this.repetitions, o2)) : this._setEndings(0 === this.repetitions, true, o2)), r2 >= e2 || r2 < 0) {
              const n3 = Math.floor(r2 / e2);
              r2 -= e2 * n3, i2 += Math.abs(n3);
              const a2 = this.repetitions - i2;
              if (a2 <= 0) this.clampWhenFinished ? this.paused = true : this.enabled = false, r2 = t2 > 0 ? e2 : 0, this.time = r2, this._mixer.dispatchEvent({ type: "finished", action: this, direction: t2 > 0 ? 1 : -1 });
              else {
                if (1 === a2) {
                  const e3 = t2 < 0;
                  this._setEndings(e3, !e3, o2);
                } else this._setEndings(false, false, o2);
                this._loopCount = i2, this.time = r2, this._mixer.dispatchEvent({ type: "loop", action: this, loopDelta: n3 });
              }
            } else this.time = r2;
            if (o2 && 1 == (1 & i2)) return e2 - r2;
          }
          return r2;
        }
        _setEndings(t2, e2, n2) {
          const r2 = this._interpolantSettings;
          n2 ? (r2.endingStart = je, r2.endingEnd = je) : (r2.endingStart = t2 ? this.zeroSlopeAtStart ? je : Ue : Ve, r2.endingEnd = e2 ? this.zeroSlopeAtEnd ? je : Ue : Ve);
        }
        _scheduleFading(t2, e2, n2) {
          const r2 = this._mixer, i2 = r2.time;
          let o2 = this._weightInterpolant;
          null === o2 && (o2 = r2._lendControlInterpolant(), this._weightInterpolant = o2);
          const a2 = o2.parameterPositions, s2 = o2.sampleValues;
          return a2[0] = i2, s2[0] = e2, a2[1] = i2 + t2, s2[1] = n2, this;
        }
      }
      function Od(t2) {
        this._root = t2, this._initMemoryManager(), this._accuIndex = 0, this.time = 0, this.timeScale = 1;
      }
      Od.prototype = Object.assign(Object.create(zn.prototype), { constructor: Od, _bindAction: function(t2, e2) {
        const n2 = t2._localRoot || this._root, r2 = t2._clip.tracks, i2 = r2.length, o2 = t2._propertyBindings, a2 = t2._interpolants, s2 = n2.uuid, c2 = this._bindingsByRootAndName;
        let u2 = c2[s2];
        void 0 === u2 && (u2 = {}, c2[s2] = u2);
        for (let t3 = 0; t3 !== i2; ++t3) {
          const i3 = r2[t3], c3 = i3.name;
          let l2 = u2[c3];
          if (void 0 !== l2) o2[t3] = l2;
          else {
            if (l2 = o2[t3], void 0 !== l2) {
              null === l2._cacheIndex && (++l2.referenceCount, this._addInactiveBinding(l2, s2, c3));
              continue;
            }
            const r3 = e2 && e2._propertyBindings[t3].binding.parsedPath;
            l2 = new xd(Ld.create(n2, c3, r3), i3.ValueTypeName, i3.getValueSize()), ++l2.referenceCount, this._addInactiveBinding(l2, s2, c3), o2[t3] = l2;
          }
          a2[t3].resultBuffer = l2.buffer;
        }
      }, _activateAction: function(t2) {
        if (!this._isActiveAction(t2)) {
          if (null === t2._cacheIndex) {
            const e3 = (t2._localRoot || this._root).uuid, n2 = t2._clip.uuid, r2 = this._actionsByClip[n2];
            this._bindAction(t2, r2 && r2.knownActions[0]), this._addInactiveAction(t2, n2, e3);
          }
          const e2 = t2._propertyBindings;
          for (let t3 = 0, n2 = e2.length; t3 !== n2; ++t3) {
            const n3 = e2[t3];
            0 == n3.useCount++ && (this._lendBinding(n3), n3.saveOriginalState());
          }
          this._lendAction(t2);
        }
      }, _deactivateAction: function(t2) {
        if (this._isActiveAction(t2)) {
          const e2 = t2._propertyBindings;
          for (let t3 = 0, n2 = e2.length; t3 !== n2; ++t3) {
            const n3 = e2[t3];
            0 == --n3.useCount && (n3.restoreOriginalState(), this._takeBackBinding(n3));
          }
          this._takeBackAction(t2);
        }
      }, _initMemoryManager: function() {
        this._actions = [], this._nActiveActions = 0, this._actionsByClip = {}, this._bindings = [], this._nActiveBindings = 0, this._bindingsByRootAndName = {}, this._controlInterpolants = [], this._nActiveControlInterpolants = 0;
        const t2 = this;
        this.stats = { actions: { get total() {
          return t2._actions.length;
        }, get inUse() {
          return t2._nActiveActions;
        } }, bindings: { get total() {
          return t2._bindings.length;
        }, get inUse() {
          return t2._nActiveBindings;
        } }, controlInterpolants: { get total() {
          return t2._controlInterpolants.length;
        }, get inUse() {
          return t2._nActiveControlInterpolants;
        } } };
      }, _isActiveAction: function(t2) {
        const e2 = t2._cacheIndex;
        return null !== e2 && e2 < this._nActiveActions;
      }, _addInactiveAction: function(t2, e2, n2) {
        const r2 = this._actions, i2 = this._actionsByClip;
        let o2 = i2[e2];
        if (void 0 === o2) o2 = { knownActions: [t2], actionByRoot: {} }, t2._byClipCacheIndex = 0, i2[e2] = o2;
        else {
          const e3 = o2.knownActions;
          t2._byClipCacheIndex = e3.length, e3.push(t2);
        }
        t2._cacheIndex = r2.length, r2.push(t2), o2.actionByRoot[n2] = t2;
      }, _removeInactiveAction: function(t2) {
        const e2 = this._actions, n2 = e2[e2.length - 1], r2 = t2._cacheIndex;
        n2._cacheIndex = r2, e2[r2] = n2, e2.pop(), t2._cacheIndex = null;
        const i2 = t2._clip.uuid, o2 = this._actionsByClip, a2 = o2[i2], s2 = a2.knownActions, c2 = s2[s2.length - 1], u2 = t2._byClipCacheIndex;
        c2._byClipCacheIndex = u2, s2[u2] = c2, s2.pop(), t2._byClipCacheIndex = null;
        delete a2.actionByRoot[(t2._localRoot || this._root).uuid], 0 === s2.length && delete o2[i2], this._removeInactiveBindingsForAction(t2);
      }, _removeInactiveBindingsForAction: function(t2) {
        const e2 = t2._propertyBindings;
        for (let t3 = 0, n2 = e2.length; t3 !== n2; ++t3) {
          const n3 = e2[t3];
          0 == --n3.referenceCount && this._removeInactiveBinding(n3);
        }
      }, _lendAction: function(t2) {
        const e2 = this._actions, n2 = t2._cacheIndex, r2 = this._nActiveActions++, i2 = e2[r2];
        t2._cacheIndex = r2, e2[r2] = t2, i2._cacheIndex = n2, e2[n2] = i2;
      }, _takeBackAction: function(t2) {
        const e2 = this._actions, n2 = t2._cacheIndex, r2 = --this._nActiveActions, i2 = e2[r2];
        t2._cacheIndex = r2, e2[r2] = t2, i2._cacheIndex = n2, e2[n2] = i2;
      }, _addInactiveBinding: function(t2, e2, n2) {
        const r2 = this._bindingsByRootAndName, i2 = this._bindings;
        let o2 = r2[e2];
        void 0 === o2 && (o2 = {}, r2[e2] = o2), o2[n2] = t2, t2._cacheIndex = i2.length, i2.push(t2);
      }, _removeInactiveBinding: function(t2) {
        const e2 = this._bindings, n2 = t2.binding, r2 = n2.rootNode.uuid, i2 = n2.path, o2 = this._bindingsByRootAndName, a2 = o2[r2], s2 = e2[e2.length - 1], c2 = t2._cacheIndex;
        s2._cacheIndex = c2, e2[c2] = s2, e2.pop(), delete a2[i2], 0 === Object.keys(a2).length && delete o2[r2];
      }, _lendBinding: function(t2) {
        const e2 = this._bindings, n2 = t2._cacheIndex, r2 = this._nActiveBindings++, i2 = e2[r2];
        t2._cacheIndex = r2, e2[r2] = t2, i2._cacheIndex = n2, e2[n2] = i2;
      }, _takeBackBinding: function(t2) {
        const e2 = this._bindings, n2 = t2._cacheIndex, r2 = --this._nActiveBindings, i2 = e2[r2];
        t2._cacheIndex = r2, e2[r2] = t2, i2._cacheIndex = n2, e2[n2] = i2;
      }, _lendControlInterpolant: function() {
        const t2 = this._controlInterpolants, e2 = this._nActiveControlInterpolants++;
        let n2 = t2[e2];
        return void 0 === n2 && (n2 = new Pl(new Float32Array(2), new Float32Array(2), 1, this._controlInterpolantsResultBuffer), n2.__cacheIndex = e2, t2[e2] = n2), n2;
      }, _takeBackControlInterpolant: function(t2) {
        const e2 = this._controlInterpolants, n2 = t2.__cacheIndex, r2 = --this._nActiveControlInterpolants, i2 = e2[r2];
        t2.__cacheIndex = r2, e2[r2] = t2, i2.__cacheIndex = n2, e2[n2] = i2;
      }, _controlInterpolantsResultBuffer: new Float32Array(1), clipAction: function(t2, e2, n2) {
        const r2 = e2 || this._root, i2 = r2.uuid;
        let o2 = "string" == typeof t2 ? Hl.findByName(r2, t2) : t2;
        const a2 = null !== o2 ? o2.uuid : t2, s2 = this._actionsByClip[a2];
        let c2 = null;
        if (void 0 === n2 && (n2 = null !== o2 ? o2.blendMode : We), void 0 !== s2) {
          const t3 = s2.actionByRoot[i2];
          if (void 0 !== t3 && t3.blendMode === n2) return t3;
          c2 = s2.knownActions[0], null === o2 && (o2 = c2._clip);
        }
        if (null === o2) return null;
        const u2 = new Rd(this, o2, e2, n2);
        return this._bindAction(u2, c2), this._addInactiveAction(u2, a2, i2), u2;
      }, existingAction: function(t2, e2) {
        const n2 = e2 || this._root, r2 = n2.uuid, i2 = "string" == typeof t2 ? Hl.findByName(n2, t2) : t2, o2 = i2 ? i2.uuid : t2, a2 = this._actionsByClip[o2];
        return void 0 !== a2 && a2.actionByRoot[r2] || null;
      }, stopAllAction: function() {
        const t2 = this._actions;
        for (let e2 = this._nActiveActions - 1; e2 >= 0; --e2) t2[e2].stop();
        return this;
      }, update: function(t2) {
        t2 *= this.timeScale;
        const e2 = this._actions, n2 = this._nActiveActions, r2 = this.time += t2, i2 = Math.sign(t2), o2 = this._accuIndex ^= 1;
        for (let a3 = 0; a3 !== n2; ++a3) {
          e2[a3]._update(r2, t2, i2, o2);
        }
        const a2 = this._bindings, s2 = this._nActiveBindings;
        for (let t3 = 0; t3 !== s2; ++t3) a2[t3].apply(o2);
        return this;
      }, setTime: function(t2) {
        this.time = 0;
        for (let t3 = 0; t3 < this._actions.length; t3++) this._actions[t3].time = 0;
        return this.update(t2);
      }, getRoot: function() {
        return this._root;
      }, uncacheClip: function(t2) {
        const e2 = this._actions, n2 = t2.uuid, r2 = this._actionsByClip, i2 = r2[n2];
        if (void 0 !== i2) {
          const t3 = i2.knownActions;
          for (let n3 = 0, r3 = t3.length; n3 !== r3; ++n3) {
            const r4 = t3[n3];
            this._deactivateAction(r4);
            const i3 = r4._cacheIndex, o2 = e2[e2.length - 1];
            r4._cacheIndex = null, r4._byClipCacheIndex = null, o2._cacheIndex = i3, e2[i3] = o2, e2.pop(), this._removeInactiveBindingsForAction(r4);
          }
          delete r2[n2];
        }
      }, uncacheRoot: function(t2) {
        const e2 = t2.uuid, n2 = this._actionsByClip;
        for (const t3 in n2) {
          const r3 = n2[t3].actionByRoot[e2];
          void 0 !== r3 && (this._deactivateAction(r3), this._removeInactiveAction(r3));
        }
        const r2 = this._bindingsByRootAndName[e2];
        if (void 0 !== r2) for (const t3 in r2) {
          const e3 = r2[t3];
          e3.restoreOriginalState(), this._removeInactiveBinding(e3);
        }
      }, uncacheAction: function(t2, e2) {
        const n2 = this.existingAction(t2, e2);
        null !== n2 && (this._deactivateAction(n2), this._removeInactiveAction(n2));
      } });
      class Dd {
        constructor(t2) {
          "string" == typeof t2 && (console.warn("THREE.Uniform: Type parameter is no longer needed."), t2 = arguments[1]), this.value = t2;
        }
        clone() {
          return new Dd(void 0 === this.value.clone ? this.value : this.value.clone());
        }
      }
      function Id(t2, e2, n2) {
        Hs.call(this, t2, e2), this.meshPerAttribute = n2 || 1;
      }
      function Nd(t2, e2, n2, r2, i2) {
        this.buffer = t2, this.type = e2, this.itemSize = n2, this.elementSize = r2, this.count = i2, this.version = 0;
      }
      function zd(t2, e2, n2, r2) {
        this.ray = new Sr(t2, e2), this.near = n2 || 0, this.far = r2 || 1 / 0, this.camera = null, this.layers = new zr(), this.params = { Mesh: {}, Line: { threshold: 1 }, LOD: {}, Points: { threshold: 1 }, Sprite: {} }, Object.defineProperties(this.params, { PointCloud: { get: function() {
          return console.warn("THREE.Raycaster: params.PointCloud has been renamed to params.Points."), this.Points;
        } } });
      }
      function kd(t2, e2) {
        return t2.distance - e2.distance;
      }
      function Fd(t2, e2, n2, r2) {
        if (t2.layers.test(e2.layers) && t2.raycast(e2, n2), true === r2) {
          const r3 = t2.children;
          for (let t3 = 0, i2 = r3.length; t3 < i2; t3++) Fd(r3[t3], e2, n2, true);
        }
      }
      Id.prototype = Object.assign(Object.create(Hs.prototype), { constructor: Id, isInstancedInterleavedBuffer: true, copy: function(t2) {
        return Hs.prototype.copy.call(this, t2), this.meshPerAttribute = t2.meshPerAttribute, this;
      }, clone: function(t2) {
        const e2 = Hs.prototype.clone.call(this, t2);
        return e2.meshPerAttribute = this.meshPerAttribute, e2;
      }, toJSON: function(t2) {
        const e2 = Hs.prototype.toJSON.call(this, t2);
        return e2.isInstancedInterleavedBuffer = true, e2.meshPerAttribute = this.meshPerAttribute, e2;
      } }), Object.defineProperty(Nd.prototype, "needsUpdate", { set: function(t2) {
        true === t2 && this.version++;
      } }), Object.assign(Nd.prototype, { isGLBufferAttribute: true, setBuffer: function(t2) {
        return this.buffer = t2, this;
      }, setType: function(t2, e2) {
        return this.type = t2, this.elementSize = e2, this;
      }, setItemSize: function(t2) {
        return this.itemSize = t2, this;
      }, setCount: function(t2) {
        return this.count = t2, this;
      } }), Object.assign(zd.prototype, { set: function(t2, e2) {
        this.ray.set(t2, e2);
      }, setFromCamera: function(t2, e2) {
        e2 && e2.isPerspectiveCamera ? (this.ray.origin.setFromMatrixPosition(e2.matrixWorld), this.ray.direction.set(t2.x, t2.y, 0.5).unproject(e2).sub(this.ray.origin).normalize(), this.camera = e2) : e2 && e2.isOrthographicCamera ? (this.ray.origin.set(t2.x, t2.y, (e2.near + e2.far) / (e2.near - e2.far)).unproject(e2), this.ray.direction.set(0, 0, -1).transformDirection(e2.matrixWorld), this.camera = e2) : console.error("THREE.Raycaster: Unsupported camera type: " + e2.type);
      }, intersectObject: function(t2, e2, n2) {
        const r2 = n2 || [];
        return Fd(t2, this, r2, e2), r2.sort(kd), r2;
      }, intersectObjects: function(t2, e2, n2) {
        const r2 = n2 || [];
        if (false === Array.isArray(t2)) return console.warn("THREE.Raycaster.intersectObjects: objects is not an Array."), r2;
        for (let n3 = 0, i2 = t2.length; n3 < i2; n3++) Fd(t2[n3], this, r2, e2);
        return r2.sort(kd), r2;
      } });
      class Bd {
        constructor(t2 = 1, e2 = 0, n2 = 0) {
          return this.radius = t2, this.phi = e2, this.theta = n2, this;
        }
        set(t2, e2, n2) {
          return this.radius = t2, this.phi = e2, this.theta = n2, this;
        }
        clone() {
          return new this.constructor().copy(this);
        }
        copy(t2) {
          return this.radius = t2.radius, this.phi = t2.phi, this.theta = t2.theta, this;
        }
        makeSafe() {
          return this.phi = Math.max(1e-6, Math.min(Math.PI - 1e-6, this.phi)), this;
        }
        setFromVector3(t2) {
          return this.setFromCartesianCoords(t2.x, t2.y, t2.z);
        }
        setFromCartesianCoords(t2, e2, n2) {
          return this.radius = Math.sqrt(t2 * t2 + e2 * e2 + n2 * n2), 0 === this.radius ? (this.theta = 0, this.phi = 0) : (this.theta = Math.atan2(t2, n2), this.phi = Math.acos(Bn.clamp(e2 / this.radius, -1, 1))), this;
        }
      }
      class Hd {
        constructor(t2, e2, n2) {
          return this.radius = void 0 !== t2 ? t2 : 1, this.theta = void 0 !== e2 ? e2 : 0, this.y = void 0 !== n2 ? n2 : 0, this;
        }
        set(t2, e2, n2) {
          return this.radius = t2, this.theta = e2, this.y = n2, this;
        }
        clone() {
          return new this.constructor().copy(this);
        }
        copy(t2) {
          return this.radius = t2.radius, this.theta = t2.theta, this.y = t2.y, this;
        }
        setFromVector3(t2) {
          return this.setFromCartesianCoords(t2.x, t2.y, t2.z);
        }
        setFromCartesianCoords(t2, e2, n2) {
          return this.radius = Math.sqrt(t2 * t2 + n2 * n2), this.theta = Math.atan2(t2, n2), this.y = e2, this;
        }
      }
      const Gd = new Hn();
      class Ud {
        constructor(t2, e2) {
          Object.defineProperty(this, "isBox2", { value: true }), this.min = void 0 !== t2 ? t2 : new Hn(1 / 0, 1 / 0), this.max = void 0 !== e2 ? e2 : new Hn(-1 / 0, -1 / 0);
        }
        set(t2, e2) {
          return this.min.copy(t2), this.max.copy(e2), this;
        }
        setFromPoints(t2) {
          this.makeEmpty();
          for (let e2 = 0, n2 = t2.length; e2 < n2; e2++) this.expandByPoint(t2[e2]);
          return this;
        }
        setFromCenterAndSize(t2, e2) {
          const n2 = Gd.copy(e2).multiplyScalar(0.5);
          return this.min.copy(t2).sub(n2), this.max.copy(t2).add(n2), this;
        }
        clone() {
          return new this.constructor().copy(this);
        }
        copy(t2) {
          return this.min.copy(t2.min), this.max.copy(t2.max), this;
        }
        makeEmpty() {
          return this.min.x = this.min.y = 1 / 0, this.max.x = this.max.y = -1 / 0, this;
        }
        isEmpty() {
          return this.max.x < this.min.x || this.max.y < this.min.y;
        }
        getCenter(t2) {
          return void 0 === t2 && (console.warn("THREE.Box2: .getCenter() target is now required"), t2 = new Hn()), this.isEmpty() ? t2.set(0, 0) : t2.addVectors(this.min, this.max).multiplyScalar(0.5);
        }
        getSize(t2) {
          return void 0 === t2 && (console.warn("THREE.Box2: .getSize() target is now required"), t2 = new Hn()), this.isEmpty() ? t2.set(0, 0) : t2.subVectors(this.max, this.min);
        }
        expandByPoint(t2) {
          return this.min.min(t2), this.max.max(t2), this;
        }
        expandByVector(t2) {
          return this.min.sub(t2), this.max.add(t2), this;
        }
        expandByScalar(t2) {
          return this.min.addScalar(-t2), this.max.addScalar(t2), this;
        }
        containsPoint(t2) {
          return !(t2.x < this.min.x || t2.x > this.max.x || t2.y < this.min.y || t2.y > this.max.y);
        }
        containsBox(t2) {
          return this.min.x <= t2.min.x && t2.max.x <= this.max.x && this.min.y <= t2.min.y && t2.max.y <= this.max.y;
        }
        getParameter(t2, e2) {
          return void 0 === e2 && (console.warn("THREE.Box2: .getParameter() target is now required"), e2 = new Hn()), e2.set((t2.x - this.min.x) / (this.max.x - this.min.x), (t2.y - this.min.y) / (this.max.y - this.min.y));
        }
        intersectsBox(t2) {
          return !(t2.max.x < this.min.x || t2.min.x > this.max.x || t2.max.y < this.min.y || t2.min.y > this.max.y);
        }
        clampPoint(t2, e2) {
          return void 0 === e2 && (console.warn("THREE.Box2: .clampPoint() target is now required"), e2 = new Hn()), e2.copy(t2).clamp(this.min, this.max);
        }
        distanceToPoint(t2) {
          return Gd.copy(t2).clamp(this.min, this.max).sub(t2).length();
        }
        intersect(t2) {
          return this.min.max(t2.min), this.max.min(t2.max), this;
        }
        union(t2) {
          return this.min.min(t2.min), this.max.max(t2.max), this;
        }
        translate(t2) {
          return this.min.add(t2), this.max.add(t2), this;
        }
        equals(t2) {
          return t2.min.equals(this.min) && t2.max.equals(this.max);
        }
      }
      const jd = new $n(), Vd = new $n();
      class Wd {
        constructor(t2, e2) {
          this.start = void 0 !== t2 ? t2 : new $n(), this.end = void 0 !== e2 ? e2 : new $n();
        }
        set(t2, e2) {
          return this.start.copy(t2), this.end.copy(e2), this;
        }
        clone() {
          return new this.constructor().copy(this);
        }
        copy(t2) {
          return this.start.copy(t2.start), this.end.copy(t2.end), this;
        }
        getCenter(t2) {
          return void 0 === t2 && (console.warn("THREE.Line3: .getCenter() target is now required"), t2 = new $n()), t2.addVectors(this.start, this.end).multiplyScalar(0.5);
        }
        delta(t2) {
          return void 0 === t2 && (console.warn("THREE.Line3: .delta() target is now required"), t2 = new $n()), t2.subVectors(this.end, this.start);
        }
        distanceSq() {
          return this.start.distanceToSquared(this.end);
        }
        distance() {
          return this.start.distanceTo(this.end);
        }
        at(t2, e2) {
          return void 0 === e2 && (console.warn("THREE.Line3: .at() target is now required"), e2 = new $n()), this.delta(e2).multiplyScalar(t2).add(this.start);
        }
        closestPointToPointParameter(t2, e2) {
          jd.subVectors(t2, this.start), Vd.subVectors(this.end, this.start);
          const n2 = Vd.dot(Vd);
          let r2 = Vd.dot(jd) / n2;
          return e2 && (r2 = Bn.clamp(r2, 0, 1)), r2;
        }
        closestPointToPoint(t2, e2, n2) {
          const r2 = this.closestPointToPointParameter(t2, e2);
          return void 0 === n2 && (console.warn("THREE.Line3: .closestPointToPoint() target is now required"), n2 = new $n()), this.delta(n2).multiplyScalar(r2).add(this.start);
        }
        applyMatrix4(t2) {
          return this.start.applyMatrix4(t2), this.end.applyMatrix4(t2), this;
        }
        equals(t2) {
          return t2.start.equals(this.start) && t2.end.equals(this.end);
        }
      }
      function qd(t2) {
        Jr.call(this), this.material = t2, this.render = function() {
        }, this.hasPositions = false, this.hasNormals = false, this.hasColors = false, this.hasUvs = false, this.positionArray = null, this.normalArray = null, this.colorArray = null, this.uvArray = null, this.count = 0;
      }
      qd.prototype = Object.create(Jr.prototype), qd.prototype.constructor = qd, qd.prototype.isImmediateRenderObject = true;
      const Xd = new $n();
      class Yd extends Jr {
        constructor(t2, e2) {
          super(), this.light = t2, this.light.updateMatrixWorld(), this.matrix = t2.matrixWorld, this.matrixAutoUpdate = false, this.color = e2;
          const n2 = new Xi(), r2 = [0, 0, 0, 0, 0, 1, 0, 0, 0, 1, 0, 1, 0, 0, 0, -1, 0, 1, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, -1, 1];
          for (let t3 = 0, e3 = 1, n3 = 32; t3 < n3; t3++, e3++) {
            const i3 = t3 / n3 * Math.PI * 2, o2 = e3 / n3 * Math.PI * 2;
            r2.push(Math.cos(i3), Math.sin(i3), 1, Math.cos(o2), Math.sin(o2), 1);
          }
          n2.setAttribute("position", new Ii(r2, 3));
          const i2 = new Mc({ fog: false, toneMapped: false });
          this.cone = new Oc(n2, i2), this.add(this.cone), this.update();
        }
        dispose() {
          this.cone.geometry.dispose(), this.cone.material.dispose();
        }
        update() {
          this.light.updateMatrixWorld();
          const t2 = this.light.distance ? this.light.distance : 1e3, e2 = t2 * Math.tan(this.light.angle);
          this.cone.scale.set(e2, e2, t2), Xd.setFromMatrixPosition(this.light.target.matrixWorld), this.cone.lookAt(Xd), void 0 !== this.color ? this.cone.material.color.set(this.color) : this.cone.material.color.copy(this.light.color);
        }
      }
      const Zd = new $n(), Jd = new Tr(), $d = new Tr();
      class Qd extends Oc {
        constructor(t2) {
          const e2 = function t3(e3) {
            const n3 = [];
            e3 && e3.isBone && n3.push(e3);
            for (let r3 = 0; r3 < e3.children.length; r3++) n3.push.apply(n3, t3(e3.children[r3]));
            return n3;
          }(t2), n2 = new Xi(), r2 = [], i2 = [], o2 = new yi(0, 0, 1), a2 = new yi(0, 1, 0);
          for (let t3 = 0; t3 < e2.length; t3++) {
            const n3 = e2[t3];
            n3.parent && n3.parent.isBone && (r2.push(0, 0, 0), r2.push(0, 0, 0), i2.push(o2.r, o2.g, o2.b), i2.push(a2.r, a2.g, a2.b));
          }
          n2.setAttribute("position", new Ii(r2, 3)), n2.setAttribute("color", new Ii(i2, 3));
          super(n2, new Mc({ vertexColors: true, depthTest: false, depthWrite: false, toneMapped: false, transparent: true })), this.type = "SkeletonHelper", this.isSkeletonHelper = true, this.root = t2, this.bones = e2, this.matrix = t2.matrixWorld, this.matrixAutoUpdate = false;
        }
        updateMatrixWorld(t2) {
          const e2 = this.bones, n2 = this.geometry, r2 = n2.getAttribute("position");
          $d.copy(this.root.matrixWorld).invert();
          for (let t3 = 0, n3 = 0; t3 < e2.length; t3++) {
            const i2 = e2[t3];
            i2.parent && i2.parent.isBone && (Jd.multiplyMatrices($d, i2.matrixWorld), Zd.setFromMatrixPosition(Jd), r2.setXYZ(n3, Zd.x, Zd.y, Zd.z), Jd.multiplyMatrices($d, i2.parent.matrixWorld), Zd.setFromMatrixPosition(Jd), r2.setXYZ(n3 + 1, Zd.x, Zd.y, Zd.z), n3 += 2);
          }
          n2.getAttribute("position").needsUpdate = true, super.updateMatrixWorld(t2);
        }
      }
      class Kd extends ho {
        constructor(t2, e2, n2) {
          super(new nl(e2, 4, 2), new _i({ wireframe: true, fog: false, toneMapped: false })), this.light = t2, this.light.updateMatrixWorld(), this.color = n2, this.type = "PointLightHelper", this.matrix = this.light.matrixWorld, this.matrixAutoUpdate = false, this.update();
        }
        dispose() {
          this.geometry.dispose(), this.material.dispose();
        }
        update() {
          void 0 !== this.color ? this.material.color.set(this.color) : this.material.color.copy(this.light.color);
        }
      }
      const tp = new $n(), ep = new yi(), np = new yi();
      class rp extends Jr {
        constructor(t2, e2, n2) {
          super(), this.light = t2, this.light.updateMatrixWorld(), this.matrix = t2.matrixWorld, this.matrixAutoUpdate = false, this.color = n2;
          const r2 = new qu(e2);
          r2.rotateY(0.5 * Math.PI), this.material = new _i({ wireframe: true, fog: false, toneMapped: false }), void 0 === this.color && (this.material.vertexColors = true);
          const i2 = r2.getAttribute("position"), o2 = new Float32Array(3 * i2.count);
          r2.setAttribute("color", new Ti(o2, 3)), this.add(new ho(r2, this.material)), this.update();
        }
        dispose() {
          this.children[0].geometry.dispose(), this.children[0].material.dispose();
        }
        update() {
          const t2 = this.children[0];
          if (void 0 !== this.color) this.material.color.set(this.color);
          else {
            const e2 = t2.geometry.getAttribute("color");
            ep.copy(this.light.color), np.copy(this.light.groundColor);
            for (let t3 = 0, n2 = e2.count; t3 < n2; t3++) {
              const r2 = t3 < n2 / 2 ? ep : np;
              e2.setXYZ(t3, r2.r, r2.g, r2.b);
            }
            e2.needsUpdate = true;
          }
          t2.lookAt(tp.setFromMatrixPosition(this.light.matrixWorld).negate());
        }
      }
      class ip extends Oc {
        constructor(t2 = 10, e2 = 10, n2 = 4473924, r2 = 8947848) {
          n2 = new yi(n2), r2 = new yi(r2);
          const i2 = e2 / 2, o2 = t2 / e2, a2 = t2 / 2, s2 = [], c2 = [];
          for (let t3 = 0, u3 = 0, l2 = -a2; t3 <= e2; t3++, l2 += o2) {
            s2.push(-a2, 0, l2, a2, 0, l2), s2.push(l2, 0, -a2, l2, 0, a2);
            const e3 = t3 === i2 ? n2 : r2;
            e3.toArray(c2, u3), u3 += 3, e3.toArray(c2, u3), u3 += 3, e3.toArray(c2, u3), u3 += 3, e3.toArray(c2, u3), u3 += 3;
          }
          const u2 = new Xi();
          u2.setAttribute("position", new Ii(s2, 3)), u2.setAttribute("color", new Ii(c2, 3));
          super(u2, new Mc({ vertexColors: true, toneMapped: false })), this.type = "GridHelper";
        }
      }
      class op extends Oc {
        constructor(t2 = 10, e2 = 16, n2 = 8, r2 = 64, i2 = 4473924, o2 = 8947848) {
          i2 = new yi(i2), o2 = new yi(o2);
          const a2 = [], s2 = [];
          for (let n3 = 0; n3 <= e2; n3++) {
            const r3 = n3 / e2 * (2 * Math.PI), c3 = Math.sin(r3) * t2, u2 = Math.cos(r3) * t2;
            a2.push(0, 0, 0), a2.push(c3, 0, u2);
            const l2 = 1 & n3 ? i2 : o2;
            s2.push(l2.r, l2.g, l2.b), s2.push(l2.r, l2.g, l2.b);
          }
          for (let e3 = 0; e3 <= n2; e3++) {
            const c3 = 1 & e3 ? i2 : o2, u2 = t2 - t2 / n2 * e3;
            for (let t3 = 0; t3 < r2; t3++) {
              let e4 = t3 / r2 * (2 * Math.PI), n3 = Math.sin(e4) * u2, i3 = Math.cos(e4) * u2;
              a2.push(n3, 0, i3), s2.push(c3.r, c3.g, c3.b), e4 = (t3 + 1) / r2 * (2 * Math.PI), n3 = Math.sin(e4) * u2, i3 = Math.cos(e4) * u2, a2.push(n3, 0, i3), s2.push(c3.r, c3.g, c3.b);
            }
          }
          const c2 = new Xi();
          c2.setAttribute("position", new Ii(a2, 3)), c2.setAttribute("color", new Ii(s2, 3));
          super(c2, new Mc({ vertexColors: true, toneMapped: false })), this.type = "PolarGridHelper";
        }
      }
      const ap = new $n(), sp = new $n(), cp = new $n();
      class up extends Jr {
        constructor(t2, e2, n2) {
          super(), this.light = t2, this.light.updateMatrixWorld(), this.matrix = t2.matrixWorld, this.matrixAutoUpdate = false, this.color = n2, void 0 === e2 && (e2 = 1);
          let r2 = new Xi();
          r2.setAttribute("position", new Ii([-e2, e2, 0, e2, e2, 0, e2, -e2, 0, -e2, -e2, 0, -e2, e2, 0], 3));
          const i2 = new Mc({ fog: false, toneMapped: false });
          this.lightPlane = new Lc(r2, i2), this.add(this.lightPlane), r2 = new Xi(), r2.setAttribute("position", new Ii([0, 0, 0, 0, 0, 1], 3)), this.targetLine = new Lc(r2, i2), this.add(this.targetLine), this.update();
        }
        dispose() {
          this.lightPlane.geometry.dispose(), this.lightPlane.material.dispose(), this.targetLine.geometry.dispose(), this.targetLine.material.dispose();
        }
        update() {
          ap.setFromMatrixPosition(this.light.matrixWorld), sp.setFromMatrixPosition(this.light.target.matrixWorld), cp.subVectors(sp, ap), this.lightPlane.lookAt(sp), void 0 !== this.color ? (this.lightPlane.material.color.set(this.color), this.targetLine.material.color.set(this.color)) : (this.lightPlane.material.color.copy(this.light.color), this.targetLine.material.color.copy(this.light.color)), this.targetLine.lookAt(sp), this.targetLine.scale.z = cp.length();
        }
      }
      const lp = new $n(), hp = new bo();
      class dp extends Oc {
        constructor(t2) {
          const e2 = new Xi(), n2 = new Mc({ color: 16777215, vertexColors: true, toneMapped: false }), r2 = [], i2 = [], o2 = {}, a2 = new yi(16755200), s2 = new yi(16711680), c2 = new yi(43775), u2 = new yi(16777215), l2 = new yi(3355443);
          function h2(t3, e3, n3) {
            d2(t3, n3), d2(e3, n3);
          }
          function d2(t3, e3) {
            r2.push(0, 0, 0), i2.push(e3.r, e3.g, e3.b), void 0 === o2[t3] && (o2[t3] = []), o2[t3].push(r2.length / 3 - 1);
          }
          h2("n1", "n2", a2), h2("n2", "n4", a2), h2("n4", "n3", a2), h2("n3", "n1", a2), h2("f1", "f2", a2), h2("f2", "f4", a2), h2("f4", "f3", a2), h2("f3", "f1", a2), h2("n1", "f1", a2), h2("n2", "f2", a2), h2("n3", "f3", a2), h2("n4", "f4", a2), h2("p", "n1", s2), h2("p", "n2", s2), h2("p", "n3", s2), h2("p", "n4", s2), h2("u1", "u2", c2), h2("u2", "u3", c2), h2("u3", "u1", c2), h2("c", "t", u2), h2("p", "c", l2), h2("cn1", "cn2", l2), h2("cn3", "cn4", l2), h2("cf1", "cf2", l2), h2("cf3", "cf4", l2), e2.setAttribute("position", new Ii(r2, 3)), e2.setAttribute("color", new Ii(i2, 3)), super(e2, n2), this.type = "CameraHelper", this.camera = t2, this.camera.updateProjectionMatrix && this.camera.updateProjectionMatrix(), this.matrix = t2.matrixWorld, this.matrixAutoUpdate = false, this.pointMap = o2, this.update();
        }
        update() {
          const t2 = this.geometry, e2 = this.pointMap;
          hp.projectionMatrixInverse.copy(this.camera.projectionMatrixInverse), pp("c", e2, t2, hp, 0, 0, -1), pp("t", e2, t2, hp, 0, 0, 1), pp("n1", e2, t2, hp, -1, -1, -1), pp("n2", e2, t2, hp, 1, -1, -1), pp("n3", e2, t2, hp, -1, 1, -1), pp("n4", e2, t2, hp, 1, 1, -1), pp("f1", e2, t2, hp, -1, -1, 1), pp("f2", e2, t2, hp, 1, -1, 1), pp("f3", e2, t2, hp, -1, 1, 1), pp("f4", e2, t2, hp, 1, 1, 1), pp("u1", e2, t2, hp, 0.7, 1.1, -1), pp("u2", e2, t2, hp, -0.7, 1.1, -1), pp("u3", e2, t2, hp, 0, 2, -1), pp("cf1", e2, t2, hp, -1, 0, 1), pp("cf2", e2, t2, hp, 1, 0, 1), pp("cf3", e2, t2, hp, 0, -1, 1), pp("cf4", e2, t2, hp, 0, 1, 1), pp("cn1", e2, t2, hp, -1, 0, -1), pp("cn2", e2, t2, hp, 1, 0, -1), pp("cn3", e2, t2, hp, 0, -1, -1), pp("cn4", e2, t2, hp, 0, 1, -1), t2.getAttribute("position").needsUpdate = true;
        }
      }
      function pp(t2, e2, n2, r2, i2, o2, a2) {
        lp.set(i2, o2, a2).unproject(r2);
        const s2 = e2[t2];
        if (void 0 !== s2) {
          const t3 = n2.getAttribute("position");
          for (let e3 = 0, n3 = s2.length; e3 < n3; e3++) t3.setXYZ(s2[e3], lp.x, lp.y, lp.z);
        }
      }
      const fp = new tr();
      class mp extends Oc {
        constructor(t2, e2 = 16776960) {
          const n2 = new Uint16Array([0, 1, 1, 2, 2, 3, 3, 0, 4, 5, 5, 6, 6, 7, 7, 4, 0, 4, 1, 5, 2, 6, 3, 7]), r2 = new Float32Array(24), i2 = new Xi();
          i2.setIndex(new Ti(n2, 1)), i2.setAttribute("position", new Ti(r2, 3)), super(i2, new Mc({ color: e2, toneMapped: false })), this.object = t2, this.type = "BoxHelper", this.matrixAutoUpdate = false, this.update();
        }
        update(t2) {
          if (void 0 !== t2 && console.warn("THREE.BoxHelper: .update() has no longer arguments."), void 0 !== this.object && fp.setFromObject(this.object), fp.isEmpty()) return;
          const e2 = fp.min, n2 = fp.max, r2 = this.geometry.attributes.position, i2 = r2.array;
          i2[0] = n2.x, i2[1] = n2.y, i2[2] = n2.z, i2[3] = e2.x, i2[4] = n2.y, i2[5] = n2.z, i2[6] = e2.x, i2[7] = e2.y, i2[8] = n2.z, i2[9] = n2.x, i2[10] = e2.y, i2[11] = n2.z, i2[12] = n2.x, i2[13] = n2.y, i2[14] = e2.z, i2[15] = e2.x, i2[16] = n2.y, i2[17] = e2.z, i2[18] = e2.x, i2[19] = e2.y, i2[20] = e2.z, i2[21] = n2.x, i2[22] = e2.y, i2[23] = e2.z, r2.needsUpdate = true, this.geometry.computeBoundingSphere();
        }
        setFromObject(t2) {
          return this.object = t2, this.update(), this;
        }
        copy(t2) {
          return Oc.prototype.copy.call(this, t2), this.object = t2.object, this;
        }
      }
      class gp extends Oc {
        constructor(t2, e2 = 16776960) {
          const n2 = new Uint16Array([0, 1, 1, 2, 2, 3, 3, 0, 4, 5, 5, 6, 6, 7, 7, 4, 0, 4, 1, 5, 2, 6, 3, 7]), r2 = new Xi();
          r2.setIndex(new Ti(n2, 1)), r2.setAttribute("position", new Ii([1, 1, 1, -1, 1, 1, -1, -1, 1, 1, -1, 1, 1, 1, -1, -1, 1, -1, -1, -1, -1, 1, -1, -1], 3)), super(r2, new Mc({ color: e2, toneMapped: false })), this.box = t2, this.type = "Box3Helper", this.geometry.computeBoundingSphere();
        }
        updateMatrixWorld(t2) {
          const e2 = this.box;
          e2.isEmpty() || (e2.getCenter(this.position), e2.getSize(this.scale), this.scale.multiplyScalar(0.5), super.updateMatrixWorld(t2));
        }
      }
      class vp extends Lc {
        constructor(t2, e2 = 1, n2 = 16776960) {
          const r2 = n2, i2 = new Xi();
          i2.setAttribute("position", new Ii([1, -1, 1, -1, 1, 1, -1, -1, 1, 1, 1, 1, -1, 1, 1, -1, -1, 1, 1, -1, 1, 1, 1, 1, 0, 0, 1, 0, 0, 0], 3)), i2.computeBoundingSphere(), super(i2, new Mc({ color: r2, toneMapped: false })), this.type = "PlaneHelper", this.plane = t2, this.size = e2;
          const o2 = new Xi();
          o2.setAttribute("position", new Ii([1, 1, 1, -1, 1, 1, -1, -1, 1, 1, 1, 1, -1, -1, 1, 1, -1, 1], 3)), o2.computeBoundingSphere(), this.add(new ho(o2, new _i({ color: r2, opacity: 0.2, transparent: true, depthWrite: false, toneMapped: false })));
        }
        updateMatrixWorld(t2) {
          let e2 = -this.plane.constant;
          Math.abs(e2) < 1e-8 && (e2 = 1e-8), this.scale.set(0.5 * this.size, 0.5 * this.size, e2), this.children[0].material.side = e2 < 0 ? m : f, this.lookAt(this.plane.normal), super.updateMatrixWorld(t2);
        }
      }
      const yp = new $n();
      let xp, bp;
      class wp extends Jr {
        constructor(t2, e2, n2, r2, i2, o2) {
          super(), this.type = "ArrowHelper", void 0 === t2 && (t2 = new $n(0, 0, 1)), void 0 === e2 && (e2 = new $n(0, 0, 0)), void 0 === n2 && (n2 = 1), void 0 === r2 && (r2 = 16776960), void 0 === i2 && (i2 = 0.2 * n2), void 0 === o2 && (o2 = 0.2 * i2), void 0 === xp && (xp = new Xi(), xp.setAttribute("position", new Ii([0, 0, 0, 0, 1, 0], 3)), bp = new Kc(0, 0.5, 1, 5, 1), bp.translate(0, -0.5, 0)), this.position.copy(e2), this.line = new Lc(xp, new Mc({ color: r2, toneMapped: false })), this.line.matrixAutoUpdate = false, this.add(this.line), this.cone = new ho(bp, new _i({ color: r2, toneMapped: false })), this.cone.matrixAutoUpdate = false, this.add(this.cone), this.setDirection(t2), this.setLength(n2, i2, o2);
        }
        setDirection(t2) {
          if (t2.y > 0.99999) this.quaternion.set(0, 0, 0, 1);
          else if (t2.y < -0.99999) this.quaternion.set(1, 0, 0, 0);
          else {
            yp.set(t2.z, 0, -t2.x).normalize();
            const e2 = Math.acos(t2.y);
            this.quaternion.setFromAxisAngle(yp, e2);
          }
        }
        setLength(t2, e2, n2) {
          void 0 === e2 && (e2 = 0.2 * t2), void 0 === n2 && (n2 = 0.2 * e2), this.line.scale.set(1, Math.max(1e-4, t2 - e2), 1), this.line.updateMatrix(), this.cone.scale.set(n2, e2, n2), this.cone.position.y = t2, this.cone.updateMatrix();
        }
        setColor(t2) {
          this.line.material.color.set(t2), this.cone.material.color.set(t2);
        }
        copy(t2) {
          return super.copy(t2, false), this.line.copy(t2.line), this.cone.copy(t2.cone), this;
        }
      }
      class _p extends Oc {
        constructor(t2 = 1) {
          const e2 = [0, 0, 0, t2, 0, 0, 0, 0, 0, 0, t2, 0, 0, 0, 0, 0, 0, t2], n2 = new Xi();
          n2.setAttribute("position", new Ii(e2, 3)), n2.setAttribute("color", new Ii([1, 0, 0, 1, 0.6, 0, 0, 1, 0, 0.6, 1, 0, 0, 0, 1, 0, 0.6, 1], 3));
          super(n2, new Mc({ vertexColors: true, toneMapped: false })), this.type = "AxesHelper";
        }
      }
      const Mp = new Float32Array(1), Sp = new Int32Array(Mp.buffer), Tp = { toHalfFloat: function(t2) {
        Mp[0] = t2;
        const e2 = Sp[0];
        let n2 = e2 >> 16 & 32768, r2 = e2 >> 12 & 2047;
        const i2 = e2 >> 23 & 255;
        return i2 < 103 ? n2 : i2 > 142 ? (n2 |= 31744, n2 |= (255 == i2 ? 0 : 1) && 8388607 & e2, n2) : i2 < 113 ? (r2 |= 2048, n2 |= (r2 >> 114 - i2) + (r2 >> 113 - i2 & 1), n2) : (n2 |= i2 - 112 << 10 | r2 >> 1, n2 += 1 & r2, n2);
      } }, Ep = Math.pow(2, 8), Ap = [0.125, 0.215, 0.35, 0.446, 0.526, 0.582], Cp = 5 + Ap.length, Lp = { [Je]: 0, [$e]: 1, [Ke]: 2, [en]: 3, [nn]: 4, [rn]: 5, [Qe]: 6 }, Pp = new Ph(), { _lodPlanes: Rp, _sizeLods: Op, _sigmas: Dp } = Gp(), Ip = new yi();
      let Np = null;
      const zp = (1 + Math.sqrt(5)) / 2, kp = 1 / zp, Fp = [new $n(1, 1, 1), new $n(-1, 1, 1), new $n(1, 1, -1), new $n(-1, 1, -1), new $n(0, zp, kp), new $n(0, zp, -kp), new $n(kp, 0, zp), new $n(-kp, 0, zp), new $n(zp, kp, 0), new $n(-zp, kp, 0)];
      class Bp {
        constructor(t2) {
          this._renderer = t2, this._pingPongRenderTarget = null, this._blurMaterial = function(t3) {
            const e2 = new Float32Array(t3), n2 = new $n(0, 1, 0);
            return new vl({ name: "SphericalGaussianBlur", defines: { n: t3 }, uniforms: { envMap: { value: null }, samples: { value: 1 }, weights: { value: e2 }, latitudinal: { value: false }, dTheta: { value: 0 }, mipInt: { value: 0 }, poleAxis: { value: n2 }, inputEncoding: { value: Lp[Je] }, outputEncoding: { value: Lp[Je] } }, vertexShader: qp(), fragmentShader: `

			precision mediump float;
			precision mediump int;

			varying vec3 vOutputDirection;

			uniform sampler2D envMap;
			uniform int samples;
			uniform float weights[ n ];
			uniform bool latitudinal;
			uniform float dTheta;
			uniform float mipInt;
			uniform vec3 poleAxis;

			${Xp()}

			#define ENVMAP_TYPE_CUBE_UV
			#include <cube_uv_reflection_fragment>

			vec3 getSample( float theta, vec3 axis ) {

				float cosTheta = cos( theta );
				// Rodrigues' axis-angle rotation
				vec3 sampleDirection = vOutputDirection * cosTheta
					+ cross( axis, vOutputDirection ) * sin( theta )
					+ axis * dot( axis, vOutputDirection ) * ( 1.0 - cosTheta );

				return bilinearCubeUV( envMap, sampleDirection, mipInt );

			}

			void main() {

				vec3 axis = latitudinal ? poleAxis : cross( poleAxis, vOutputDirection );

				if ( all( equal( axis, vec3( 0.0 ) ) ) ) {

					axis = vec3( vOutputDirection.z, 0.0, - vOutputDirection.x );

				}

				axis = normalize( axis );

				gl_FragColor = vec4( 0.0, 0.0, 0.0, 1.0 );
				gl_FragColor.rgb += weights[ 0 ] * getSample( 0.0, axis );

				for ( int i = 1; i < n; i++ ) {

					if ( i >= samples ) {

						break;

					}

					float theta = dTheta * float( i );
					gl_FragColor.rgb += weights[ i ] * getSample( -1.0 * theta, axis );
					gl_FragColor.rgb += weights[ i ] * getSample( theta, axis );

				}

				gl_FragColor = linearToOutputTexel( gl_FragColor );

			}
		`, blending: x, depthTest: false, depthWrite: false });
          }(20), this._equirectShader = null, this._cubemapShader = null, this._compileMaterial(this._blurMaterial);
        }
        fromScene(t2, e2 = 0, n2 = 0.1, r2 = 100) {
          Np = this._renderer.getRenderTarget();
          const i2 = this._allocateTargets();
          return this._sceneToCubeUV(t2, n2, r2, i2), e2 > 0 && this._blur(i2, 0, 0, e2), this._applyPMREM(i2), this._cleanup(i2), i2;
        }
        fromEquirectangular(t2) {
          return this._fromTexture(t2);
        }
        fromCubemap(t2) {
          return this._fromTexture(t2);
        }
        compileCubemapShader() {
          null === this._cubemapShader && (this._cubemapShader = Wp(), this._compileMaterial(this._cubemapShader));
        }
        compileEquirectangularShader() {
          null === this._equirectShader && (this._equirectShader = Vp(), this._compileMaterial(this._equirectShader));
        }
        dispose() {
          this._blurMaterial.dispose(), null !== this._cubemapShader && this._cubemapShader.dispose(), null !== this._equirectShader && this._equirectShader.dispose();
          for (let t2 = 0; t2 < Rp.length; t2++) Rp[t2].dispose();
        }
        _cleanup(t2) {
          this._pingPongRenderTarget.dispose(), this._renderer.setRenderTarget(Np), t2.scissorTest = false, jp(t2, 0, 0, t2.width, t2.height);
        }
        _fromTexture(t2) {
          Np = this._renderer.getRenderTarget();
          const e2 = this._allocateTargets(t2);
          return this._textureToCubeUV(t2, e2), this._applyPMREM(e2), this._cleanup(e2), e2;
        }
        _allocateTargets(t2) {
          const e2 = { magFilter: ft, minFilter: ft, generateMipmaps: false, type: St, format: Gt, encoding: Hp(t2) ? t2.encoding : Ke, depthBuffer: false }, n2 = Up(e2);
          return n2.depthBuffer = !t2, this._pingPongRenderTarget = Up(e2), n2;
        }
        _compileMaterial(t2) {
          const e2 = new ho(Rp[0], t2);
          this._renderer.compile(e2, Pp);
        }
        _sceneToCubeUV(t2, e2, n2, r2) {
          const i2 = new wo(90, 1, e2, n2), o2 = [1, -1, 1, 1, 1, 1], a2 = [1, 1, 1, -1, -1, -1], s2 = this._renderer, c2 = s2.outputEncoding, u2 = s2.toneMapping;
          s2.getClearColor(Ip);
          const l2 = s2.getClearAlpha();
          s2.toneMapping = Q, s2.outputEncoding = Je;
          let h2 = t2.background;
          if (h2 && h2.isColor) {
            h2.convertSRGBToLinear();
            const e3 = Math.max(h2.r, h2.g, h2.b), n3 = Math.min(Math.max(Math.ceil(Math.log2(e3)), -128), 127);
            h2 = h2.multiplyScalar(Math.pow(2, -n3));
            const r3 = (n3 + 128) / 255;
            s2.setClearColor(h2, r3), t2.background = null;
          }
          for (let e3 = 0; e3 < 6; e3++) {
            const n3 = e3 % 3;
            0 == n3 ? (i2.up.set(0, o2[e3], 0), i2.lookAt(a2[e3], 0, 0)) : 1 == n3 ? (i2.up.set(0, 0, o2[e3]), i2.lookAt(0, a2[e3], 0)) : (i2.up.set(0, o2[e3], 0), i2.lookAt(0, 0, a2[e3])), jp(r2, n3 * Ep, e3 > 2 ? Ep : 0, Ep, Ep), s2.setRenderTarget(r2), s2.render(t2, i2);
          }
          s2.toneMapping = u2, s2.outputEncoding = c2, s2.setClearColor(Ip, l2);
        }
        _textureToCubeUV(t2, e2) {
          const n2 = this._renderer;
          t2.isCubeTexture ? null == this._cubemapShader && (this._cubemapShader = Wp()) : null == this._equirectShader && (this._equirectShader = Vp());
          const r2 = t2.isCubeTexture ? this._cubemapShader : this._equirectShader, i2 = new ho(Rp[0], r2), o2 = r2.uniforms;
          o2.envMap.value = t2, t2.isCubeTexture || o2.texelSize.value.set(1 / t2.image.width, 1 / t2.image.height), o2.inputEncoding.value = Lp[t2.encoding], o2.outputEncoding.value = Lp[e2.texture.encoding], jp(e2, 0, 0, 3 * Ep, 2 * Ep), n2.setRenderTarget(e2), n2.render(i2, Pp);
        }
        _applyPMREM(t2) {
          const e2 = this._renderer, n2 = e2.autoClear;
          e2.autoClear = false;
          for (let e3 = 1; e3 < Cp; e3++) {
            const n3 = Math.sqrt(Dp[e3] * Dp[e3] - Dp[e3 - 1] * Dp[e3 - 1]), r2 = Fp[(e3 - 1) % Fp.length];
            this._blur(t2, e3 - 1, e3, n3, r2);
          }
          e2.autoClear = n2;
        }
        _blur(t2, e2, n2, r2, i2) {
          const o2 = this._pingPongRenderTarget;
          this._halfBlur(t2, o2, e2, n2, r2, "latitudinal", i2), this._halfBlur(o2, t2, n2, n2, r2, "longitudinal", i2);
        }
        _halfBlur(t2, e2, n2, r2, i2, o2, a2) {
          const s2 = this._renderer, c2 = this._blurMaterial;
          "latitudinal" !== o2 && "longitudinal" !== o2 && console.error("blur direction must be either latitudinal or longitudinal!");
          const u2 = new ho(Rp[r2], c2), l2 = c2.uniforms, h2 = Op[n2] - 1, d2 = isFinite(i2) ? Math.PI / (2 * h2) : 2 * Math.PI / 39, p2 = i2 / d2, f2 = isFinite(i2) ? 1 + Math.floor(3 * p2) : 20;
          f2 > 20 && console.warn(`sigmaRadians, ${i2}, is too large and will clip, as it requested ${f2} samples when the maximum is set to 20`);
          const m2 = [];
          let g2 = 0;
          for (let t3 = 0; t3 < 20; ++t3) {
            const e3 = t3 / p2, n3 = Math.exp(-e3 * e3 / 2);
            m2.push(n3), 0 == t3 ? g2 += n3 : t3 < f2 && (g2 += 2 * n3);
          }
          for (let t3 = 0; t3 < m2.length; t3++) m2[t3] = m2[t3] / g2;
          l2.envMap.value = t2.texture, l2.samples.value = f2, l2.weights.value = m2, l2.latitudinal.value = "latitudinal" === o2, a2 && (l2.poleAxis.value = a2), l2.dTheta.value = d2, l2.mipInt.value = 8 - n2, l2.inputEncoding.value = Lp[t2.texture.encoding], l2.outputEncoding.value = Lp[t2.texture.encoding];
          const v2 = Op[r2];
          jp(e2, 3 * Math.max(0, Ep - 2 * v2), (0 === r2 ? 0 : 2 * Ep) + 2 * v2 * (r2 > 4 ? r2 - 8 + 4 : 0), 3 * v2, 2 * v2), s2.setRenderTarget(e2), s2.render(u2, Pp);
        }
      }
      function Hp(t2) {
        return void 0 !== t2 && t2.type === St && (t2.encoding === Je || t2.encoding === $e || t2.encoding === Qe);
      }
      function Gp() {
        const t2 = [], e2 = [], n2 = [];
        let r2 = 8;
        for (let i2 = 0; i2 < Cp; i2++) {
          const o2 = Math.pow(2, r2);
          e2.push(o2);
          let a2 = 1 / o2;
          i2 > 4 ? a2 = Ap[i2 - 8 + 4 - 1] : 0 == i2 && (a2 = 0), n2.push(a2);
          const s2 = 1 / (o2 - 1), c2 = -s2 / 2, u2 = 1 + s2 / 2, l2 = [c2, c2, u2, c2, u2, u2, c2, c2, u2, u2, c2, u2], h2 = 6, d2 = 6, p2 = 3, f2 = 2, m2 = 1, g2 = new Float32Array(p2 * d2 * h2), v2 = new Float32Array(f2 * d2 * h2), y2 = new Float32Array(m2 * d2 * h2);
          for (let t3 = 0; t3 < h2; t3++) {
            const e3 = t3 % 3 * 2 / 3 - 1, n3 = t3 > 2 ? 0 : -1, r3 = [e3, n3, 0, e3 + 2 / 3, n3, 0, e3 + 2 / 3, n3 + 1, 0, e3, n3, 0, e3 + 2 / 3, n3 + 1, 0, e3, n3 + 1, 0];
            g2.set(r3, p2 * d2 * t3), v2.set(l2, f2 * d2 * t3);
            const i3 = [t3, t3, t3, t3, t3, t3];
            y2.set(i3, m2 * d2 * t3);
          }
          const x2 = new Xi();
          x2.setAttribute("position", new Ti(g2, p2)), x2.setAttribute("uv", new Ti(v2, f2)), x2.setAttribute("faceIndex", new Ti(y2, m2)), t2.push(x2), r2 > 4 && r2--;
        }
        return { _lodPlanes: t2, _sizeLods: e2, _sigmas: n2 };
      }
      function Up(t2) {
        const e2 = new Yn(3 * Ep, 3 * Ep, t2);
        return e2.texture.mapping = ut, e2.texture.name = "PMREM.cubeUv", e2.scissorTest = true, e2;
      }
      function jp(t2, e2, n2, r2, i2) {
        t2.viewport.set(e2, n2, r2, i2), t2.scissor.set(e2, n2, r2, i2);
      }
      function Vp() {
        return new vl({ name: "EquirectangularToCubeUV", uniforms: { envMap: { value: null }, texelSize: { value: new Hn(1, 1) }, inputEncoding: { value: Lp[Je] }, outputEncoding: { value: Lp[Je] } }, vertexShader: qp(), fragmentShader: `

			precision mediump float;
			precision mediump int;

			varying vec3 vOutputDirection;

			uniform sampler2D envMap;
			uniform vec2 texelSize;

			${Xp()}

			#include <common>

			void main() {

				gl_FragColor = vec4( 0.0, 0.0, 0.0, 1.0 );

				vec3 outputDirection = normalize( vOutputDirection );
				vec2 uv = equirectUv( outputDirection );

				vec2 f = fract( uv / texelSize - 0.5 );
				uv -= f * texelSize;
				vec3 tl = envMapTexelToLinear( texture2D ( envMap, uv ) ).rgb;
				uv.x += texelSize.x;
				vec3 tr = envMapTexelToLinear( texture2D ( envMap, uv ) ).rgb;
				uv.y += texelSize.y;
				vec3 br = envMapTexelToLinear( texture2D ( envMap, uv ) ).rgb;
				uv.x -= texelSize.x;
				vec3 bl = envMapTexelToLinear( texture2D ( envMap, uv ) ).rgb;

				vec3 tm = mix( tl, tr, f.x );
				vec3 bm = mix( bl, br, f.x );
				gl_FragColor.rgb = mix( tm, bm, f.y );

				gl_FragColor = linearToOutputTexel( gl_FragColor );

			}
		`, blending: x, depthTest: false, depthWrite: false });
      }
      function Wp() {
        return new vl({ name: "CubemapToCubeUV", uniforms: { envMap: { value: null }, inputEncoding: { value: Lp[Je] }, outputEncoding: { value: Lp[Je] } }, vertexShader: qp(), fragmentShader: `

			precision mediump float;
			precision mediump int;

			varying vec3 vOutputDirection;

			uniform samplerCube envMap;

			${Xp()}

			void main() {

				gl_FragColor = vec4( 0.0, 0.0, 0.0, 1.0 );
				gl_FragColor.rgb = envMapTexelToLinear( textureCube( envMap, vec3( - vOutputDirection.x, vOutputDirection.yz ) ) ).rgb;
				gl_FragColor = linearToOutputTexel( gl_FragColor );

			}
		`, blending: x, depthTest: false, depthWrite: false });
      }
      function qp() {
        return "\n\n		precision mediump float;\n		precision mediump int;\n\n		attribute vec3 position;\n		attribute vec2 uv;\n		attribute float faceIndex;\n\n		varying vec3 vOutputDirection;\n\n		// RH coordinate system; PMREM face-indexing convention\n		vec3 getDirection( vec2 uv, float face ) {\n\n			uv = 2.0 * uv - 1.0;\n\n			vec3 direction = vec3( uv, 1.0 );\n\n			if ( face == 0.0 ) {\n\n				direction = direction.zyx; // ( 1, v, u ) pos x\n\n			} else if ( face == 1.0 ) {\n\n				direction = direction.xzy;\n				direction.xz *= -1.0; // ( -u, 1, -v ) pos y\n\n			} else if ( face == 2.0 ) {\n\n				direction.x *= -1.0; // ( -u, v, 1 ) pos z\n\n			} else if ( face == 3.0 ) {\n\n				direction = direction.zyx;\n				direction.xz *= -1.0; // ( -1, v, -u ) neg x\n\n			} else if ( face == 4.0 ) {\n\n				direction = direction.xzy;\n				direction.xy *= -1.0; // ( -u, -1, v ) neg y\n\n			} else if ( face == 5.0 ) {\n\n				direction.z *= -1.0; // ( u, v, -1 ) neg z\n\n			}\n\n			return direction;\n\n		}\n\n		void main() {\n\n			vOutputDirection = getDirection( uv, faceIndex );\n			gl_Position = vec4( position, 1.0 );\n\n		}\n	";
      }
      function Xp() {
        return "\n\n		uniform int inputEncoding;\n		uniform int outputEncoding;\n\n		#include <encodings_pars_fragment>\n\n		vec4 inputTexelToLinear( vec4 value ) {\n\n			if ( inputEncoding == 0 ) {\n\n				return value;\n\n			} else if ( inputEncoding == 1 ) {\n\n				return sRGBToLinear( value );\n\n			} else if ( inputEncoding == 2 ) {\n\n				return RGBEToLinear( value );\n\n			} else if ( inputEncoding == 3 ) {\n\n				return RGBMToLinear( value, 7.0 );\n\n			} else if ( inputEncoding == 4 ) {\n\n				return RGBMToLinear( value, 16.0 );\n\n			} else if ( inputEncoding == 5 ) {\n\n				return RGBDToLinear( value, 256.0 );\n\n			} else {\n\n				return GammaToLinear( value, 2.2 );\n\n			}\n\n		}\n\n		vec4 linearToOutputTexel( vec4 value ) {\n\n			if ( outputEncoding == 0 ) {\n\n				return value;\n\n			} else if ( outputEncoding == 1 ) {\n\n				return LinearTosRGB( value );\n\n			} else if ( outputEncoding == 2 ) {\n\n				return LinearToRGBE( value );\n\n			} else if ( outputEncoding == 3 ) {\n\n				return LinearToRGBM( value, 7.0 );\n\n			} else if ( outputEncoding == 4 ) {\n\n				return LinearToRGBM( value, 16.0 );\n\n			} else if ( outputEncoding == 5 ) {\n\n				return LinearToRGBD( value, 256.0 );\n\n			} else {\n\n				return LinearToGamma( value, 2.2 );\n\n			}\n\n		}\n\n		vec4 envMapTexelToLinear( vec4 color ) {\n\n			return inputTexelToLinear( color );\n\n		}\n	";
      }
      function Yp(t2, e2, n2, r2, i2, o2, a2) {
        return console.warn("THREE.Face4 has been removed. A THREE.Face3 will be created instead."), new xi(t2, e2, n2, i2, o2, a2);
      }
      const Zp = 0, Jp = 1, $p = 0, Qp = 1, Kp = 2;
      function tf(t2) {
        return console.warn("THREE.MeshFaceMaterial has been removed. Use an Array instead."), t2;
      }
      function ef(t2 = []) {
        return console.warn("THREE.MultiMaterial has been removed. Use an Array instead."), t2.isMultiMaterial = true, t2.materials = t2, t2.clone = function() {
          return t2.slice();
        }, t2;
      }
      function nf(t2, e2) {
        return console.warn("THREE.PointCloud has been renamed to THREE.Points."), new Bc(t2, e2);
      }
      function rf(t2) {
        return console.warn("THREE.Particle has been renamed to THREE.Sprite."), new rc(t2);
      }
      function of(t2, e2) {
        return console.warn("THREE.ParticleSystem has been renamed to THREE.Points."), new Bc(t2, e2);
      }
      function af(t2) {
        return console.warn("THREE.PointCloudMaterial has been renamed to THREE.PointsMaterial."), new Ic(t2);
      }
      function sf(t2) {
        return console.warn("THREE.ParticleBasicMaterial has been renamed to THREE.PointsMaterial."), new Ic(t2);
      }
      function cf(t2) {
        return console.warn("THREE.ParticleSystemMaterial has been renamed to THREE.PointsMaterial."), new Ic(t2);
      }
      function uf(t2, e2, n2) {
        return console.warn("THREE.Vertex has been removed. Use THREE.Vector3 instead."), new $n(t2, e2, n2);
      }
      function lf(t2, e2) {
        return console.warn("THREE.DynamicBufferAttribute has been removed. Use new THREE.BufferAttribute().setUsage( THREE.DynamicDrawUsage ) instead."), new Ti(t2, e2).setUsage(En);
      }
      function hf(t2, e2) {
        return console.warn("THREE.Int8Attribute has been removed. Use new THREE.Int8BufferAttribute() instead."), new Ei(t2, e2);
      }
      function df(t2, e2) {
        return console.warn("THREE.Uint8Attribute has been removed. Use new THREE.Uint8BufferAttribute() instead."), new Ai(t2, e2);
      }
      function pf(t2, e2) {
        return console.warn("THREE.Uint8ClampedAttribute has been removed. Use new THREE.Uint8ClampedBufferAttribute() instead."), new Ci(t2, e2);
      }
      function ff(t2, e2) {
        return console.warn("THREE.Int16Attribute has been removed. Use new THREE.Int16BufferAttribute() instead."), new Li(t2, e2);
      }
      function mf(t2, e2) {
        return console.warn("THREE.Uint16Attribute has been removed. Use new THREE.Uint16BufferAttribute() instead."), new Pi(t2, e2);
      }
      function gf(t2, e2) {
        return console.warn("THREE.Int32Attribute has been removed. Use new THREE.Int32BufferAttribute() instead."), new Ri(t2, e2);
      }
      function vf(t2, e2) {
        return console.warn("THREE.Uint32Attribute has been removed. Use new THREE.Uint32BufferAttribute() instead."), new Oi(t2, e2);
      }
      function yf(t2, e2) {
        return console.warn("THREE.Float32Attribute has been removed. Use new THREE.Float32BufferAttribute() instead."), new Ii(t2, e2);
      }
      function xf(t2, e2) {
        return console.warn("THREE.Float64Attribute has been removed. Use new THREE.Float64BufferAttribute() instead."), new Ni(t2, e2);
      }
      function bf(t2) {
        console.warn("THREE.ClosedSplineCurve3 has been deprecated. Use THREE.CatmullRomCurve3 instead."), ch.call(this, t2), this.type = "catmullrom", this.closed = true;
      }
      function wf(t2) {
        console.warn("THREE.SplineCurve3 has been deprecated. Use THREE.CatmullRomCurve3 instead."), ch.call(this, t2), this.type = "catmullrom";
      }
      function _f(t2) {
        console.warn("THREE.Spline has been removed. Use THREE.CatmullRomCurve3 instead."), ch.call(this, t2), this.type = "catmullrom";
      }
      function Mf(t2) {
        return console.warn("THREE.AxisHelper has been renamed to THREE.AxesHelper."), new _p(t2);
      }
      function Sf(t2, e2) {
        return console.warn("THREE.BoundingBoxHelper has been deprecated. Creating a THREE.BoxHelper instead."), new mp(t2, e2);
      }
      function Tf(t2, e2) {
        return console.warn("THREE.EdgesHelper has been removed. Use THREE.EdgesGeometry instead."), new Oc(new lu(t2.geometry), new Mc({ color: void 0 !== e2 ? e2 : 16777215 }));
      }
      function Ef(t2, e2) {
        return console.warn("THREE.WireframeHelper has been removed. Use THREE.WireframeGeometry instead."), new Oc(new fl(t2.geometry), new Mc({ color: void 0 !== e2 ? e2 : 16777215 }));
      }
      function Af(t2) {
        return console.warn("THREE.XHRLoader has been renamed to THREE.FileLoader."), new Xl(t2);
      }
      function Cf(t2) {
        return console.warn("THREE.BinaryTextureLoader has been renamed to THREE.DataTextureLoader."), new Ql(t2);
      }
      function Lf(t2, e2, n2) {
        return console.warn("THREE.WebGLRenderTargetCube( width, height, options ) is now WebGLCubeRenderTarget( size, options )."), new So(t2, n2);
      }
      th.create = function(t2, e2) {
        return console.log("THREE.Curve.create() has been deprecated"), t2.prototype = Object.create(th.prototype), t2.prototype.constructor = t2, t2.prototype.getPoint = e2, t2;
      }, Object.assign(bh.prototype, { createPointsGeometry: function(t2) {
        console.warn("THREE.CurvePath: .createPointsGeometry() has been removed. Use new THREE.Geometry().setFromPoints( points ) instead.");
        const e2 = this.getPoints(t2);
        return this.createGeometry(e2);
      }, createSpacedPointsGeometry: function(t2) {
        console.warn("THREE.CurvePath: .createSpacedPointsGeometry() has been removed. Use new THREE.Geometry().setFromPoints( points ) instead.");
        const e2 = this.getSpacedPoints(t2);
        return this.createGeometry(e2);
      }, createGeometry: function(t2) {
        console.warn("THREE.CurvePath: .createGeometry() has been removed. Use new THREE.Geometry().setFromPoints( points ) instead.");
        const e2 = new Zc();
        for (let n2 = 0, r2 = t2.length; n2 < r2; n2++) {
          const r3 = t2[n2];
          e2.vertices.push(new $n(r3.x, r3.y, r3.z || 0));
        }
        return e2;
      } }), Object.assign(wh.prototype, { fromPoints: function(t2) {
        return console.warn("THREE.Path: .fromPoints() has been renamed to .setFromPoints()."), this.setFromPoints(t2);
      } }), bf.prototype = Object.create(ch.prototype), wf.prototype = Object.create(ch.prototype), _f.prototype = Object.create(ch.prototype), Object.assign(_f.prototype, { initFromArray: function() {
        console.error("THREE.Spline: .initFromArray() has been removed.");
      }, getControlPointsArray: function() {
        console.error("THREE.Spline: .getControlPointsArray() has been removed.");
      }, reparametrizeByArcLength: function() {
        console.error("THREE.Spline: .reparametrizeByArcLength() has been removed.");
      } }), ip.prototype.setColors = function() {
        console.error("THREE.GridHelper: setColors() has been deprecated, pass them in the constructor instead.");
      }, Qd.prototype.update = function() {
        console.error("THREE.SkeletonHelper: update() no longer needs to be called.");
      }, Object.assign(Wl.prototype, { extractUrlBase: function(t2) {
        return console.warn("THREE.Loader: .extractUrlBase() has been deprecated. Use THREE.LoaderUtils.extractUrlBase() instead."), Fh.extractUrlBase(t2);
      } }), Wl.Handlers = { add: function() {
        console.error("THREE.Loader: Handlers.add() has been removed. Use LoadingManager.addHandler() instead.");
      }, get: function() {
        console.error("THREE.Loader: Handlers.get() has been removed. Use LoadingManager.getHandler() instead.");
      } }, Object.assign(Ud.prototype, { center: function(t2) {
        return console.warn("THREE.Box2: .center() has been renamed to .getCenter()."), this.getCenter(t2);
      }, empty: function() {
        return console.warn("THREE.Box2: .empty() has been renamed to .isEmpty()."), this.isEmpty();
      }, isIntersectionBox: function(t2) {
        return console.warn("THREE.Box2: .isIntersectionBox() has been renamed to .intersectsBox()."), this.intersectsBox(t2);
      }, size: function(t2) {
        return console.warn("THREE.Box2: .size() has been renamed to .getSize()."), this.getSize(t2);
      } }), Object.assign(tr.prototype, { center: function(t2) {
        return console.warn("THREE.Box3: .center() has been renamed to .getCenter()."), this.getCenter(t2);
      }, empty: function() {
        return console.warn("THREE.Box3: .empty() has been renamed to .isEmpty()."), this.isEmpty();
      }, isIntersectionBox: function(t2) {
        return console.warn("THREE.Box3: .isIntersectionBox() has been renamed to .intersectsBox()."), this.intersectsBox(t2);
      }, isIntersectionSphere: function(t2) {
        return console.warn("THREE.Box3: .isIntersectionSphere() has been renamed to .intersectsSphere()."), this.intersectsSphere(t2);
      }, size: function(t2) {
        return console.warn("THREE.Box3: .size() has been renamed to .getSize()."), this.getSize(t2);
      } }), Object.assign(gr.prototype, { empty: function() {
        return console.warn("THREE.Sphere: .empty() has been renamed to .isEmpty()."), this.isEmpty();
      } }), Co.prototype.setFromMatrix = function(t2) {
        return console.warn("THREE.Frustum: .setFromMatrix() has been renamed to .setFromProjectionMatrix()."), this.setFromProjectionMatrix(t2);
      }, Wd.prototype.center = function(t2) {
        return console.warn("THREE.Line3: .center() has been renamed to .getCenter()."), this.getCenter(t2);
      }, Object.assign(Bn, { random16: function() {
        return console.warn("THREE.Math: .random16() has been deprecated. Use Math.random() instead."), Math.random();
      }, nearestPowerOfTwo: function(t2) {
        return console.warn("THREE.Math: .nearestPowerOfTwo() has been renamed to .floorPowerOfTwo()."), Bn.floorPowerOfTwo(t2);
      }, nextPowerOfTwo: function(t2) {
        return console.warn("THREE.Math: .nextPowerOfTwo() has been renamed to .ceilPowerOfTwo()."), Bn.ceilPowerOfTwo(t2);
      } }), Object.assign(Gn.prototype, { flattenToArrayOffset: function(t2, e2) {
        return console.warn("THREE.Matrix3: .flattenToArrayOffset() has been deprecated. Use .toArray() instead."), this.toArray(t2, e2);
      }, multiplyVector3: function(t2) {
        return console.warn("THREE.Matrix3: .multiplyVector3() has been removed. Use vector.applyMatrix3( matrix ) instead."), t2.applyMatrix3(this);
      }, multiplyVector3Array: function() {
        console.error("THREE.Matrix3: .multiplyVector3Array() has been removed.");
      }, applyToBufferAttribute: function(t2) {
        return console.warn("THREE.Matrix3: .applyToBufferAttribute() has been removed. Use attribute.applyMatrix3( matrix ) instead."), t2.applyMatrix3(this);
      }, applyToVector3Array: function() {
        console.error("THREE.Matrix3: .applyToVector3Array() has been removed.");
      }, getInverse: function(t2) {
        return console.warn("THREE.Matrix3: .getInverse() has been removed. Use matrixInv.copy( matrix ).invert(); instead."), this.copy(t2).invert();
      } }), Object.assign(Tr.prototype, { extractPosition: function(t2) {
        return console.warn("THREE.Matrix4: .extractPosition() has been renamed to .copyPosition()."), this.copyPosition(t2);
      }, flattenToArrayOffset: function(t2, e2) {
        return console.warn("THREE.Matrix4: .flattenToArrayOffset() has been deprecated. Use .toArray() instead."), this.toArray(t2, e2);
      }, getPosition: function() {
        return console.warn("THREE.Matrix4: .getPosition() has been removed. Use Vector3.setFromMatrixPosition( matrix ) instead."), new $n().setFromMatrixColumn(this, 3);
      }, setRotationFromQuaternion: function(t2) {
        return console.warn("THREE.Matrix4: .setRotationFromQuaternion() has been renamed to .makeRotationFromQuaternion()."), this.makeRotationFromQuaternion(t2);
      }, multiplyToArray: function() {
        console.warn("THREE.Matrix4: .multiplyToArray() has been removed.");
      }, multiplyVector3: function(t2) {
        return console.warn("THREE.Matrix4: .multiplyVector3() has been removed. Use vector.applyMatrix4( matrix ) instead."), t2.applyMatrix4(this);
      }, multiplyVector4: function(t2) {
        return console.warn("THREE.Matrix4: .multiplyVector4() has been removed. Use vector.applyMatrix4( matrix ) instead."), t2.applyMatrix4(this);
      }, multiplyVector3Array: function() {
        console.error("THREE.Matrix4: .multiplyVector3Array() has been removed.");
      }, rotateAxis: function(t2) {
        console.warn("THREE.Matrix4: .rotateAxis() has been removed. Use Vector3.transformDirection( matrix ) instead."), t2.transformDirection(this);
      }, crossVector: function(t2) {
        return console.warn("THREE.Matrix4: .crossVector() has been removed. Use vector.applyMatrix4( matrix ) instead."), t2.applyMatrix4(this);
      }, translate: function() {
        console.error("THREE.Matrix4: .translate() has been removed.");
      }, rotateX: function() {
        console.error("THREE.Matrix4: .rotateX() has been removed.");
      }, rotateY: function() {
        console.error("THREE.Matrix4: .rotateY() has been removed.");
      }, rotateZ: function() {
        console.error("THREE.Matrix4: .rotateZ() has been removed.");
      }, rotateByAxis: function() {
        console.error("THREE.Matrix4: .rotateByAxis() has been removed.");
      }, applyToBufferAttribute: function(t2) {
        return console.warn("THREE.Matrix4: .applyToBufferAttribute() has been removed. Use attribute.applyMatrix4( matrix ) instead."), t2.applyMatrix4(this);
      }, applyToVector3Array: function() {
        console.error("THREE.Matrix4: .applyToVector3Array() has been removed.");
      }, makeFrustum: function(t2, e2, n2, r2, i2, o2) {
        return console.warn("THREE.Matrix4: .makeFrustum() has been removed. Use .makePerspective( left, right, top, bottom, near, far ) instead."), this.makePerspective(t2, e2, r2, n2, i2, o2);
      }, getInverse: function(t2) {
        return console.warn("THREE.Matrix4: .getInverse() has been removed. Use matrixInv.copy( matrix ).invert(); instead."), this.copy(t2).invert();
      } }), ti.prototype.isIntersectionLine = function(t2) {
        return console.warn("THREE.Plane: .isIntersectionLine() has been renamed to .intersectsLine()."), this.intersectsLine(t2);
      }, Object.assign(Jn.prototype, { multiplyVector3: function(t2) {
        return console.warn("THREE.Quaternion: .multiplyVector3() has been removed. Use is now vector.applyQuaternion( quaternion ) instead."), t2.applyQuaternion(this);
      }, inverse: function() {
        return console.warn("THREE.Quaternion: .inverse() has been renamed to invert()."), this.invert();
      } }), Object.assign(Sr.prototype, { isIntersectionBox: function(t2) {
        return console.warn("THREE.Ray: .isIntersectionBox() has been renamed to .intersectsBox()."), this.intersectsBox(t2);
      }, isIntersectionPlane: function(t2) {
        return console.warn("THREE.Ray: .isIntersectionPlane() has been renamed to .intersectsPlane()."), this.intersectsPlane(t2);
      }, isIntersectionSphere: function(t2) {
        return console.warn("THREE.Ray: .isIntersectionSphere() has been renamed to .intersectsSphere()."), this.intersectsSphere(t2);
      } }), Object.assign(hi.prototype, { area: function() {
        return console.warn("THREE.Triangle: .area() has been renamed to .getArea()."), this.getArea();
      }, barycoordFromPoint: function(t2, e2) {
        return console.warn("THREE.Triangle: .barycoordFromPoint() has been renamed to .getBarycoord()."), this.getBarycoord(t2, e2);
      }, midpoint: function(t2) {
        return console.warn("THREE.Triangle: .midpoint() has been renamed to .getMidpoint()."), this.getMidpoint(t2);
      }, normal: function(t2) {
        return console.warn("THREE.Triangle: .normal() has been renamed to .getNormal()."), this.getNormal(t2);
      }, plane: function(t2) {
        return console.warn("THREE.Triangle: .plane() has been renamed to .getPlane()."), this.getPlane(t2);
      } }), Object.assign(hi, { barycoordFromPoint: function(t2, e2, n2, r2, i2) {
        return console.warn("THREE.Triangle: .barycoordFromPoint() has been renamed to .getBarycoord()."), hi.getBarycoord(t2, e2, n2, r2, i2);
      }, normal: function(t2, e2, n2, r2) {
        return console.warn("THREE.Triangle: .normal() has been renamed to .getNormal()."), hi.getNormal(t2, e2, n2, r2);
      } }), Object.assign(_h.prototype, { extractAllPoints: function(t2) {
        return console.warn("THREE.Shape: .extractAllPoints() has been removed. Use .extractPoints() instead."), this.extractPoints(t2);
      }, extrude: function(t2) {
        return console.warn("THREE.Shape: .extrude() has been removed. Use ExtrudeGeometry() instead."), new Gu(this, t2);
      }, makeGeometry: function(t2) {
        return console.warn("THREE.Shape: .makeGeometry() has been removed. Use ShapeGeometry() instead."), new el(this, t2);
      } }), Object.assign(Hn.prototype, { fromAttribute: function(t2, e2, n2) {
        return console.warn("THREE.Vector2: .fromAttribute() has been renamed to .fromBufferAttribute()."), this.fromBufferAttribute(t2, e2, n2);
      }, distanceToManhattan: function(t2) {
        return console.warn("THREE.Vector2: .distanceToManhattan() has been renamed to .manhattanDistanceTo()."), this.manhattanDistanceTo(t2);
      }, lengthManhattan: function() {
        return console.warn("THREE.Vector2: .lengthManhattan() has been renamed to .manhattanLength()."), this.manhattanLength();
      } }), Object.assign($n.prototype, { setEulerFromRotationMatrix: function() {
        console.error("THREE.Vector3: .setEulerFromRotationMatrix() has been removed. Use Euler.setFromRotationMatrix() instead.");
      }, setEulerFromQuaternion: function() {
        console.error("THREE.Vector3: .setEulerFromQuaternion() has been removed. Use Euler.setFromQuaternion() instead.");
      }, getPositionFromMatrix: function(t2) {
        return console.warn("THREE.Vector3: .getPositionFromMatrix() has been renamed to .setFromMatrixPosition()."), this.setFromMatrixPosition(t2);
      }, getScaleFromMatrix: function(t2) {
        return console.warn("THREE.Vector3: .getScaleFromMatrix() has been renamed to .setFromMatrixScale()."), this.setFromMatrixScale(t2);
      }, getColumnFromMatrix: function(t2, e2) {
        return console.warn("THREE.Vector3: .getColumnFromMatrix() has been renamed to .setFromMatrixColumn()."), this.setFromMatrixColumn(e2, t2);
      }, applyProjection: function(t2) {
        return console.warn("THREE.Vector3: .applyProjection() has been removed. Use .applyMatrix4( m ) instead."), this.applyMatrix4(t2);
      }, fromAttribute: function(t2, e2, n2) {
        return console.warn("THREE.Vector3: .fromAttribute() has been renamed to .fromBufferAttribute()."), this.fromBufferAttribute(t2, e2, n2);
      }, distanceToManhattan: function(t2) {
        return console.warn("THREE.Vector3: .distanceToManhattan() has been renamed to .manhattanDistanceTo()."), this.manhattanDistanceTo(t2);
      }, lengthManhattan: function() {
        return console.warn("THREE.Vector3: .lengthManhattan() has been renamed to .manhattanLength()."), this.manhattanLength();
      } }), Object.assign(Xn.prototype, { fromAttribute: function(t2, e2, n2) {
        return console.warn("THREE.Vector4: .fromAttribute() has been renamed to .fromBufferAttribute()."), this.fromBufferAttribute(t2, e2, n2);
      }, lengthManhattan: function() {
        return console.warn("THREE.Vector4: .lengthManhattan() has been renamed to .manhattanLength()."), this.manhattanLength();
      } }), Object.assign(Zc.prototype, { computeTangents: function() {
        console.error("THREE.Geometry: .computeTangents() has been removed.");
      }, computeLineDistances: function() {
        console.error("THREE.Geometry: .computeLineDistances() has been removed. Use THREE.Line.computeLineDistances() instead.");
      }, applyMatrix: function(t2) {
        return console.warn("THREE.Geometry: .applyMatrix() has been renamed to .applyMatrix4()."), this.applyMatrix4(t2);
      } }), Object.assign(Jr.prototype, { getChildByName: function(t2) {
        return console.warn("THREE.Object3D: .getChildByName() has been renamed to .getObjectByName()."), this.getObjectByName(t2);
      }, renderDepth: function() {
        console.warn("THREE.Object3D: .renderDepth has been removed. Use .renderOrder, instead.");
      }, translate: function(t2, e2) {
        return console.warn("THREE.Object3D: .translate() has been removed. Use .translateOnAxis( axis, distance ) instead."), this.translateOnAxis(e2, t2);
      }, getWorldRotation: function() {
        console.error("THREE.Object3D: .getWorldRotation() has been removed. Use THREE.Object3D.getWorldQuaternion( target ) instead.");
      }, applyMatrix: function(t2) {
        return console.warn("THREE.Object3D: .applyMatrix() has been renamed to .applyMatrix4()."), this.applyMatrix4(t2);
      } }), Object.defineProperties(Jr.prototype, { eulerOrder: { get: function() {
        return console.warn("THREE.Object3D: .eulerOrder is now .rotation.order."), this.rotation.order;
      }, set: function(t2) {
        console.warn("THREE.Object3D: .eulerOrder is now .rotation.order."), this.rotation.order = t2;
      } }, useQuaternion: { get: function() {
        console.warn("THREE.Object3D: .useQuaternion has been removed. The library now uses quaternions by default.");
      }, set: function() {
        console.warn("THREE.Object3D: .useQuaternion has been removed. The library now uses quaternions by default.");
      } } }), Object.assign(ho.prototype, { setDrawMode: function() {
        console.error("THREE.Mesh: .setDrawMode() has been removed. The renderer now always assumes THREE.TrianglesDrawMode. Transform your geometry via BufferGeometryUtils.toTrianglesDrawMode() if necessary.");
      } }), Object.defineProperties(ho.prototype, { drawMode: { get: function() {
        return console.error("THREE.Mesh: .drawMode has been removed. The renderer now always assumes THREE.TrianglesDrawMode."), Xe;
      }, set: function() {
        console.error("THREE.Mesh: .drawMode has been removed. The renderer now always assumes THREE.TrianglesDrawMode. Transform your geometry via BufferGeometryUtils.toTrianglesDrawMode() if necessary.");
      } } }), Object.defineProperties(sc.prototype, { objects: { get: function() {
        return console.warn("THREE.LOD: .objects has been renamed to .levels."), this.levels;
      } } }), Object.defineProperty(vc.prototype, "useVertexTexture", { get: function() {
        console.warn("THREE.Skeleton: useVertexTexture has been removed.");
      }, set: function() {
        console.warn("THREE.Skeleton: useVertexTexture has been removed.");
      } }), pc.prototype.initBones = function() {
        console.error("THREE.SkinnedMesh: initBones() has been removed.");
      }, Object.defineProperty(th.prototype, "__arcLengthDivisions", { get: function() {
        return console.warn("THREE.Curve: .__arcLengthDivisions is now .arcLengthDivisions."), this.arcLengthDivisions;
      }, set: function(t2) {
        console.warn("THREE.Curve: .__arcLengthDivisions is now .arcLengthDivisions."), this.arcLengthDivisions = t2;
      } }), wo.prototype.setLens = function(t2, e2) {
        console.warn("THREE.PerspectiveCamera.setLens is deprecated. Use .setFocalLength and .filmGauge for a photographic setup."), void 0 !== e2 && (this.filmGauge = e2), this.setFocalLength(t2);
      }, Object.defineProperties(Mh.prototype, { onlyShadow: { set: function() {
        console.warn("THREE.Light: .onlyShadow has been removed.");
      } }, shadowCameraFov: { set: function(t2) {
        console.warn("THREE.Light: .shadowCameraFov is now .shadow.camera.fov."), this.shadow.camera.fov = t2;
      } }, shadowCameraLeft: { set: function(t2) {
        console.warn("THREE.Light: .shadowCameraLeft is now .shadow.camera.left."), this.shadow.camera.left = t2;
      } }, shadowCameraRight: { set: function(t2) {
        console.warn("THREE.Light: .shadowCameraRight is now .shadow.camera.right."), this.shadow.camera.right = t2;
      } }, shadowCameraTop: { set: function(t2) {
        console.warn("THREE.Light: .shadowCameraTop is now .shadow.camera.top."), this.shadow.camera.top = t2;
      } }, shadowCameraBottom: { set: function(t2) {
        console.warn("THREE.Light: .shadowCameraBottom is now .shadow.camera.bottom."), this.shadow.camera.bottom = t2;
      } }, shadowCameraNear: { set: function(t2) {
        console.warn("THREE.Light: .shadowCameraNear is now .shadow.camera.near."), this.shadow.camera.near = t2;
      } }, shadowCameraFar: { set: function(t2) {
        console.warn("THREE.Light: .shadowCameraFar is now .shadow.camera.far."), this.shadow.camera.far = t2;
      } }, shadowCameraVisible: { set: function() {
        console.warn("THREE.Light: .shadowCameraVisible has been removed. Use new THREE.CameraHelper( light.shadow.camera ) instead.");
      } }, shadowBias: { set: function(t2) {
        console.warn("THREE.Light: .shadowBias is now .shadow.bias."), this.shadow.bias = t2;
      } }, shadowDarkness: { set: function() {
        console.warn("THREE.Light: .shadowDarkness has been removed.");
      } }, shadowMapWidth: { set: function(t2) {
        console.warn("THREE.Light: .shadowMapWidth is now .shadow.mapSize.width."), this.shadow.mapSize.width = t2;
      } }, shadowMapHeight: { set: function(t2) {
        console.warn("THREE.Light: .shadowMapHeight is now .shadow.mapSize.height."), this.shadow.mapSize.height = t2;
      } } }), Object.defineProperties(Ti.prototype, { length: { get: function() {
        return console.warn("THREE.BufferAttribute: .length has been deprecated. Use .count instead."), this.array.length;
      } }, dynamic: { get: function() {
        return console.warn("THREE.BufferAttribute: .dynamic has been deprecated. Use .usage instead."), this.usage === En;
      }, set: function() {
        console.warn("THREE.BufferAttribute: .dynamic has been deprecated. Use .usage instead."), this.setUsage(En);
      } } }), Object.assign(Ti.prototype, { setDynamic: function(t2) {
        return console.warn("THREE.BufferAttribute: .setDynamic() has been deprecated. Use .setUsage() instead."), this.setUsage(true === t2 ? En : Tn), this;
      }, copyIndicesArray: function() {
        console.error("THREE.BufferAttribute: .copyIndicesArray() has been removed.");
      }, setArray: function() {
        console.error("THREE.BufferAttribute: .setArray has been removed. Use BufferGeometry .setAttribute to replace/resize attribute buffers");
      } }), Object.assign(Xi.prototype, { addIndex: function(t2) {
        console.warn("THREE.BufferGeometry: .addIndex() has been renamed to .setIndex()."), this.setIndex(t2);
      }, addAttribute: function(t2, e2) {
        return console.warn("THREE.BufferGeometry: .addAttribute() has been renamed to .setAttribute()."), e2 && e2.isBufferAttribute || e2 && e2.isInterleavedBufferAttribute ? "index" === t2 ? (console.warn("THREE.BufferGeometry.addAttribute: Use .setIndex() for index attribute."), this.setIndex(e2), this) : this.setAttribute(t2, e2) : (console.warn("THREE.BufferGeometry: .addAttribute() now expects ( name, attribute )."), this.setAttribute(t2, new Ti(arguments[1], arguments[2])));
      }, addDrawCall: function(t2, e2, n2) {
        void 0 !== n2 && console.warn("THREE.BufferGeometry: .addDrawCall() no longer supports indexOffset."), console.warn("THREE.BufferGeometry: .addDrawCall() is now .addGroup()."), this.addGroup(t2, e2);
      }, clearDrawCalls: function() {
        console.warn("THREE.BufferGeometry: .clearDrawCalls() is now .clearGroups()."), this.clearGroups();
      }, computeTangents: function() {
        console.warn("THREE.BufferGeometry: .computeTangents() has been removed.");
      }, computeOffsets: function() {
        console.warn("THREE.BufferGeometry: .computeOffsets() has been removed.");
      }, removeAttribute: function(t2) {
        return console.warn("THREE.BufferGeometry: .removeAttribute() has been renamed to .deleteAttribute()."), this.deleteAttribute(t2);
      }, applyMatrix: function(t2) {
        return console.warn("THREE.BufferGeometry: .applyMatrix() has been renamed to .applyMatrix4()."), this.applyMatrix4(t2);
      } }), Object.defineProperties(Xi.prototype, { drawcalls: { get: function() {
        return console.error("THREE.BufferGeometry: .drawcalls has been renamed to .groups."), this.groups;
      } }, offsets: { get: function() {
        return console.warn("THREE.BufferGeometry: .offsets has been renamed to .groups."), this.groups;
      } } }), Object.defineProperties(Bh.prototype, { maxInstancedCount: { get: function() {
        return console.warn("THREE.InstancedBufferGeometry: .maxInstancedCount has been renamed to .instanceCount."), this.instanceCount;
      }, set: function(t2) {
        console.warn("THREE.InstancedBufferGeometry: .maxInstancedCount has been renamed to .instanceCount."), this.instanceCount = t2;
      } } }), Object.defineProperties(zd.prototype, { linePrecision: { get: function() {
        return console.warn("THREE.Raycaster: .linePrecision has been deprecated. Use .params.Line.threshold instead."), this.params.Line.threshold;
      }, set: function(t2) {
        console.warn("THREE.Raycaster: .linePrecision has been deprecated. Use .params.Line.threshold instead."), this.params.Line.threshold = t2;
      } } }), Object.defineProperties(Hs.prototype, { dynamic: { get: function() {
        return console.warn("THREE.InterleavedBuffer: .length has been deprecated. Use .usage instead."), this.usage === En;
      }, set: function(t2) {
        console.warn("THREE.InterleavedBuffer: .length has been deprecated. Use .usage instead."), this.setUsage(t2);
      } } }), Object.assign(Hs.prototype, { setDynamic: function(t2) {
        return console.warn("THREE.InterleavedBuffer: .setDynamic() has been deprecated. Use .setUsage() instead."), this.setUsage(true === t2 ? En : Tn), this;
      }, setArray: function() {
        console.error("THREE.InterleavedBuffer: .setArray has been removed. Use BufferGeometry .setAttribute to replace/resize attribute buffers");
      } }), Object.assign(Bu.prototype, { getArrays: function() {
        console.error("THREE.ExtrudeBufferGeometry: .getArrays() has been removed.");
      }, addShapeList: function() {
        console.error("THREE.ExtrudeBufferGeometry: .addShapeList() has been removed.");
      }, addShape: function() {
        console.error("THREE.ExtrudeBufferGeometry: .addShape() has been removed.");
      } }), Object.assign(Bs.prototype, { dispose: function() {
        console.error("THREE.Scene: .dispose() has been removed.");
      } }), Object.defineProperties(Dd.prototype, { dynamic: { set: function() {
        console.warn("THREE.Uniform: .dynamic has been removed. Use object.onBeforeRender() instead.");
      } }, onUpdate: { value: function() {
        return console.warn("THREE.Uniform: .onUpdate() has been removed. Use object.onBeforeRender() instead."), this;
      } } }), Object.defineProperties(wi.prototype, { wrapAround: { get: function() {
        console.warn("THREE.Material: .wrapAround has been removed.");
      }, set: function() {
        console.warn("THREE.Material: .wrapAround has been removed.");
      } }, overdraw: { get: function() {
        console.warn("THREE.Material: .overdraw has been removed.");
      }, set: function() {
        console.warn("THREE.Material: .overdraw has been removed.");
      } }, wrapRGB: { get: function() {
        return console.warn("THREE.Material: .wrapRGB has been removed."), new yi();
      } }, shading: { get: function() {
        console.error("THREE." + this.type + ": .shading has been removed. Use the boolean .flatShading instead.");
      }, set: function(t2) {
        console.warn("THREE." + this.type + ": .shading has been removed. Use the boolean .flatShading instead."), this.flatShading = t2 === v;
      } }, stencilMask: { get: function() {
        return console.warn("THREE." + this.type + ": .stencilMask has been removed. Use .stencilFuncMask instead."), this.stencilFuncMask;
      }, set: function(t2) {
        console.warn("THREE." + this.type + ": .stencilMask has been removed. Use .stencilFuncMask instead."), this.stencilFuncMask = t2;
      } } }), Object.defineProperties(bl.prototype, { metal: { get: function() {
        return console.warn("THREE.MeshPhongMaterial: .metal has been removed. Use THREE.MeshStandardMaterial instead."), false;
      }, set: function() {
        console.warn("THREE.MeshPhongMaterial: .metal has been removed. Use THREE.MeshStandardMaterial instead");
      } } }), Object.defineProperties(xl.prototype, { transparency: { get: function() {
        return console.warn("THREE.MeshPhysicalMaterial: .transparency has been renamed to .transmission."), this.transmission;
      }, set: function(t2) {
        console.warn("THREE.MeshPhysicalMaterial: .transparency has been renamed to .transmission."), this.transmission = t2;
      } } }), Object.defineProperties(xo.prototype, { derivatives: { get: function() {
        return console.warn("THREE.ShaderMaterial: .derivatives has been moved to .extensions.derivatives."), this.extensions.derivatives;
      }, set: function(t2) {
        console.warn("THREE. ShaderMaterial: .derivatives has been moved to .extensions.derivatives."), this.extensions.derivatives = t2;
      } } }), Object.assign(Ns.prototype, { clearTarget: function(t2, e2, n2, r2) {
        console.warn("THREE.WebGLRenderer: .clearTarget() has been deprecated. Use .setRenderTarget() and .clear() instead."), this.setRenderTarget(t2), this.clear(e2, n2, r2);
      }, animate: function(t2) {
        console.warn("THREE.WebGLRenderer: .animate() is now .setAnimationLoop()."), this.setAnimationLoop(t2);
      }, getCurrentRenderTarget: function() {
        return console.warn("THREE.WebGLRenderer: .getCurrentRenderTarget() is now .getRenderTarget()."), this.getRenderTarget();
      }, getMaxAnisotropy: function() {
        return console.warn("THREE.WebGLRenderer: .getMaxAnisotropy() is now .capabilities.getMaxAnisotropy()."), this.capabilities.getMaxAnisotropy();
      }, getPrecision: function() {
        return console.warn("THREE.WebGLRenderer: .getPrecision() is now .capabilities.precision."), this.capabilities.precision;
      }, resetGLState: function() {
        return console.warn("THREE.WebGLRenderer: .resetGLState() is now .state.reset()."), this.state.reset();
      }, supportsFloatTextures: function() {
        return console.warn("THREE.WebGLRenderer: .supportsFloatTextures() is now .extensions.get( 'OES_texture_float' )."), this.extensions.get("OES_texture_float");
      }, supportsHalfFloatTextures: function() {
        return console.warn("THREE.WebGLRenderer: .supportsHalfFloatTextures() is now .extensions.get( 'OES_texture_half_float' )."), this.extensions.get("OES_texture_half_float");
      }, supportsStandardDerivatives: function() {
        return console.warn("THREE.WebGLRenderer: .supportsStandardDerivatives() is now .extensions.get( 'OES_standard_derivatives' )."), this.extensions.get("OES_standard_derivatives");
      }, supportsCompressedTextureS3TC: function() {
        return console.warn("THREE.WebGLRenderer: .supportsCompressedTextureS3TC() is now .extensions.get( 'WEBGL_compressed_texture_s3tc' )."), this.extensions.get("WEBGL_compressed_texture_s3tc");
      }, supportsCompressedTexturePVRTC: function() {
        return console.warn("THREE.WebGLRenderer: .supportsCompressedTexturePVRTC() is now .extensions.get( 'WEBGL_compressed_texture_pvrtc' )."), this.extensions.get("WEBGL_compressed_texture_pvrtc");
      }, supportsBlendMinMax: function() {
        return console.warn("THREE.WebGLRenderer: .supportsBlendMinMax() is now .extensions.get( 'EXT_blend_minmax' )."), this.extensions.get("EXT_blend_minmax");
      }, supportsVertexTextures: function() {
        return console.warn("THREE.WebGLRenderer: .supportsVertexTextures() is now .capabilities.vertexTextures."), this.capabilities.vertexTextures;
      }, supportsInstancedArrays: function() {
        return console.warn("THREE.WebGLRenderer: .supportsInstancedArrays() is now .extensions.get( 'ANGLE_instanced_arrays' )."), this.extensions.get("ANGLE_instanced_arrays");
      }, enableScissorTest: function(t2) {
        console.warn("THREE.WebGLRenderer: .enableScissorTest() is now .setScissorTest()."), this.setScissorTest(t2);
      }, initMaterial: function() {
        console.warn("THREE.WebGLRenderer: .initMaterial() has been removed.");
      }, addPrePlugin: function() {
        console.warn("THREE.WebGLRenderer: .addPrePlugin() has been removed.");
      }, addPostPlugin: function() {
        console.warn("THREE.WebGLRenderer: .addPostPlugin() has been removed.");
      }, updateShadowMap: function() {
        console.warn("THREE.WebGLRenderer: .updateShadowMap() has been removed.");
      }, setFaceCulling: function() {
        console.warn("THREE.WebGLRenderer: .setFaceCulling() has been removed.");
      }, allocTextureUnit: function() {
        console.warn("THREE.WebGLRenderer: .allocTextureUnit() has been removed.");
      }, setTexture: function() {
        console.warn("THREE.WebGLRenderer: .setTexture() has been removed.");
      }, setTexture2D: function() {
        console.warn("THREE.WebGLRenderer: .setTexture2D() has been removed.");
      }, setTextureCube: function() {
        console.warn("THREE.WebGLRenderer: .setTextureCube() has been removed.");
      }, getActiveMipMapLevel: function() {
        return console.warn("THREE.WebGLRenderer: .getActiveMipMapLevel() is now .getActiveMipmapLevel()."), this.getActiveMipmapLevel();
      } }), Object.defineProperties(Ns.prototype, { shadowMapEnabled: { get: function() {
        return this.shadowMap.enabled;
      }, set: function(t2) {
        console.warn("THREE.WebGLRenderer: .shadowMapEnabled is now .shadowMap.enabled."), this.shadowMap.enabled = t2;
      } }, shadowMapType: { get: function() {
        return this.shadowMap.type;
      }, set: function(t2) {
        console.warn("THREE.WebGLRenderer: .shadowMapType is now .shadowMap.type."), this.shadowMap.type = t2;
      } }, shadowMapCullFace: { get: function() {
        console.warn("THREE.WebGLRenderer: .shadowMapCullFace has been removed. Set Material.shadowSide instead.");
      }, set: function() {
        console.warn("THREE.WebGLRenderer: .shadowMapCullFace has been removed. Set Material.shadowSide instead.");
      } }, context: { get: function() {
        return console.warn("THREE.WebGLRenderer: .context has been removed. Use .getContext() instead."), this.getContext();
      } }, vr: { get: function() {
        return console.warn("THREE.WebGLRenderer: .vr has been renamed to .xr"), this.xr;
      } }, gammaInput: { get: function() {
        return console.warn("THREE.WebGLRenderer: .gammaInput has been removed. Set the encoding for textures via Texture.encoding instead."), false;
      }, set: function() {
        console.warn("THREE.WebGLRenderer: .gammaInput has been removed. Set the encoding for textures via Texture.encoding instead.");
      } }, gammaOutput: { get: function() {
        return console.warn("THREE.WebGLRenderer: .gammaOutput has been removed. Set WebGLRenderer.outputEncoding instead."), false;
      }, set: function(t2) {
        console.warn("THREE.WebGLRenderer: .gammaOutput has been removed. Set WebGLRenderer.outputEncoding instead."), this.outputEncoding = true === t2 ? $e : Je;
      } }, toneMappingWhitePoint: { get: function() {
        return console.warn("THREE.WebGLRenderer: .toneMappingWhitePoint has been removed."), 1;
      }, set: function() {
        console.warn("THREE.WebGLRenderer: .toneMappingWhitePoint has been removed.");
      } } }), Object.defineProperties(Es.prototype, { cullFace: { get: function() {
        console.warn("THREE.WebGLRenderer: .shadowMap.cullFace has been removed. Set Material.shadowSide instead.");
      }, set: function() {
        console.warn("THREE.WebGLRenderer: .shadowMap.cullFace has been removed. Set Material.shadowSide instead.");
      } }, renderReverseSided: { get: function() {
        console.warn("THREE.WebGLRenderer: .shadowMap.renderReverseSided has been removed. Set Material.shadowSide instead.");
      }, set: function() {
        console.warn("THREE.WebGLRenderer: .shadowMap.renderReverseSided has been removed. Set Material.shadowSide instead.");
      } }, renderSingleSided: { get: function() {
        console.warn("THREE.WebGLRenderer: .shadowMap.renderSingleSided has been removed. Set Material.shadowSide instead.");
      }, set: function() {
        console.warn("THREE.WebGLRenderer: .shadowMap.renderSingleSided has been removed. Set Material.shadowSide instead.");
      } } }), Object.defineProperties(Yn.prototype, { wrapS: { get: function() {
        return console.warn("THREE.WebGLRenderTarget: .wrapS is now .texture.wrapS."), this.texture.wrapS;
      }, set: function(t2) {
        console.warn("THREE.WebGLRenderTarget: .wrapS is now .texture.wrapS."), this.texture.wrapS = t2;
      } }, wrapT: { get: function() {
        return console.warn("THREE.WebGLRenderTarget: .wrapT is now .texture.wrapT."), this.texture.wrapT;
      }, set: function(t2) {
        console.warn("THREE.WebGLRenderTarget: .wrapT is now .texture.wrapT."), this.texture.wrapT = t2;
      } }, magFilter: { get: function() {
        return console.warn("THREE.WebGLRenderTarget: .magFilter is now .texture.magFilter."), this.texture.magFilter;
      }, set: function(t2) {
        console.warn("THREE.WebGLRenderTarget: .magFilter is now .texture.magFilter."), this.texture.magFilter = t2;
      } }, minFilter: { get: function() {
        return console.warn("THREE.WebGLRenderTarget: .minFilter is now .texture.minFilter."), this.texture.minFilter;
      }, set: function(t2) {
        console.warn("THREE.WebGLRenderTarget: .minFilter is now .texture.minFilter."), this.texture.minFilter = t2;
      } }, anisotropy: { get: function() {
        return console.warn("THREE.WebGLRenderTarget: .anisotropy is now .texture.anisotropy."), this.texture.anisotropy;
      }, set: function(t2) {
        console.warn("THREE.WebGLRenderTarget: .anisotropy is now .texture.anisotropy."), this.texture.anisotropy = t2;
      } }, offset: { get: function() {
        return console.warn("THREE.WebGLRenderTarget: .offset is now .texture.offset."), this.texture.offset;
      }, set: function(t2) {
        console.warn("THREE.WebGLRenderTarget: .offset is now .texture.offset."), this.texture.offset = t2;
      } }, repeat: { get: function() {
        return console.warn("THREE.WebGLRenderTarget: .repeat is now .texture.repeat."), this.texture.repeat;
      }, set: function(t2) {
        console.warn("THREE.WebGLRenderTarget: .repeat is now .texture.repeat."), this.texture.repeat = t2;
      } }, format: { get: function() {
        return console.warn("THREE.WebGLRenderTarget: .format is now .texture.format."), this.texture.format;
      }, set: function(t2) {
        console.warn("THREE.WebGLRenderTarget: .format is now .texture.format."), this.texture.format = t2;
      } }, type: { get: function() {
        return console.warn("THREE.WebGLRenderTarget: .type is now .texture.type."), this.texture.type;
      }, set: function(t2) {
        console.warn("THREE.WebGLRenderTarget: .type is now .texture.type."), this.texture.type = t2;
      } }, generateMipmaps: { get: function() {
        return console.warn("THREE.WebGLRenderTarget: .generateMipmaps is now .texture.generateMipmaps."), this.texture.generateMipmaps;
      }, set: function(t2) {
        console.warn("THREE.WebGLRenderTarget: .generateMipmaps is now .texture.generateMipmaps."), this.texture.generateMipmaps = t2;
      } } }), Object.defineProperties(dd.prototype, { load: { value: function(t2) {
        console.warn("THREE.Audio: .load has been deprecated. Use THREE.AudioLoader instead.");
        const e2 = this;
        return new Kh().load(t2, function(t3) {
          e2.setBuffer(t3);
        }), this;
      } }, startTime: { set: function() {
        console.warn("THREE.Audio: .startTime is now .play( delay ).");
      } } }), yd.prototype.getData = function() {
        return console.warn("THREE.AudioAnalyser: .getData() is now .getFrequencyData()."), this.getFrequencyData();
      }, _o.prototype.updateCubeMap = function(t2, e2) {
        return console.warn("THREE.CubeCamera: .updateCubeMap() is now .update()."), this.update(t2, e2);
      }, _o.prototype.clear = function(t2, e2, n2, r2) {
        return console.warn("THREE.CubeCamera: .clear() is now .renderTarget.clear()."), this.renderTarget.clear(t2, e2, n2, r2);
      };
      const Pf = { merge: function(t2, e2, n2) {
        let r2;
        console.warn("THREE.GeometryUtils: .merge() has been moved to Geometry. Use geometry.merge( geometry2, matrix, materialIndexOffset ) instead."), e2.isMesh && (e2.matrixAutoUpdate && e2.updateMatrix(), r2 = e2.matrix, e2 = e2.geometry), t2.merge(e2, r2, n2);
      }, center: function(t2) {
        return console.warn("THREE.GeometryUtils: .center() has been moved to Geometry. Use geometry.center() instead."), t2.center();
      } };
      function Rf() {
        console.error("THREE.CanvasRenderer has been removed");
      }
      function Of() {
        console.error("THREE.JSONLoader has been removed.");
      }
      jn.crossOrigin = void 0, jn.loadTexture = function(t2, e2, n2, r2) {
        console.warn("THREE.ImageUtils.loadTexture has been deprecated. Use THREE.TextureLoader() instead.");
        const i2 = new Kl();
        i2.setCrossOrigin(this.crossOrigin);
        const o2 = i2.load(t2, n2, void 0, r2);
        return e2 && (o2.mapping = e2), o2;
      }, jn.loadTextureCube = function(t2, e2, n2, r2) {
        console.warn("THREE.ImageUtils.loadTextureCube has been deprecated. Use THREE.CubeTextureLoader() instead.");
        const i2 = new $l();
        i2.setCrossOrigin(this.crossOrigin);
        const o2 = i2.load(t2, n2, void 0, r2);
        return e2 && (o2.mapping = e2), o2;
      }, jn.loadCompressedTexture = function() {
        console.error("THREE.ImageUtils.loadCompressedTexture has been removed. Use THREE.DDSLoader instead.");
      }, jn.loadCompressedTextureCube = function() {
        console.error("THREE.ImageUtils.loadCompressedTextureCube has been removed. Use THREE.DDSLoader instead.");
      };
      const Df = { createMultiMaterialObject: function() {
        console.error("THREE.SceneUtils has been moved to /examples/jsm/utils/SceneUtils.js");
      }, detach: function() {
        console.error("THREE.SceneUtils has been moved to /examples/jsm/utils/SceneUtils.js");
      }, attach: function() {
        console.error("THREE.SceneUtils has been moved to /examples/jsm/utils/SceneUtils.js");
      } };
      function If() {
        console.error("THREE.LensFlare has been moved to /examples/jsm/objects/Lensflare.js");
      }
      "undefined" != typeof __THREE_DEVTOOLS__ && __THREE_DEVTOOLS__.dispatchEvent(new CustomEvent("register", { detail: { revision: r } }));
    }, function(t, e, n) {
      "use strict";
      t.exports = n(27);
    }, function(t, e, n) {
      "use strict";
      var r = n(28), i = { childContextTypes: true, contextType: true, contextTypes: true, defaultProps: true, displayName: true, getDefaultProps: true, getDerivedStateFromError: true, getDerivedStateFromProps: true, mixins: true, propTypes: true, type: true }, o = { name: true, length: true, prototype: true, caller: true, callee: true, arguments: true, arity: true }, a = { $$typeof: true, compare: true, defaultProps: true, displayName: true, propTypes: true, type: true }, s = {};
      function c(t2) {
        return r.isMemo(t2) ? a : s[t2.$$typeof] || i;
      }
      s[r.ForwardRef] = { $$typeof: true, render: true, defaultProps: true, displayName: true, propTypes: true }, s[r.Memo] = a;
      var u = Object.defineProperty, l = Object.getOwnPropertyNames, h = Object.getOwnPropertySymbols, d = Object.getOwnPropertyDescriptor, p = Object.getPrototypeOf, f = Object.prototype;
      t.exports = function t2(e2, n2, r2) {
        if ("string" != typeof n2) {
          if (f) {
            var i2 = p(n2);
            i2 && i2 !== f && t2(e2, i2, r2);
          }
          var a2 = l(n2);
          h && (a2 = a2.concat(h(n2)));
          for (var s2 = c(e2), m = c(n2), g = 0; g < a2.length; ++g) {
            var v = a2[g];
            if (!(o[v] || r2 && r2[v] || m && m[v] || s2 && s2[v])) {
              var y = d(n2, v);
              try {
                u(e2, v, y);
              } catch (t3) {
              }
            }
          }
        }
        return e2;
      };
    }, function(t, e, n) {
      "use strict";
      var r = /^((children|dangerouslySetInnerHTML|key|ref|autoFocus|defaultValue|defaultChecked|innerHTML|suppressContentEditableWarning|suppressHydrationWarning|valueLink|accept|acceptCharset|accessKey|action|allow|allowUserMedia|allowPaymentRequest|allowFullScreen|allowTransparency|alt|async|autoComplete|autoPlay|capture|cellPadding|cellSpacing|challenge|charSet|checked|cite|classID|className|cols|colSpan|content|contentEditable|contextMenu|controls|controlsList|coords|crossOrigin|data|dateTime|decoding|default|defer|dir|disabled|disablePictureInPicture|download|draggable|encType|form|formAction|formEncType|formMethod|formNoValidate|formTarget|frameBorder|headers|height|hidden|high|href|hrefLang|htmlFor|httpEquiv|id|inputMode|integrity|is|keyParams|keyType|kind|label|lang|list|loading|loop|low|marginHeight|marginWidth|max|maxLength|media|mediaGroup|method|min|minLength|multiple|muted|name|nonce|noValidate|open|optimum|pattern|placeholder|playsInline|poster|preload|profile|radioGroup|readOnly|referrerPolicy|rel|required|reversed|role|rows|rowSpan|sandbox|scope|scoped|scrolling|seamless|selected|shape|size|sizes|slot|span|spellCheck|src|srcDoc|srcLang|srcSet|start|step|style|summary|tabIndex|target|title|type|useMap|value|width|wmode|wrap|about|datatype|inlist|prefix|property|resource|typeof|vocab|autoCapitalize|autoCorrect|autoSave|color|inert|itemProp|itemScope|itemType|itemID|itemRef|on|results|security|unselectable|accentHeight|accumulate|additive|alignmentBaseline|allowReorder|alphabetic|amplitude|arabicForm|ascent|attributeName|attributeType|autoReverse|azimuth|baseFrequency|baselineShift|baseProfile|bbox|begin|bias|by|calcMode|capHeight|clip|clipPathUnits|clipPath|clipRule|colorInterpolation|colorInterpolationFilters|colorProfile|colorRendering|contentScriptType|contentStyleType|cursor|cx|cy|d|decelerate|descent|diffuseConstant|direction|display|divisor|dominantBaseline|dur|dx|dy|edgeMode|elevation|enableBackground|end|exponent|externalResourcesRequired|fill|fillOpacity|fillRule|filter|filterRes|filterUnits|floodColor|floodOpacity|focusable|fontFamily|fontSize|fontSizeAdjust|fontStretch|fontStyle|fontVariant|fontWeight|format|from|fr|fx|fy|g1|g2|glyphName|glyphOrientationHorizontal|glyphOrientationVertical|glyphRef|gradientTransform|gradientUnits|hanging|horizAdvX|horizOriginX|ideographic|imageRendering|in|in2|intercept|k|k1|k2|k3|k4|kernelMatrix|kernelUnitLength|kerning|keyPoints|keySplines|keyTimes|lengthAdjust|letterSpacing|lightingColor|limitingConeAngle|local|markerEnd|markerMid|markerStart|markerHeight|markerUnits|markerWidth|mask|maskContentUnits|maskUnits|mathematical|mode|numOctaves|offset|opacity|operator|order|orient|orientation|origin|overflow|overlinePosition|overlineThickness|panose1|paintOrder|pathLength|patternContentUnits|patternTransform|patternUnits|pointerEvents|points|pointsAtX|pointsAtY|pointsAtZ|preserveAlpha|preserveAspectRatio|primitiveUnits|r|radius|refX|refY|renderingIntent|repeatCount|repeatDur|requiredExtensions|requiredFeatures|restart|result|rotate|rx|ry|scale|seed|shapeRendering|slope|spacing|specularConstant|specularExponent|speed|spreadMethod|startOffset|stdDeviation|stemh|stemv|stitchTiles|stopColor|stopOpacity|strikethroughPosition|strikethroughThickness|string|stroke|strokeDasharray|strokeDashoffset|strokeLinecap|strokeLinejoin|strokeMiterlimit|strokeOpacity|strokeWidth|surfaceScale|systemLanguage|tableValues|targetX|targetY|textAnchor|textDecoration|textRendering|textLength|to|transform|u1|u2|underlinePosition|underlineThickness|unicode|unicodeBidi|unicodeRange|unitsPerEm|vAlphabetic|vHanging|vIdeographic|vMathematical|values|vectorEffect|version|vertAdvY|vertOriginX|vertOriginY|viewBox|viewTarget|visibility|widths|wordSpacing|writingMode|x|xHeight|x1|x2|xChannelSelector|xlinkActuate|xlinkArcrole|xlinkHref|xlinkRole|xlinkShow|xlinkTitle|xlinkType|xmlBase|xmlns|xmlnsXlink|xmlLang|xmlSpace|y|y1|y2|yChannelSelector|z|zoomAndPan|for|class|autofocus)|(([Dd][Aa][Tt][Aa]|[Aa][Rr][Ii][Aa]|x)-.*))$/, i = /* @__PURE__ */ function(t2) {
        var e2 = {};
        return function(n2) {
          return void 0 === e2[n2] && (e2[n2] = t2(n2)), e2[n2];
        };
      }(function(t2) {
        return r.test(t2) || 111 === t2.charCodeAt(0) && 110 === t2.charCodeAt(1) && t2.charCodeAt(2) < 91;
      });
      e.a = i;
    }, function(t, e, n) {
      var r;
      !function(e2, n2) {
        "use strict";
        "object" == typeof t.exports ? t.exports = e2.document ? n2(e2, true) : function(t2) {
          if (!t2.document) throw new Error("jQuery requires a window with a document");
          return n2(t2);
        } : n2(e2);
      }("undefined" != typeof window ? window : this, function(n2, i) {
        "use strict";
        var o = [], a = Object.getPrototypeOf, s = o.slice, c = o.flat ? function(t2) {
          return o.flat.call(t2);
        } : function(t2) {
          return o.concat.apply([], t2);
        }, u = o.push, l = o.indexOf, h = {}, d = h.toString, p = h.hasOwnProperty, f = p.toString, m = f.call(Object), g = {}, v = function(t2) {
          return "function" == typeof t2 && "number" != typeof t2.nodeType;
        }, y = function(t2) {
          return null != t2 && t2 === t2.window;
        }, x = n2.document, b = { type: true, src: true, nonce: true, noModule: true };
        function w(t2, e2, n3) {
          var r2, i2, o2 = (n3 = n3 || x).createElement("script");
          if (o2.text = t2, e2) for (r2 in b) (i2 = e2[r2] || e2.getAttribute && e2.getAttribute(r2)) && o2.setAttribute(r2, i2);
          n3.head.appendChild(o2).parentNode.removeChild(o2);
        }
        function _(t2) {
          return null == t2 ? t2 + "" : "object" == typeof t2 || "function" == typeof t2 ? h[d.call(t2)] || "object" : typeof t2;
        }
        var M = function(t2, e2) {
          return new M.fn.init(t2, e2);
        };
        function S(t2) {
          var e2 = !!t2 && "length" in t2 && t2.length, n3 = _(t2);
          return !v(t2) && !y(t2) && ("array" === n3 || 0 === e2 || "number" == typeof e2 && e2 > 0 && e2 - 1 in t2);
        }
        M.fn = M.prototype = { jquery: "3.5.1", constructor: M, length: 0, toArray: function() {
          return s.call(this);
        }, get: function(t2) {
          return null == t2 ? s.call(this) : t2 < 0 ? this[t2 + this.length] : this[t2];
        }, pushStack: function(t2) {
          var e2 = M.merge(this.constructor(), t2);
          return e2.prevObject = this, e2;
        }, each: function(t2) {
          return M.each(this, t2);
        }, map: function(t2) {
          return this.pushStack(M.map(this, function(e2, n3) {
            return t2.call(e2, n3, e2);
          }));
        }, slice: function() {
          return this.pushStack(s.apply(this, arguments));
        }, first: function() {
          return this.eq(0);
        }, last: function() {
          return this.eq(-1);
        }, even: function() {
          return this.pushStack(M.grep(this, function(t2, e2) {
            return (e2 + 1) % 2;
          }));
        }, odd: function() {
          return this.pushStack(M.grep(this, function(t2, e2) {
            return e2 % 2;
          }));
        }, eq: function(t2) {
          var e2 = this.length, n3 = +t2 + (t2 < 0 ? e2 : 0);
          return this.pushStack(n3 >= 0 && n3 < e2 ? [this[n3]] : []);
        }, end: function() {
          return this.prevObject || this.constructor();
        }, push: u, sort: o.sort, splice: o.splice }, M.extend = M.fn.extend = function() {
          var t2, e2, n3, r2, i2, o2, a2 = arguments[0] || {}, s2 = 1, c2 = arguments.length, u2 = false;
          for ("boolean" == typeof a2 && (u2 = a2, a2 = arguments[s2] || {}, s2++), "object" == typeof a2 || v(a2) || (a2 = {}), s2 === c2 && (a2 = this, s2--); s2 < c2; s2++) if (null != (t2 = arguments[s2])) for (e2 in t2) r2 = t2[e2], "__proto__" !== e2 && a2 !== r2 && (u2 && r2 && (M.isPlainObject(r2) || (i2 = Array.isArray(r2))) ? (n3 = a2[e2], o2 = i2 && !Array.isArray(n3) ? [] : i2 || M.isPlainObject(n3) ? n3 : {}, i2 = false, a2[e2] = M.extend(u2, o2, r2)) : void 0 !== r2 && (a2[e2] = r2));
          return a2;
        }, M.extend({ expando: "jQuery" + ("3.5.1" + Math.random()).replace(/\D/g, ""), isReady: true, error: function(t2) {
          throw new Error(t2);
        }, noop: function() {
        }, isPlainObject: function(t2) {
          var e2, n3;
          return !(!t2 || "[object Object]" !== d.call(t2)) && (!(e2 = a(t2)) || "function" == typeof (n3 = p.call(e2, "constructor") && e2.constructor) && f.call(n3) === m);
        }, isEmptyObject: function(t2) {
          var e2;
          for (e2 in t2) return false;
          return true;
        }, globalEval: function(t2, e2, n3) {
          w(t2, { nonce: e2 && e2.nonce }, n3);
        }, each: function(t2, e2) {
          var n3, r2 = 0;
          if (S(t2)) for (n3 = t2.length; r2 < n3 && false !== e2.call(t2[r2], r2, t2[r2]); r2++) ;
          else for (r2 in t2) if (false === e2.call(t2[r2], r2, t2[r2])) break;
          return t2;
        }, makeArray: function(t2, e2) {
          var n3 = e2 || [];
          return null != t2 && (S(Object(t2)) ? M.merge(n3, "string" == typeof t2 ? [t2] : t2) : u.call(n3, t2)), n3;
        }, inArray: function(t2, e2, n3) {
          return null == e2 ? -1 : l.call(e2, t2, n3);
        }, merge: function(t2, e2) {
          for (var n3 = +e2.length, r2 = 0, i2 = t2.length; r2 < n3; r2++) t2[i2++] = e2[r2];
          return t2.length = i2, t2;
        }, grep: function(t2, e2, n3) {
          for (var r2 = [], i2 = 0, o2 = t2.length, a2 = !n3; i2 < o2; i2++) !e2(t2[i2], i2) !== a2 && r2.push(t2[i2]);
          return r2;
        }, map: function(t2, e2, n3) {
          var r2, i2, o2 = 0, a2 = [];
          if (S(t2)) for (r2 = t2.length; o2 < r2; o2++) null != (i2 = e2(t2[o2], o2, n3)) && a2.push(i2);
          else for (o2 in t2) null != (i2 = e2(t2[o2], o2, n3)) && a2.push(i2);
          return c(a2);
        }, guid: 1, support: g }), "function" == typeof Symbol && (M.fn[Symbol.iterator] = o[Symbol.iterator]), M.each("Boolean Number String Function Array Date RegExp Object Error Symbol".split(" "), function(t2, e2) {
          h["[object " + e2 + "]"] = e2.toLowerCase();
        });
        var T = (
          /*!
           * Sizzle CSS Selector Engine v2.3.5
           * https://sizzlejs.com/
           *
           * Copyright JS Foundation and other contributors
           * Released under the MIT license
           * https://js.foundation/
           *
           * Date: 2020-03-14
           */
          function(t2) {
            var e2, n3, r2, i2, o2, a2, s2, c2, u2, l2, h2, d2, p2, f2, m2, g2, v2, y2, x2, b2 = "sizzle" + 1 * /* @__PURE__ */ new Date(), w2 = t2.document, _2 = 0, M2 = 0, S2 = ct2(), T2 = ct2(), E2 = ct2(), A2 = ct2(), C2 = function(t3, e3) {
              return t3 === e3 && (h2 = true), 0;
            }, L2 = {}.hasOwnProperty, P2 = [], R2 = P2.pop, O2 = P2.push, D2 = P2.push, I2 = P2.slice, N2 = function(t3, e3) {
              for (var n4 = 0, r3 = t3.length; n4 < r3; n4++) if (t3[n4] === e3) return n4;
              return -1;
            }, z2 = "checked|selected|async|autofocus|autoplay|controls|defer|disabled|hidden|ismap|loop|multiple|open|readonly|required|scoped", k2 = "[\\x20\\t\\r\\n\\f]", F2 = "(?:\\\\[\\da-fA-F]{1,6}" + k2 + "?|\\\\[^\\r\\n\\f]|[\\w-]|[^\0-\\x7f])+", B2 = "\\[" + k2 + "*(" + F2 + ")(?:" + k2 + "*([*^$|!~]?=)" + k2 + `*(?:'((?:\\\\.|[^\\\\'])*)'|"((?:\\\\.|[^\\\\"])*)"|(` + F2 + "))|)" + k2 + "*\\]", H2 = ":(" + F2 + `)(?:\\((('((?:\\\\.|[^\\\\'])*)'|"((?:\\\\.|[^\\\\"])*)")|((?:\\\\.|[^\\\\()[\\]]|` + B2 + ")*)|.*)\\)|)", G2 = new RegExp(k2 + "+", "g"), U2 = new RegExp("^" + k2 + "+|((?:^|[^\\\\])(?:\\\\.)*)" + k2 + "+$", "g"), j2 = new RegExp("^" + k2 + "*," + k2 + "*"), V2 = new RegExp("^" + k2 + "*([>+~]|" + k2 + ")" + k2 + "*"), W2 = new RegExp(k2 + "|>"), q2 = new RegExp(H2), X2 = new RegExp("^" + F2 + "$"), Y2 = { ID: new RegExp("^#(" + F2 + ")"), CLASS: new RegExp("^\\.(" + F2 + ")"), TAG: new RegExp("^(" + F2 + "|[*])"), ATTR: new RegExp("^" + B2), PSEUDO: new RegExp("^" + H2), CHILD: new RegExp("^:(only|first|last|nth|nth-last)-(child|of-type)(?:\\(" + k2 + "*(even|odd|(([+-]|)(\\d*)n|)" + k2 + "*(?:([+-]|)" + k2 + "*(\\d+)|))" + k2 + "*\\)|)", "i"), bool: new RegExp("^(?:" + z2 + ")$", "i"), needsContext: new RegExp("^" + k2 + "*[>+~]|:(even|odd|eq|gt|lt|nth|first|last)(?:\\(" + k2 + "*((?:-\\d)?\\d*)" + k2 + "*\\)|)(?=[^-]|$)", "i") }, Z2 = /HTML$/i, J2 = /^(?:input|select|textarea|button)$/i, $2 = /^h\d$/i, Q2 = /^[^{]+\{\s*\[native \w/, K2 = /^(?:#([\w-]+)|(\w+)|\.([\w-]+))$/, tt2 = /[+~]/, et2 = new RegExp("\\\\[\\da-fA-F]{1,6}" + k2 + "?|\\\\([^\\r\\n\\f])", "g"), nt2 = function(t3, e3) {
              var n4 = "0x" + t3.slice(1) - 65536;
              return e3 || (n4 < 0 ? String.fromCharCode(n4 + 65536) : String.fromCharCode(n4 >> 10 | 55296, 1023 & n4 | 56320));
            }, rt2 = /([\0-\x1f\x7f]|^-?\d)|^-$|[^\0-\x1f\x7f-\uFFFF\w-]/g, it2 = function(t3, e3) {
              return e3 ? "\0" === t3 ? "�" : t3.slice(0, -1) + "\\" + t3.charCodeAt(t3.length - 1).toString(16) + " " : "\\" + t3;
            }, ot2 = function() {
              d2();
            }, at2 = bt2(function(t3) {
              return true === t3.disabled && "fieldset" === t3.nodeName.toLowerCase();
            }, { dir: "parentNode", next: "legend" });
            try {
              D2.apply(P2 = I2.call(w2.childNodes), w2.childNodes), P2[w2.childNodes.length].nodeType;
            } catch (t3) {
              D2 = { apply: P2.length ? function(t4, e3) {
                O2.apply(t4, I2.call(e3));
              } : function(t4, e3) {
                for (var n4 = t4.length, r3 = 0; t4[n4++] = e3[r3++]; ) ;
                t4.length = n4 - 1;
              } };
            }
            function st2(t3, e3, r3, i3) {
              var o3, s3, u3, l3, h3, f3, v3, y3 = e3 && e3.ownerDocument, w3 = e3 ? e3.nodeType : 9;
              if (r3 = r3 || [], "string" != typeof t3 || !t3 || 1 !== w3 && 9 !== w3 && 11 !== w3) return r3;
              if (!i3 && (d2(e3), e3 = e3 || p2, m2)) {
                if (11 !== w3 && (h3 = K2.exec(t3))) if (o3 = h3[1]) {
                  if (9 === w3) {
                    if (!(u3 = e3.getElementById(o3))) return r3;
                    if (u3.id === o3) return r3.push(u3), r3;
                  } else if (y3 && (u3 = y3.getElementById(o3)) && x2(e3, u3) && u3.id === o3) return r3.push(u3), r3;
                } else {
                  if (h3[2]) return D2.apply(r3, e3.getElementsByTagName(t3)), r3;
                  if ((o3 = h3[3]) && n3.getElementsByClassName && e3.getElementsByClassName) return D2.apply(r3, e3.getElementsByClassName(o3)), r3;
                }
                if (n3.qsa && !A2[t3 + " "] && (!g2 || !g2.test(t3)) && (1 !== w3 || "object" !== e3.nodeName.toLowerCase())) {
                  if (v3 = t3, y3 = e3, 1 === w3 && (W2.test(t3) || V2.test(t3))) {
                    for ((y3 = tt2.test(t3) && vt2(e3.parentNode) || e3) === e3 && n3.scope || ((l3 = e3.getAttribute("id")) ? l3 = l3.replace(rt2, it2) : e3.setAttribute("id", l3 = b2)), s3 = (f3 = a2(t3)).length; s3--; ) f3[s3] = (l3 ? "#" + l3 : ":scope") + " " + xt2(f3[s3]);
                    v3 = f3.join(",");
                  }
                  try {
                    return D2.apply(r3, y3.querySelectorAll(v3)), r3;
                  } catch (e4) {
                    A2(t3, true);
                  } finally {
                    l3 === b2 && e3.removeAttribute("id");
                  }
                }
              }
              return c2(t3.replace(U2, "$1"), e3, r3, i3);
            }
            function ct2() {
              var t3 = [];
              return function e3(n4, i3) {
                return t3.push(n4 + " ") > r2.cacheLength && delete e3[t3.shift()], e3[n4 + " "] = i3;
              };
            }
            function ut2(t3) {
              return t3[b2] = true, t3;
            }
            function lt2(t3) {
              var e3 = p2.createElement("fieldset");
              try {
                return !!t3(e3);
              } catch (t4) {
                return false;
              } finally {
                e3.parentNode && e3.parentNode.removeChild(e3), e3 = null;
              }
            }
            function ht2(t3, e3) {
              for (var n4 = t3.split("|"), i3 = n4.length; i3--; ) r2.attrHandle[n4[i3]] = e3;
            }
            function dt2(t3, e3) {
              var n4 = e3 && t3, r3 = n4 && 1 === t3.nodeType && 1 === e3.nodeType && t3.sourceIndex - e3.sourceIndex;
              if (r3) return r3;
              if (n4) {
                for (; n4 = n4.nextSibling; ) if (n4 === e3) return -1;
              }
              return t3 ? 1 : -1;
            }
            function pt2(t3) {
              return function(e3) {
                return "input" === e3.nodeName.toLowerCase() && e3.type === t3;
              };
            }
            function ft2(t3) {
              return function(e3) {
                var n4 = e3.nodeName.toLowerCase();
                return ("input" === n4 || "button" === n4) && e3.type === t3;
              };
            }
            function mt2(t3) {
              return function(e3) {
                return "form" in e3 ? e3.parentNode && false === e3.disabled ? "label" in e3 ? "label" in e3.parentNode ? e3.parentNode.disabled === t3 : e3.disabled === t3 : e3.isDisabled === t3 || e3.isDisabled !== !t3 && at2(e3) === t3 : e3.disabled === t3 : "label" in e3 && e3.disabled === t3;
              };
            }
            function gt2(t3) {
              return ut2(function(e3) {
                return e3 = +e3, ut2(function(n4, r3) {
                  for (var i3, o3 = t3([], n4.length, e3), a3 = o3.length; a3--; ) n4[i3 = o3[a3]] && (n4[i3] = !(r3[i3] = n4[i3]));
                });
              });
            }
            function vt2(t3) {
              return t3 && void 0 !== t3.getElementsByTagName && t3;
            }
            for (e2 in n3 = st2.support = {}, o2 = st2.isXML = function(t3) {
              var e3 = t3.namespaceURI, n4 = (t3.ownerDocument || t3).documentElement;
              return !Z2.test(e3 || n4 && n4.nodeName || "HTML");
            }, d2 = st2.setDocument = function(t3) {
              var e3, i3, a3 = t3 ? t3.ownerDocument || t3 : w2;
              return a3 != p2 && 9 === a3.nodeType && a3.documentElement ? (f2 = (p2 = a3).documentElement, m2 = !o2(p2), w2 != p2 && (i3 = p2.defaultView) && i3.top !== i3 && (i3.addEventListener ? i3.addEventListener("unload", ot2, false) : i3.attachEvent && i3.attachEvent("onunload", ot2)), n3.scope = lt2(function(t4) {
                return f2.appendChild(t4).appendChild(p2.createElement("div")), void 0 !== t4.querySelectorAll && !t4.querySelectorAll(":scope fieldset div").length;
              }), n3.attributes = lt2(function(t4) {
                return t4.className = "i", !t4.getAttribute("className");
              }), n3.getElementsByTagName = lt2(function(t4) {
                return t4.appendChild(p2.createComment("")), !t4.getElementsByTagName("*").length;
              }), n3.getElementsByClassName = Q2.test(p2.getElementsByClassName), n3.getById = lt2(function(t4) {
                return f2.appendChild(t4).id = b2, !p2.getElementsByName || !p2.getElementsByName(b2).length;
              }), n3.getById ? (r2.filter.ID = function(t4) {
                var e4 = t4.replace(et2, nt2);
                return function(t5) {
                  return t5.getAttribute("id") === e4;
                };
              }, r2.find.ID = function(t4, e4) {
                if (void 0 !== e4.getElementById && m2) {
                  var n4 = e4.getElementById(t4);
                  return n4 ? [n4] : [];
                }
              }) : (r2.filter.ID = function(t4) {
                var e4 = t4.replace(et2, nt2);
                return function(t5) {
                  var n4 = void 0 !== t5.getAttributeNode && t5.getAttributeNode("id");
                  return n4 && n4.value === e4;
                };
              }, r2.find.ID = function(t4, e4) {
                if (void 0 !== e4.getElementById && m2) {
                  var n4, r3, i4, o3 = e4.getElementById(t4);
                  if (o3) {
                    if ((n4 = o3.getAttributeNode("id")) && n4.value === t4) return [o3];
                    for (i4 = e4.getElementsByName(t4), r3 = 0; o3 = i4[r3++]; ) if ((n4 = o3.getAttributeNode("id")) && n4.value === t4) return [o3];
                  }
                  return [];
                }
              }), r2.find.TAG = n3.getElementsByTagName ? function(t4, e4) {
                return void 0 !== e4.getElementsByTagName ? e4.getElementsByTagName(t4) : n3.qsa ? e4.querySelectorAll(t4) : void 0;
              } : function(t4, e4) {
                var n4, r3 = [], i4 = 0, o3 = e4.getElementsByTagName(t4);
                if ("*" === t4) {
                  for (; n4 = o3[i4++]; ) 1 === n4.nodeType && r3.push(n4);
                  return r3;
                }
                return o3;
              }, r2.find.CLASS = n3.getElementsByClassName && function(t4, e4) {
                if (void 0 !== e4.getElementsByClassName && m2) return e4.getElementsByClassName(t4);
              }, v2 = [], g2 = [], (n3.qsa = Q2.test(p2.querySelectorAll)) && (lt2(function(t4) {
                var e4;
                f2.appendChild(t4).innerHTML = "<a id='" + b2 + "'></a><select id='" + b2 + "-\r\\' msallowcapture=''><option selected=''></option></select>", t4.querySelectorAll("[msallowcapture^='']").length && g2.push("[*^$]=" + k2 + `*(?:''|"")`), t4.querySelectorAll("[selected]").length || g2.push("\\[" + k2 + "*(?:value|" + z2 + ")"), t4.querySelectorAll("[id~=" + b2 + "-]").length || g2.push("~="), (e4 = p2.createElement("input")).setAttribute("name", ""), t4.appendChild(e4), t4.querySelectorAll("[name='']").length || g2.push("\\[" + k2 + "*name" + k2 + "*=" + k2 + `*(?:''|"")`), t4.querySelectorAll(":checked").length || g2.push(":checked"), t4.querySelectorAll("a#" + b2 + "+*").length || g2.push(".#.+[+~]"), t4.querySelectorAll("\\\f"), g2.push("[\\r\\n\\f]");
              }), lt2(function(t4) {
                t4.innerHTML = "<a href='' disabled='disabled'></a><select disabled='disabled'><option/></select>";
                var e4 = p2.createElement("input");
                e4.setAttribute("type", "hidden"), t4.appendChild(e4).setAttribute("name", "D"), t4.querySelectorAll("[name=d]").length && g2.push("name" + k2 + "*[*^$|!~]?="), 2 !== t4.querySelectorAll(":enabled").length && g2.push(":enabled", ":disabled"), f2.appendChild(t4).disabled = true, 2 !== t4.querySelectorAll(":disabled").length && g2.push(":enabled", ":disabled"), t4.querySelectorAll("*,:x"), g2.push(",.*:");
              })), (n3.matchesSelector = Q2.test(y2 = f2.matches || f2.webkitMatchesSelector || f2.mozMatchesSelector || f2.oMatchesSelector || f2.msMatchesSelector)) && lt2(function(t4) {
                n3.disconnectedMatch = y2.call(t4, "*"), y2.call(t4, "[s!='']:x"), v2.push("!=", H2);
              }), g2 = g2.length && new RegExp(g2.join("|")), v2 = v2.length && new RegExp(v2.join("|")), e3 = Q2.test(f2.compareDocumentPosition), x2 = e3 || Q2.test(f2.contains) ? function(t4, e4) {
                var n4 = 9 === t4.nodeType ? t4.documentElement : t4, r3 = e4 && e4.parentNode;
                return t4 === r3 || !(!r3 || 1 !== r3.nodeType || !(n4.contains ? n4.contains(r3) : t4.compareDocumentPosition && 16 & t4.compareDocumentPosition(r3)));
              } : function(t4, e4) {
                if (e4) {
                  for (; e4 = e4.parentNode; ) if (e4 === t4) return true;
                }
                return false;
              }, C2 = e3 ? function(t4, e4) {
                if (t4 === e4) return h2 = true, 0;
                var r3 = !t4.compareDocumentPosition - !e4.compareDocumentPosition;
                return r3 || (1 & (r3 = (t4.ownerDocument || t4) == (e4.ownerDocument || e4) ? t4.compareDocumentPosition(e4) : 1) || !n3.sortDetached && e4.compareDocumentPosition(t4) === r3 ? t4 == p2 || t4.ownerDocument == w2 && x2(w2, t4) ? -1 : e4 == p2 || e4.ownerDocument == w2 && x2(w2, e4) ? 1 : l2 ? N2(l2, t4) - N2(l2, e4) : 0 : 4 & r3 ? -1 : 1);
              } : function(t4, e4) {
                if (t4 === e4) return h2 = true, 0;
                var n4, r3 = 0, i4 = t4.parentNode, o3 = e4.parentNode, a4 = [t4], s3 = [e4];
                if (!i4 || !o3) return t4 == p2 ? -1 : e4 == p2 ? 1 : i4 ? -1 : o3 ? 1 : l2 ? N2(l2, t4) - N2(l2, e4) : 0;
                if (i4 === o3) return dt2(t4, e4);
                for (n4 = t4; n4 = n4.parentNode; ) a4.unshift(n4);
                for (n4 = e4; n4 = n4.parentNode; ) s3.unshift(n4);
                for (; a4[r3] === s3[r3]; ) r3++;
                return r3 ? dt2(a4[r3], s3[r3]) : a4[r3] == w2 ? -1 : s3[r3] == w2 ? 1 : 0;
              }, p2) : p2;
            }, st2.matches = function(t3, e3) {
              return st2(t3, null, null, e3);
            }, st2.matchesSelector = function(t3, e3) {
              if (d2(t3), n3.matchesSelector && m2 && !A2[e3 + " "] && (!v2 || !v2.test(e3)) && (!g2 || !g2.test(e3))) try {
                var r3 = y2.call(t3, e3);
                if (r3 || n3.disconnectedMatch || t3.document && 11 !== t3.document.nodeType) return r3;
              } catch (t4) {
                A2(e3, true);
              }
              return st2(e3, p2, null, [t3]).length > 0;
            }, st2.contains = function(t3, e3) {
              return (t3.ownerDocument || t3) != p2 && d2(t3), x2(t3, e3);
            }, st2.attr = function(t3, e3) {
              (t3.ownerDocument || t3) != p2 && d2(t3);
              var i3 = r2.attrHandle[e3.toLowerCase()], o3 = i3 && L2.call(r2.attrHandle, e3.toLowerCase()) ? i3(t3, e3, !m2) : void 0;
              return void 0 !== o3 ? o3 : n3.attributes || !m2 ? t3.getAttribute(e3) : (o3 = t3.getAttributeNode(e3)) && o3.specified ? o3.value : null;
            }, st2.escape = function(t3) {
              return (t3 + "").replace(rt2, it2);
            }, st2.error = function(t3) {
              throw new Error("Syntax error, unrecognized expression: " + t3);
            }, st2.uniqueSort = function(t3) {
              var e3, r3 = [], i3 = 0, o3 = 0;
              if (h2 = !n3.detectDuplicates, l2 = !n3.sortStable && t3.slice(0), t3.sort(C2), h2) {
                for (; e3 = t3[o3++]; ) e3 === t3[o3] && (i3 = r3.push(o3));
                for (; i3--; ) t3.splice(r3[i3], 1);
              }
              return l2 = null, t3;
            }, i2 = st2.getText = function(t3) {
              var e3, n4 = "", r3 = 0, o3 = t3.nodeType;
              if (o3) {
                if (1 === o3 || 9 === o3 || 11 === o3) {
                  if ("string" == typeof t3.textContent) return t3.textContent;
                  for (t3 = t3.firstChild; t3; t3 = t3.nextSibling) n4 += i2(t3);
                } else if (3 === o3 || 4 === o3) return t3.nodeValue;
              } else for (; e3 = t3[r3++]; ) n4 += i2(e3);
              return n4;
            }, (r2 = st2.selectors = { cacheLength: 50, createPseudo: ut2, match: Y2, attrHandle: {}, find: {}, relative: { ">": { dir: "parentNode", first: true }, " ": { dir: "parentNode" }, "+": { dir: "previousSibling", first: true }, "~": { dir: "previousSibling" } }, preFilter: { ATTR: function(t3) {
              return t3[1] = t3[1].replace(et2, nt2), t3[3] = (t3[3] || t3[4] || t3[5] || "").replace(et2, nt2), "~=" === t3[2] && (t3[3] = " " + t3[3] + " "), t3.slice(0, 4);
            }, CHILD: function(t3) {
              return t3[1] = t3[1].toLowerCase(), "nth" === t3[1].slice(0, 3) ? (t3[3] || st2.error(t3[0]), t3[4] = +(t3[4] ? t3[5] + (t3[6] || 1) : 2 * ("even" === t3[3] || "odd" === t3[3])), t3[5] = +(t3[7] + t3[8] || "odd" === t3[3])) : t3[3] && st2.error(t3[0]), t3;
            }, PSEUDO: function(t3) {
              var e3, n4 = !t3[6] && t3[2];
              return Y2.CHILD.test(t3[0]) ? null : (t3[3] ? t3[2] = t3[4] || t3[5] || "" : n4 && q2.test(n4) && (e3 = a2(n4, true)) && (e3 = n4.indexOf(")", n4.length - e3) - n4.length) && (t3[0] = t3[0].slice(0, e3), t3[2] = n4.slice(0, e3)), t3.slice(0, 3));
            } }, filter: { TAG: function(t3) {
              var e3 = t3.replace(et2, nt2).toLowerCase();
              return "*" === t3 ? function() {
                return true;
              } : function(t4) {
                return t4.nodeName && t4.nodeName.toLowerCase() === e3;
              };
            }, CLASS: function(t3) {
              var e3 = S2[t3 + " "];
              return e3 || (e3 = new RegExp("(^|" + k2 + ")" + t3 + "(" + k2 + "|$)")) && S2(t3, function(t4) {
                return e3.test("string" == typeof t4.className && t4.className || void 0 !== t4.getAttribute && t4.getAttribute("class") || "");
              });
            }, ATTR: function(t3, e3, n4) {
              return function(r3) {
                var i3 = st2.attr(r3, t3);
                return null == i3 ? "!=" === e3 : !e3 || (i3 += "", "=" === e3 ? i3 === n4 : "!=" === e3 ? i3 !== n4 : "^=" === e3 ? n4 && 0 === i3.indexOf(n4) : "*=" === e3 ? n4 && i3.indexOf(n4) > -1 : "$=" === e3 ? n4 && i3.slice(-n4.length) === n4 : "~=" === e3 ? (" " + i3.replace(G2, " ") + " ").indexOf(n4) > -1 : "|=" === e3 && (i3 === n4 || i3.slice(0, n4.length + 1) === n4 + "-"));
              };
            }, CHILD: function(t3, e3, n4, r3, i3) {
              var o3 = "nth" !== t3.slice(0, 3), a3 = "last" !== t3.slice(-4), s3 = "of-type" === e3;
              return 1 === r3 && 0 === i3 ? function(t4) {
                return !!t4.parentNode;
              } : function(e4, n5, c3) {
                var u3, l3, h3, d3, p3, f3, m3 = o3 !== a3 ? "nextSibling" : "previousSibling", g3 = e4.parentNode, v3 = s3 && e4.nodeName.toLowerCase(), y3 = !c3 && !s3, x3 = false;
                if (g3) {
                  if (o3) {
                    for (; m3; ) {
                      for (d3 = e4; d3 = d3[m3]; ) if (s3 ? d3.nodeName.toLowerCase() === v3 : 1 === d3.nodeType) return false;
                      f3 = m3 = "only" === t3 && !f3 && "nextSibling";
                    }
                    return true;
                  }
                  if (f3 = [a3 ? g3.firstChild : g3.lastChild], a3 && y3) {
                    for (x3 = (p3 = (u3 = (l3 = (h3 = (d3 = g3)[b2] || (d3[b2] = {}))[d3.uniqueID] || (h3[d3.uniqueID] = {}))[t3] || [])[0] === _2 && u3[1]) && u3[2], d3 = p3 && g3.childNodes[p3]; d3 = ++p3 && d3 && d3[m3] || (x3 = p3 = 0) || f3.pop(); ) if (1 === d3.nodeType && ++x3 && d3 === e4) {
                      l3[t3] = [_2, p3, x3];
                      break;
                    }
                  } else if (y3 && (x3 = p3 = (u3 = (l3 = (h3 = (d3 = e4)[b2] || (d3[b2] = {}))[d3.uniqueID] || (h3[d3.uniqueID] = {}))[t3] || [])[0] === _2 && u3[1]), false === x3) for (; (d3 = ++p3 && d3 && d3[m3] || (x3 = p3 = 0) || f3.pop()) && ((s3 ? d3.nodeName.toLowerCase() !== v3 : 1 !== d3.nodeType) || !++x3 || (y3 && ((l3 = (h3 = d3[b2] || (d3[b2] = {}))[d3.uniqueID] || (h3[d3.uniqueID] = {}))[t3] = [_2, x3]), d3 !== e4)); ) ;
                  return (x3 -= i3) === r3 || x3 % r3 == 0 && x3 / r3 >= 0;
                }
              };
            }, PSEUDO: function(t3, e3) {
              var n4, i3 = r2.pseudos[t3] || r2.setFilters[t3.toLowerCase()] || st2.error("unsupported pseudo: " + t3);
              return i3[b2] ? i3(e3) : i3.length > 1 ? (n4 = [t3, t3, "", e3], r2.setFilters.hasOwnProperty(t3.toLowerCase()) ? ut2(function(t4, n5) {
                for (var r3, o3 = i3(t4, e3), a3 = o3.length; a3--; ) t4[r3 = N2(t4, o3[a3])] = !(n5[r3] = o3[a3]);
              }) : function(t4) {
                return i3(t4, 0, n4);
              }) : i3;
            } }, pseudos: { not: ut2(function(t3) {
              var e3 = [], n4 = [], r3 = s2(t3.replace(U2, "$1"));
              return r3[b2] ? ut2(function(t4, e4, n5, i3) {
                for (var o3, a3 = r3(t4, null, i3, []), s3 = t4.length; s3--; ) (o3 = a3[s3]) && (t4[s3] = !(e4[s3] = o3));
              }) : function(t4, i3, o3) {
                return e3[0] = t4, r3(e3, null, o3, n4), e3[0] = null, !n4.pop();
              };
            }), has: ut2(function(t3) {
              return function(e3) {
                return st2(t3, e3).length > 0;
              };
            }), contains: ut2(function(t3) {
              return t3 = t3.replace(et2, nt2), function(e3) {
                return (e3.textContent || i2(e3)).indexOf(t3) > -1;
              };
            }), lang: ut2(function(t3) {
              return X2.test(t3 || "") || st2.error("unsupported lang: " + t3), t3 = t3.replace(et2, nt2).toLowerCase(), function(e3) {
                var n4;
                do {
                  if (n4 = m2 ? e3.lang : e3.getAttribute("xml:lang") || e3.getAttribute("lang")) return (n4 = n4.toLowerCase()) === t3 || 0 === n4.indexOf(t3 + "-");
                } while ((e3 = e3.parentNode) && 1 === e3.nodeType);
                return false;
              };
            }), target: function(e3) {
              var n4 = t2.location && t2.location.hash;
              return n4 && n4.slice(1) === e3.id;
            }, root: function(t3) {
              return t3 === f2;
            }, focus: function(t3) {
              return t3 === p2.activeElement && (!p2.hasFocus || p2.hasFocus()) && !!(t3.type || t3.href || ~t3.tabIndex);
            }, enabled: mt2(false), disabled: mt2(true), checked: function(t3) {
              var e3 = t3.nodeName.toLowerCase();
              return "input" === e3 && !!t3.checked || "option" === e3 && !!t3.selected;
            }, selected: function(t3) {
              return t3.parentNode && t3.parentNode.selectedIndex, true === t3.selected;
            }, empty: function(t3) {
              for (t3 = t3.firstChild; t3; t3 = t3.nextSibling) if (t3.nodeType < 6) return false;
              return true;
            }, parent: function(t3) {
              return !r2.pseudos.empty(t3);
            }, header: function(t3) {
              return $2.test(t3.nodeName);
            }, input: function(t3) {
              return J2.test(t3.nodeName);
            }, button: function(t3) {
              var e3 = t3.nodeName.toLowerCase();
              return "input" === e3 && "button" === t3.type || "button" === e3;
            }, text: function(t3) {
              var e3;
              return "input" === t3.nodeName.toLowerCase() && "text" === t3.type && (null == (e3 = t3.getAttribute("type")) || "text" === e3.toLowerCase());
            }, first: gt2(function() {
              return [0];
            }), last: gt2(function(t3, e3) {
              return [e3 - 1];
            }), eq: gt2(function(t3, e3, n4) {
              return [n4 < 0 ? n4 + e3 : n4];
            }), even: gt2(function(t3, e3) {
              for (var n4 = 0; n4 < e3; n4 += 2) t3.push(n4);
              return t3;
            }), odd: gt2(function(t3, e3) {
              for (var n4 = 1; n4 < e3; n4 += 2) t3.push(n4);
              return t3;
            }), lt: gt2(function(t3, e3, n4) {
              for (var r3 = n4 < 0 ? n4 + e3 : n4 > e3 ? e3 : n4; --r3 >= 0; ) t3.push(r3);
              return t3;
            }), gt: gt2(function(t3, e3, n4) {
              for (var r3 = n4 < 0 ? n4 + e3 : n4; ++r3 < e3; ) t3.push(r3);
              return t3;
            }) } }).pseudos.nth = r2.pseudos.eq, { radio: true, checkbox: true, file: true, password: true, image: true }) r2.pseudos[e2] = pt2(e2);
            for (e2 in { submit: true, reset: true }) r2.pseudos[e2] = ft2(e2);
            function yt2() {
            }
            function xt2(t3) {
              for (var e3 = 0, n4 = t3.length, r3 = ""; e3 < n4; e3++) r3 += t3[e3].value;
              return r3;
            }
            function bt2(t3, e3, n4) {
              var r3 = e3.dir, i3 = e3.next, o3 = i3 || r3, a3 = n4 && "parentNode" === o3, s3 = M2++;
              return e3.first ? function(e4, n5, i4) {
                for (; e4 = e4[r3]; ) if (1 === e4.nodeType || a3) return t3(e4, n5, i4);
                return false;
              } : function(e4, n5, c3) {
                var u3, l3, h3, d3 = [_2, s3];
                if (c3) {
                  for (; e4 = e4[r3]; ) if ((1 === e4.nodeType || a3) && t3(e4, n5, c3)) return true;
                } else for (; e4 = e4[r3]; ) if (1 === e4.nodeType || a3) if (l3 = (h3 = e4[b2] || (e4[b2] = {}))[e4.uniqueID] || (h3[e4.uniqueID] = {}), i3 && i3 === e4.nodeName.toLowerCase()) e4 = e4[r3] || e4;
                else {
                  if ((u3 = l3[o3]) && u3[0] === _2 && u3[1] === s3) return d3[2] = u3[2];
                  if (l3[o3] = d3, d3[2] = t3(e4, n5, c3)) return true;
                }
                return false;
              };
            }
            function wt2(t3) {
              return t3.length > 1 ? function(e3, n4, r3) {
                for (var i3 = t3.length; i3--; ) if (!t3[i3](e3, n4, r3)) return false;
                return true;
              } : t3[0];
            }
            function _t2(t3, e3, n4, r3, i3) {
              for (var o3, a3 = [], s3 = 0, c3 = t3.length, u3 = null != e3; s3 < c3; s3++) (o3 = t3[s3]) && (n4 && !n4(o3, r3, i3) || (a3.push(o3), u3 && e3.push(s3)));
              return a3;
            }
            function Mt2(t3, e3, n4, r3, i3, o3) {
              return r3 && !r3[b2] && (r3 = Mt2(r3)), i3 && !i3[b2] && (i3 = Mt2(i3, o3)), ut2(function(o4, a3, s3, c3) {
                var u3, l3, h3, d3 = [], p3 = [], f3 = a3.length, m3 = o4 || function(t4, e4, n5) {
                  for (var r4 = 0, i4 = e4.length; r4 < i4; r4++) st2(t4, e4[r4], n5);
                  return n5;
                }(e3 || "*", s3.nodeType ? [s3] : s3, []), g3 = !t3 || !o4 && e3 ? m3 : _t2(m3, d3, t3, s3, c3), v3 = n4 ? i3 || (o4 ? t3 : f3 || r3) ? [] : a3 : g3;
                if (n4 && n4(g3, v3, s3, c3), r3) for (u3 = _t2(v3, p3), r3(u3, [], s3, c3), l3 = u3.length; l3--; ) (h3 = u3[l3]) && (v3[p3[l3]] = !(g3[p3[l3]] = h3));
                if (o4) {
                  if (i3 || t3) {
                    if (i3) {
                      for (u3 = [], l3 = v3.length; l3--; ) (h3 = v3[l3]) && u3.push(g3[l3] = h3);
                      i3(null, v3 = [], u3, c3);
                    }
                    for (l3 = v3.length; l3--; ) (h3 = v3[l3]) && (u3 = i3 ? N2(o4, h3) : d3[l3]) > -1 && (o4[u3] = !(a3[u3] = h3));
                  }
                } else v3 = _t2(v3 === a3 ? v3.splice(f3, v3.length) : v3), i3 ? i3(null, a3, v3, c3) : D2.apply(a3, v3);
              });
            }
            function St2(t3) {
              for (var e3, n4, i3, o3 = t3.length, a3 = r2.relative[t3[0].type], s3 = a3 || r2.relative[" "], c3 = a3 ? 1 : 0, l3 = bt2(function(t4) {
                return t4 === e3;
              }, s3, true), h3 = bt2(function(t4) {
                return N2(e3, t4) > -1;
              }, s3, true), d3 = [function(t4, n5, r3) {
                var i4 = !a3 && (r3 || n5 !== u2) || ((e3 = n5).nodeType ? l3(t4, n5, r3) : h3(t4, n5, r3));
                return e3 = null, i4;
              }]; c3 < o3; c3++) if (n4 = r2.relative[t3[c3].type]) d3 = [bt2(wt2(d3), n4)];
              else {
                if ((n4 = r2.filter[t3[c3].type].apply(null, t3[c3].matches))[b2]) {
                  for (i3 = ++c3; i3 < o3 && !r2.relative[t3[i3].type]; i3++) ;
                  return Mt2(c3 > 1 && wt2(d3), c3 > 1 && xt2(t3.slice(0, c3 - 1).concat({ value: " " === t3[c3 - 2].type ? "*" : "" })).replace(U2, "$1"), n4, c3 < i3 && St2(t3.slice(c3, i3)), i3 < o3 && St2(t3 = t3.slice(i3)), i3 < o3 && xt2(t3));
                }
                d3.push(n4);
              }
              return wt2(d3);
            }
            return yt2.prototype = r2.filters = r2.pseudos, r2.setFilters = new yt2(), a2 = st2.tokenize = function(t3, e3) {
              var n4, i3, o3, a3, s3, c3, u3, l3 = T2[t3 + " "];
              if (l3) return e3 ? 0 : l3.slice(0);
              for (s3 = t3, c3 = [], u3 = r2.preFilter; s3; ) {
                for (a3 in n4 && !(i3 = j2.exec(s3)) || (i3 && (s3 = s3.slice(i3[0].length) || s3), c3.push(o3 = [])), n4 = false, (i3 = V2.exec(s3)) && (n4 = i3.shift(), o3.push({ value: n4, type: i3[0].replace(U2, " ") }), s3 = s3.slice(n4.length)), r2.filter) !(i3 = Y2[a3].exec(s3)) || u3[a3] && !(i3 = u3[a3](i3)) || (n4 = i3.shift(), o3.push({ value: n4, type: a3, matches: i3 }), s3 = s3.slice(n4.length));
                if (!n4) break;
              }
              return e3 ? s3.length : s3 ? st2.error(t3) : T2(t3, c3).slice(0);
            }, s2 = st2.compile = function(t3, e3) {
              var n4, i3 = [], o3 = [], s3 = E2[t3 + " "];
              if (!s3) {
                for (e3 || (e3 = a2(t3)), n4 = e3.length; n4--; ) (s3 = St2(e3[n4]))[b2] ? i3.push(s3) : o3.push(s3);
                (s3 = E2(t3, function(t4, e4) {
                  var n5 = e4.length > 0, i4 = t4.length > 0, o4 = function(o5, a3, s4, c3, l3) {
                    var h3, f3, g3, v3 = 0, y3 = "0", x3 = o5 && [], b3 = [], w3 = u2, M3 = o5 || i4 && r2.find.TAG("*", l3), S3 = _2 += null == w3 ? 1 : Math.random() || 0.1, T3 = M3.length;
                    for (l3 && (u2 = a3 == p2 || a3 || l3); y3 !== T3 && null != (h3 = M3[y3]); y3++) {
                      if (i4 && h3) {
                        for (f3 = 0, a3 || h3.ownerDocument == p2 || (d2(h3), s4 = !m2); g3 = t4[f3++]; ) if (g3(h3, a3 || p2, s4)) {
                          c3.push(h3);
                          break;
                        }
                        l3 && (_2 = S3);
                      }
                      n5 && ((h3 = !g3 && h3) && v3--, o5 && x3.push(h3));
                    }
                    if (v3 += y3, n5 && y3 !== v3) {
                      for (f3 = 0; g3 = e4[f3++]; ) g3(x3, b3, a3, s4);
                      if (o5) {
                        if (v3 > 0) for (; y3--; ) x3[y3] || b3[y3] || (b3[y3] = R2.call(c3));
                        b3 = _t2(b3);
                      }
                      D2.apply(c3, b3), l3 && !o5 && b3.length > 0 && v3 + e4.length > 1 && st2.uniqueSort(c3);
                    }
                    return l3 && (_2 = S3, u2 = w3), x3;
                  };
                  return n5 ? ut2(o4) : o4;
                }(o3, i3))).selector = t3;
              }
              return s3;
            }, c2 = st2.select = function(t3, e3, n4, i3) {
              var o3, c3, u3, l3, h3, d3 = "function" == typeof t3 && t3, p3 = !i3 && a2(t3 = d3.selector || t3);
              if (n4 = n4 || [], 1 === p3.length) {
                if ((c3 = p3[0] = p3[0].slice(0)).length > 2 && "ID" === (u3 = c3[0]).type && 9 === e3.nodeType && m2 && r2.relative[c3[1].type]) {
                  if (!(e3 = (r2.find.ID(u3.matches[0].replace(et2, nt2), e3) || [])[0])) return n4;
                  d3 && (e3 = e3.parentNode), t3 = t3.slice(c3.shift().value.length);
                }
                for (o3 = Y2.needsContext.test(t3) ? 0 : c3.length; o3-- && (u3 = c3[o3], !r2.relative[l3 = u3.type]); ) if ((h3 = r2.find[l3]) && (i3 = h3(u3.matches[0].replace(et2, nt2), tt2.test(c3[0].type) && vt2(e3.parentNode) || e3))) {
                  if (c3.splice(o3, 1), !(t3 = i3.length && xt2(c3))) return D2.apply(n4, i3), n4;
                  break;
                }
              }
              return (d3 || s2(t3, p3))(i3, e3, !m2, n4, !e3 || tt2.test(t3) && vt2(e3.parentNode) || e3), n4;
            }, n3.sortStable = b2.split("").sort(C2).join("") === b2, n3.detectDuplicates = !!h2, d2(), n3.sortDetached = lt2(function(t3) {
              return 1 & t3.compareDocumentPosition(p2.createElement("fieldset"));
            }), lt2(function(t3) {
              return t3.innerHTML = "<a href='#'></a>", "#" === t3.firstChild.getAttribute("href");
            }) || ht2("type|href|height|width", function(t3, e3, n4) {
              if (!n4) return t3.getAttribute(e3, "type" === e3.toLowerCase() ? 1 : 2);
            }), n3.attributes && lt2(function(t3) {
              return t3.innerHTML = "<input/>", t3.firstChild.setAttribute("value", ""), "" === t3.firstChild.getAttribute("value");
            }) || ht2("value", function(t3, e3, n4) {
              if (!n4 && "input" === t3.nodeName.toLowerCase()) return t3.defaultValue;
            }), lt2(function(t3) {
              return null == t3.getAttribute("disabled");
            }) || ht2(z2, function(t3, e3, n4) {
              var r3;
              if (!n4) return true === t3[e3] ? e3.toLowerCase() : (r3 = t3.getAttributeNode(e3)) && r3.specified ? r3.value : null;
            }), st2;
          }(n2)
        );
        M.find = T, M.expr = T.selectors, M.expr[":"] = M.expr.pseudos, M.uniqueSort = M.unique = T.uniqueSort, M.text = T.getText, M.isXMLDoc = T.isXML, M.contains = T.contains, M.escapeSelector = T.escape;
        var E = function(t2, e2, n3) {
          for (var r2 = [], i2 = void 0 !== n3; (t2 = t2[e2]) && 9 !== t2.nodeType; ) if (1 === t2.nodeType) {
            if (i2 && M(t2).is(n3)) break;
            r2.push(t2);
          }
          return r2;
        }, A = function(t2, e2) {
          for (var n3 = []; t2; t2 = t2.nextSibling) 1 === t2.nodeType && t2 !== e2 && n3.push(t2);
          return n3;
        }, C = M.expr.match.needsContext;
        function L(t2, e2) {
          return t2.nodeName && t2.nodeName.toLowerCase() === e2.toLowerCase();
        }
        var P = /^<([a-z][^\/\0>:\x20\t\r\n\f]*)[\x20\t\r\n\f]*\/?>(?:<\/\1>|)$/i;
        function R(t2, e2, n3) {
          return v(e2) ? M.grep(t2, function(t3, r2) {
            return !!e2.call(t3, r2, t3) !== n3;
          }) : e2.nodeType ? M.grep(t2, function(t3) {
            return t3 === e2 !== n3;
          }) : "string" != typeof e2 ? M.grep(t2, function(t3) {
            return l.call(e2, t3) > -1 !== n3;
          }) : M.filter(e2, t2, n3);
        }
        M.filter = function(t2, e2, n3) {
          var r2 = e2[0];
          return n3 && (t2 = ":not(" + t2 + ")"), 1 === e2.length && 1 === r2.nodeType ? M.find.matchesSelector(r2, t2) ? [r2] : [] : M.find.matches(t2, M.grep(e2, function(t3) {
            return 1 === t3.nodeType;
          }));
        }, M.fn.extend({ find: function(t2) {
          var e2, n3, r2 = this.length, i2 = this;
          if ("string" != typeof t2) return this.pushStack(M(t2).filter(function() {
            for (e2 = 0; e2 < r2; e2++) if (M.contains(i2[e2], this)) return true;
          }));
          for (n3 = this.pushStack([]), e2 = 0; e2 < r2; e2++) M.find(t2, i2[e2], n3);
          return r2 > 1 ? M.uniqueSort(n3) : n3;
        }, filter: function(t2) {
          return this.pushStack(R(this, t2 || [], false));
        }, not: function(t2) {
          return this.pushStack(R(this, t2 || [], true));
        }, is: function(t2) {
          return !!R(this, "string" == typeof t2 && C.test(t2) ? M(t2) : t2 || [], false).length;
        } });
        var O, D = /^(?:\s*(<[\w\W]+>)[^>]*|#([\w-]+))$/;
        (M.fn.init = function(t2, e2, n3) {
          var r2, i2;
          if (!t2) return this;
          if (n3 = n3 || O, "string" == typeof t2) {
            if (!(r2 = "<" === t2[0] && ">" === t2[t2.length - 1] && t2.length >= 3 ? [null, t2, null] : D.exec(t2)) || !r2[1] && e2) return !e2 || e2.jquery ? (e2 || n3).find(t2) : this.constructor(e2).find(t2);
            if (r2[1]) {
              if (e2 = e2 instanceof M ? e2[0] : e2, M.merge(this, M.parseHTML(r2[1], e2 && e2.nodeType ? e2.ownerDocument || e2 : x, true)), P.test(r2[1]) && M.isPlainObject(e2)) for (r2 in e2) v(this[r2]) ? this[r2](e2[r2]) : this.attr(r2, e2[r2]);
              return this;
            }
            return (i2 = x.getElementById(r2[2])) && (this[0] = i2, this.length = 1), this;
          }
          return t2.nodeType ? (this[0] = t2, this.length = 1, this) : v(t2) ? void 0 !== n3.ready ? n3.ready(t2) : t2(M) : M.makeArray(t2, this);
        }).prototype = M.fn, O = M(x);
        var I = /^(?:parents|prev(?:Until|All))/, N = { children: true, contents: true, next: true, prev: true };
        function z(t2, e2) {
          for (; (t2 = t2[e2]) && 1 !== t2.nodeType; ) ;
          return t2;
        }
        M.fn.extend({ has: function(t2) {
          var e2 = M(t2, this), n3 = e2.length;
          return this.filter(function() {
            for (var t3 = 0; t3 < n3; t3++) if (M.contains(this, e2[t3])) return true;
          });
        }, closest: function(t2, e2) {
          var n3, r2 = 0, i2 = this.length, o2 = [], a2 = "string" != typeof t2 && M(t2);
          if (!C.test(t2)) {
            for (; r2 < i2; r2++) for (n3 = this[r2]; n3 && n3 !== e2; n3 = n3.parentNode) if (n3.nodeType < 11 && (a2 ? a2.index(n3) > -1 : 1 === n3.nodeType && M.find.matchesSelector(n3, t2))) {
              o2.push(n3);
              break;
            }
          }
          return this.pushStack(o2.length > 1 ? M.uniqueSort(o2) : o2);
        }, index: function(t2) {
          return t2 ? "string" == typeof t2 ? l.call(M(t2), this[0]) : l.call(this, t2.jquery ? t2[0] : t2) : this[0] && this[0].parentNode ? this.first().prevAll().length : -1;
        }, add: function(t2, e2) {
          return this.pushStack(M.uniqueSort(M.merge(this.get(), M(t2, e2))));
        }, addBack: function(t2) {
          return this.add(null == t2 ? this.prevObject : this.prevObject.filter(t2));
        } }), M.each({ parent: function(t2) {
          var e2 = t2.parentNode;
          return e2 && 11 !== e2.nodeType ? e2 : null;
        }, parents: function(t2) {
          return E(t2, "parentNode");
        }, parentsUntil: function(t2, e2, n3) {
          return E(t2, "parentNode", n3);
        }, next: function(t2) {
          return z(t2, "nextSibling");
        }, prev: function(t2) {
          return z(t2, "previousSibling");
        }, nextAll: function(t2) {
          return E(t2, "nextSibling");
        }, prevAll: function(t2) {
          return E(t2, "previousSibling");
        }, nextUntil: function(t2, e2, n3) {
          return E(t2, "nextSibling", n3);
        }, prevUntil: function(t2, e2, n3) {
          return E(t2, "previousSibling", n3);
        }, siblings: function(t2) {
          return A((t2.parentNode || {}).firstChild, t2);
        }, children: function(t2) {
          return A(t2.firstChild);
        }, contents: function(t2) {
          return null != t2.contentDocument && a(t2.contentDocument) ? t2.contentDocument : (L(t2, "template") && (t2 = t2.content || t2), M.merge([], t2.childNodes));
        } }, function(t2, e2) {
          M.fn[t2] = function(n3, r2) {
            var i2 = M.map(this, e2, n3);
            return "Until" !== t2.slice(-5) && (r2 = n3), r2 && "string" == typeof r2 && (i2 = M.filter(r2, i2)), this.length > 1 && (N[t2] || M.uniqueSort(i2), I.test(t2) && i2.reverse()), this.pushStack(i2);
          };
        });
        var k = /[^\x20\t\r\n\f]+/g;
        function F(t2) {
          return t2;
        }
        function B(t2) {
          throw t2;
        }
        function H(t2, e2, n3, r2) {
          var i2;
          try {
            t2 && v(i2 = t2.promise) ? i2.call(t2).done(e2).fail(n3) : t2 && v(i2 = t2.then) ? i2.call(t2, e2, n3) : e2.apply(void 0, [t2].slice(r2));
          } catch (t3) {
            n3.apply(void 0, [t3]);
          }
        }
        M.Callbacks = function(t2) {
          t2 = "string" == typeof t2 ? function(t3) {
            var e3 = {};
            return M.each(t3.match(k) || [], function(t4, n4) {
              e3[n4] = true;
            }), e3;
          }(t2) : M.extend({}, t2);
          var e2, n3, r2, i2, o2 = [], a2 = [], s2 = -1, c2 = function() {
            for (i2 = i2 || t2.once, r2 = e2 = true; a2.length; s2 = -1) for (n3 = a2.shift(); ++s2 < o2.length; ) false === o2[s2].apply(n3[0], n3[1]) && t2.stopOnFalse && (s2 = o2.length, n3 = false);
            t2.memory || (n3 = false), e2 = false, i2 && (o2 = n3 ? [] : "");
          }, u2 = { add: function() {
            return o2 && (n3 && !e2 && (s2 = o2.length - 1, a2.push(n3)), function e3(n4) {
              M.each(n4, function(n5, r3) {
                v(r3) ? t2.unique && u2.has(r3) || o2.push(r3) : r3 && r3.length && "string" !== _(r3) && e3(r3);
              });
            }(arguments), n3 && !e2 && c2()), this;
          }, remove: function() {
            return M.each(arguments, function(t3, e3) {
              for (var n4; (n4 = M.inArray(e3, o2, n4)) > -1; ) o2.splice(n4, 1), n4 <= s2 && s2--;
            }), this;
          }, has: function(t3) {
            return t3 ? M.inArray(t3, o2) > -1 : o2.length > 0;
          }, empty: function() {
            return o2 && (o2 = []), this;
          }, disable: function() {
            return i2 = a2 = [], o2 = n3 = "", this;
          }, disabled: function() {
            return !o2;
          }, lock: function() {
            return i2 = a2 = [], n3 || e2 || (o2 = n3 = ""), this;
          }, locked: function() {
            return !!i2;
          }, fireWith: function(t3, n4) {
            return i2 || (n4 = [t3, (n4 = n4 || []).slice ? n4.slice() : n4], a2.push(n4), e2 || c2()), this;
          }, fire: function() {
            return u2.fireWith(this, arguments), this;
          }, fired: function() {
            return !!r2;
          } };
          return u2;
        }, M.extend({ Deferred: function(t2) {
          var e2 = [["notify", "progress", M.Callbacks("memory"), M.Callbacks("memory"), 2], ["resolve", "done", M.Callbacks("once memory"), M.Callbacks("once memory"), 0, "resolved"], ["reject", "fail", M.Callbacks("once memory"), M.Callbacks("once memory"), 1, "rejected"]], r2 = "pending", i2 = { state: function() {
            return r2;
          }, always: function() {
            return o2.done(arguments).fail(arguments), this;
          }, catch: function(t3) {
            return i2.then(null, t3);
          }, pipe: function() {
            var t3 = arguments;
            return M.Deferred(function(n3) {
              M.each(e2, function(e3, r3) {
                var i3 = v(t3[r3[4]]) && t3[r3[4]];
                o2[r3[1]](function() {
                  var t4 = i3 && i3.apply(this, arguments);
                  t4 && v(t4.promise) ? t4.promise().progress(n3.notify).done(n3.resolve).fail(n3.reject) : n3[r3[0] + "With"](this, i3 ? [t4] : arguments);
                });
              }), t3 = null;
            }).promise();
          }, then: function(t3, r3, i3) {
            var o3 = 0;
            function a2(t4, e3, r4, i4) {
              return function() {
                var s2 = this, c2 = arguments, u2 = function() {
                  var n3, u3;
                  if (!(t4 < o3)) {
                    if ((n3 = r4.apply(s2, c2)) === e3.promise()) throw new TypeError("Thenable self-resolution");
                    u3 = n3 && ("object" == typeof n3 || "function" == typeof n3) && n3.then, v(u3) ? i4 ? u3.call(n3, a2(o3, e3, F, i4), a2(o3, e3, B, i4)) : (o3++, u3.call(n3, a2(o3, e3, F, i4), a2(o3, e3, B, i4), a2(o3, e3, F, e3.notifyWith))) : (r4 !== F && (s2 = void 0, c2 = [n3]), (i4 || e3.resolveWith)(s2, c2));
                  }
                }, l2 = i4 ? u2 : function() {
                  try {
                    u2();
                  } catch (n3) {
                    M.Deferred.exceptionHook && M.Deferred.exceptionHook(n3, l2.stackTrace), t4 + 1 >= o3 && (r4 !== B && (s2 = void 0, c2 = [n3]), e3.rejectWith(s2, c2));
                  }
                };
                t4 ? l2() : (M.Deferred.getStackHook && (l2.stackTrace = M.Deferred.getStackHook()), n2.setTimeout(l2));
              };
            }
            return M.Deferred(function(n3) {
              e2[0][3].add(a2(0, n3, v(i3) ? i3 : F, n3.notifyWith)), e2[1][3].add(a2(0, n3, v(t3) ? t3 : F)), e2[2][3].add(a2(0, n3, v(r3) ? r3 : B));
            }).promise();
          }, promise: function(t3) {
            return null != t3 ? M.extend(t3, i2) : i2;
          } }, o2 = {};
          return M.each(e2, function(t3, n3) {
            var a2 = n3[2], s2 = n3[5];
            i2[n3[1]] = a2.add, s2 && a2.add(function() {
              r2 = s2;
            }, e2[3 - t3][2].disable, e2[3 - t3][3].disable, e2[0][2].lock, e2[0][3].lock), a2.add(n3[3].fire), o2[n3[0]] = function() {
              return o2[n3[0] + "With"](this === o2 ? void 0 : this, arguments), this;
            }, o2[n3[0] + "With"] = a2.fireWith;
          }), i2.promise(o2), t2 && t2.call(o2, o2), o2;
        }, when: function(t2) {
          var e2 = arguments.length, n3 = e2, r2 = Array(n3), i2 = s.call(arguments), o2 = M.Deferred(), a2 = function(t3) {
            return function(n4) {
              r2[t3] = this, i2[t3] = arguments.length > 1 ? s.call(arguments) : n4, --e2 || o2.resolveWith(r2, i2);
            };
          };
          if (e2 <= 1 && (H(t2, o2.done(a2(n3)).resolve, o2.reject, !e2), "pending" === o2.state() || v(i2[n3] && i2[n3].then))) return o2.then();
          for (; n3--; ) H(i2[n3], a2(n3), o2.reject);
          return o2.promise();
        } });
        var G = /^(Eval|Internal|Range|Reference|Syntax|Type|URI)Error$/;
        M.Deferred.exceptionHook = function(t2, e2) {
          n2.console && n2.console.warn && t2 && G.test(t2.name) && n2.console.warn("jQuery.Deferred exception: " + t2.message, t2.stack, e2);
        }, M.readyException = function(t2) {
          n2.setTimeout(function() {
            throw t2;
          });
        };
        var U = M.Deferred();
        function j() {
          x.removeEventListener("DOMContentLoaded", j), n2.removeEventListener("load", j), M.ready();
        }
        M.fn.ready = function(t2) {
          return U.then(t2).catch(function(t3) {
            M.readyException(t3);
          }), this;
        }, M.extend({ isReady: false, readyWait: 1, ready: function(t2) {
          (true === t2 ? --M.readyWait : M.isReady) || (M.isReady = true, true !== t2 && --M.readyWait > 0 || U.resolveWith(x, [M]));
        } }), M.ready.then = U.then, "complete" === x.readyState || "loading" !== x.readyState && !x.documentElement.doScroll ? n2.setTimeout(M.ready) : (x.addEventListener("DOMContentLoaded", j), n2.addEventListener("load", j));
        var V = function(t2, e2, n3, r2, i2, o2, a2) {
          var s2 = 0, c2 = t2.length, u2 = null == n3;
          if ("object" === _(n3)) for (s2 in i2 = true, n3) V(t2, e2, s2, n3[s2], true, o2, a2);
          else if (void 0 !== r2 && (i2 = true, v(r2) || (a2 = true), u2 && (a2 ? (e2.call(t2, r2), e2 = null) : (u2 = e2, e2 = function(t3, e3, n4) {
            return u2.call(M(t3), n4);
          })), e2)) for (; s2 < c2; s2++) e2(t2[s2], n3, a2 ? r2 : r2.call(t2[s2], s2, e2(t2[s2], n3)));
          return i2 ? t2 : u2 ? e2.call(t2) : c2 ? e2(t2[0], n3) : o2;
        }, W = /^-ms-/, q = /-([a-z])/g;
        function X(t2, e2) {
          return e2.toUpperCase();
        }
        function Y(t2) {
          return t2.replace(W, "ms-").replace(q, X);
        }
        var Z = function(t2) {
          return 1 === t2.nodeType || 9 === t2.nodeType || !+t2.nodeType;
        };
        function J() {
          this.expando = M.expando + J.uid++;
        }
        J.uid = 1, J.prototype = { cache: function(t2) {
          var e2 = t2[this.expando];
          return e2 || (e2 = {}, Z(t2) && (t2.nodeType ? t2[this.expando] = e2 : Object.defineProperty(t2, this.expando, { value: e2, configurable: true }))), e2;
        }, set: function(t2, e2, n3) {
          var r2, i2 = this.cache(t2);
          if ("string" == typeof e2) i2[Y(e2)] = n3;
          else for (r2 in e2) i2[Y(r2)] = e2[r2];
          return i2;
        }, get: function(t2, e2) {
          return void 0 === e2 ? this.cache(t2) : t2[this.expando] && t2[this.expando][Y(e2)];
        }, access: function(t2, e2, n3) {
          return void 0 === e2 || e2 && "string" == typeof e2 && void 0 === n3 ? this.get(t2, e2) : (this.set(t2, e2, n3), void 0 !== n3 ? n3 : e2);
        }, remove: function(t2, e2) {
          var n3, r2 = t2[this.expando];
          if (void 0 !== r2) {
            if (void 0 !== e2) {
              n3 = (e2 = Array.isArray(e2) ? e2.map(Y) : (e2 = Y(e2)) in r2 ? [e2] : e2.match(k) || []).length;
              for (; n3--; ) delete r2[e2[n3]];
            }
            (void 0 === e2 || M.isEmptyObject(r2)) && (t2.nodeType ? t2[this.expando] = void 0 : delete t2[this.expando]);
          }
        }, hasData: function(t2) {
          var e2 = t2[this.expando];
          return void 0 !== e2 && !M.isEmptyObject(e2);
        } };
        var $ = new J(), Q = new J(), K = /^(?:\{[\w\W]*\}|\[[\w\W]*\])$/, tt = /[A-Z]/g;
        function et(t2, e2, n3) {
          var r2;
          if (void 0 === n3 && 1 === t2.nodeType) if (r2 = "data-" + e2.replace(tt, "-$&").toLowerCase(), "string" == typeof (n3 = t2.getAttribute(r2))) {
            try {
              n3 = function(t3) {
                return "true" === t3 || "false" !== t3 && ("null" === t3 ? null : t3 === +t3 + "" ? +t3 : K.test(t3) ? JSON.parse(t3) : t3);
              }(n3);
            } catch (t3) {
            }
            Q.set(t2, e2, n3);
          } else n3 = void 0;
          return n3;
        }
        M.extend({ hasData: function(t2) {
          return Q.hasData(t2) || $.hasData(t2);
        }, data: function(t2, e2, n3) {
          return Q.access(t2, e2, n3);
        }, removeData: function(t2, e2) {
          Q.remove(t2, e2);
        }, _data: function(t2, e2, n3) {
          return $.access(t2, e2, n3);
        }, _removeData: function(t2, e2) {
          $.remove(t2, e2);
        } }), M.fn.extend({ data: function(t2, e2) {
          var n3, r2, i2, o2 = this[0], a2 = o2 && o2.attributes;
          if (void 0 === t2) {
            if (this.length && (i2 = Q.get(o2), 1 === o2.nodeType && !$.get(o2, "hasDataAttrs"))) {
              for (n3 = a2.length; n3--; ) a2[n3] && 0 === (r2 = a2[n3].name).indexOf("data-") && (r2 = Y(r2.slice(5)), et(o2, r2, i2[r2]));
              $.set(o2, "hasDataAttrs", true);
            }
            return i2;
          }
          return "object" == typeof t2 ? this.each(function() {
            Q.set(this, t2);
          }) : V(this, function(e3) {
            var n4;
            if (o2 && void 0 === e3) return void 0 !== (n4 = Q.get(o2, t2)) || void 0 !== (n4 = et(o2, t2)) ? n4 : void 0;
            this.each(function() {
              Q.set(this, t2, e3);
            });
          }, null, e2, arguments.length > 1, null, true);
        }, removeData: function(t2) {
          return this.each(function() {
            Q.remove(this, t2);
          });
        } }), M.extend({ queue: function(t2, e2, n3) {
          var r2;
          if (t2) return e2 = (e2 || "fx") + "queue", r2 = $.get(t2, e2), n3 && (!r2 || Array.isArray(n3) ? r2 = $.access(t2, e2, M.makeArray(n3)) : r2.push(n3)), r2 || [];
        }, dequeue: function(t2, e2) {
          e2 = e2 || "fx";
          var n3 = M.queue(t2, e2), r2 = n3.length, i2 = n3.shift(), o2 = M._queueHooks(t2, e2);
          "inprogress" === i2 && (i2 = n3.shift(), r2--), i2 && ("fx" === e2 && n3.unshift("inprogress"), delete o2.stop, i2.call(t2, function() {
            M.dequeue(t2, e2);
          }, o2)), !r2 && o2 && o2.empty.fire();
        }, _queueHooks: function(t2, e2) {
          var n3 = e2 + "queueHooks";
          return $.get(t2, n3) || $.access(t2, n3, { empty: M.Callbacks("once memory").add(function() {
            $.remove(t2, [e2 + "queue", n3]);
          }) });
        } }), M.fn.extend({ queue: function(t2, e2) {
          var n3 = 2;
          return "string" != typeof t2 && (e2 = t2, t2 = "fx", n3--), arguments.length < n3 ? M.queue(this[0], t2) : void 0 === e2 ? this : this.each(function() {
            var n4 = M.queue(this, t2, e2);
            M._queueHooks(this, t2), "fx" === t2 && "inprogress" !== n4[0] && M.dequeue(this, t2);
          });
        }, dequeue: function(t2) {
          return this.each(function() {
            M.dequeue(this, t2);
          });
        }, clearQueue: function(t2) {
          return this.queue(t2 || "fx", []);
        }, promise: function(t2, e2) {
          var n3, r2 = 1, i2 = M.Deferred(), o2 = this, a2 = this.length, s2 = function() {
            --r2 || i2.resolveWith(o2, [o2]);
          };
          for ("string" != typeof t2 && (e2 = t2, t2 = void 0), t2 = t2 || "fx"; a2--; ) (n3 = $.get(o2[a2], t2 + "queueHooks")) && n3.empty && (r2++, n3.empty.add(s2));
          return s2(), i2.promise(e2);
        } });
        var nt = /[+-]?(?:\d*\.|)\d+(?:[eE][+-]?\d+|)/.source, rt = new RegExp("^(?:([+-])=|)(" + nt + ")([a-z%]*)$", "i"), it = ["Top", "Right", "Bottom", "Left"], ot = x.documentElement, at = function(t2) {
          return M.contains(t2.ownerDocument, t2);
        }, st = { composed: true };
        ot.getRootNode && (at = function(t2) {
          return M.contains(t2.ownerDocument, t2) || t2.getRootNode(st) === t2.ownerDocument;
        });
        var ct = function(t2, e2) {
          return "none" === (t2 = e2 || t2).style.display || "" === t2.style.display && at(t2) && "none" === M.css(t2, "display");
        };
        function ut(t2, e2, n3, r2) {
          var i2, o2, a2 = 20, s2 = r2 ? function() {
            return r2.cur();
          } : function() {
            return M.css(t2, e2, "");
          }, c2 = s2(), u2 = n3 && n3[3] || (M.cssNumber[e2] ? "" : "px"), l2 = t2.nodeType && (M.cssNumber[e2] || "px" !== u2 && +c2) && rt.exec(M.css(t2, e2));
          if (l2 && l2[3] !== u2) {
            for (c2 /= 2, u2 = u2 || l2[3], l2 = +c2 || 1; a2--; ) M.style(t2, e2, l2 + u2), (1 - o2) * (1 - (o2 = s2() / c2 || 0.5)) <= 0 && (a2 = 0), l2 /= o2;
            l2 *= 2, M.style(t2, e2, l2 + u2), n3 = n3 || [];
          }
          return n3 && (l2 = +l2 || +c2 || 0, i2 = n3[1] ? l2 + (n3[1] + 1) * n3[2] : +n3[2], r2 && (r2.unit = u2, r2.start = l2, r2.end = i2)), i2;
        }
        var lt = {};
        function ht(t2) {
          var e2, n3 = t2.ownerDocument, r2 = t2.nodeName, i2 = lt[r2];
          return i2 || (e2 = n3.body.appendChild(n3.createElement(r2)), i2 = M.css(e2, "display"), e2.parentNode.removeChild(e2), "none" === i2 && (i2 = "block"), lt[r2] = i2, i2);
        }
        function dt(t2, e2) {
          for (var n3, r2, i2 = [], o2 = 0, a2 = t2.length; o2 < a2; o2++) (r2 = t2[o2]).style && (n3 = r2.style.display, e2 ? ("none" === n3 && (i2[o2] = $.get(r2, "display") || null, i2[o2] || (r2.style.display = "")), "" === r2.style.display && ct(r2) && (i2[o2] = ht(r2))) : "none" !== n3 && (i2[o2] = "none", $.set(r2, "display", n3)));
          for (o2 = 0; o2 < a2; o2++) null != i2[o2] && (t2[o2].style.display = i2[o2]);
          return t2;
        }
        M.fn.extend({ show: function() {
          return dt(this, true);
        }, hide: function() {
          return dt(this);
        }, toggle: function(t2) {
          return "boolean" == typeof t2 ? t2 ? this.show() : this.hide() : this.each(function() {
            ct(this) ? M(this).show() : M(this).hide();
          });
        } });
        var pt, ft, mt = /^(?:checkbox|radio)$/i, gt = /<([a-z][^\/\0>\x20\t\r\n\f]*)/i, vt = /^$|^module$|\/(?:java|ecma)script/i;
        pt = x.createDocumentFragment().appendChild(x.createElement("div")), (ft = x.createElement("input")).setAttribute("type", "radio"), ft.setAttribute("checked", "checked"), ft.setAttribute("name", "t"), pt.appendChild(ft), g.checkClone = pt.cloneNode(true).cloneNode(true).lastChild.checked, pt.innerHTML = "<textarea>x</textarea>", g.noCloneChecked = !!pt.cloneNode(true).lastChild.defaultValue, pt.innerHTML = "<option></option>", g.option = !!pt.lastChild;
        var yt = { thead: [1, "<table>", "</table>"], col: [2, "<table><colgroup>", "</colgroup></table>"], tr: [2, "<table><tbody>", "</tbody></table>"], td: [3, "<table><tbody><tr>", "</tr></tbody></table>"], _default: [0, "", ""] };
        function xt(t2, e2) {
          var n3;
          return n3 = void 0 !== t2.getElementsByTagName ? t2.getElementsByTagName(e2 || "*") : void 0 !== t2.querySelectorAll ? t2.querySelectorAll(e2 || "*") : [], void 0 === e2 || e2 && L(t2, e2) ? M.merge([t2], n3) : n3;
        }
        function bt(t2, e2) {
          for (var n3 = 0, r2 = t2.length; n3 < r2; n3++) $.set(t2[n3], "globalEval", !e2 || $.get(e2[n3], "globalEval"));
        }
        yt.tbody = yt.tfoot = yt.colgroup = yt.caption = yt.thead, yt.th = yt.td, g.option || (yt.optgroup = yt.option = [1, "<select multiple='multiple'>", "</select>"]);
        var wt = /<|&#?\w+;/;
        function _t(t2, e2, n3, r2, i2) {
          for (var o2, a2, s2, c2, u2, l2, h2 = e2.createDocumentFragment(), d2 = [], p2 = 0, f2 = t2.length; p2 < f2; p2++) if ((o2 = t2[p2]) || 0 === o2) if ("object" === _(o2)) M.merge(d2, o2.nodeType ? [o2] : o2);
          else if (wt.test(o2)) {
            for (a2 = a2 || h2.appendChild(e2.createElement("div")), s2 = (gt.exec(o2) || ["", ""])[1].toLowerCase(), c2 = yt[s2] || yt._default, a2.innerHTML = c2[1] + M.htmlPrefilter(o2) + c2[2], l2 = c2[0]; l2--; ) a2 = a2.lastChild;
            M.merge(d2, a2.childNodes), (a2 = h2.firstChild).textContent = "";
          } else d2.push(e2.createTextNode(o2));
          for (h2.textContent = "", p2 = 0; o2 = d2[p2++]; ) if (r2 && M.inArray(o2, r2) > -1) i2 && i2.push(o2);
          else if (u2 = at(o2), a2 = xt(h2.appendChild(o2), "script"), u2 && bt(a2), n3) for (l2 = 0; o2 = a2[l2++]; ) vt.test(o2.type || "") && n3.push(o2);
          return h2;
        }
        var Mt = /^key/, St = /^(?:mouse|pointer|contextmenu|drag|drop)|click/, Tt = /^([^.]*)(?:\.(.+)|)/;
        function Et() {
          return true;
        }
        function At() {
          return false;
        }
        function Ct(t2, e2) {
          return t2 === function() {
            try {
              return x.activeElement;
            } catch (t3) {
            }
          }() == ("focus" === e2);
        }
        function Lt(t2, e2, n3, r2, i2, o2) {
          var a2, s2;
          if ("object" == typeof e2) {
            for (s2 in "string" != typeof n3 && (r2 = r2 || n3, n3 = void 0), e2) Lt(t2, s2, n3, r2, e2[s2], o2);
            return t2;
          }
          if (null == r2 && null == i2 ? (i2 = n3, r2 = n3 = void 0) : null == i2 && ("string" == typeof n3 ? (i2 = r2, r2 = void 0) : (i2 = r2, r2 = n3, n3 = void 0)), false === i2) i2 = At;
          else if (!i2) return t2;
          return 1 === o2 && (a2 = i2, (i2 = function(t3) {
            return M().off(t3), a2.apply(this, arguments);
          }).guid = a2.guid || (a2.guid = M.guid++)), t2.each(function() {
            M.event.add(this, e2, i2, r2, n3);
          });
        }
        function Pt(t2, e2, n3) {
          n3 ? ($.set(t2, e2, false), M.event.add(t2, e2, { namespace: false, handler: function(t3) {
            var r2, i2, o2 = $.get(this, e2);
            if (1 & t3.isTrigger && this[e2]) {
              if (o2.length) (M.event.special[e2] || {}).delegateType && t3.stopPropagation();
              else if (o2 = s.call(arguments), $.set(this, e2, o2), r2 = n3(this, e2), this[e2](), o2 !== (i2 = $.get(this, e2)) || r2 ? $.set(this, e2, false) : i2 = {}, o2 !== i2) return t3.stopImmediatePropagation(), t3.preventDefault(), i2.value;
            } else o2.length && ($.set(this, e2, { value: M.event.trigger(M.extend(o2[0], M.Event.prototype), o2.slice(1), this) }), t3.stopImmediatePropagation());
          } })) : void 0 === $.get(t2, e2) && M.event.add(t2, e2, Et);
        }
        M.event = { global: {}, add: function(t2, e2, n3, r2, i2) {
          var o2, a2, s2, c2, u2, l2, h2, d2, p2, f2, m2, g2 = $.get(t2);
          if (Z(t2)) for (n3.handler && (n3 = (o2 = n3).handler, i2 = o2.selector), i2 && M.find.matchesSelector(ot, i2), n3.guid || (n3.guid = M.guid++), (c2 = g2.events) || (c2 = g2.events = /* @__PURE__ */ Object.create(null)), (a2 = g2.handle) || (a2 = g2.handle = function(e3) {
            return void 0 !== M && M.event.triggered !== e3.type ? M.event.dispatch.apply(t2, arguments) : void 0;
          }), u2 = (e2 = (e2 || "").match(k) || [""]).length; u2--; ) p2 = m2 = (s2 = Tt.exec(e2[u2]) || [])[1], f2 = (s2[2] || "").split(".").sort(), p2 && (h2 = M.event.special[p2] || {}, p2 = (i2 ? h2.delegateType : h2.bindType) || p2, h2 = M.event.special[p2] || {}, l2 = M.extend({ type: p2, origType: m2, data: r2, handler: n3, guid: n3.guid, selector: i2, needsContext: i2 && M.expr.match.needsContext.test(i2), namespace: f2.join(".") }, o2), (d2 = c2[p2]) || ((d2 = c2[p2] = []).delegateCount = 0, h2.setup && false !== h2.setup.call(t2, r2, f2, a2) || t2.addEventListener && t2.addEventListener(p2, a2)), h2.add && (h2.add.call(t2, l2), l2.handler.guid || (l2.handler.guid = n3.guid)), i2 ? d2.splice(d2.delegateCount++, 0, l2) : d2.push(l2), M.event.global[p2] = true);
        }, remove: function(t2, e2, n3, r2, i2) {
          var o2, a2, s2, c2, u2, l2, h2, d2, p2, f2, m2, g2 = $.hasData(t2) && $.get(t2);
          if (g2 && (c2 = g2.events)) {
            for (u2 = (e2 = (e2 || "").match(k) || [""]).length; u2--; ) if (p2 = m2 = (s2 = Tt.exec(e2[u2]) || [])[1], f2 = (s2[2] || "").split(".").sort(), p2) {
              for (h2 = M.event.special[p2] || {}, d2 = c2[p2 = (r2 ? h2.delegateType : h2.bindType) || p2] || [], s2 = s2[2] && new RegExp("(^|\\.)" + f2.join("\\.(?:.*\\.|)") + "(\\.|$)"), a2 = o2 = d2.length; o2--; ) l2 = d2[o2], !i2 && m2 !== l2.origType || n3 && n3.guid !== l2.guid || s2 && !s2.test(l2.namespace) || r2 && r2 !== l2.selector && ("**" !== r2 || !l2.selector) || (d2.splice(o2, 1), l2.selector && d2.delegateCount--, h2.remove && h2.remove.call(t2, l2));
              a2 && !d2.length && (h2.teardown && false !== h2.teardown.call(t2, f2, g2.handle) || M.removeEvent(t2, p2, g2.handle), delete c2[p2]);
            } else for (p2 in c2) M.event.remove(t2, p2 + e2[u2], n3, r2, true);
            M.isEmptyObject(c2) && $.remove(t2, "handle events");
          }
        }, dispatch: function(t2) {
          var e2, n3, r2, i2, o2, a2, s2 = new Array(arguments.length), c2 = M.event.fix(t2), u2 = ($.get(this, "events") || /* @__PURE__ */ Object.create(null))[c2.type] || [], l2 = M.event.special[c2.type] || {};
          for (s2[0] = c2, e2 = 1; e2 < arguments.length; e2++) s2[e2] = arguments[e2];
          if (c2.delegateTarget = this, !l2.preDispatch || false !== l2.preDispatch.call(this, c2)) {
            for (a2 = M.event.handlers.call(this, c2, u2), e2 = 0; (i2 = a2[e2++]) && !c2.isPropagationStopped(); ) for (c2.currentTarget = i2.elem, n3 = 0; (o2 = i2.handlers[n3++]) && !c2.isImmediatePropagationStopped(); ) c2.rnamespace && false !== o2.namespace && !c2.rnamespace.test(o2.namespace) || (c2.handleObj = o2, c2.data = o2.data, void 0 !== (r2 = ((M.event.special[o2.origType] || {}).handle || o2.handler).apply(i2.elem, s2)) && false === (c2.result = r2) && (c2.preventDefault(), c2.stopPropagation()));
            return l2.postDispatch && l2.postDispatch.call(this, c2), c2.result;
          }
        }, handlers: function(t2, e2) {
          var n3, r2, i2, o2, a2, s2 = [], c2 = e2.delegateCount, u2 = t2.target;
          if (c2 && u2.nodeType && !("click" === t2.type && t2.button >= 1)) {
            for (; u2 !== this; u2 = u2.parentNode || this) if (1 === u2.nodeType && ("click" !== t2.type || true !== u2.disabled)) {
              for (o2 = [], a2 = {}, n3 = 0; n3 < c2; n3++) void 0 === a2[i2 = (r2 = e2[n3]).selector + " "] && (a2[i2] = r2.needsContext ? M(i2, this).index(u2) > -1 : M.find(i2, this, null, [u2]).length), a2[i2] && o2.push(r2);
              o2.length && s2.push({ elem: u2, handlers: o2 });
            }
          }
          return u2 = this, c2 < e2.length && s2.push({ elem: u2, handlers: e2.slice(c2) }), s2;
        }, addProp: function(t2, e2) {
          Object.defineProperty(M.Event.prototype, t2, { enumerable: true, configurable: true, get: v(e2) ? function() {
            if (this.originalEvent) return e2(this.originalEvent);
          } : function() {
            if (this.originalEvent) return this.originalEvent[t2];
          }, set: function(e3) {
            Object.defineProperty(this, t2, { enumerable: true, configurable: true, writable: true, value: e3 });
          } });
        }, fix: function(t2) {
          return t2[M.expando] ? t2 : new M.Event(t2);
        }, special: { load: { noBubble: true }, click: { setup: function(t2) {
          var e2 = this || t2;
          return mt.test(e2.type) && e2.click && L(e2, "input") && Pt(e2, "click", Et), false;
        }, trigger: function(t2) {
          var e2 = this || t2;
          return mt.test(e2.type) && e2.click && L(e2, "input") && Pt(e2, "click"), true;
        }, _default: function(t2) {
          var e2 = t2.target;
          return mt.test(e2.type) && e2.click && L(e2, "input") && $.get(e2, "click") || L(e2, "a");
        } }, beforeunload: { postDispatch: function(t2) {
          void 0 !== t2.result && t2.originalEvent && (t2.originalEvent.returnValue = t2.result);
        } } } }, M.removeEvent = function(t2, e2, n3) {
          t2.removeEventListener && t2.removeEventListener(e2, n3);
        }, M.Event = function(t2, e2) {
          if (!(this instanceof M.Event)) return new M.Event(t2, e2);
          t2 && t2.type ? (this.originalEvent = t2, this.type = t2.type, this.isDefaultPrevented = t2.defaultPrevented || void 0 === t2.defaultPrevented && false === t2.returnValue ? Et : At, this.target = t2.target && 3 === t2.target.nodeType ? t2.target.parentNode : t2.target, this.currentTarget = t2.currentTarget, this.relatedTarget = t2.relatedTarget) : this.type = t2, e2 && M.extend(this, e2), this.timeStamp = t2 && t2.timeStamp || Date.now(), this[M.expando] = true;
        }, M.Event.prototype = { constructor: M.Event, isDefaultPrevented: At, isPropagationStopped: At, isImmediatePropagationStopped: At, isSimulated: false, preventDefault: function() {
          var t2 = this.originalEvent;
          this.isDefaultPrevented = Et, t2 && !this.isSimulated && t2.preventDefault();
        }, stopPropagation: function() {
          var t2 = this.originalEvent;
          this.isPropagationStopped = Et, t2 && !this.isSimulated && t2.stopPropagation();
        }, stopImmediatePropagation: function() {
          var t2 = this.originalEvent;
          this.isImmediatePropagationStopped = Et, t2 && !this.isSimulated && t2.stopImmediatePropagation(), this.stopPropagation();
        } }, M.each({ altKey: true, bubbles: true, cancelable: true, changedTouches: true, ctrlKey: true, detail: true, eventPhase: true, metaKey: true, pageX: true, pageY: true, shiftKey: true, view: true, char: true, code: true, charCode: true, key: true, keyCode: true, button: true, buttons: true, clientX: true, clientY: true, offsetX: true, offsetY: true, pointerId: true, pointerType: true, screenX: true, screenY: true, targetTouches: true, toElement: true, touches: true, which: function(t2) {
          var e2 = t2.button;
          return null == t2.which && Mt.test(t2.type) ? null != t2.charCode ? t2.charCode : t2.keyCode : !t2.which && void 0 !== e2 && St.test(t2.type) ? 1 & e2 ? 1 : 2 & e2 ? 3 : 4 & e2 ? 2 : 0 : t2.which;
        } }, M.event.addProp), M.each({ focus: "focusin", blur: "focusout" }, function(t2, e2) {
          M.event.special[t2] = { setup: function() {
            return Pt(this, t2, Ct), false;
          }, trigger: function() {
            return Pt(this, t2), true;
          }, delegateType: e2 };
        }), M.each({ mouseenter: "mouseover", mouseleave: "mouseout", pointerenter: "pointerover", pointerleave: "pointerout" }, function(t2, e2) {
          M.event.special[t2] = { delegateType: e2, bindType: e2, handle: function(t3) {
            var n3, r2 = this, i2 = t3.relatedTarget, o2 = t3.handleObj;
            return i2 && (i2 === r2 || M.contains(r2, i2)) || (t3.type = o2.origType, n3 = o2.handler.apply(this, arguments), t3.type = e2), n3;
          } };
        }), M.fn.extend({ on: function(t2, e2, n3, r2) {
          return Lt(this, t2, e2, n3, r2);
        }, one: function(t2, e2, n3, r2) {
          return Lt(this, t2, e2, n3, r2, 1);
        }, off: function(t2, e2, n3) {
          var r2, i2;
          if (t2 && t2.preventDefault && t2.handleObj) return r2 = t2.handleObj, M(t2.delegateTarget).off(r2.namespace ? r2.origType + "." + r2.namespace : r2.origType, r2.selector, r2.handler), this;
          if ("object" == typeof t2) {
            for (i2 in t2) this.off(i2, e2, t2[i2]);
            return this;
          }
          return false !== e2 && "function" != typeof e2 || (n3 = e2, e2 = void 0), false === n3 && (n3 = At), this.each(function() {
            M.event.remove(this, t2, n3, e2);
          });
        } });
        var Rt = /<script|<style|<link/i, Ot = /checked\s*(?:[^=]|=\s*.checked.)/i, Dt = /^\s*<!(?:\[CDATA\[|--)|(?:\]\]|--)>\s*$/g;
        function It(t2, e2) {
          return L(t2, "table") && L(11 !== e2.nodeType ? e2 : e2.firstChild, "tr") && M(t2).children("tbody")[0] || t2;
        }
        function Nt(t2) {
          return t2.type = (null !== t2.getAttribute("type")) + "/" + t2.type, t2;
        }
        function zt(t2) {
          return "true/" === (t2.type || "").slice(0, 5) ? t2.type = t2.type.slice(5) : t2.removeAttribute("type"), t2;
        }
        function kt(t2, e2) {
          var n3, r2, i2, o2, a2, s2;
          if (1 === e2.nodeType) {
            if ($.hasData(t2) && (s2 = $.get(t2).events)) for (i2 in $.remove(e2, "handle events"), s2) for (n3 = 0, r2 = s2[i2].length; n3 < r2; n3++) M.event.add(e2, i2, s2[i2][n3]);
            Q.hasData(t2) && (o2 = Q.access(t2), a2 = M.extend({}, o2), Q.set(e2, a2));
          }
        }
        function Ft(t2, e2) {
          var n3 = e2.nodeName.toLowerCase();
          "input" === n3 && mt.test(t2.type) ? e2.checked = t2.checked : "input" !== n3 && "textarea" !== n3 || (e2.defaultValue = t2.defaultValue);
        }
        function Bt(t2, e2, n3, r2) {
          e2 = c(e2);
          var i2, o2, a2, s2, u2, l2, h2 = 0, d2 = t2.length, p2 = d2 - 1, f2 = e2[0], m2 = v(f2);
          if (m2 || d2 > 1 && "string" == typeof f2 && !g.checkClone && Ot.test(f2)) return t2.each(function(i3) {
            var o3 = t2.eq(i3);
            m2 && (e2[0] = f2.call(this, i3, o3.html())), Bt(o3, e2, n3, r2);
          });
          if (d2 && (o2 = (i2 = _t(e2, t2[0].ownerDocument, false, t2, r2)).firstChild, 1 === i2.childNodes.length && (i2 = o2), o2 || r2)) {
            for (s2 = (a2 = M.map(xt(i2, "script"), Nt)).length; h2 < d2; h2++) u2 = i2, h2 !== p2 && (u2 = M.clone(u2, true, true), s2 && M.merge(a2, xt(u2, "script"))), n3.call(t2[h2], u2, h2);
            if (s2) for (l2 = a2[a2.length - 1].ownerDocument, M.map(a2, zt), h2 = 0; h2 < s2; h2++) u2 = a2[h2], vt.test(u2.type || "") && !$.access(u2, "globalEval") && M.contains(l2, u2) && (u2.src && "module" !== (u2.type || "").toLowerCase() ? M._evalUrl && !u2.noModule && M._evalUrl(u2.src, { nonce: u2.nonce || u2.getAttribute("nonce") }, l2) : w(u2.textContent.replace(Dt, ""), u2, l2));
          }
          return t2;
        }
        function Ht(t2, e2, n3) {
          for (var r2, i2 = e2 ? M.filter(e2, t2) : t2, o2 = 0; null != (r2 = i2[o2]); o2++) n3 || 1 !== r2.nodeType || M.cleanData(xt(r2)), r2.parentNode && (n3 && at(r2) && bt(xt(r2, "script")), r2.parentNode.removeChild(r2));
          return t2;
        }
        M.extend({ htmlPrefilter: function(t2) {
          return t2;
        }, clone: function(t2, e2, n3) {
          var r2, i2, o2, a2, s2 = t2.cloneNode(true), c2 = at(t2);
          if (!(g.noCloneChecked || 1 !== t2.nodeType && 11 !== t2.nodeType || M.isXMLDoc(t2))) for (a2 = xt(s2), r2 = 0, i2 = (o2 = xt(t2)).length; r2 < i2; r2++) Ft(o2[r2], a2[r2]);
          if (e2) if (n3) for (o2 = o2 || xt(t2), a2 = a2 || xt(s2), r2 = 0, i2 = o2.length; r2 < i2; r2++) kt(o2[r2], a2[r2]);
          else kt(t2, s2);
          return (a2 = xt(s2, "script")).length > 0 && bt(a2, !c2 && xt(t2, "script")), s2;
        }, cleanData: function(t2) {
          for (var e2, n3, r2, i2 = M.event.special, o2 = 0; void 0 !== (n3 = t2[o2]); o2++) if (Z(n3)) {
            if (e2 = n3[$.expando]) {
              if (e2.events) for (r2 in e2.events) i2[r2] ? M.event.remove(n3, r2) : M.removeEvent(n3, r2, e2.handle);
              n3[$.expando] = void 0;
            }
            n3[Q.expando] && (n3[Q.expando] = void 0);
          }
        } }), M.fn.extend({ detach: function(t2) {
          return Ht(this, t2, true);
        }, remove: function(t2) {
          return Ht(this, t2);
        }, text: function(t2) {
          return V(this, function(t3) {
            return void 0 === t3 ? M.text(this) : this.empty().each(function() {
              1 !== this.nodeType && 11 !== this.nodeType && 9 !== this.nodeType || (this.textContent = t3);
            });
          }, null, t2, arguments.length);
        }, append: function() {
          return Bt(this, arguments, function(t2) {
            1 !== this.nodeType && 11 !== this.nodeType && 9 !== this.nodeType || It(this, t2).appendChild(t2);
          });
        }, prepend: function() {
          return Bt(this, arguments, function(t2) {
            if (1 === this.nodeType || 11 === this.nodeType || 9 === this.nodeType) {
              var e2 = It(this, t2);
              e2.insertBefore(t2, e2.firstChild);
            }
          });
        }, before: function() {
          return Bt(this, arguments, function(t2) {
            this.parentNode && this.parentNode.insertBefore(t2, this);
          });
        }, after: function() {
          return Bt(this, arguments, function(t2) {
            this.parentNode && this.parentNode.insertBefore(t2, this.nextSibling);
          });
        }, empty: function() {
          for (var t2, e2 = 0; null != (t2 = this[e2]); e2++) 1 === t2.nodeType && (M.cleanData(xt(t2, false)), t2.textContent = "");
          return this;
        }, clone: function(t2, e2) {
          return t2 = null != t2 && t2, e2 = null == e2 ? t2 : e2, this.map(function() {
            return M.clone(this, t2, e2);
          });
        }, html: function(t2) {
          return V(this, function(t3) {
            var e2 = this[0] || {}, n3 = 0, r2 = this.length;
            if (void 0 === t3 && 1 === e2.nodeType) return e2.innerHTML;
            if ("string" == typeof t3 && !Rt.test(t3) && !yt[(gt.exec(t3) || ["", ""])[1].toLowerCase()]) {
              t3 = M.htmlPrefilter(t3);
              try {
                for (; n3 < r2; n3++) 1 === (e2 = this[n3] || {}).nodeType && (M.cleanData(xt(e2, false)), e2.innerHTML = t3);
                e2 = 0;
              } catch (t4) {
              }
            }
            e2 && this.empty().append(t3);
          }, null, t2, arguments.length);
        }, replaceWith: function() {
          var t2 = [];
          return Bt(this, arguments, function(e2) {
            var n3 = this.parentNode;
            M.inArray(this, t2) < 0 && (M.cleanData(xt(this)), n3 && n3.replaceChild(e2, this));
          }, t2);
        } }), M.each({ appendTo: "append", prependTo: "prepend", insertBefore: "before", insertAfter: "after", replaceAll: "replaceWith" }, function(t2, e2) {
          M.fn[t2] = function(t3) {
            for (var n3, r2 = [], i2 = M(t3), o2 = i2.length - 1, a2 = 0; a2 <= o2; a2++) n3 = a2 === o2 ? this : this.clone(true), M(i2[a2])[e2](n3), u.apply(r2, n3.get());
            return this.pushStack(r2);
          };
        });
        var Gt = new RegExp("^(" + nt + ")(?!px)[a-z%]+$", "i"), Ut = function(t2) {
          var e2 = t2.ownerDocument.defaultView;
          return e2 && e2.opener || (e2 = n2), e2.getComputedStyle(t2);
        }, jt = function(t2, e2, n3) {
          var r2, i2, o2 = {};
          for (i2 in e2) o2[i2] = t2.style[i2], t2.style[i2] = e2[i2];
          for (i2 in r2 = n3.call(t2), e2) t2.style[i2] = o2[i2];
          return r2;
        }, Vt = new RegExp(it.join("|"), "i");
        function Wt(t2, e2, n3) {
          var r2, i2, o2, a2, s2 = t2.style;
          return (n3 = n3 || Ut(t2)) && ("" !== (a2 = n3.getPropertyValue(e2) || n3[e2]) || at(t2) || (a2 = M.style(t2, e2)), !g.pixelBoxStyles() && Gt.test(a2) && Vt.test(e2) && (r2 = s2.width, i2 = s2.minWidth, o2 = s2.maxWidth, s2.minWidth = s2.maxWidth = s2.width = a2, a2 = n3.width, s2.width = r2, s2.minWidth = i2, s2.maxWidth = o2)), void 0 !== a2 ? a2 + "" : a2;
        }
        function qt(t2, e2) {
          return { get: function() {
            if (!t2()) return (this.get = e2).apply(this, arguments);
            delete this.get;
          } };
        }
        !function() {
          function t2() {
            if (l2) {
              u2.style.cssText = "position:absolute;left:-11111px;width:60px;margin-top:1px;padding:0;border:0", l2.style.cssText = "position:relative;display:block;box-sizing:border-box;overflow:scroll;margin:auto;border:1px;padding:1px;width:60%;top:1%", ot.appendChild(u2).appendChild(l2);
              var t3 = n2.getComputedStyle(l2);
              r2 = "1%" !== t3.top, c2 = 12 === e2(t3.marginLeft), l2.style.right = "60%", a2 = 36 === e2(t3.right), i2 = 36 === e2(t3.width), l2.style.position = "absolute", o2 = 12 === e2(l2.offsetWidth / 3), ot.removeChild(u2), l2 = null;
            }
          }
          function e2(t3) {
            return Math.round(parseFloat(t3));
          }
          var r2, i2, o2, a2, s2, c2, u2 = x.createElement("div"), l2 = x.createElement("div");
          l2.style && (l2.style.backgroundClip = "content-box", l2.cloneNode(true).style.backgroundClip = "", g.clearCloneStyle = "content-box" === l2.style.backgroundClip, M.extend(g, { boxSizingReliable: function() {
            return t2(), i2;
          }, pixelBoxStyles: function() {
            return t2(), a2;
          }, pixelPosition: function() {
            return t2(), r2;
          }, reliableMarginLeft: function() {
            return t2(), c2;
          }, scrollboxSize: function() {
            return t2(), o2;
          }, reliableTrDimensions: function() {
            var t3, e3, r3, i3;
            return null == s2 && (t3 = x.createElement("table"), e3 = x.createElement("tr"), r3 = x.createElement("div"), t3.style.cssText = "position:absolute;left:-11111px", e3.style.height = "1px", r3.style.height = "9px", ot.appendChild(t3).appendChild(e3).appendChild(r3), i3 = n2.getComputedStyle(e3), s2 = parseInt(i3.height) > 3, ot.removeChild(t3)), s2;
          } }));
        }();
        var Xt = ["Webkit", "Moz", "ms"], Yt = x.createElement("div").style, Zt = {};
        function Jt(t2) {
          var e2 = M.cssProps[t2] || Zt[t2];
          return e2 || (t2 in Yt ? t2 : Zt[t2] = function(t3) {
            for (var e3 = t3[0].toUpperCase() + t3.slice(1), n3 = Xt.length; n3--; ) if ((t3 = Xt[n3] + e3) in Yt) return t3;
          }(t2) || t2);
        }
        var $t = /^(none|table(?!-c[ea]).+)/, Qt = /^--/, Kt = { position: "absolute", visibility: "hidden", display: "block" }, te = { letterSpacing: "0", fontWeight: "400" };
        function ee(t2, e2, n3) {
          var r2 = rt.exec(e2);
          return r2 ? Math.max(0, r2[2] - (n3 || 0)) + (r2[3] || "px") : e2;
        }
        function ne(t2, e2, n3, r2, i2, o2) {
          var a2 = "width" === e2 ? 1 : 0, s2 = 0, c2 = 0;
          if (n3 === (r2 ? "border" : "content")) return 0;
          for (; a2 < 4; a2 += 2) "margin" === n3 && (c2 += M.css(t2, n3 + it[a2], true, i2)), r2 ? ("content" === n3 && (c2 -= M.css(t2, "padding" + it[a2], true, i2)), "margin" !== n3 && (c2 -= M.css(t2, "border" + it[a2] + "Width", true, i2))) : (c2 += M.css(t2, "padding" + it[a2], true, i2), "padding" !== n3 ? c2 += M.css(t2, "border" + it[a2] + "Width", true, i2) : s2 += M.css(t2, "border" + it[a2] + "Width", true, i2));
          return !r2 && o2 >= 0 && (c2 += Math.max(0, Math.ceil(t2["offset" + e2[0].toUpperCase() + e2.slice(1)] - o2 - c2 - s2 - 0.5)) || 0), c2;
        }
        function re(t2, e2, n3) {
          var r2 = Ut(t2), i2 = (!g.boxSizingReliable() || n3) && "border-box" === M.css(t2, "boxSizing", false, r2), o2 = i2, a2 = Wt(t2, e2, r2), s2 = "offset" + e2[0].toUpperCase() + e2.slice(1);
          if (Gt.test(a2)) {
            if (!n3) return a2;
            a2 = "auto";
          }
          return (!g.boxSizingReliable() && i2 || !g.reliableTrDimensions() && L(t2, "tr") || "auto" === a2 || !parseFloat(a2) && "inline" === M.css(t2, "display", false, r2)) && t2.getClientRects().length && (i2 = "border-box" === M.css(t2, "boxSizing", false, r2), (o2 = s2 in t2) && (a2 = t2[s2])), (a2 = parseFloat(a2) || 0) + ne(t2, e2, n3 || (i2 ? "border" : "content"), o2, r2, a2) + "px";
        }
        function ie(t2, e2, n3, r2, i2) {
          return new ie.prototype.init(t2, e2, n3, r2, i2);
        }
        M.extend({ cssHooks: { opacity: { get: function(t2, e2) {
          if (e2) {
            var n3 = Wt(t2, "opacity");
            return "" === n3 ? "1" : n3;
          }
        } } }, cssNumber: { animationIterationCount: true, columnCount: true, fillOpacity: true, flexGrow: true, flexShrink: true, fontWeight: true, gridArea: true, gridColumn: true, gridColumnEnd: true, gridColumnStart: true, gridRow: true, gridRowEnd: true, gridRowStart: true, lineHeight: true, opacity: true, order: true, orphans: true, widows: true, zIndex: true, zoom: true }, cssProps: {}, style: function(t2, e2, n3, r2) {
          if (t2 && 3 !== t2.nodeType && 8 !== t2.nodeType && t2.style) {
            var i2, o2, a2, s2 = Y(e2), c2 = Qt.test(e2), u2 = t2.style;
            if (c2 || (e2 = Jt(s2)), a2 = M.cssHooks[e2] || M.cssHooks[s2], void 0 === n3) return a2 && "get" in a2 && void 0 !== (i2 = a2.get(t2, false, r2)) ? i2 : u2[e2];
            "string" === (o2 = typeof n3) && (i2 = rt.exec(n3)) && i2[1] && (n3 = ut(t2, e2, i2), o2 = "number"), null != n3 && n3 == n3 && ("number" !== o2 || c2 || (n3 += i2 && i2[3] || (M.cssNumber[s2] ? "" : "px")), g.clearCloneStyle || "" !== n3 || 0 !== e2.indexOf("background") || (u2[e2] = "inherit"), a2 && "set" in a2 && void 0 === (n3 = a2.set(t2, n3, r2)) || (c2 ? u2.setProperty(e2, n3) : u2[e2] = n3));
          }
        }, css: function(t2, e2, n3, r2) {
          var i2, o2, a2, s2 = Y(e2);
          return Qt.test(e2) || (e2 = Jt(s2)), (a2 = M.cssHooks[e2] || M.cssHooks[s2]) && "get" in a2 && (i2 = a2.get(t2, true, n3)), void 0 === i2 && (i2 = Wt(t2, e2, r2)), "normal" === i2 && e2 in te && (i2 = te[e2]), "" === n3 || n3 ? (o2 = parseFloat(i2), true === n3 || isFinite(o2) ? o2 || 0 : i2) : i2;
        } }), M.each(["height", "width"], function(t2, e2) {
          M.cssHooks[e2] = { get: function(t3, n3, r2) {
            if (n3) return !$t.test(M.css(t3, "display")) || t3.getClientRects().length && t3.getBoundingClientRect().width ? re(t3, e2, r2) : jt(t3, Kt, function() {
              return re(t3, e2, r2);
            });
          }, set: function(t3, n3, r2) {
            var i2, o2 = Ut(t3), a2 = !g.scrollboxSize() && "absolute" === o2.position, s2 = (a2 || r2) && "border-box" === M.css(t3, "boxSizing", false, o2), c2 = r2 ? ne(t3, e2, r2, s2, o2) : 0;
            return s2 && a2 && (c2 -= Math.ceil(t3["offset" + e2[0].toUpperCase() + e2.slice(1)] - parseFloat(o2[e2]) - ne(t3, e2, "border", false, o2) - 0.5)), c2 && (i2 = rt.exec(n3)) && "px" !== (i2[3] || "px") && (t3.style[e2] = n3, n3 = M.css(t3, e2)), ee(0, n3, c2);
          } };
        }), M.cssHooks.marginLeft = qt(g.reliableMarginLeft, function(t2, e2) {
          if (e2) return (parseFloat(Wt(t2, "marginLeft")) || t2.getBoundingClientRect().left - jt(t2, { marginLeft: 0 }, function() {
            return t2.getBoundingClientRect().left;
          })) + "px";
        }), M.each({ margin: "", padding: "", border: "Width" }, function(t2, e2) {
          M.cssHooks[t2 + e2] = { expand: function(n3) {
            for (var r2 = 0, i2 = {}, o2 = "string" == typeof n3 ? n3.split(" ") : [n3]; r2 < 4; r2++) i2[t2 + it[r2] + e2] = o2[r2] || o2[r2 - 2] || o2[0];
            return i2;
          } }, "margin" !== t2 && (M.cssHooks[t2 + e2].set = ee);
        }), M.fn.extend({ css: function(t2, e2) {
          return V(this, function(t3, e3, n3) {
            var r2, i2, o2 = {}, a2 = 0;
            if (Array.isArray(e3)) {
              for (r2 = Ut(t3), i2 = e3.length; a2 < i2; a2++) o2[e3[a2]] = M.css(t3, e3[a2], false, r2);
              return o2;
            }
            return void 0 !== n3 ? M.style(t3, e3, n3) : M.css(t3, e3);
          }, t2, e2, arguments.length > 1);
        } }), M.Tween = ie, ie.prototype = { constructor: ie, init: function(t2, e2, n3, r2, i2, o2) {
          this.elem = t2, this.prop = n3, this.easing = i2 || M.easing._default, this.options = e2, this.start = this.now = this.cur(), this.end = r2, this.unit = o2 || (M.cssNumber[n3] ? "" : "px");
        }, cur: function() {
          var t2 = ie.propHooks[this.prop];
          return t2 && t2.get ? t2.get(this) : ie.propHooks._default.get(this);
        }, run: function(t2) {
          var e2, n3 = ie.propHooks[this.prop];
          return this.options.duration ? this.pos = e2 = M.easing[this.easing](t2, this.options.duration * t2, 0, 1, this.options.duration) : this.pos = e2 = t2, this.now = (this.end - this.start) * e2 + this.start, this.options.step && this.options.step.call(this.elem, this.now, this), n3 && n3.set ? n3.set(this) : ie.propHooks._default.set(this), this;
        } }, ie.prototype.init.prototype = ie.prototype, ie.propHooks = { _default: { get: function(t2) {
          var e2;
          return 1 !== t2.elem.nodeType || null != t2.elem[t2.prop] && null == t2.elem.style[t2.prop] ? t2.elem[t2.prop] : (e2 = M.css(t2.elem, t2.prop, "")) && "auto" !== e2 ? e2 : 0;
        }, set: function(t2) {
          M.fx.step[t2.prop] ? M.fx.step[t2.prop](t2) : 1 !== t2.elem.nodeType || !M.cssHooks[t2.prop] && null == t2.elem.style[Jt(t2.prop)] ? t2.elem[t2.prop] = t2.now : M.style(t2.elem, t2.prop, t2.now + t2.unit);
        } } }, ie.propHooks.scrollTop = ie.propHooks.scrollLeft = { set: function(t2) {
          t2.elem.nodeType && t2.elem.parentNode && (t2.elem[t2.prop] = t2.now);
        } }, M.easing = { linear: function(t2) {
          return t2;
        }, swing: function(t2) {
          return 0.5 - Math.cos(t2 * Math.PI) / 2;
        }, _default: "swing" }, M.fx = ie.prototype.init, M.fx.step = {};
        var oe, ae, se = /^(?:toggle|show|hide)$/, ce = /queueHooks$/;
        function ue() {
          ae && (false === x.hidden && n2.requestAnimationFrame ? n2.requestAnimationFrame(ue) : n2.setTimeout(ue, M.fx.interval), M.fx.tick());
        }
        function le() {
          return n2.setTimeout(function() {
            oe = void 0;
          }), oe = Date.now();
        }
        function he(t2, e2) {
          var n3, r2 = 0, i2 = { height: t2 };
          for (e2 = e2 ? 1 : 0; r2 < 4; r2 += 2 - e2) i2["margin" + (n3 = it[r2])] = i2["padding" + n3] = t2;
          return e2 && (i2.opacity = i2.width = t2), i2;
        }
        function de(t2, e2, n3) {
          for (var r2, i2 = (pe.tweeners[e2] || []).concat(pe.tweeners["*"]), o2 = 0, a2 = i2.length; o2 < a2; o2++) if (r2 = i2[o2].call(n3, e2, t2)) return r2;
        }
        function pe(t2, e2, n3) {
          var r2, i2, o2 = 0, a2 = pe.prefilters.length, s2 = M.Deferred().always(function() {
            delete c2.elem;
          }), c2 = function() {
            if (i2) return false;
            for (var e3 = oe || le(), n4 = Math.max(0, u2.startTime + u2.duration - e3), r3 = 1 - (n4 / u2.duration || 0), o3 = 0, a3 = u2.tweens.length; o3 < a3; o3++) u2.tweens[o3].run(r3);
            return s2.notifyWith(t2, [u2, r3, n4]), r3 < 1 && a3 ? n4 : (a3 || s2.notifyWith(t2, [u2, 1, 0]), s2.resolveWith(t2, [u2]), false);
          }, u2 = s2.promise({ elem: t2, props: M.extend({}, e2), opts: M.extend(true, { specialEasing: {}, easing: M.easing._default }, n3), originalProperties: e2, originalOptions: n3, startTime: oe || le(), duration: n3.duration, tweens: [], createTween: function(e3, n4) {
            var r3 = M.Tween(t2, u2.opts, e3, n4, u2.opts.specialEasing[e3] || u2.opts.easing);
            return u2.tweens.push(r3), r3;
          }, stop: function(e3) {
            var n4 = 0, r3 = e3 ? u2.tweens.length : 0;
            if (i2) return this;
            for (i2 = true; n4 < r3; n4++) u2.tweens[n4].run(1);
            return e3 ? (s2.notifyWith(t2, [u2, 1, 0]), s2.resolveWith(t2, [u2, e3])) : s2.rejectWith(t2, [u2, e3]), this;
          } }), l2 = u2.props;
          for (!function(t3, e3) {
            var n4, r3, i3, o3, a3;
            for (n4 in t3) if (i3 = e3[r3 = Y(n4)], o3 = t3[n4], Array.isArray(o3) && (i3 = o3[1], o3 = t3[n4] = o3[0]), n4 !== r3 && (t3[r3] = o3, delete t3[n4]), (a3 = M.cssHooks[r3]) && "expand" in a3) for (n4 in o3 = a3.expand(o3), delete t3[r3], o3) n4 in t3 || (t3[n4] = o3[n4], e3[n4] = i3);
            else e3[r3] = i3;
          }(l2, u2.opts.specialEasing); o2 < a2; o2++) if (r2 = pe.prefilters[o2].call(u2, t2, l2, u2.opts)) return v(r2.stop) && (M._queueHooks(u2.elem, u2.opts.queue).stop = r2.stop.bind(r2)), r2;
          return M.map(l2, de, u2), v(u2.opts.start) && u2.opts.start.call(t2, u2), u2.progress(u2.opts.progress).done(u2.opts.done, u2.opts.complete).fail(u2.opts.fail).always(u2.opts.always), M.fx.timer(M.extend(c2, { elem: t2, anim: u2, queue: u2.opts.queue })), u2;
        }
        M.Animation = M.extend(pe, { tweeners: { "*": [function(t2, e2) {
          var n3 = this.createTween(t2, e2);
          return ut(n3.elem, t2, rt.exec(e2), n3), n3;
        }] }, tweener: function(t2, e2) {
          v(t2) ? (e2 = t2, t2 = ["*"]) : t2 = t2.match(k);
          for (var n3, r2 = 0, i2 = t2.length; r2 < i2; r2++) n3 = t2[r2], pe.tweeners[n3] = pe.tweeners[n3] || [], pe.tweeners[n3].unshift(e2);
        }, prefilters: [function(t2, e2, n3) {
          var r2, i2, o2, a2, s2, c2, u2, l2, h2 = "width" in e2 || "height" in e2, d2 = this, p2 = {}, f2 = t2.style, m2 = t2.nodeType && ct(t2), g2 = $.get(t2, "fxshow");
          for (r2 in n3.queue || (null == (a2 = M._queueHooks(t2, "fx")).unqueued && (a2.unqueued = 0, s2 = a2.empty.fire, a2.empty.fire = function() {
            a2.unqueued || s2();
          }), a2.unqueued++, d2.always(function() {
            d2.always(function() {
              a2.unqueued--, M.queue(t2, "fx").length || a2.empty.fire();
            });
          })), e2) if (i2 = e2[r2], se.test(i2)) {
            if (delete e2[r2], o2 = o2 || "toggle" === i2, i2 === (m2 ? "hide" : "show")) {
              if ("show" !== i2 || !g2 || void 0 === g2[r2]) continue;
              m2 = true;
            }
            p2[r2] = g2 && g2[r2] || M.style(t2, r2);
          }
          if ((c2 = !M.isEmptyObject(e2)) || !M.isEmptyObject(p2)) for (r2 in h2 && 1 === t2.nodeType && (n3.overflow = [f2.overflow, f2.overflowX, f2.overflowY], null == (u2 = g2 && g2.display) && (u2 = $.get(t2, "display")), "none" === (l2 = M.css(t2, "display")) && (u2 ? l2 = u2 : (dt([t2], true), u2 = t2.style.display || u2, l2 = M.css(t2, "display"), dt([t2]))), ("inline" === l2 || "inline-block" === l2 && null != u2) && "none" === M.css(t2, "float") && (c2 || (d2.done(function() {
            f2.display = u2;
          }), null == u2 && (l2 = f2.display, u2 = "none" === l2 ? "" : l2)), f2.display = "inline-block")), n3.overflow && (f2.overflow = "hidden", d2.always(function() {
            f2.overflow = n3.overflow[0], f2.overflowX = n3.overflow[1], f2.overflowY = n3.overflow[2];
          })), c2 = false, p2) c2 || (g2 ? "hidden" in g2 && (m2 = g2.hidden) : g2 = $.access(t2, "fxshow", { display: u2 }), o2 && (g2.hidden = !m2), m2 && dt([t2], true), d2.done(function() {
            for (r2 in m2 || dt([t2]), $.remove(t2, "fxshow"), p2) M.style(t2, r2, p2[r2]);
          })), c2 = de(m2 ? g2[r2] : 0, r2, d2), r2 in g2 || (g2[r2] = c2.start, m2 && (c2.end = c2.start, c2.start = 0));
        }], prefilter: function(t2, e2) {
          e2 ? pe.prefilters.unshift(t2) : pe.prefilters.push(t2);
        } }), M.speed = function(t2, e2, n3) {
          var r2 = t2 && "object" == typeof t2 ? M.extend({}, t2) : { complete: n3 || !n3 && e2 || v(t2) && t2, duration: t2, easing: n3 && e2 || e2 && !v(e2) && e2 };
          return M.fx.off ? r2.duration = 0 : "number" != typeof r2.duration && (r2.duration in M.fx.speeds ? r2.duration = M.fx.speeds[r2.duration] : r2.duration = M.fx.speeds._default), null != r2.queue && true !== r2.queue || (r2.queue = "fx"), r2.old = r2.complete, r2.complete = function() {
            v(r2.old) && r2.old.call(this), r2.queue && M.dequeue(this, r2.queue);
          }, r2;
        }, M.fn.extend({ fadeTo: function(t2, e2, n3, r2) {
          return this.filter(ct).css("opacity", 0).show().end().animate({ opacity: e2 }, t2, n3, r2);
        }, animate: function(t2, e2, n3, r2) {
          var i2 = M.isEmptyObject(t2), o2 = M.speed(e2, n3, r2), a2 = function() {
            var e3 = pe(this, M.extend({}, t2), o2);
            (i2 || $.get(this, "finish")) && e3.stop(true);
          };
          return a2.finish = a2, i2 || false === o2.queue ? this.each(a2) : this.queue(o2.queue, a2);
        }, stop: function(t2, e2, n3) {
          var r2 = function(t3) {
            var e3 = t3.stop;
            delete t3.stop, e3(n3);
          };
          return "string" != typeof t2 && (n3 = e2, e2 = t2, t2 = void 0), e2 && this.queue(t2 || "fx", []), this.each(function() {
            var e3 = true, i2 = null != t2 && t2 + "queueHooks", o2 = M.timers, a2 = $.get(this);
            if (i2) a2[i2] && a2[i2].stop && r2(a2[i2]);
            else for (i2 in a2) a2[i2] && a2[i2].stop && ce.test(i2) && r2(a2[i2]);
            for (i2 = o2.length; i2--; ) o2[i2].elem !== this || null != t2 && o2[i2].queue !== t2 || (o2[i2].anim.stop(n3), e3 = false, o2.splice(i2, 1));
            !e3 && n3 || M.dequeue(this, t2);
          });
        }, finish: function(t2) {
          return false !== t2 && (t2 = t2 || "fx"), this.each(function() {
            var e2, n3 = $.get(this), r2 = n3[t2 + "queue"], i2 = n3[t2 + "queueHooks"], o2 = M.timers, a2 = r2 ? r2.length : 0;
            for (n3.finish = true, M.queue(this, t2, []), i2 && i2.stop && i2.stop.call(this, true), e2 = o2.length; e2--; ) o2[e2].elem === this && o2[e2].queue === t2 && (o2[e2].anim.stop(true), o2.splice(e2, 1));
            for (e2 = 0; e2 < a2; e2++) r2[e2] && r2[e2].finish && r2[e2].finish.call(this);
            delete n3.finish;
          });
        } }), M.each(["toggle", "show", "hide"], function(t2, e2) {
          var n3 = M.fn[e2];
          M.fn[e2] = function(t3, r2, i2) {
            return null == t3 || "boolean" == typeof t3 ? n3.apply(this, arguments) : this.animate(he(e2, true), t3, r2, i2);
          };
        }), M.each({ slideDown: he("show"), slideUp: he("hide"), slideToggle: he("toggle"), fadeIn: { opacity: "show" }, fadeOut: { opacity: "hide" }, fadeToggle: { opacity: "toggle" } }, function(t2, e2) {
          M.fn[t2] = function(t3, n3, r2) {
            return this.animate(e2, t3, n3, r2);
          };
        }), M.timers = [], M.fx.tick = function() {
          var t2, e2 = 0, n3 = M.timers;
          for (oe = Date.now(); e2 < n3.length; e2++) (t2 = n3[e2])() || n3[e2] !== t2 || n3.splice(e2--, 1);
          n3.length || M.fx.stop(), oe = void 0;
        }, M.fx.timer = function(t2) {
          M.timers.push(t2), M.fx.start();
        }, M.fx.interval = 13, M.fx.start = function() {
          ae || (ae = true, ue());
        }, M.fx.stop = function() {
          ae = null;
        }, M.fx.speeds = { slow: 600, fast: 200, _default: 400 }, M.fn.delay = function(t2, e2) {
          return t2 = M.fx && M.fx.speeds[t2] || t2, e2 = e2 || "fx", this.queue(e2, function(e3, r2) {
            var i2 = n2.setTimeout(e3, t2);
            r2.stop = function() {
              n2.clearTimeout(i2);
            };
          });
        }, function() {
          var t2 = x.createElement("input"), e2 = x.createElement("select").appendChild(x.createElement("option"));
          t2.type = "checkbox", g.checkOn = "" !== t2.value, g.optSelected = e2.selected, (t2 = x.createElement("input")).value = "t", t2.type = "radio", g.radioValue = "t" === t2.value;
        }();
        var fe, me = M.expr.attrHandle;
        M.fn.extend({ attr: function(t2, e2) {
          return V(this, M.attr, t2, e2, arguments.length > 1);
        }, removeAttr: function(t2) {
          return this.each(function() {
            M.removeAttr(this, t2);
          });
        } }), M.extend({ attr: function(t2, e2, n3) {
          var r2, i2, o2 = t2.nodeType;
          if (3 !== o2 && 8 !== o2 && 2 !== o2) return void 0 === t2.getAttribute ? M.prop(t2, e2, n3) : (1 === o2 && M.isXMLDoc(t2) || (i2 = M.attrHooks[e2.toLowerCase()] || (M.expr.match.bool.test(e2) ? fe : void 0)), void 0 !== n3 ? null === n3 ? void M.removeAttr(t2, e2) : i2 && "set" in i2 && void 0 !== (r2 = i2.set(t2, n3, e2)) ? r2 : (t2.setAttribute(e2, n3 + ""), n3) : i2 && "get" in i2 && null !== (r2 = i2.get(t2, e2)) ? r2 : null == (r2 = M.find.attr(t2, e2)) ? void 0 : r2);
        }, attrHooks: { type: { set: function(t2, e2) {
          if (!g.radioValue && "radio" === e2 && L(t2, "input")) {
            var n3 = t2.value;
            return t2.setAttribute("type", e2), n3 && (t2.value = n3), e2;
          }
        } } }, removeAttr: function(t2, e2) {
          var n3, r2 = 0, i2 = e2 && e2.match(k);
          if (i2 && 1 === t2.nodeType) for (; n3 = i2[r2++]; ) t2.removeAttribute(n3);
        } }), fe = { set: function(t2, e2, n3) {
          return false === e2 ? M.removeAttr(t2, n3) : t2.setAttribute(n3, n3), n3;
        } }, M.each(M.expr.match.bool.source.match(/\w+/g), function(t2, e2) {
          var n3 = me[e2] || M.find.attr;
          me[e2] = function(t3, e3, r2) {
            var i2, o2, a2 = e3.toLowerCase();
            return r2 || (o2 = me[a2], me[a2] = i2, i2 = null != n3(t3, e3, r2) ? a2 : null, me[a2] = o2), i2;
          };
        });
        var ge = /^(?:input|select|textarea|button)$/i, ve = /^(?:a|area)$/i;
        function ye(t2) {
          return (t2.match(k) || []).join(" ");
        }
        function xe(t2) {
          return t2.getAttribute && t2.getAttribute("class") || "";
        }
        function be(t2) {
          return Array.isArray(t2) ? t2 : "string" == typeof t2 && t2.match(k) || [];
        }
        M.fn.extend({ prop: function(t2, e2) {
          return V(this, M.prop, t2, e2, arguments.length > 1);
        }, removeProp: function(t2) {
          return this.each(function() {
            delete this[M.propFix[t2] || t2];
          });
        } }), M.extend({ prop: function(t2, e2, n3) {
          var r2, i2, o2 = t2.nodeType;
          if (3 !== o2 && 8 !== o2 && 2 !== o2) return 1 === o2 && M.isXMLDoc(t2) || (e2 = M.propFix[e2] || e2, i2 = M.propHooks[e2]), void 0 !== n3 ? i2 && "set" in i2 && void 0 !== (r2 = i2.set(t2, n3, e2)) ? r2 : t2[e2] = n3 : i2 && "get" in i2 && null !== (r2 = i2.get(t2, e2)) ? r2 : t2[e2];
        }, propHooks: { tabIndex: { get: function(t2) {
          var e2 = M.find.attr(t2, "tabindex");
          return e2 ? parseInt(e2, 10) : ge.test(t2.nodeName) || ve.test(t2.nodeName) && t2.href ? 0 : -1;
        } } }, propFix: { for: "htmlFor", class: "className" } }), g.optSelected || (M.propHooks.selected = { get: function(t2) {
          var e2 = t2.parentNode;
          return e2 && e2.parentNode && e2.parentNode.selectedIndex, null;
        }, set: function(t2) {
          var e2 = t2.parentNode;
          e2 && (e2.selectedIndex, e2.parentNode && e2.parentNode.selectedIndex);
        } }), M.each(["tabIndex", "readOnly", "maxLength", "cellSpacing", "cellPadding", "rowSpan", "colSpan", "useMap", "frameBorder", "contentEditable"], function() {
          M.propFix[this.toLowerCase()] = this;
        }), M.fn.extend({ addClass: function(t2) {
          var e2, n3, r2, i2, o2, a2, s2, c2 = 0;
          if (v(t2)) return this.each(function(e3) {
            M(this).addClass(t2.call(this, e3, xe(this)));
          });
          if ((e2 = be(t2)).length) {
            for (; n3 = this[c2++]; ) if (i2 = xe(n3), r2 = 1 === n3.nodeType && " " + ye(i2) + " ") {
              for (a2 = 0; o2 = e2[a2++]; ) r2.indexOf(" " + o2 + " ") < 0 && (r2 += o2 + " ");
              i2 !== (s2 = ye(r2)) && n3.setAttribute("class", s2);
            }
          }
          return this;
        }, removeClass: function(t2) {
          var e2, n3, r2, i2, o2, a2, s2, c2 = 0;
          if (v(t2)) return this.each(function(e3) {
            M(this).removeClass(t2.call(this, e3, xe(this)));
          });
          if (!arguments.length) return this.attr("class", "");
          if ((e2 = be(t2)).length) {
            for (; n3 = this[c2++]; ) if (i2 = xe(n3), r2 = 1 === n3.nodeType && " " + ye(i2) + " ") {
              for (a2 = 0; o2 = e2[a2++]; ) for (; r2.indexOf(" " + o2 + " ") > -1; ) r2 = r2.replace(" " + o2 + " ", " ");
              i2 !== (s2 = ye(r2)) && n3.setAttribute("class", s2);
            }
          }
          return this;
        }, toggleClass: function(t2, e2) {
          var n3 = typeof t2, r2 = "string" === n3 || Array.isArray(t2);
          return "boolean" == typeof e2 && r2 ? e2 ? this.addClass(t2) : this.removeClass(t2) : v(t2) ? this.each(function(n4) {
            M(this).toggleClass(t2.call(this, n4, xe(this), e2), e2);
          }) : this.each(function() {
            var e3, i2, o2, a2;
            if (r2) for (i2 = 0, o2 = M(this), a2 = be(t2); e3 = a2[i2++]; ) o2.hasClass(e3) ? o2.removeClass(e3) : o2.addClass(e3);
            else void 0 !== t2 && "boolean" !== n3 || ((e3 = xe(this)) && $.set(this, "__className__", e3), this.setAttribute && this.setAttribute("class", e3 || false === t2 ? "" : $.get(this, "__className__") || ""));
          });
        }, hasClass: function(t2) {
          var e2, n3, r2 = 0;
          for (e2 = " " + t2 + " "; n3 = this[r2++]; ) if (1 === n3.nodeType && (" " + ye(xe(n3)) + " ").indexOf(e2) > -1) return true;
          return false;
        } });
        var we = /\r/g;
        M.fn.extend({ val: function(t2) {
          var e2, n3, r2, i2 = this[0];
          return arguments.length ? (r2 = v(t2), this.each(function(n4) {
            var i3;
            1 === this.nodeType && (null == (i3 = r2 ? t2.call(this, n4, M(this).val()) : t2) ? i3 = "" : "number" == typeof i3 ? i3 += "" : Array.isArray(i3) && (i3 = M.map(i3, function(t3) {
              return null == t3 ? "" : t3 + "";
            })), (e2 = M.valHooks[this.type] || M.valHooks[this.nodeName.toLowerCase()]) && "set" in e2 && void 0 !== e2.set(this, i3, "value") || (this.value = i3));
          })) : i2 ? (e2 = M.valHooks[i2.type] || M.valHooks[i2.nodeName.toLowerCase()]) && "get" in e2 && void 0 !== (n3 = e2.get(i2, "value")) ? n3 : "string" == typeof (n3 = i2.value) ? n3.replace(we, "") : null == n3 ? "" : n3 : void 0;
        } }), M.extend({ valHooks: { option: { get: function(t2) {
          var e2 = M.find.attr(t2, "value");
          return null != e2 ? e2 : ye(M.text(t2));
        } }, select: { get: function(t2) {
          var e2, n3, r2, i2 = t2.options, o2 = t2.selectedIndex, a2 = "select-one" === t2.type, s2 = a2 ? null : [], c2 = a2 ? o2 + 1 : i2.length;
          for (r2 = o2 < 0 ? c2 : a2 ? o2 : 0; r2 < c2; r2++) if (((n3 = i2[r2]).selected || r2 === o2) && !n3.disabled && (!n3.parentNode.disabled || !L(n3.parentNode, "optgroup"))) {
            if (e2 = M(n3).val(), a2) return e2;
            s2.push(e2);
          }
          return s2;
        }, set: function(t2, e2) {
          for (var n3, r2, i2 = t2.options, o2 = M.makeArray(e2), a2 = i2.length; a2--; ) ((r2 = i2[a2]).selected = M.inArray(M.valHooks.option.get(r2), o2) > -1) && (n3 = true);
          return n3 || (t2.selectedIndex = -1), o2;
        } } } }), M.each(["radio", "checkbox"], function() {
          M.valHooks[this] = { set: function(t2, e2) {
            if (Array.isArray(e2)) return t2.checked = M.inArray(M(t2).val(), e2) > -1;
          } }, g.checkOn || (M.valHooks[this].get = function(t2) {
            return null === t2.getAttribute("value") ? "on" : t2.value;
          });
        }), g.focusin = "onfocusin" in n2;
        var _e = /^(?:focusinfocus|focusoutblur)$/, Me = function(t2) {
          t2.stopPropagation();
        };
        M.extend(M.event, { trigger: function(t2, e2, r2, i2) {
          var o2, a2, s2, c2, u2, l2, h2, d2, f2 = [r2 || x], m2 = p.call(t2, "type") ? t2.type : t2, g2 = p.call(t2, "namespace") ? t2.namespace.split(".") : [];
          if (a2 = d2 = s2 = r2 = r2 || x, 3 !== r2.nodeType && 8 !== r2.nodeType && !_e.test(m2 + M.event.triggered) && (m2.indexOf(".") > -1 && (g2 = m2.split("."), m2 = g2.shift(), g2.sort()), u2 = m2.indexOf(":") < 0 && "on" + m2, (t2 = t2[M.expando] ? t2 : new M.Event(m2, "object" == typeof t2 && t2)).isTrigger = i2 ? 2 : 3, t2.namespace = g2.join("."), t2.rnamespace = t2.namespace ? new RegExp("(^|\\.)" + g2.join("\\.(?:.*\\.|)") + "(\\.|$)") : null, t2.result = void 0, t2.target || (t2.target = r2), e2 = null == e2 ? [t2] : M.makeArray(e2, [t2]), h2 = M.event.special[m2] || {}, i2 || !h2.trigger || false !== h2.trigger.apply(r2, e2))) {
            if (!i2 && !h2.noBubble && !y(r2)) {
              for (c2 = h2.delegateType || m2, _e.test(c2 + m2) || (a2 = a2.parentNode); a2; a2 = a2.parentNode) f2.push(a2), s2 = a2;
              s2 === (r2.ownerDocument || x) && f2.push(s2.defaultView || s2.parentWindow || n2);
            }
            for (o2 = 0; (a2 = f2[o2++]) && !t2.isPropagationStopped(); ) d2 = a2, t2.type = o2 > 1 ? c2 : h2.bindType || m2, (l2 = ($.get(a2, "events") || /* @__PURE__ */ Object.create(null))[t2.type] && $.get(a2, "handle")) && l2.apply(a2, e2), (l2 = u2 && a2[u2]) && l2.apply && Z(a2) && (t2.result = l2.apply(a2, e2), false === t2.result && t2.preventDefault());
            return t2.type = m2, i2 || t2.isDefaultPrevented() || h2._default && false !== h2._default.apply(f2.pop(), e2) || !Z(r2) || u2 && v(r2[m2]) && !y(r2) && ((s2 = r2[u2]) && (r2[u2] = null), M.event.triggered = m2, t2.isPropagationStopped() && d2.addEventListener(m2, Me), r2[m2](), t2.isPropagationStopped() && d2.removeEventListener(m2, Me), M.event.triggered = void 0, s2 && (r2[u2] = s2)), t2.result;
          }
        }, simulate: function(t2, e2, n3) {
          var r2 = M.extend(new M.Event(), n3, { type: t2, isSimulated: true });
          M.event.trigger(r2, null, e2);
        } }), M.fn.extend({ trigger: function(t2, e2) {
          return this.each(function() {
            M.event.trigger(t2, e2, this);
          });
        }, triggerHandler: function(t2, e2) {
          var n3 = this[0];
          if (n3) return M.event.trigger(t2, e2, n3, true);
        } }), g.focusin || M.each({ focus: "focusin", blur: "focusout" }, function(t2, e2) {
          var n3 = function(t3) {
            M.event.simulate(e2, t3.target, M.event.fix(t3));
          };
          M.event.special[e2] = { setup: function() {
            var r2 = this.ownerDocument || this.document || this, i2 = $.access(r2, e2);
            i2 || r2.addEventListener(t2, n3, true), $.access(r2, e2, (i2 || 0) + 1);
          }, teardown: function() {
            var r2 = this.ownerDocument || this.document || this, i2 = $.access(r2, e2) - 1;
            i2 ? $.access(r2, e2, i2) : (r2.removeEventListener(t2, n3, true), $.remove(r2, e2));
          } };
        });
        var Se = n2.location, Te = { guid: Date.now() }, Ee = /\?/;
        M.parseXML = function(t2) {
          var e2;
          if (!t2 || "string" != typeof t2) return null;
          try {
            e2 = new n2.DOMParser().parseFromString(t2, "text/xml");
          } catch (t3) {
            e2 = void 0;
          }
          return e2 && !e2.getElementsByTagName("parsererror").length || M.error("Invalid XML: " + t2), e2;
        };
        var Ae = /\[\]$/, Ce = /\r?\n/g, Le = /^(?:submit|button|image|reset|file)$/i, Pe = /^(?:input|select|textarea|keygen)/i;
        function Re(t2, e2, n3, r2) {
          var i2;
          if (Array.isArray(e2)) M.each(e2, function(e3, i3) {
            n3 || Ae.test(t2) ? r2(t2, i3) : Re(t2 + "[" + ("object" == typeof i3 && null != i3 ? e3 : "") + "]", i3, n3, r2);
          });
          else if (n3 || "object" !== _(e2)) r2(t2, e2);
          else for (i2 in e2) Re(t2 + "[" + i2 + "]", e2[i2], n3, r2);
        }
        M.param = function(t2, e2) {
          var n3, r2 = [], i2 = function(t3, e3) {
            var n4 = v(e3) ? e3() : e3;
            r2[r2.length] = encodeURIComponent(t3) + "=" + encodeURIComponent(null == n4 ? "" : n4);
          };
          if (null == t2) return "";
          if (Array.isArray(t2) || t2.jquery && !M.isPlainObject(t2)) M.each(t2, function() {
            i2(this.name, this.value);
          });
          else for (n3 in t2) Re(n3, t2[n3], e2, i2);
          return r2.join("&");
        }, M.fn.extend({ serialize: function() {
          return M.param(this.serializeArray());
        }, serializeArray: function() {
          return this.map(function() {
            var t2 = M.prop(this, "elements");
            return t2 ? M.makeArray(t2) : this;
          }).filter(function() {
            var t2 = this.type;
            return this.name && !M(this).is(":disabled") && Pe.test(this.nodeName) && !Le.test(t2) && (this.checked || !mt.test(t2));
          }).map(function(t2, e2) {
            var n3 = M(this).val();
            return null == n3 ? null : Array.isArray(n3) ? M.map(n3, function(t3) {
              return { name: e2.name, value: t3.replace(Ce, "\r\n") };
            }) : { name: e2.name, value: n3.replace(Ce, "\r\n") };
          }).get();
        } });
        var Oe = /%20/g, De = /#.*$/, Ie = /([?&])_=[^&]*/, Ne = /^(.*?):[ \t]*([^\r\n]*)$/gm, ze = /^(?:GET|HEAD)$/, ke = /^\/\//, Fe = {}, Be = {}, He = "*/".concat("*"), Ge = x.createElement("a");
        function Ue(t2) {
          return function(e2, n3) {
            "string" != typeof e2 && (n3 = e2, e2 = "*");
            var r2, i2 = 0, o2 = e2.toLowerCase().match(k) || [];
            if (v(n3)) for (; r2 = o2[i2++]; ) "+" === r2[0] ? (r2 = r2.slice(1) || "*", (t2[r2] = t2[r2] || []).unshift(n3)) : (t2[r2] = t2[r2] || []).push(n3);
          };
        }
        function je(t2, e2, n3, r2) {
          var i2 = {}, o2 = t2 === Be;
          function a2(s2) {
            var c2;
            return i2[s2] = true, M.each(t2[s2] || [], function(t3, s3) {
              var u2 = s3(e2, n3, r2);
              return "string" != typeof u2 || o2 || i2[u2] ? o2 ? !(c2 = u2) : void 0 : (e2.dataTypes.unshift(u2), a2(u2), false);
            }), c2;
          }
          return a2(e2.dataTypes[0]) || !i2["*"] && a2("*");
        }
        function Ve(t2, e2) {
          var n3, r2, i2 = M.ajaxSettings.flatOptions || {};
          for (n3 in e2) void 0 !== e2[n3] && ((i2[n3] ? t2 : r2 || (r2 = {}))[n3] = e2[n3]);
          return r2 && M.extend(true, t2, r2), t2;
        }
        Ge.href = Se.href, M.extend({ active: 0, lastModified: {}, etag: {}, ajaxSettings: { url: Se.href, type: "GET", isLocal: /^(?:about|app|app-storage|.+-extension|file|res|widget):$/.test(Se.protocol), global: true, processData: true, async: true, contentType: "application/x-www-form-urlencoded; charset=UTF-8", accepts: { "*": He, text: "text/plain", html: "text/html", xml: "application/xml, text/xml", json: "application/json, text/javascript" }, contents: { xml: /\bxml\b/, html: /\bhtml/, json: /\bjson\b/ }, responseFields: { xml: "responseXML", text: "responseText", json: "responseJSON" }, converters: { "* text": String, "text html": true, "text json": JSON.parse, "text xml": M.parseXML }, flatOptions: { url: true, context: true } }, ajaxSetup: function(t2, e2) {
          return e2 ? Ve(Ve(t2, M.ajaxSettings), e2) : Ve(M.ajaxSettings, t2);
        }, ajaxPrefilter: Ue(Fe), ajaxTransport: Ue(Be), ajax: function(t2, e2) {
          "object" == typeof t2 && (e2 = t2, t2 = void 0), e2 = e2 || {};
          var r2, i2, o2, a2, s2, c2, u2, l2, h2, d2, p2 = M.ajaxSetup({}, e2), f2 = p2.context || p2, m2 = p2.context && (f2.nodeType || f2.jquery) ? M(f2) : M.event, g2 = M.Deferred(), v2 = M.Callbacks("once memory"), y2 = p2.statusCode || {}, b2 = {}, w2 = {}, _2 = "canceled", S2 = { readyState: 0, getResponseHeader: function(t3) {
            var e3;
            if (u2) {
              if (!a2) for (a2 = {}; e3 = Ne.exec(o2); ) a2[e3[1].toLowerCase() + " "] = (a2[e3[1].toLowerCase() + " "] || []).concat(e3[2]);
              e3 = a2[t3.toLowerCase() + " "];
            }
            return null == e3 ? null : e3.join(", ");
          }, getAllResponseHeaders: function() {
            return u2 ? o2 : null;
          }, setRequestHeader: function(t3, e3) {
            return null == u2 && (t3 = w2[t3.toLowerCase()] = w2[t3.toLowerCase()] || t3, b2[t3] = e3), this;
          }, overrideMimeType: function(t3) {
            return null == u2 && (p2.mimeType = t3), this;
          }, statusCode: function(t3) {
            var e3;
            if (t3) if (u2) S2.always(t3[S2.status]);
            else for (e3 in t3) y2[e3] = [y2[e3], t3[e3]];
            return this;
          }, abort: function(t3) {
            var e3 = t3 || _2;
            return r2 && r2.abort(e3), T2(0, e3), this;
          } };
          if (g2.promise(S2), p2.url = ((t2 || p2.url || Se.href) + "").replace(ke, Se.protocol + "//"), p2.type = e2.method || e2.type || p2.method || p2.type, p2.dataTypes = (p2.dataType || "*").toLowerCase().match(k) || [""], null == p2.crossDomain) {
            c2 = x.createElement("a");
            try {
              c2.href = p2.url, c2.href = c2.href, p2.crossDomain = Ge.protocol + "//" + Ge.host != c2.protocol + "//" + c2.host;
            } catch (t3) {
              p2.crossDomain = true;
            }
          }
          if (p2.data && p2.processData && "string" != typeof p2.data && (p2.data = M.param(p2.data, p2.traditional)), je(Fe, p2, e2, S2), u2) return S2;
          for (h2 in (l2 = M.event && p2.global) && 0 == M.active++ && M.event.trigger("ajaxStart"), p2.type = p2.type.toUpperCase(), p2.hasContent = !ze.test(p2.type), i2 = p2.url.replace(De, ""), p2.hasContent ? p2.data && p2.processData && 0 === (p2.contentType || "").indexOf("application/x-www-form-urlencoded") && (p2.data = p2.data.replace(Oe, "+")) : (d2 = p2.url.slice(i2.length), p2.data && (p2.processData || "string" == typeof p2.data) && (i2 += (Ee.test(i2) ? "&" : "?") + p2.data, delete p2.data), false === p2.cache && (i2 = i2.replace(Ie, "$1"), d2 = (Ee.test(i2) ? "&" : "?") + "_=" + Te.guid++ + d2), p2.url = i2 + d2), p2.ifModified && (M.lastModified[i2] && S2.setRequestHeader("If-Modified-Since", M.lastModified[i2]), M.etag[i2] && S2.setRequestHeader("If-None-Match", M.etag[i2])), (p2.data && p2.hasContent && false !== p2.contentType || e2.contentType) && S2.setRequestHeader("Content-Type", p2.contentType), S2.setRequestHeader("Accept", p2.dataTypes[0] && p2.accepts[p2.dataTypes[0]] ? p2.accepts[p2.dataTypes[0]] + ("*" !== p2.dataTypes[0] ? ", " + He + "; q=0.01" : "") : p2.accepts["*"]), p2.headers) S2.setRequestHeader(h2, p2.headers[h2]);
          if (p2.beforeSend && (false === p2.beforeSend.call(f2, S2, p2) || u2)) return S2.abort();
          if (_2 = "abort", v2.add(p2.complete), S2.done(p2.success), S2.fail(p2.error), r2 = je(Be, p2, e2, S2)) {
            if (S2.readyState = 1, l2 && m2.trigger("ajaxSend", [S2, p2]), u2) return S2;
            p2.async && p2.timeout > 0 && (s2 = n2.setTimeout(function() {
              S2.abort("timeout");
            }, p2.timeout));
            try {
              u2 = false, r2.send(b2, T2);
            } catch (t3) {
              if (u2) throw t3;
              T2(-1, t3);
            }
          } else T2(-1, "No Transport");
          function T2(t3, e3, a3, c3) {
            var h3, d3, x2, b3, w3, _3 = e3;
            u2 || (u2 = true, s2 && n2.clearTimeout(s2), r2 = void 0, o2 = c3 || "", S2.readyState = t3 > 0 ? 4 : 0, h3 = t3 >= 200 && t3 < 300 || 304 === t3, a3 && (b3 = function(t4, e4, n3) {
              for (var r3, i3, o3, a4, s3 = t4.contents, c4 = t4.dataTypes; "*" === c4[0]; ) c4.shift(), void 0 === r3 && (r3 = t4.mimeType || e4.getResponseHeader("Content-Type"));
              if (r3) {
                for (i3 in s3) if (s3[i3] && s3[i3].test(r3)) {
                  c4.unshift(i3);
                  break;
                }
              }
              if (c4[0] in n3) o3 = c4[0];
              else {
                for (i3 in n3) {
                  if (!c4[0] || t4.converters[i3 + " " + c4[0]]) {
                    o3 = i3;
                    break;
                  }
                  a4 || (a4 = i3);
                }
                o3 = o3 || a4;
              }
              if (o3) return o3 !== c4[0] && c4.unshift(o3), n3[o3];
            }(p2, S2, a3)), !h3 && M.inArray("script", p2.dataTypes) > -1 && (p2.converters["text script"] = function() {
            }), b3 = function(t4, e4, n3, r3) {
              var i3, o3, a4, s3, c4, u3 = {}, l3 = t4.dataTypes.slice();
              if (l3[1]) for (a4 in t4.converters) u3[a4.toLowerCase()] = t4.converters[a4];
              for (o3 = l3.shift(); o3; ) if (t4.responseFields[o3] && (n3[t4.responseFields[o3]] = e4), !c4 && r3 && t4.dataFilter && (e4 = t4.dataFilter(e4, t4.dataType)), c4 = o3, o3 = l3.shift()) {
                if ("*" === o3) o3 = c4;
                else if ("*" !== c4 && c4 !== o3) {
                  if (!(a4 = u3[c4 + " " + o3] || u3["* " + o3])) {
                    for (i3 in u3) if ((s3 = i3.split(" "))[1] === o3 && (a4 = u3[c4 + " " + s3[0]] || u3["* " + s3[0]])) {
                      true === a4 ? a4 = u3[i3] : true !== u3[i3] && (o3 = s3[0], l3.unshift(s3[1]));
                      break;
                    }
                  }
                  if (true !== a4) if (a4 && t4.throws) e4 = a4(e4);
                  else try {
                    e4 = a4(e4);
                  } catch (t5) {
                    return { state: "parsererror", error: a4 ? t5 : "No conversion from " + c4 + " to " + o3 };
                  }
                }
              }
              return { state: "success", data: e4 };
            }(p2, b3, S2, h3), h3 ? (p2.ifModified && ((w3 = S2.getResponseHeader("Last-Modified")) && (M.lastModified[i2] = w3), (w3 = S2.getResponseHeader("etag")) && (M.etag[i2] = w3)), 204 === t3 || "HEAD" === p2.type ? _3 = "nocontent" : 304 === t3 ? _3 = "notmodified" : (_3 = b3.state, d3 = b3.data, h3 = !(x2 = b3.error))) : (x2 = _3, !t3 && _3 || (_3 = "error", t3 < 0 && (t3 = 0))), S2.status = t3, S2.statusText = (e3 || _3) + "", h3 ? g2.resolveWith(f2, [d3, _3, S2]) : g2.rejectWith(f2, [S2, _3, x2]), S2.statusCode(y2), y2 = void 0, l2 && m2.trigger(h3 ? "ajaxSuccess" : "ajaxError", [S2, p2, h3 ? d3 : x2]), v2.fireWith(f2, [S2, _3]), l2 && (m2.trigger("ajaxComplete", [S2, p2]), --M.active || M.event.trigger("ajaxStop")));
          }
          return S2;
        }, getJSON: function(t2, e2, n3) {
          return M.get(t2, e2, n3, "json");
        }, getScript: function(t2, e2) {
          return M.get(t2, void 0, e2, "script");
        } }), M.each(["get", "post"], function(t2, e2) {
          M[e2] = function(t3, n3, r2, i2) {
            return v(n3) && (i2 = i2 || r2, r2 = n3, n3 = void 0), M.ajax(M.extend({ url: t3, type: e2, dataType: i2, data: n3, success: r2 }, M.isPlainObject(t3) && t3));
          };
        }), M.ajaxPrefilter(function(t2) {
          var e2;
          for (e2 in t2.headers) "content-type" === e2.toLowerCase() && (t2.contentType = t2.headers[e2] || "");
        }), M._evalUrl = function(t2, e2, n3) {
          return M.ajax({ url: t2, type: "GET", dataType: "script", cache: true, async: false, global: false, converters: { "text script": function() {
          } }, dataFilter: function(t3) {
            M.globalEval(t3, e2, n3);
          } });
        }, M.fn.extend({ wrapAll: function(t2) {
          var e2;
          return this[0] && (v(t2) && (t2 = t2.call(this[0])), e2 = M(t2, this[0].ownerDocument).eq(0).clone(true), this[0].parentNode && e2.insertBefore(this[0]), e2.map(function() {
            for (var t3 = this; t3.firstElementChild; ) t3 = t3.firstElementChild;
            return t3;
          }).append(this)), this;
        }, wrapInner: function(t2) {
          return v(t2) ? this.each(function(e2) {
            M(this).wrapInner(t2.call(this, e2));
          }) : this.each(function() {
            var e2 = M(this), n3 = e2.contents();
            n3.length ? n3.wrapAll(t2) : e2.append(t2);
          });
        }, wrap: function(t2) {
          var e2 = v(t2);
          return this.each(function(n3) {
            M(this).wrapAll(e2 ? t2.call(this, n3) : t2);
          });
        }, unwrap: function(t2) {
          return this.parent(t2).not("body").each(function() {
            M(this).replaceWith(this.childNodes);
          }), this;
        } }), M.expr.pseudos.hidden = function(t2) {
          return !M.expr.pseudos.visible(t2);
        }, M.expr.pseudos.visible = function(t2) {
          return !!(t2.offsetWidth || t2.offsetHeight || t2.getClientRects().length);
        }, M.ajaxSettings.xhr = function() {
          try {
            return new n2.XMLHttpRequest();
          } catch (t2) {
          }
        };
        var We = { 0: 200, 1223: 204 }, qe = M.ajaxSettings.xhr();
        g.cors = !!qe && "withCredentials" in qe, g.ajax = qe = !!qe, M.ajaxTransport(function(t2) {
          var e2, r2;
          if (g.cors || qe && !t2.crossDomain) return { send: function(i2, o2) {
            var a2, s2 = t2.xhr();
            if (s2.open(t2.type, t2.url, t2.async, t2.username, t2.password), t2.xhrFields) for (a2 in t2.xhrFields) s2[a2] = t2.xhrFields[a2];
            for (a2 in t2.mimeType && s2.overrideMimeType && s2.overrideMimeType(t2.mimeType), t2.crossDomain || i2["X-Requested-With"] || (i2["X-Requested-With"] = "XMLHttpRequest"), i2) s2.setRequestHeader(a2, i2[a2]);
            e2 = function(t3) {
              return function() {
                e2 && (e2 = r2 = s2.onload = s2.onerror = s2.onabort = s2.ontimeout = s2.onreadystatechange = null, "abort" === t3 ? s2.abort() : "error" === t3 ? "number" != typeof s2.status ? o2(0, "error") : o2(s2.status, s2.statusText) : o2(We[s2.status] || s2.status, s2.statusText, "text" !== (s2.responseType || "text") || "string" != typeof s2.responseText ? { binary: s2.response } : { text: s2.responseText }, s2.getAllResponseHeaders()));
              };
            }, s2.onload = e2(), r2 = s2.onerror = s2.ontimeout = e2("error"), void 0 !== s2.onabort ? s2.onabort = r2 : s2.onreadystatechange = function() {
              4 === s2.readyState && n2.setTimeout(function() {
                e2 && r2();
              });
            }, e2 = e2("abort");
            try {
              s2.send(t2.hasContent && t2.data || null);
            } catch (t3) {
              if (e2) throw t3;
            }
          }, abort: function() {
            e2 && e2();
          } };
        }), M.ajaxPrefilter(function(t2) {
          t2.crossDomain && (t2.contents.script = false);
        }), M.ajaxSetup({ accepts: { script: "text/javascript, application/javascript, application/ecmascript, application/x-ecmascript" }, contents: { script: /\b(?:java|ecma)script\b/ }, converters: { "text script": function(t2) {
          return M.globalEval(t2), t2;
        } } }), M.ajaxPrefilter("script", function(t2) {
          void 0 === t2.cache && (t2.cache = false), t2.crossDomain && (t2.type = "GET");
        }), M.ajaxTransport("script", function(t2) {
          var e2, n3;
          if (t2.crossDomain || t2.scriptAttrs) return { send: function(r2, i2) {
            e2 = M("<script>").attr(t2.scriptAttrs || {}).prop({ charset: t2.scriptCharset, src: t2.url }).on("load error", n3 = function(t3) {
              e2.remove(), n3 = null, t3 && i2("error" === t3.type ? 404 : 200, t3.type);
            }), x.head.appendChild(e2[0]);
          }, abort: function() {
            n3 && n3();
          } };
        });
        var Xe, Ye = [], Ze = /(=)\?(?=&|$)|\?\?/;
        M.ajaxSetup({ jsonp: "callback", jsonpCallback: function() {
          var t2 = Ye.pop() || M.expando + "_" + Te.guid++;
          return this[t2] = true, t2;
        } }), M.ajaxPrefilter("json jsonp", function(t2, e2, r2) {
          var i2, o2, a2, s2 = false !== t2.jsonp && (Ze.test(t2.url) ? "url" : "string" == typeof t2.data && 0 === (t2.contentType || "").indexOf("application/x-www-form-urlencoded") && Ze.test(t2.data) && "data");
          if (s2 || "jsonp" === t2.dataTypes[0]) return i2 = t2.jsonpCallback = v(t2.jsonpCallback) ? t2.jsonpCallback() : t2.jsonpCallback, s2 ? t2[s2] = t2[s2].replace(Ze, "$1" + i2) : false !== t2.jsonp && (t2.url += (Ee.test(t2.url) ? "&" : "?") + t2.jsonp + "=" + i2), t2.converters["script json"] = function() {
            return a2 || M.error(i2 + " was not called"), a2[0];
          }, t2.dataTypes[0] = "json", o2 = n2[i2], n2[i2] = function() {
            a2 = arguments;
          }, r2.always(function() {
            void 0 === o2 ? M(n2).removeProp(i2) : n2[i2] = o2, t2[i2] && (t2.jsonpCallback = e2.jsonpCallback, Ye.push(i2)), a2 && v(o2) && o2(a2[0]), a2 = o2 = void 0;
          }), "script";
        }), g.createHTMLDocument = ((Xe = x.implementation.createHTMLDocument("").body).innerHTML = "<form></form><form></form>", 2 === Xe.childNodes.length), M.parseHTML = function(t2, e2, n3) {
          return "string" != typeof t2 ? [] : ("boolean" == typeof e2 && (n3 = e2, e2 = false), e2 || (g.createHTMLDocument ? ((r2 = (e2 = x.implementation.createHTMLDocument("")).createElement("base")).href = x.location.href, e2.head.appendChild(r2)) : e2 = x), o2 = !n3 && [], (i2 = P.exec(t2)) ? [e2.createElement(i2[1])] : (i2 = _t([t2], e2, o2), o2 && o2.length && M(o2).remove(), M.merge([], i2.childNodes)));
          var r2, i2, o2;
        }, M.fn.load = function(t2, e2, n3) {
          var r2, i2, o2, a2 = this, s2 = t2.indexOf(" ");
          return s2 > -1 && (r2 = ye(t2.slice(s2)), t2 = t2.slice(0, s2)), v(e2) ? (n3 = e2, e2 = void 0) : e2 && "object" == typeof e2 && (i2 = "POST"), a2.length > 0 && M.ajax({ url: t2, type: i2 || "GET", dataType: "html", data: e2 }).done(function(t3) {
            o2 = arguments, a2.html(r2 ? M("<div>").append(M.parseHTML(t3)).find(r2) : t3);
          }).always(n3 && function(t3, e3) {
            a2.each(function() {
              n3.apply(this, o2 || [t3.responseText, e3, t3]);
            });
          }), this;
        }, M.expr.pseudos.animated = function(t2) {
          return M.grep(M.timers, function(e2) {
            return t2 === e2.elem;
          }).length;
        }, M.offset = { setOffset: function(t2, e2, n3) {
          var r2, i2, o2, a2, s2, c2, u2 = M.css(t2, "position"), l2 = M(t2), h2 = {};
          "static" === u2 && (t2.style.position = "relative"), s2 = l2.offset(), o2 = M.css(t2, "top"), c2 = M.css(t2, "left"), ("absolute" === u2 || "fixed" === u2) && (o2 + c2).indexOf("auto") > -1 ? (a2 = (r2 = l2.position()).top, i2 = r2.left) : (a2 = parseFloat(o2) || 0, i2 = parseFloat(c2) || 0), v(e2) && (e2 = e2.call(t2, n3, M.extend({}, s2))), null != e2.top && (h2.top = e2.top - s2.top + a2), null != e2.left && (h2.left = e2.left - s2.left + i2), "using" in e2 ? e2.using.call(t2, h2) : ("number" == typeof h2.top && (h2.top += "px"), "number" == typeof h2.left && (h2.left += "px"), l2.css(h2));
        } }, M.fn.extend({ offset: function(t2) {
          if (arguments.length) return void 0 === t2 ? this : this.each(function(e3) {
            M.offset.setOffset(this, t2, e3);
          });
          var e2, n3, r2 = this[0];
          return r2 ? r2.getClientRects().length ? (e2 = r2.getBoundingClientRect(), n3 = r2.ownerDocument.defaultView, { top: e2.top + n3.pageYOffset, left: e2.left + n3.pageXOffset }) : { top: 0, left: 0 } : void 0;
        }, position: function() {
          if (this[0]) {
            var t2, e2, n3, r2 = this[0], i2 = { top: 0, left: 0 };
            if ("fixed" === M.css(r2, "position")) e2 = r2.getBoundingClientRect();
            else {
              for (e2 = this.offset(), n3 = r2.ownerDocument, t2 = r2.offsetParent || n3.documentElement; t2 && (t2 === n3.body || t2 === n3.documentElement) && "static" === M.css(t2, "position"); ) t2 = t2.parentNode;
              t2 && t2 !== r2 && 1 === t2.nodeType && ((i2 = M(t2).offset()).top += M.css(t2, "borderTopWidth", true), i2.left += M.css(t2, "borderLeftWidth", true));
            }
            return { top: e2.top - i2.top - M.css(r2, "marginTop", true), left: e2.left - i2.left - M.css(r2, "marginLeft", true) };
          }
        }, offsetParent: function() {
          return this.map(function() {
            for (var t2 = this.offsetParent; t2 && "static" === M.css(t2, "position"); ) t2 = t2.offsetParent;
            return t2 || ot;
          });
        } }), M.each({ scrollLeft: "pageXOffset", scrollTop: "pageYOffset" }, function(t2, e2) {
          var n3 = "pageYOffset" === e2;
          M.fn[t2] = function(r2) {
            return V(this, function(t3, r3, i2) {
              var o2;
              if (y(t3) ? o2 = t3 : 9 === t3.nodeType && (o2 = t3.defaultView), void 0 === i2) return o2 ? o2[e2] : t3[r3];
              o2 ? o2.scrollTo(n3 ? o2.pageXOffset : i2, n3 ? i2 : o2.pageYOffset) : t3[r3] = i2;
            }, t2, r2, arguments.length);
          };
        }), M.each(["top", "left"], function(t2, e2) {
          M.cssHooks[e2] = qt(g.pixelPosition, function(t3, n3) {
            if (n3) return n3 = Wt(t3, e2), Gt.test(n3) ? M(t3).position()[e2] + "px" : n3;
          });
        }), M.each({ Height: "height", Width: "width" }, function(t2, e2) {
          M.each({ padding: "inner" + t2, content: e2, "": "outer" + t2 }, function(n3, r2) {
            M.fn[r2] = function(i2, o2) {
              var a2 = arguments.length && (n3 || "boolean" != typeof i2), s2 = n3 || (true === i2 || true === o2 ? "margin" : "border");
              return V(this, function(e3, n4, i3) {
                var o3;
                return y(e3) ? 0 === r2.indexOf("outer") ? e3["inner" + t2] : e3.document.documentElement["client" + t2] : 9 === e3.nodeType ? (o3 = e3.documentElement, Math.max(e3.body["scroll" + t2], o3["scroll" + t2], e3.body["offset" + t2], o3["offset" + t2], o3["client" + t2])) : void 0 === i3 ? M.css(e3, n4, s2) : M.style(e3, n4, i3, s2);
              }, e2, a2 ? i2 : void 0, a2);
            };
          });
        }), M.each(["ajaxStart", "ajaxStop", "ajaxComplete", "ajaxError", "ajaxSuccess", "ajaxSend"], function(t2, e2) {
          M.fn[e2] = function(t3) {
            return this.on(e2, t3);
          };
        }), M.fn.extend({ bind: function(t2, e2, n3) {
          return this.on(t2, null, e2, n3);
        }, unbind: function(t2, e2) {
          return this.off(t2, null, e2);
        }, delegate: function(t2, e2, n3, r2) {
          return this.on(e2, t2, n3, r2);
        }, undelegate: function(t2, e2, n3) {
          return 1 === arguments.length ? this.off(t2, "**") : this.off(e2, t2 || "**", n3);
        }, hover: function(t2, e2) {
          return this.mouseenter(t2).mouseleave(e2 || t2);
        } }), M.each("blur focus focusin focusout resize scroll click dblclick mousedown mouseup mousemove mouseover mouseout mouseenter mouseleave change select submit keydown keypress keyup contextmenu".split(" "), function(t2, e2) {
          M.fn[e2] = function(t3, n3) {
            return arguments.length > 0 ? this.on(e2, null, t3, n3) : this.trigger(e2);
          };
        });
        var Je = /^[\s\uFEFF\xA0]+|[\s\uFEFF\xA0]+$/g;
        M.proxy = function(t2, e2) {
          var n3, r2, i2;
          if ("string" == typeof e2 && (n3 = t2[e2], e2 = t2, t2 = n3), v(t2)) return r2 = s.call(arguments, 2), (i2 = function() {
            return t2.apply(e2 || this, r2.concat(s.call(arguments)));
          }).guid = t2.guid = t2.guid || M.guid++, i2;
        }, M.holdReady = function(t2) {
          t2 ? M.readyWait++ : M.ready(true);
        }, M.isArray = Array.isArray, M.parseJSON = JSON.parse, M.nodeName = L, M.isFunction = v, M.isWindow = y, M.camelCase = Y, M.type = _, M.now = Date.now, M.isNumeric = function(t2) {
          var e2 = M.type(t2);
          return ("number" === e2 || "string" === e2) && !isNaN(t2 - parseFloat(t2));
        }, M.trim = function(t2) {
          return null == t2 ? "" : (t2 + "").replace(Je, "");
        }, void 0 === (r = (function() {
          return M;
        }).apply(e, [])) || (t.exports = r);
        var $e = n2.jQuery, Qe = n2.$;
        return M.noConflict = function(t2) {
          return n2.$ === M && (n2.$ = Qe), t2 && n2.jQuery === M && (n2.jQuery = $e), M;
        }, void 0 === i && (n2.jQuery = n2.$ = M), M;
      });
    }, function(t, e, n) {
      var r, i;
      r = this, i = function() {
        var t2 = { isCanvas: true, begin: function(t3) {
          t3.beginPath();
        }, move: function(t3, e2, n2) {
          t3.moveTo(n2.x, n2.y);
        }, line: function(t3, e2, n2) {
          t3.lineTo(n2.x, n2.y);
        }, bezier: function(t3, e2, n2, r2, i2) {
          t3.bezierCurveTo(n2.x, n2.y, r2.x, r2.y, i2.x, i2.y);
        }, closePath: function(t3) {
          t3.closePath();
        }, setPath: function() {
        }, renderPath: function(e2, n2, r2, i2) {
          this.begin(e2, n2), r2.forEach(function(r3) {
            r3.render(e2, n2, t2);
          }), i2 && this.closePath(e2, n2);
        }, stroke: function(t3, e2, n2, r2, i2) {
          n2 && (t3.strokeStyle = r2, t3.lineWidth = i2, t3.stroke());
        }, fill: function(t3, e2, n2, r2) {
          n2 && (t3.fillStyle = r2, t3.fill());
        }, end: function() {
        } };
        return t2;
      }, t.exports ? t.exports = i() : r.Zdog.CanvasRenderer = i();
    }, function(t, e, n) {
      var r, i;
      r = this, i = function() {
        var t2 = { isSvg: true }, e2 = t2.round = function(t3) {
          return Math.round(1e3 * t3) / 1e3;
        };
        function n2(t3) {
          return e2(t3.x) + "," + e2(t3.y) + " ";
        }
        return t2.begin = function() {
        }, t2.move = function(t3, e3, r2) {
          return "M" + n2(r2);
        }, t2.line = function(t3, e3, r2) {
          return "L" + n2(r2);
        }, t2.bezier = function(t3, e3, r2, i2, o) {
          return "C" + n2(r2) + n2(i2) + n2(o);
        }, t2.closePath = function() {
          return "Z";
        }, t2.setPath = function(t3, e3, n3) {
          e3.setAttribute("d", n3);
        }, t2.renderPath = function(e3, n3, r2, i2) {
          var o = "";
          r2.forEach(function(r3) {
            o += r3.render(e3, n3, t2);
          }), i2 && (o += this.closePath(e3, n3)), this.setPath(e3, n3, o);
        }, t2.stroke = function(t3, e3, n3, r2, i2) {
          n3 && (e3.setAttribute("stroke", r2), e3.setAttribute("stroke-width", i2));
        }, t2.fill = function(t3, e3, n3, r2) {
          var i2 = n3 ? r2 : "none";
          e3.setAttribute("fill", i2);
        }, t2.end = function(t3, e3) {
          t3.appendChild(e3);
        }, t2;
      }, t.exports ? t.exports = i() : r.Zdog.SvgRenderer = i();
    }, function(t, e, n) {
      var r, i;
      r = this, i = function() {
        var t2 = "undefined" != typeof window, e2 = "mousedown", n2 = "mousemove", r2 = "mouseup";
        function i2() {
        }
        function o(t3) {
          this.create(t3 || {});
        }
        return t2 && (window.PointerEvent ? (e2 = "pointerdown", n2 = "pointermove", r2 = "pointerup") : "ontouchstart" in window && (e2 = "touchstart", n2 = "touchmove", r2 = "touchend")), o.prototype.create = function(t3) {
          this.onDragStart = t3.onDragStart || i2, this.onDragMove = t3.onDragMove || i2, this.onDragEnd = t3.onDragEnd || i2, this.bindDrag(t3.startElement);
        }, o.prototype.bindDrag = function(t3) {
          (t3 = this.getQueryElement(t3)) && (t3.style.touchAction = "none", t3.addEventListener(e2, this));
        }, o.prototype.getQueryElement = function(t3) {
          return "string" == typeof t3 && (t3 = document.querySelector(t3)), t3;
        }, o.prototype.handleEvent = function(t3) {
          var e3 = this["on" + t3.type];
          e3 && e3.call(this, t3);
        }, o.prototype.onmousedown = o.prototype.onpointerdown = function(t3) {
          this.dragStart(t3, t3);
        }, o.prototype.ontouchstart = function(t3) {
          this.dragStart(t3, t3.changedTouches[0]);
        }, o.prototype.dragStart = function(e3, i3) {
          e3.preventDefault(), this.dragStartX = i3.pageX, this.dragStartY = i3.pageY, t2 && (window.addEventListener(n2, this), window.addEventListener(r2, this)), this.onDragStart(i3);
        }, o.prototype.ontouchmove = function(t3) {
          this.dragMove(t3, t3.changedTouches[0]);
        }, o.prototype.onmousemove = o.prototype.onpointermove = function(t3) {
          this.dragMove(t3, t3);
        }, o.prototype.dragMove = function(t3, e3) {
          t3.preventDefault();
          var n3 = e3.pageX - this.dragStartX, r3 = e3.pageY - this.dragStartY;
          this.onDragMove(e3, n3, r3);
        }, o.prototype.onmouseup = o.prototype.onpointerup = o.prototype.ontouchend = o.prototype.dragEnd = function() {
          window.removeEventListener(n2, this), window.removeEventListener(r2, this), this.onDragEnd();
        }, o;
      }, t.exports ? t.exports = i() : r.Zdog.Dragger = i();
    }, function(t, e, n) {
      !function(e2, r) {
        if (t.exports) t.exports = r(n(4));
        else {
          var i = e2.Zdog;
          i.Group = r(i.Anchor);
        }
      }(this, function(t2) {
        var e2 = t2.subclass({ updateSort: false, visible: true });
        return e2.prototype.updateSortValue = function() {
          var e3 = 0;
          this.flatGraph.forEach(function(t3) {
            t3.updateSortValue(), e3 += t3.sortValue;
          }), this.sortValue = e3 / this.flatGraph.length, this.updateSort && this.flatGraph.sort(t2.shapeSorter);
        }, e2.prototype.render = function(t3, e3) {
          this.visible && this.flatGraph.forEach(function(n2) {
            n2.render(t3, e3);
          });
        }, e2.prototype.updateFlatGraph = function() {
          this.flatGraph = this.addChildFlatGraph([]);
        }, e2.prototype.getFlatGraph = function() {
          return [this];
        }, e2;
      });
    }, function(t, e, n) {
      !function(e2, r) {
        if (t.exports) t.exports = r(n(5));
        else {
          var i = e2.Zdog;
          i.Rect = r(i.Shape);
        }
      }(this, function(t2) {
        var e2 = t2.subclass({ width: 1, height: 1 });
        return e2.prototype.setPath = function() {
          var t3 = this.width / 2, e3 = this.height / 2;
          this.path = [{ x: -t3, y: -e3 }, { x: t3, y: -e3 }, { x: t3, y: e3 }, { x: -t3, y: e3 }];
        }, e2;
      });
    }, function(t, e, n) {
      "use strict";
      function r() {
        return (r = Object.assign || function(t2) {
          for (var e2 = 1; e2 < arguments.length; e2++) {
            var n2 = arguments[e2];
            for (var r2 in n2) Object.prototype.hasOwnProperty.call(n2, r2) && (t2[r2] = n2[r2]);
          }
          return t2;
        }).apply(this, arguments);
      }
      function i(t2) {
        return (i = Object.setPrototypeOf ? Object.getPrototypeOf : function(t3) {
          return t3.__proto__ || Object.getPrototypeOf(t3);
        })(t2);
      }
      function o(t2, e2) {
        return (o = Object.setPrototypeOf || function(t3, e3) {
          return t3.__proto__ = e3, t3;
        })(t2, e2);
      }
      function a() {
        if ("undefined" == typeof Reflect || !Reflect.construct) return false;
        if (Reflect.construct.sham) return false;
        if ("function" == typeof Proxy) return true;
        try {
          return Date.prototype.toString.call(Reflect.construct(Date, [], function() {
          })), true;
        } catch (t2) {
          return false;
        }
      }
      function s(t2, e2, n2) {
        return (s = a() ? Reflect.construct : function(t3, e3, n3) {
          var r2 = [null];
          r2.push.apply(r2, e3);
          var i2 = new (Function.bind.apply(t3, r2))();
          return n3 && o(i2, n3.prototype), i2;
        }).apply(null, arguments);
      }
      function c(t2) {
        var e2 = "function" == typeof Map ? /* @__PURE__ */ new Map() : void 0;
        return (c = function(t3) {
          if (null === t3 || (n2 = t3, -1 === Function.toString.call(n2).indexOf("[native code]"))) return t3;
          var n2;
          if ("function" != typeof t3) throw new TypeError("Super expression must either be null or a function");
          if (void 0 !== e2) {
            if (e2.has(t3)) return e2.get(t3);
            e2.set(t3, r2);
          }
          function r2() {
            return s(t3, arguments, i(this).constructor);
          }
          return r2.prototype = Object.create(t3.prototype, { constructor: { value: r2, enumerable: false, writable: true, configurable: true } }), o(r2, t3);
        })(t2);
      }
      function u(t2, e2) {
        return e2 || (e2 = t2.slice(0)), t2.raw = e2, t2;
      }
      function l() {
        var t2;
        return (t2 = arguments.length - 1) < 0 || arguments.length <= t2 ? void 0 : arguments[t2];
      }
      n.r(e), n.d(e, "adjustHue", function() {
        return Ut;
      }), n.d(e, "animation", function() {
        return Me;
      }), n.d(e, "backgroundImages", function() {
        return Se;
      }), n.d(e, "backgrounds", function() {
        return Te;
      }), n.d(e, "between", function() {
        return U;
      }), n.d(e, "border", function() {
        return Ae;
      }), n.d(e, "borderColor", function() {
        return Ce;
      }), n.d(e, "borderRadius", function() {
        return Le;
      }), n.d(e, "borderStyle", function() {
        return Pe;
      }), n.d(e, "borderWidth", function() {
        return Re;
      }), n.d(e, "buttons", function() {
        return ze;
      }), n.d(e, "clearFix", function() {
        return j;
      }), n.d(e, "complement", function() {
        return jt;
      }), n.d(e, "cover", function() {
        return V;
      }), n.d(e, "cssVar", function() {
        return x;
      }), n.d(e, "darken", function() {
        return qt;
      }), n.d(e, "desaturate", function() {
        return Yt;
      }), n.d(e, "directionalProperty", function() {
        return S;
      }), n.d(e, "easeIn", function() {
        return k;
      }), n.d(e, "easeInOut", function() {
        return B;
      }), n.d(e, "easeOut", function() {
        return G;
      }), n.d(e, "ellipsis", function() {
        return W;
      }), n.d(e, "em", function() {
        return L;
      }), n.d(e, "fluidRange", function() {
        return Y;
      }), n.d(e, "fontFace", function() {
        return tt;
      }), n.d(e, "getContrast", function() {
        return Jt;
      }), n.d(e, "getLuminance", function() {
        return Zt;
      }), n.d(e, "getValueAndUnit", function() {
        return R;
      }), n.d(e, "grayscale", function() {
        return $t;
      }), n.d(e, "hiDPI", function() {
        return rt;
      }), n.d(e, "hideText", function() {
        return et;
      }), n.d(e, "hideVisually", function() {
        return nt;
      }), n.d(e, "hsl", function() {
        return Nt;
      }), n.d(e, "hslToColorString", function() {
        return Qt;
      }), n.d(e, "hsla", function() {
        return zt;
      }), n.d(e, "important", function() {
        return O;
      }), n.d(e, "invert", function() {
        return Kt;
      }), n.d(e, "lighten", function() {
        return ee;
      }), n.d(e, "linearGradient", function() {
        return at;
      }), n.d(e, "margin", function() {
        return ke;
      }), n.d(e, "math", function() {
        return v;
      }), n.d(e, "meetsContrastGuidelines", function() {
        return ne;
      }), n.d(e, "mix", function() {
        return ie;
      }), n.d(e, "modularScale", function() {
        return I;
      }), n.d(e, "normalize", function() {
        return st;
      }), n.d(e, "opacify", function() {
        return ae;
      }), n.d(e, "padding", function() {
        return Fe;
      }), n.d(e, "parseToHsl", function() {
        return Lt;
      }), n.d(e, "parseToRgb", function() {
        return Ct;
      }), n.d(e, "position", function() {
        return He;
      }), n.d(e, "radialGradient", function() {
        return ut;
      }), n.d(e, "readableColor", function() {
        return se;
      }), n.d(e, "rem", function() {
        return N;
      }), n.d(e, "retinaImage", function() {
        return lt;
      }), n.d(e, "rgb", function() {
        return kt;
      }), n.d(e, "rgbToColorString", function() {
        return ce;
      }), n.d(e, "rgba", function() {
        return Ft;
      }), n.d(e, "saturate", function() {
        return le;
      }), n.d(e, "setHue", function() {
        return de;
      }), n.d(e, "setLightness", function() {
        return fe;
      }), n.d(e, "setSaturation", function() {
        return ge;
      }), n.d(e, "shade", function() {
        return ye;
      }), n.d(e, "size", function() {
        return Ge;
      }), n.d(e, "stripUnit", function() {
        return A;
      }), n.d(e, "textInputs", function() {
        return Ve;
      }), n.d(e, "timingFunctions", function() {
        return dt;
      }), n.d(e, "tint", function() {
        return be;
      }), n.d(e, "toColorString", function() {
        return Bt;
      }), n.d(e, "transitions", function() {
        return We;
      }), n.d(e, "transparentize", function() {
        return _e;
      }), n.d(e, "triangle", function() {
        return ft;
      }), n.d(e, "wordWrap", function() {
        return mt;
      });
      var h = { symbols: { "*": { infix: { symbol: "*", f: function(t2, e2) {
        return t2 * e2;
      }, notation: "infix", precedence: 4, rightToLeft: 0, argCount: 2 }, symbol: "*", regSymbol: "\\*" }, "/": { infix: { symbol: "/", f: function(t2, e2) {
        return t2 / e2;
      }, notation: "infix", precedence: 4, rightToLeft: 0, argCount: 2 }, symbol: "/", regSymbol: "/" }, "+": { infix: { symbol: "+", f: function(t2, e2) {
        return t2 + e2;
      }, notation: "infix", precedence: 2, rightToLeft: 0, argCount: 2 }, prefix: { symbol: "+", f: l, notation: "prefix", precedence: 3, rightToLeft: 0, argCount: 1 }, symbol: "+", regSymbol: "\\+" }, "-": { infix: { symbol: "-", f: function(t2, e2) {
        return t2 - e2;
      }, notation: "infix", precedence: 2, rightToLeft: 0, argCount: 2 }, prefix: { symbol: "-", f: function(t2) {
        return -t2;
      }, notation: "prefix", precedence: 3, rightToLeft: 0, argCount: 1 }, symbol: "-", regSymbol: "-" }, ",": { infix: { symbol: ",", f: function() {
        return Array.of.apply(Array, arguments);
      }, notation: "infix", precedence: 1, rightToLeft: 0, argCount: 2 }, symbol: ",", regSymbol: "," }, "(": { prefix: { symbol: "(", f: l, notation: "prefix", precedence: 0, rightToLeft: 0, argCount: 1 }, symbol: "(", regSymbol: "\\(" }, ")": { postfix: { symbol: ")", f: void 0, notation: "postfix", precedence: 0, rightToLeft: 0, argCount: 1 }, symbol: ")", regSymbol: "\\)" }, min: { func: { symbol: "min", f: function() {
        return Math.min.apply(Math, arguments);
      }, notation: "func", precedence: 0, rightToLeft: 0, argCount: 1 }, symbol: "min", regSymbol: "min\\b" }, max: { func: { symbol: "max", f: function() {
        return Math.max.apply(Math, arguments);
      }, notation: "func", precedence: 0, rightToLeft: 0, argCount: 1 }, symbol: "max", regSymbol: "max\\b" } } };
      var d = function(t2) {
        var e2, n2;
        function r2(e3) {
          return function(t3) {
            if (void 0 === t3) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
            return t3;
          }(t2.call(this, "An error occurred. See https://github.com/styled-components/polished/blob/main/src/internalHelpers/errors.md#" + e3 + " for more information.") || this);
        }
        return n2 = t2, (e2 = r2).prototype = Object.create(n2.prototype), e2.prototype.constructor = e2, e2.__proto__ = n2, r2;
      }(c(Error)), p = /((?!\w)a|na|hc|mc|dg|me[r]?|xe|ni(?![a-zA-Z])|mm|cp|tp|xp|q(?!s)|hv|xamv|nimv|wv|sm|s(?!\D|$)|ged|darg?|nrut)/g;
      function f(t2, e2) {
        var n2, r2 = t2.pop();
        return e2.push(r2.f.apply(r2, (n2 = []).concat.apply(n2, e2.splice(-r2.argCount)))), r2.precedence;
      }
      function m(t2, e2) {
        var n2, i2 = function(t3) {
          var e3 = {};
          return e3.symbols = t3 ? r({}, h.symbols, t3.symbols) : r({}, h.symbols), e3;
        }(e2), o2 = [i2.symbols["("].prefix], a2 = [], s2 = new RegExp("\\d+(?:\\.\\d+)?|" + Object.keys(i2.symbols).map(function(t3) {
          return i2.symbols[t3];
        }).sort(function(t3, e3) {
          return e3.symbol.length - t3.symbol.length;
        }).map(function(t3) {
          return t3.regSymbol;
        }).join("|") + "|(\\S)", "g");
        s2.lastIndex = 0;
        var c2 = false;
        do {
          var u2 = (n2 = s2.exec(t2)) || [")", void 0], l2 = u2[0], p2 = u2[1], m2 = i2.symbols[l2], g2 = m2 && !m2.prefix && !m2.func, v2 = !m2 || !m2.postfix && !m2.infix;
          if (p2 || (c2 ? v2 : g2)) throw new d(37, n2 ? n2.index : t2.length, t2);
          if (c2) {
            var y2 = m2.postfix || m2.infix;
            do {
              var x2 = o2[o2.length - 1];
              if ((y2.precedence - x2.precedence || x2.rightToLeft) > 0) break;
            } while (f(o2, a2));
            c2 = "postfix" === y2.notation, ")" !== y2.symbol && (o2.push(y2), c2 && f(o2, a2));
          } else if (m2) {
            if (o2.push(m2.prefix || m2.func), m2.func && (!(n2 = s2.exec(t2)) || "(" !== n2[0])) throw new d(38, n2 ? n2.index : t2.length, t2);
          } else a2.push(+l2), c2 = true;
        } while (n2 && o2.length);
        if (o2.length) throw new d(39, n2 ? n2.index : t2.length, t2);
        if (n2) throw new d(40, n2 ? n2.index : t2.length, t2);
        return a2.pop();
      }
      function g(t2) {
        return t2.split("").reverse().join("");
      }
      function v(t2, e2) {
        var n2 = g(t2), r2 = n2.match(p);
        if (r2 && !r2.every(function(t3) {
          return t3 === r2[0];
        })) throw new d(41);
        return "" + m(g(n2.replace(p, "")), e2) + (r2 ? g(r2[0]) : "");
      }
      var y = /--[\S]*/g;
      function x(t2, e2) {
        if (!t2 || !t2.match(y)) throw new d(73);
        var n2;
        if ("undefined" != typeof document && null !== document.documentElement && (n2 = getComputedStyle(document.documentElement).getPropertyValue(t2)), n2) return n2.trim();
        if (e2) return e2;
        throw new d(74);
      }
      function b(t2) {
        return t2.charAt(0).toUpperCase() + t2.slice(1);
      }
      var w = ["Top", "Right", "Bottom", "Left"];
      function _(t2, e2) {
        if (!t2) return e2.toLowerCase();
        var n2 = t2.split("-");
        if (n2.length > 1) return n2.splice(1, 0, e2), n2.reduce(function(t3, e3) {
          return "" + t3 + b(e3);
        });
        var r2 = t2.replace(/([a-z])([A-Z])/g, "$1" + e2 + "$2");
        return t2 === r2 ? "" + t2 + e2 : r2;
      }
      function M(t2, e2) {
        for (var n2 = {}, r2 = 0; r2 < e2.length; r2 += 1) (e2[r2] || 0 === e2[r2]) && (n2[_(t2, w[r2])] = e2[r2]);
        return n2;
      }
      function S(t2) {
        for (var e2 = arguments.length, n2 = new Array(e2 > 1 ? e2 - 1 : 0), r2 = 1; r2 < e2; r2++) n2[r2 - 1] = arguments[r2];
        var i2 = n2[0], o2 = n2[1], a2 = void 0 === o2 ? i2 : o2, s2 = n2[2], c2 = void 0 === s2 ? i2 : s2, u2 = n2[3], l2 = void 0 === u2 ? a2 : u2, h2 = [i2, a2, c2, l2];
        return M(t2, h2);
      }
      function T(t2, e2) {
        return t2.substr(-e2.length) === e2;
      }
      var E = /^([+-]?(?:\d+|\d*\.\d+))([a-z]*|%)$/;
      function A(t2) {
        return "string" != typeof t2 ? t2 : t2.match(E) ? parseFloat(t2) : t2;
      }
      var C = function(t2) {
        return function(e2, n2) {
          void 0 === n2 && (n2 = "16px");
          var r2 = e2, i2 = n2;
          if ("string" == typeof e2) {
            if (!T(e2, "px")) throw new d(69, t2, e2);
            r2 = A(e2);
          }
          if ("string" == typeof n2) {
            if (!T(n2, "px")) throw new d(70, t2, n2);
            i2 = A(n2);
          }
          if ("string" == typeof r2) throw new d(71, e2, t2);
          if ("string" == typeof i2) throw new d(72, n2, t2);
          return "" + r2 / i2 + t2;
        };
      }, L = C("em"), P = /^([+-]?(?:\d+|\d*\.\d+))([a-z]*|%)$/;
      function R(t2) {
        if ("string" != typeof t2) return [t2, ""];
        var e2 = t2.match(P);
        return e2 ? [parseFloat(t2), e2[2]] : [t2, void 0];
      }
      function O(t2, e2) {
        if ("object" != typeof t2 || null === t2) throw new d(75, typeof t2);
        var n2 = {};
        return Object.keys(t2).forEach(function(r2) {
          "object" == typeof t2[r2] && null !== t2[r2] ? n2[r2] = O(t2[r2], e2) : !e2 || e2 && (e2 === r2 || e2.indexOf(r2) >= 0) ? n2[r2] = t2[r2] + " !important" : n2[r2] = t2[r2];
        }), n2;
      }
      var D = { minorSecond: 1.067, majorSecond: 1.125, minorThird: 1.2, majorThird: 1.25, perfectFourth: 1.333, augFourth: 1.414, perfectFifth: 1.5, minorSixth: 1.6, goldenSection: 1.618, majorSixth: 1.667, minorSeventh: 1.778, majorSeventh: 1.875, octave: 2, majorTenth: 2.5, majorEleventh: 2.667, majorTwelfth: 3, doubleOctave: 4 };
      function I(t2, e2, n2) {
        if (void 0 === e2 && (e2 = "1em"), void 0 === n2 && (n2 = 1.333), "number" != typeof t2) throw new d(42);
        if ("string" == typeof n2 && !D[n2]) throw new d(43);
        var r2 = "string" == typeof e2 ? R(e2) : [e2, ""], i2 = r2[0], o2 = r2[1], a2 = "string" == typeof n2 ? D[n2] : n2;
        if ("string" == typeof i2) throw new d(44, e2);
        return "" + i2 * Math.pow(a2, t2) + (o2 || "");
      }
      var N = C("rem"), z = { back: "cubic-bezier(0.600, -0.280, 0.735, 0.045)", circ: "cubic-bezier(0.600,  0.040, 0.980, 0.335)", cubic: "cubic-bezier(0.550,  0.055, 0.675, 0.190)", expo: "cubic-bezier(0.950,  0.050, 0.795, 0.035)", quad: "cubic-bezier(0.550,  0.085, 0.680, 0.530)", quart: "cubic-bezier(0.895,  0.030, 0.685, 0.220)", quint: "cubic-bezier(0.755,  0.050, 0.855, 0.060)", sine: "cubic-bezier(0.470,  0.000, 0.745, 0.715)" };
      function k(t2) {
        return z[t2.toLowerCase().trim()];
      }
      var F = { back: "cubic-bezier(0.680, -0.550, 0.265, 1.550)", circ: "cubic-bezier(0.785,  0.135, 0.150, 0.860)", cubic: "cubic-bezier(0.645,  0.045, 0.355, 1.000)", expo: "cubic-bezier(1.000,  0.000, 0.000, 1.000)", quad: "cubic-bezier(0.455,  0.030, 0.515, 0.955)", quart: "cubic-bezier(0.770,  0.000, 0.175, 1.000)", quint: "cubic-bezier(0.860,  0.000, 0.070, 1.000)", sine: "cubic-bezier(0.445,  0.050, 0.550, 0.950)" };
      function B(t2) {
        return F[t2.toLowerCase().trim()];
      }
      var H = { back: "cubic-bezier(0.175,  0.885, 0.320, 1.275)", cubic: "cubic-bezier(0.215,  0.610, 0.355, 1.000)", circ: "cubic-bezier(0.075,  0.820, 0.165, 1.000)", expo: "cubic-bezier(0.190,  1.000, 0.220, 1.000)", quad: "cubic-bezier(0.250,  0.460, 0.450, 0.940)", quart: "cubic-bezier(0.165,  0.840, 0.440, 1.000)", quint: "cubic-bezier(0.230,  1.000, 0.320, 1.000)", sine: "cubic-bezier(0.390,  0.575, 0.565, 1.000)" };
      function G(t2) {
        return H[t2.toLowerCase().trim()];
      }
      function U(t2, e2, n2, r2) {
        void 0 === n2 && (n2 = "320px"), void 0 === r2 && (r2 = "1200px");
        var i2 = R(t2), o2 = i2[0], a2 = i2[1], s2 = R(e2), c2 = s2[0], u2 = s2[1], l2 = R(n2), h2 = l2[0], p2 = l2[1], f2 = R(r2), m2 = f2[0], g2 = f2[1];
        if ("number" != typeof h2 || "number" != typeof m2 || !p2 || !g2 || p2 !== g2) throw new d(47);
        if ("number" != typeof o2 || "number" != typeof c2 || a2 !== u2) throw new d(48);
        if (a2 !== p2 || u2 !== g2) throw new d(76);
        var v2 = (o2 - c2) / (h2 - m2);
        return "calc(" + (c2 - v2 * m2).toFixed(2) + (a2 || "") + " + " + (100 * v2).toFixed(2) + "vw)";
      }
      function j(t2) {
        var e2;
        return void 0 === t2 && (t2 = "&"), (e2 = {})[t2 + "::after"] = { clear: "both", content: '""', display: "table" }, e2;
      }
      function V(t2) {
        return void 0 === t2 && (t2 = 0), { position: "absolute", top: t2, right: t2, bottom: t2, left: t2 };
      }
      function W(t2, e2) {
        void 0 === e2 && (e2 = 1);
        var n2 = { display: "inline-block", maxWidth: t2 || "100%", overflow: "hidden", textOverflow: "ellipsis", whiteSpace: "nowrap", wordWrap: "normal" };
        return e2 > 1 ? r({}, n2, { WebkitBoxOrient: "vertical", WebkitLineClamp: e2, display: "-webkit-box", whiteSpace: "normal" }) : n2;
      }
      function q(t2, e2) {
        var n2;
        if ("undefined" == typeof Symbol || null == t2[Symbol.iterator]) {
          if (Array.isArray(t2) || (n2 = function(t3, e3) {
            if (!t3) return;
            if ("string" == typeof t3) return X(t3, e3);
            var n3 = Object.prototype.toString.call(t3).slice(8, -1);
            "Object" === n3 && t3.constructor && (n3 = t3.constructor.name);
            if ("Map" === n3 || "Set" === n3) return Array.from(t3);
            if ("Arguments" === n3 || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n3)) return X(t3, e3);
          }(t2)) || e2 && t2 && "number" == typeof t2.length) {
            n2 && (t2 = n2);
            var r2 = 0;
            return function() {
              return r2 >= t2.length ? { done: true } : { done: false, value: t2[r2++] };
            };
          }
          throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
        }
        return (n2 = t2[Symbol.iterator]()).next.bind(n2);
      }
      function X(t2, e2) {
        (null == e2 || e2 > t2.length) && (e2 = t2.length);
        for (var n2 = 0, r2 = new Array(e2); n2 < e2; n2++) r2[n2] = t2[n2];
        return r2;
      }
      function Y(t2, e2, n2) {
        if (void 0 === e2 && (e2 = "320px"), void 0 === n2 && (n2 = "1200px"), !Array.isArray(t2) && "object" != typeof t2 || null === t2) throw new d(49);
        if (Array.isArray(t2)) {
          for (var i2, o2 = {}, a2 = {}, s2 = q(t2); !(i2 = s2()).done; ) {
            var c2, u2, l2 = i2.value;
            if (!l2.prop || !l2.fromSize || !l2.toSize) throw new d(50);
            a2[l2.prop] = l2.fromSize, o2["@media (min-width: " + e2 + ")"] = r({}, o2["@media (min-width: " + e2 + ")"], ((c2 = {})[l2.prop] = U(l2.fromSize, l2.toSize, e2, n2), c2)), o2["@media (min-width: " + n2 + ")"] = r({}, o2["@media (min-width: " + n2 + ")"], ((u2 = {})[l2.prop] = l2.toSize, u2));
          }
          return r({}, a2, o2);
        }
        var h2, p2, f2;
        if (!t2.prop || !t2.fromSize || !t2.toSize) throw new d(51);
        return (f2 = {})[t2.prop] = t2.fromSize, f2["@media (min-width: " + e2 + ")"] = ((h2 = {})[t2.prop] = U(t2.fromSize, t2.toSize, e2, n2), h2), f2["@media (min-width: " + n2 + ")"] = ((p2 = {})[t2.prop] = t2.toSize, p2), f2;
      }
      var Z = /^\s*data:([a-z]+\/[a-z-]+(;[a-z-]+=[a-z-]+)?)?(;charset=[a-z0-9-]+)?(;base64)?,[a-z0-9!$&',()*+,;=\-._~:@/?%\s]*\s*$/i, J = { woff: "woff", woff2: "woff2", ttf: "truetype", otf: "opentype", eot: "embedded-opentype", svg: "svg", svgz: "svg" };
      function $(t2, e2) {
        return e2 ? ' format("' + J[t2] + '")' : "";
      }
      function Q(t2, e2, n2) {
        return function(t3) {
          return !!t3.match(Z);
        }(t2) ? 'url("' + t2 + '")' + $(e2[0], n2) : e2.map(function(e3) {
          return 'url("' + t2 + "." + e3 + '")' + $(e3, n2);
        }).join(", ");
      }
      function K(t2, e2, n2, r2) {
        var i2 = [];
        return e2 && i2.push(function(t3) {
          return t3.map(function(t4) {
            return 'local("' + t4 + '")';
          }).join(", ");
        }(e2)), t2 && i2.push(Q(t2, n2, r2)), i2.join(", ");
      }
      function tt(t2) {
        var e2 = t2.fontFamily, n2 = t2.fontFilePath, r2 = t2.fontStretch, i2 = t2.fontStyle, o2 = t2.fontVariant, a2 = t2.fontWeight, s2 = t2.fileFormats, c2 = void 0 === s2 ? ["eot", "woff2", "woff", "ttf", "svg"] : s2, u2 = t2.formatHint, l2 = void 0 !== u2 && u2, h2 = t2.localFonts, p2 = void 0 === h2 ? [e2] : h2, f2 = t2.unicodeRange, m2 = t2.fontDisplay, g2 = t2.fontVariationSettings, v2 = t2.fontFeatureSettings;
        if (!e2) throw new d(55);
        if (!n2 && !p2) throw new d(52);
        if (p2 && !Array.isArray(p2)) throw new d(53);
        if (!Array.isArray(c2)) throw new d(54);
        var y2 = { "@font-face": { fontFamily: e2, src: K(n2, p2, c2, l2), unicodeRange: f2, fontStretch: r2, fontStyle: i2, fontVariant: o2, fontWeight: a2, fontDisplay: m2, fontVariationSettings: g2, fontFeatureSettings: v2 } };
        return JSON.parse(JSON.stringify(y2));
      }
      function et() {
        return { textIndent: "101%", overflow: "hidden", whiteSpace: "nowrap" };
      }
      function nt() {
        return { border: "0", clip: "rect(0 0 0 0)", height: "1px", margin: "-1px", overflow: "hidden", padding: "0", position: "absolute", whiteSpace: "nowrap", width: "1px" };
      }
      function rt(t2) {
        return void 0 === t2 && (t2 = 1.3), "\n    @media only screen and (-webkit-min-device-pixel-ratio: " + t2 + "),\n    only screen and (min--moz-device-pixel-ratio: " + t2 + "),\n    only screen and (-o-min-device-pixel-ratio: " + t2 + "/1),\n    only screen and (min-resolution: " + Math.round(96 * t2) + "dpi),\n    only screen and (min-resolution: " + t2 + "dppx)\n  ";
      }
      function it(t2) {
        for (var e2 = "", n2 = arguments.length, r2 = new Array(n2 > 1 ? n2 - 1 : 0), i2 = 1; i2 < n2; i2++) r2[i2 - 1] = arguments[i2];
        for (var o2 = 0; o2 < t2.length; o2 += 1) if (e2 += t2[o2], o2 === r2.length - 1 && r2[o2]) {
          var a2 = r2.filter(function(t3) {
            return !!t3;
          });
          a2.length > 1 ? (e2 = e2.slice(0, -1), e2 += ", " + r2[o2]) : 1 === a2.length && (e2 += "" + r2[o2]);
        } else r2[o2] && (e2 += r2[o2] + " ");
        return e2.trim();
      }
      function ot() {
        var t2 = u(["linear-gradient(", "", ")"]);
        return ot = function() {
          return t2;
        }, t2;
      }
      function at(t2) {
        var e2 = t2.colorStops, n2 = t2.fallback, r2 = t2.toDirection, i2 = void 0 === r2 ? "" : r2;
        if (!e2 || e2.length < 2) throw new d(56);
        return { backgroundColor: n2 || e2[0].replace(/,\s+/g, ",").split(" ")[0].replace(/,(?=\S)/g, ", "), backgroundImage: it(ot(), i2, e2.join(", ").replace(/,(?=\S)/g, ", ")) };
      }
      function st() {
        var t2;
        return [(t2 = { html: { lineHeight: "1.15", textSizeAdjust: "100%" }, body: { margin: "0" }, main: { display: "block" }, h1: { fontSize: "2em", margin: "0.67em 0" }, hr: { boxSizing: "content-box", height: "0", overflow: "visible" }, pre: { fontFamily: "monospace, monospace", fontSize: "1em" }, a: { backgroundColor: "transparent" }, "abbr[title]": { borderBottom: "none", textDecoration: "underline" } }, t2["b,\n    strong"] = { fontWeight: "bolder" }, t2["code,\n    kbd,\n    samp"] = { fontFamily: "monospace, monospace", fontSize: "1em" }, t2.small = { fontSize: "80%" }, t2["sub,\n    sup"] = { fontSize: "75%", lineHeight: "0", position: "relative", verticalAlign: "baseline" }, t2.sub = { bottom: "-0.25em" }, t2.sup = { top: "-0.5em" }, t2.img = { borderStyle: "none" }, t2["button,\n    input,\n    optgroup,\n    select,\n    textarea"] = { fontFamily: "inherit", fontSize: "100%", lineHeight: "1.15", margin: "0" }, t2["button,\n    input"] = { overflow: "visible" }, t2["button,\n    select"] = { textTransform: "none" }, t2['button,\n    html [type="button"],\n    [type="reset"],\n    [type="submit"]'] = { WebkitAppearance: "button" }, t2['button::-moz-focus-inner,\n    [type="button"]::-moz-focus-inner,\n    [type="reset"]::-moz-focus-inner,\n    [type="submit"]::-moz-focus-inner'] = { borderStyle: "none", padding: "0" }, t2['button:-moz-focusring,\n    [type="button"]:-moz-focusring,\n    [type="reset"]:-moz-focusring,\n    [type="submit"]:-moz-focusring'] = { outline: "1px dotted ButtonText" }, t2.fieldset = { padding: "0.35em 0.625em 0.75em" }, t2.legend = { boxSizing: "border-box", color: "inherit", display: "table", maxWidth: "100%", padding: "0", whiteSpace: "normal" }, t2.progress = { verticalAlign: "baseline" }, t2.textarea = { overflow: "auto" }, t2['[type="checkbox"],\n    [type="radio"]'] = { boxSizing: "border-box", padding: "0" }, t2['[type="number"]::-webkit-inner-spin-button,\n    [type="number"]::-webkit-outer-spin-button'] = { height: "auto" }, t2['[type="search"]'] = { WebkitAppearance: "textfield", outlineOffset: "-2px" }, t2['[type="search"]::-webkit-search-decoration'] = { WebkitAppearance: "none" }, t2["::-webkit-file-upload-button"] = { WebkitAppearance: "button", font: "inherit" }, t2.details = { display: "block" }, t2.summary = { display: "list-item" }, t2.template = { display: "none" }, t2["[hidden]"] = { display: "none" }, t2), { "abbr[title]": { textDecoration: "underline dotted" } }];
      }
      function ct() {
        var t2 = u(["radial-gradient(", "", "", "", ")"]);
        return ct = function() {
          return t2;
        }, t2;
      }
      function ut(t2) {
        var e2 = t2.colorStops, n2 = t2.extent, r2 = void 0 === n2 ? "" : n2, i2 = t2.fallback, o2 = t2.position, a2 = void 0 === o2 ? "" : o2, s2 = t2.shape, c2 = void 0 === s2 ? "" : s2;
        if (!e2 || e2.length < 2) throw new d(57);
        return { backgroundColor: i2 || e2[0].split(" ")[0], backgroundImage: it(ct(), a2, c2, r2, e2.join(", ")) };
      }
      function lt(t2, e2, n2, i2, o2) {
        var a2;
        if (void 0 === n2 && (n2 = "png"), void 0 === o2 && (o2 = "_2x"), !t2) throw new d(58);
        var s2 = n2.replace(/^\./, ""), c2 = i2 ? i2 + "." + s2 : "" + t2 + o2 + "." + s2;
        return (a2 = { backgroundImage: "url(" + t2 + "." + s2 + ")" })[rt()] = r({ backgroundImage: "url(" + c2 + ")" }, e2 ? { backgroundSize: e2 } : {}), a2;
      }
      var ht = { easeInBack: "cubic-bezier(0.600, -0.280, 0.735, 0.045)", easeInCirc: "cubic-bezier(0.600,  0.040, 0.980, 0.335)", easeInCubic: "cubic-bezier(0.550,  0.055, 0.675, 0.190)", easeInExpo: "cubic-bezier(0.950,  0.050, 0.795, 0.035)", easeInQuad: "cubic-bezier(0.550,  0.085, 0.680, 0.530)", easeInQuart: "cubic-bezier(0.895,  0.030, 0.685, 0.220)", easeInQuint: "cubic-bezier(0.755,  0.050, 0.855, 0.060)", easeInSine: "cubic-bezier(0.470,  0.000, 0.745, 0.715)", easeOutBack: "cubic-bezier(0.175,  0.885, 0.320, 1.275)", easeOutCubic: "cubic-bezier(0.215,  0.610, 0.355, 1.000)", easeOutCirc: "cubic-bezier(0.075,  0.820, 0.165, 1.000)", easeOutExpo: "cubic-bezier(0.190,  1.000, 0.220, 1.000)", easeOutQuad: "cubic-bezier(0.250,  0.460, 0.450, 0.940)", easeOutQuart: "cubic-bezier(0.165,  0.840, 0.440, 1.000)", easeOutQuint: "cubic-bezier(0.230,  1.000, 0.320, 1.000)", easeOutSine: "cubic-bezier(0.390,  0.575, 0.565, 1.000)", easeInOutBack: "cubic-bezier(0.680, -0.550, 0.265, 1.550)", easeInOutCirc: "cubic-bezier(0.785,  0.135, 0.150, 0.860)", easeInOutCubic: "cubic-bezier(0.645,  0.045, 0.355, 1.000)", easeInOutExpo: "cubic-bezier(1.000,  0.000, 0.000, 1.000)", easeInOutQuad: "cubic-bezier(0.455,  0.030, 0.515, 0.955)", easeInOutQuart: "cubic-bezier(0.770,  0.000, 0.175, 1.000)", easeInOutQuint: "cubic-bezier(0.860,  0.000, 0.070, 1.000)", easeInOutSine: "cubic-bezier(0.445,  0.050, 0.550, 0.950)" };
      function dt(t2) {
        return ht[t2];
      }
      var pt = function(t2, e2, n2) {
        var r2 = "" + n2[0] + (n2[1] || ""), i2 = "" + n2[0] / 2 + (n2[1] || ""), o2 = "" + e2[0] + (e2[1] || ""), a2 = "" + e2[0] / 2 + (e2[1] || "");
        switch (t2) {
          case "top":
            return "0 " + i2 + " " + o2 + " " + i2;
          case "topLeft":
            return r2 + " " + o2 + " 0 0";
          case "left":
            return a2 + " " + r2 + " " + a2 + " 0";
          case "bottomLeft":
            return r2 + " 0 0 " + o2;
          case "bottom":
            return o2 + " " + i2 + " 0 " + i2;
          case "bottomRight":
            return "0 0 " + r2 + " " + o2;
          case "right":
            return a2 + " 0 " + a2 + " " + r2;
          case "topRight":
          default:
            return "0 " + r2 + " " + o2 + " 0";
        }
      };
      function ft(t2) {
        var e2 = t2.pointingDirection, n2 = t2.height, i2 = t2.width, o2 = t2.foregroundColor, a2 = t2.backgroundColor, s2 = void 0 === a2 ? "transparent" : a2, c2 = R(i2), u2 = R(n2);
        if (isNaN(u2[0]) || isNaN(c2[0])) throw new d(60);
        return r({ width: "0", height: "0", borderColor: s2 }, function(t3, e3) {
          switch (t3) {
            case "top":
            case "bottomRight":
              return { borderBottomColor: e3 };
            case "right":
            case "bottomLeft":
              return { borderLeftColor: e3 };
            case "bottom":
            case "topLeft":
              return { borderTopColor: e3 };
            case "left":
            case "topRight":
              return { borderRightColor: e3 };
            default:
              throw new d(59);
          }
        }(e2, o2), { borderStyle: "solid", borderWidth: pt(e2, u2, c2) });
      }
      function mt(t2) {
        return void 0 === t2 && (t2 = "break-word"), { overflowWrap: t2, wordWrap: t2, wordBreak: "break-word" === t2 ? "break-all" : t2 };
      }
      function gt(t2) {
        return Math.round(255 * t2);
      }
      function vt(t2, e2, n2) {
        return gt(t2) + "," + gt(e2) + "," + gt(n2);
      }
      function yt(t2, e2, n2, r2) {
        if (void 0 === r2 && (r2 = vt), 0 === e2) return r2(n2, n2, n2);
        var i2 = (t2 % 360 + 360) % 360 / 60, o2 = (1 - Math.abs(2 * n2 - 1)) * e2, a2 = o2 * (1 - Math.abs(i2 % 2 - 1)), s2 = 0, c2 = 0, u2 = 0;
        i2 >= 0 && i2 < 1 ? (s2 = o2, c2 = a2) : i2 >= 1 && i2 < 2 ? (s2 = a2, c2 = o2) : i2 >= 2 && i2 < 3 ? (c2 = o2, u2 = a2) : i2 >= 3 && i2 < 4 ? (c2 = a2, u2 = o2) : i2 >= 4 && i2 < 5 ? (s2 = a2, u2 = o2) : i2 >= 5 && i2 < 6 && (s2 = o2, u2 = a2);
        var l2 = n2 - o2 / 2;
        return r2(s2 + l2, c2 + l2, u2 + l2);
      }
      var xt = { aliceblue: "f0f8ff", antiquewhite: "faebd7", aqua: "00ffff", aquamarine: "7fffd4", azure: "f0ffff", beige: "f5f5dc", bisque: "ffe4c4", black: "000", blanchedalmond: "ffebcd", blue: "0000ff", blueviolet: "8a2be2", brown: "a52a2a", burlywood: "deb887", cadetblue: "5f9ea0", chartreuse: "7fff00", chocolate: "d2691e", coral: "ff7f50", cornflowerblue: "6495ed", cornsilk: "fff8dc", crimson: "dc143c", cyan: "00ffff", darkblue: "00008b", darkcyan: "008b8b", darkgoldenrod: "b8860b", darkgray: "a9a9a9", darkgreen: "006400", darkgrey: "a9a9a9", darkkhaki: "bdb76b", darkmagenta: "8b008b", darkolivegreen: "556b2f", darkorange: "ff8c00", darkorchid: "9932cc", darkred: "8b0000", darksalmon: "e9967a", darkseagreen: "8fbc8f", darkslateblue: "483d8b", darkslategray: "2f4f4f", darkslategrey: "2f4f4f", darkturquoise: "00ced1", darkviolet: "9400d3", deeppink: "ff1493", deepskyblue: "00bfff", dimgray: "696969", dimgrey: "696969", dodgerblue: "1e90ff", firebrick: "b22222", floralwhite: "fffaf0", forestgreen: "228b22", fuchsia: "ff00ff", gainsboro: "dcdcdc", ghostwhite: "f8f8ff", gold: "ffd700", goldenrod: "daa520", gray: "808080", green: "008000", greenyellow: "adff2f", grey: "808080", honeydew: "f0fff0", hotpink: "ff69b4", indianred: "cd5c5c", indigo: "4b0082", ivory: "fffff0", khaki: "f0e68c", lavender: "e6e6fa", lavenderblush: "fff0f5", lawngreen: "7cfc00", lemonchiffon: "fffacd", lightblue: "add8e6", lightcoral: "f08080", lightcyan: "e0ffff", lightgoldenrodyellow: "fafad2", lightgray: "d3d3d3", lightgreen: "90ee90", lightgrey: "d3d3d3", lightpink: "ffb6c1", lightsalmon: "ffa07a", lightseagreen: "20b2aa", lightskyblue: "87cefa", lightslategray: "789", lightslategrey: "789", lightsteelblue: "b0c4de", lightyellow: "ffffe0", lime: "0f0", limegreen: "32cd32", linen: "faf0e6", magenta: "f0f", maroon: "800000", mediumaquamarine: "66cdaa", mediumblue: "0000cd", mediumorchid: "ba55d3", mediumpurple: "9370db", mediumseagreen: "3cb371", mediumslateblue: "7b68ee", mediumspringgreen: "00fa9a", mediumturquoise: "48d1cc", mediumvioletred: "c71585", midnightblue: "191970", mintcream: "f5fffa", mistyrose: "ffe4e1", moccasin: "ffe4b5", navajowhite: "ffdead", navy: "000080", oldlace: "fdf5e6", olive: "808000", olivedrab: "6b8e23", orange: "ffa500", orangered: "ff4500", orchid: "da70d6", palegoldenrod: "eee8aa", palegreen: "98fb98", paleturquoise: "afeeee", palevioletred: "db7093", papayawhip: "ffefd5", peachpuff: "ffdab9", peru: "cd853f", pink: "ffc0cb", plum: "dda0dd", powderblue: "b0e0e6", purple: "800080", rebeccapurple: "639", red: "f00", rosybrown: "bc8f8f", royalblue: "4169e1", saddlebrown: "8b4513", salmon: "fa8072", sandybrown: "f4a460", seagreen: "2e8b57", seashell: "fff5ee", sienna: "a0522d", silver: "c0c0c0", skyblue: "87ceeb", slateblue: "6a5acd", slategray: "708090", slategrey: "708090", snow: "fffafa", springgreen: "00ff7f", steelblue: "4682b4", tan: "d2b48c", teal: "008080", thistle: "d8bfd8", tomato: "ff6347", turquoise: "40e0d0", violet: "ee82ee", wheat: "f5deb3", white: "fff", whitesmoke: "f5f5f5", yellow: "ff0", yellowgreen: "9acd32" };
      var bt = /^#[a-fA-F0-9]{6}$/, wt = /^#[a-fA-F0-9]{8}$/, _t = /^#[a-fA-F0-9]{3}$/, Mt = /^#[a-fA-F0-9]{4}$/, St = /^rgb\(\s*(\d{1,3})\s*,\s*(\d{1,3})\s*,\s*(\d{1,3})\s*\)$/i, Tt = /^rgba\(\s*(\d{1,3})\s*,\s*(\d{1,3})\s*,\s*(\d{1,3})\s*,\s*([-+]?[0-9]*[.]?[0-9]+)\s*\)$/i, Et = /^hsl\(\s*(\d{0,3}[.]?[0-9]+)\s*,\s*(\d{1,3}[.]?[0-9]?)%\s*,\s*(\d{1,3}[.]?[0-9]?)%\s*\)$/i, At = /^hsla\(\s*(\d{0,3}[.]?[0-9]+)\s*,\s*(\d{1,3}[.]?[0-9]?)%\s*,\s*(\d{1,3}[.]?[0-9]?)%\s*,\s*([-+]?[0-9]*[.]?[0-9]+)\s*\)$/i;
      function Ct(t2) {
        if ("string" != typeof t2) throw new d(3);
        var e2 = function(t3) {
          if ("string" != typeof t3) return t3;
          var e3 = t3.toLowerCase();
          return xt[e3] ? "#" + xt[e3] : t3;
        }(t2);
        if (e2.match(bt)) return { red: parseInt("" + e2[1] + e2[2], 16), green: parseInt("" + e2[3] + e2[4], 16), blue: parseInt("" + e2[5] + e2[6], 16) };
        if (e2.match(wt)) {
          var n2 = parseFloat((parseInt("" + e2[7] + e2[8], 16) / 255).toFixed(2));
          return { red: parseInt("" + e2[1] + e2[2], 16), green: parseInt("" + e2[3] + e2[4], 16), blue: parseInt("" + e2[5] + e2[6], 16), alpha: n2 };
        }
        if (e2.match(_t)) return { red: parseInt("" + e2[1] + e2[1], 16), green: parseInt("" + e2[2] + e2[2], 16), blue: parseInt("" + e2[3] + e2[3], 16) };
        if (e2.match(Mt)) {
          var r2 = parseFloat((parseInt("" + e2[4] + e2[4], 16) / 255).toFixed(2));
          return { red: parseInt("" + e2[1] + e2[1], 16), green: parseInt("" + e2[2] + e2[2], 16), blue: parseInt("" + e2[3] + e2[3], 16), alpha: r2 };
        }
        var i2 = St.exec(e2);
        if (i2) return { red: parseInt("" + i2[1], 10), green: parseInt("" + i2[2], 10), blue: parseInt("" + i2[3], 10) };
        var o2 = Tt.exec(e2);
        if (o2) return { red: parseInt("" + o2[1], 10), green: parseInt("" + o2[2], 10), blue: parseInt("" + o2[3], 10), alpha: parseFloat("" + o2[4]) };
        var a2 = Et.exec(e2);
        if (a2) {
          var s2 = "rgb(" + yt(parseInt("" + a2[1], 10), parseInt("" + a2[2], 10) / 100, parseInt("" + a2[3], 10) / 100) + ")", c2 = St.exec(s2);
          if (!c2) throw new d(4, e2, s2);
          return { red: parseInt("" + c2[1], 10), green: parseInt("" + c2[2], 10), blue: parseInt("" + c2[3], 10) };
        }
        var u2 = At.exec(e2);
        if (u2) {
          var l2 = "rgb(" + yt(parseInt("" + u2[1], 10), parseInt("" + u2[2], 10) / 100, parseInt("" + u2[3], 10) / 100) + ")", h2 = St.exec(l2);
          if (!h2) throw new d(4, e2, l2);
          return { red: parseInt("" + h2[1], 10), green: parseInt("" + h2[2], 10), blue: parseInt("" + h2[3], 10), alpha: parseFloat("" + u2[4]) };
        }
        throw new d(5);
      }
      function Lt(t2) {
        return function(t3) {
          var e2, n2 = t3.red / 255, r2 = t3.green / 255, i2 = t3.blue / 255, o2 = Math.max(n2, r2, i2), a2 = Math.min(n2, r2, i2), s2 = (o2 + a2) / 2;
          if (o2 === a2) return void 0 !== t3.alpha ? { hue: 0, saturation: 0, lightness: s2, alpha: t3.alpha } : { hue: 0, saturation: 0, lightness: s2 };
          var c2 = o2 - a2, u2 = s2 > 0.5 ? c2 / (2 - o2 - a2) : c2 / (o2 + a2);
          switch (o2) {
            case n2:
              e2 = (r2 - i2) / c2 + (r2 < i2 ? 6 : 0);
              break;
            case r2:
              e2 = (i2 - n2) / c2 + 2;
              break;
            default:
              e2 = (n2 - r2) / c2 + 4;
          }
          return e2 *= 60, void 0 !== t3.alpha ? { hue: e2, saturation: u2, lightness: s2, alpha: t3.alpha } : { hue: e2, saturation: u2, lightness: s2 };
        }(Ct(t2));
      }
      var Pt = function(t2) {
        return 7 === t2.length && t2[1] === t2[2] && t2[3] === t2[4] && t2[5] === t2[6] ? "#" + t2[1] + t2[3] + t2[5] : t2;
      };
      function Rt(t2) {
        var e2 = t2.toString(16);
        return 1 === e2.length ? "0" + e2 : e2;
      }
      function Ot(t2) {
        return Rt(Math.round(255 * t2));
      }
      function Dt(t2, e2, n2) {
        return Pt("#" + Ot(t2) + Ot(e2) + Ot(n2));
      }
      function It(t2, e2, n2) {
        return yt(t2, e2, n2, Dt);
      }
      function Nt(t2, e2, n2) {
        if ("number" == typeof t2 && "number" == typeof e2 && "number" == typeof n2) return It(t2, e2, n2);
        if ("object" == typeof t2 && void 0 === e2 && void 0 === n2) return It(t2.hue, t2.saturation, t2.lightness);
        throw new d(1);
      }
      function zt(t2, e2, n2, r2) {
        if ("number" == typeof t2 && "number" == typeof e2 && "number" == typeof n2 && "number" == typeof r2) return r2 >= 1 ? It(t2, e2, n2) : "rgba(" + yt(t2, e2, n2) + "," + r2 + ")";
        if ("object" == typeof t2 && void 0 === e2 && void 0 === n2 && void 0 === r2) return t2.alpha >= 1 ? It(t2.hue, t2.saturation, t2.lightness) : "rgba(" + yt(t2.hue, t2.saturation, t2.lightness) + "," + t2.alpha + ")";
        throw new d(2);
      }
      function kt(t2, e2, n2) {
        if ("number" == typeof t2 && "number" == typeof e2 && "number" == typeof n2) return Pt("#" + Rt(t2) + Rt(e2) + Rt(n2));
        if ("object" == typeof t2 && void 0 === e2 && void 0 === n2) return Pt("#" + Rt(t2.red) + Rt(t2.green) + Rt(t2.blue));
        throw new d(6);
      }
      function Ft(t2, e2, n2, r2) {
        if ("string" == typeof t2 && "number" == typeof e2) {
          var i2 = Ct(t2);
          return "rgba(" + i2.red + "," + i2.green + "," + i2.blue + "," + e2 + ")";
        }
        if ("number" == typeof t2 && "number" == typeof e2 && "number" == typeof n2 && "number" == typeof r2) return r2 >= 1 ? kt(t2, e2, n2) : "rgba(" + t2 + "," + e2 + "," + n2 + "," + r2 + ")";
        if ("object" == typeof t2 && void 0 === e2 && void 0 === n2 && void 0 === r2) return t2.alpha >= 1 ? kt(t2.red, t2.green, t2.blue) : "rgba(" + t2.red + "," + t2.green + "," + t2.blue + "," + t2.alpha + ")";
        throw new d(7);
      }
      function Bt(t2) {
        if ("object" != typeof t2) throw new d(8);
        if (function(t3) {
          return "number" == typeof t3.red && "number" == typeof t3.green && "number" == typeof t3.blue && "number" == typeof t3.alpha;
        }(t2)) return Ft(t2);
        if (function(t3) {
          return "number" == typeof t3.red && "number" == typeof t3.green && "number" == typeof t3.blue && ("number" != typeof t3.alpha || void 0 === t3.alpha);
        }(t2)) return kt(t2);
        if (function(t3) {
          return "number" == typeof t3.hue && "number" == typeof t3.saturation && "number" == typeof t3.lightness && "number" == typeof t3.alpha;
        }(t2)) return zt(t2);
        if (function(t3) {
          return "number" == typeof t3.hue && "number" == typeof t3.saturation && "number" == typeof t3.lightness && ("number" != typeof t3.alpha || void 0 === t3.alpha);
        }(t2)) return Nt(t2);
        throw new d(8);
      }
      function Ht(t2) {
        return /* @__PURE__ */ function t3(e2, n2, r2) {
          return function() {
            var i2 = r2.concat(Array.prototype.slice.call(arguments));
            return i2.length >= n2 ? e2.apply(this, i2) : t3(e2, n2, i2);
          };
        }(t2, t2.length, []);
      }
      function Gt(t2, e2) {
        if ("transparent" === e2) return e2;
        var n2 = Lt(e2);
        return Bt(r({}, n2, { hue: n2.hue + parseFloat(t2) }));
      }
      var Ut = Ht(Gt);
      function jt(t2) {
        if ("transparent" === t2) return t2;
        var e2 = Lt(t2);
        return Bt(r({}, e2, { hue: (e2.hue + 180) % 360 }));
      }
      function Vt(t2, e2, n2) {
        return Math.max(t2, Math.min(e2, n2));
      }
      function Wt(t2, e2) {
        if ("transparent" === e2) return e2;
        var n2 = Lt(e2);
        return Bt(r({}, n2, { lightness: Vt(0, 1, n2.lightness - parseFloat(t2)) }));
      }
      var qt = Ht(Wt);
      function Xt(t2, e2) {
        if ("transparent" === e2) return e2;
        var n2 = Lt(e2);
        return Bt(r({}, n2, { saturation: Vt(0, 1, n2.saturation - parseFloat(t2)) }));
      }
      var Yt = Ht(Xt);
      function Zt(t2) {
        if ("transparent" === t2) return 0;
        var e2 = Ct(t2), n2 = Object.keys(e2).map(function(t3) {
          var n3 = e2[t3] / 255;
          return n3 <= 0.03928 ? n3 / 12.92 : Math.pow((n3 + 0.055) / 1.055, 2.4);
        }), r2 = n2[0], i2 = n2[1], o2 = n2[2];
        return parseFloat((0.2126 * r2 + 0.7152 * i2 + 0.0722 * o2).toFixed(3));
      }
      function Jt(t2, e2) {
        var n2 = Zt(t2), r2 = Zt(e2);
        return parseFloat((n2 > r2 ? (n2 + 0.05) / (r2 + 0.05) : (r2 + 0.05) / (n2 + 0.05)).toFixed(2));
      }
      function $t(t2) {
        return "transparent" === t2 ? t2 : Bt(r({}, Lt(t2), { saturation: 0 }));
      }
      function Qt(t2) {
        if ("object" == typeof t2 && "number" == typeof t2.hue && "number" == typeof t2.saturation && "number" == typeof t2.lightness) return t2.alpha && "number" == typeof t2.alpha ? zt({ hue: t2.hue, saturation: t2.saturation, lightness: t2.lightness, alpha: t2.alpha }) : Nt({ hue: t2.hue, saturation: t2.saturation, lightness: t2.lightness });
        throw new d(45);
      }
      function Kt(t2) {
        if ("transparent" === t2) return t2;
        var e2 = Ct(t2);
        return Bt(r({}, e2, { red: 255 - e2.red, green: 255 - e2.green, blue: 255 - e2.blue }));
      }
      function te(t2, e2) {
        if ("transparent" === e2) return e2;
        var n2 = Lt(e2);
        return Bt(r({}, n2, { lightness: Vt(0, 1, n2.lightness + parseFloat(t2)) }));
      }
      var ee = Ht(te);
      function ne(t2, e2) {
        var n2 = Jt(t2, e2);
        return { AA: n2 >= 4.5, AALarge: n2 >= 3, AAA: n2 >= 7, AAALarge: n2 >= 4.5 };
      }
      function re(t2, e2, n2) {
        if ("transparent" === e2) return n2;
        if ("transparent" === n2) return e2;
        if (0 === t2) return n2;
        var i2 = Ct(e2), o2 = r({}, i2, { alpha: "number" == typeof i2.alpha ? i2.alpha : 1 }), a2 = Ct(n2), s2 = r({}, a2, { alpha: "number" == typeof a2.alpha ? a2.alpha : 1 }), c2 = o2.alpha - s2.alpha, u2 = 2 * parseFloat(t2) - 1, l2 = ((u2 * c2 == -1 ? u2 : u2 + c2) / (1 + u2 * c2) + 1) / 2, h2 = 1 - l2;
        return Ft({ red: Math.floor(o2.red * l2 + s2.red * h2), green: Math.floor(o2.green * l2 + s2.green * h2), blue: Math.floor(o2.blue * l2 + s2.blue * h2), alpha: o2.alpha * (parseFloat(t2) / 1) + s2.alpha * (1 - parseFloat(t2) / 1) });
      }
      var ie = Ht(re);
      function oe(t2, e2) {
        if ("transparent" === e2) return e2;
        var n2 = Ct(e2);
        return Ft(r({}, n2, { alpha: Vt(0, 1, (100 * ("number" == typeof n2.alpha ? n2.alpha : 1) + 100 * parseFloat(t2)) / 100) }));
      }
      var ae = Ht(oe);
      function se(t2, e2, n2, r2) {
        void 0 === e2 && (e2 = "#000"), void 0 === n2 && (n2 = "#fff"), void 0 === r2 && (r2 = true);
        var i2 = Zt(t2) > 0.179, o2 = i2 ? e2 : n2;
        return !r2 || Jt(t2, o2) >= 4.5 ? o2 : i2 ? "#000" : "#fff";
      }
      function ce(t2) {
        if ("object" == typeof t2 && "number" == typeof t2.red && "number" == typeof t2.green && "number" == typeof t2.blue) return "number" == typeof t2.alpha ? Ft({ red: t2.red, green: t2.green, blue: t2.blue, alpha: t2.alpha }) : kt({ red: t2.red, green: t2.green, blue: t2.blue });
        throw new d(46);
      }
      function ue(t2, e2) {
        if ("transparent" === e2) return e2;
        var n2 = Lt(e2);
        return Bt(r({}, n2, { saturation: Vt(0, 1, n2.saturation + parseFloat(t2)) }));
      }
      var le = Ht(ue);
      function he(t2, e2) {
        return "transparent" === e2 ? e2 : Bt(r({}, Lt(e2), { hue: parseFloat(t2) }));
      }
      var de = Ht(he);
      function pe(t2, e2) {
        return "transparent" === e2 ? e2 : Bt(r({}, Lt(e2), { lightness: parseFloat(t2) }));
      }
      var fe = Ht(pe);
      function me(t2, e2) {
        return "transparent" === e2 ? e2 : Bt(r({}, Lt(e2), { saturation: parseFloat(t2) }));
      }
      var ge = Ht(me);
      function ve(t2, e2) {
        return "transparent" === e2 ? e2 : ie(parseFloat(t2), "rgb(0, 0, 0)", e2);
      }
      var ye = Ht(ve);
      function xe(t2, e2) {
        return "transparent" === e2 ? e2 : ie(parseFloat(t2), "rgb(255, 255, 255)", e2);
      }
      var be = Ht(xe);
      function we(t2, e2) {
        if ("transparent" === e2) return e2;
        var n2 = Ct(e2);
        return Ft(r({}, n2, { alpha: Vt(0, 1, +(100 * ("number" == typeof n2.alpha ? n2.alpha : 1) - 100 * parseFloat(t2)).toFixed(2) / 100) }));
      }
      var _e = Ht(we);
      function Me() {
        for (var t2 = arguments.length, e2 = new Array(t2), n2 = 0; n2 < t2; n2++) e2[n2] = arguments[n2];
        var r2 = Array.isArray(e2[0]);
        if (!r2 && e2.length > 8) throw new d(64);
        var i2 = e2.map(function(t3) {
          if (r2 && !Array.isArray(t3) || !r2 && Array.isArray(t3)) throw new d(65);
          if (Array.isArray(t3) && t3.length > 8) throw new d(66);
          return Array.isArray(t3) ? t3.join(" ") : t3;
        }).join(", ");
        return { animation: i2 };
      }
      function Se() {
        for (var t2 = arguments.length, e2 = new Array(t2), n2 = 0; n2 < t2; n2++) e2[n2] = arguments[n2];
        return { backgroundImage: e2.join(", ") };
      }
      function Te() {
        for (var t2 = arguments.length, e2 = new Array(t2), n2 = 0; n2 < t2; n2++) e2[n2] = arguments[n2];
        return { background: e2.join(", ") };
      }
      var Ee = ["top", "right", "bottom", "left"];
      function Ae(t2) {
        for (var e2 = arguments.length, n2 = new Array(e2 > 1 ? e2 - 1 : 0), r2 = 1; r2 < e2; r2++) n2[r2 - 1] = arguments[r2];
        var i2;
        return "string" == typeof t2 && Ee.indexOf(t2) >= 0 ? ((i2 = {})["border" + b(t2) + "Width"] = n2[0], i2["border" + b(t2) + "Style"] = n2[1], i2["border" + b(t2) + "Color"] = n2[2], i2) : (n2.unshift(t2), { borderWidth: n2[0], borderStyle: n2[1], borderColor: n2[2] });
      }
      function Ce() {
        for (var t2 = arguments.length, e2 = new Array(t2), n2 = 0; n2 < t2; n2++) e2[n2] = arguments[n2];
        return S.apply(void 0, ["borderColor"].concat(e2));
      }
      function Le(t2, e2) {
        var n2, r2, i2 = b(t2);
        if (!e2 && 0 !== e2) throw new d(62);
        if ("Top" === i2 || "Bottom" === i2) return (n2 = {})["border" + i2 + "RightRadius"] = e2, n2["border" + i2 + "LeftRadius"] = e2, n2;
        if ("Left" === i2 || "Right" === i2) return (r2 = {})["borderTop" + i2 + "Radius"] = e2, r2["borderBottom" + i2 + "Radius"] = e2, r2;
        throw new d(63);
      }
      function Pe() {
        for (var t2 = arguments.length, e2 = new Array(t2), n2 = 0; n2 < t2; n2++) e2[n2] = arguments[n2];
        return S.apply(void 0, ["borderStyle"].concat(e2));
      }
      function Re() {
        for (var t2 = arguments.length, e2 = new Array(t2), n2 = 0; n2 < t2; n2++) e2[n2] = arguments[n2];
        return S.apply(void 0, ["borderWidth"].concat(e2));
      }
      function Oe(t2, e2) {
        return t2(e2 ? ":" + e2 : "");
      }
      function De(t2, e2, n2) {
        if (!e2) throw new d(67);
        if (0 === t2.length) return Oe(e2, null);
        for (var r2 = [], i2 = 0; i2 < t2.length; i2 += 1) {
          if (n2 && n2.indexOf(t2[i2]) < 0) throw new d(68);
          r2.push(Oe(e2, t2[i2]));
        }
        return r2 = r2.join(",");
      }
      var Ie = [void 0, null, "active", "focus", "hover"];
      function Ne(t2) {
        return "button" + t2 + ',\n  input[type="button"]' + t2 + ',\n  input[type="reset"]' + t2 + ',\n  input[type="submit"]' + t2;
      }
      function ze() {
        for (var t2 = arguments.length, e2 = new Array(t2), n2 = 0; n2 < t2; n2++) e2[n2] = arguments[n2];
        return De(e2, Ne, Ie);
      }
      function ke() {
        for (var t2 = arguments.length, e2 = new Array(t2), n2 = 0; n2 < t2; n2++) e2[n2] = arguments[n2];
        return S.apply(void 0, ["margin"].concat(e2));
      }
      function Fe() {
        for (var t2 = arguments.length, e2 = new Array(t2), n2 = 0; n2 < t2; n2++) e2[n2] = arguments[n2];
        return S.apply(void 0, ["padding"].concat(e2));
      }
      var Be = ["absolute", "fixed", "relative", "static", "sticky"];
      function He(t2) {
        for (var e2 = arguments.length, n2 = new Array(e2 > 1 ? e2 - 1 : 0), i2 = 1; i2 < e2; i2++) n2[i2 - 1] = arguments[i2];
        return Be.indexOf(t2) >= 0 && t2 ? r({}, S.apply(void 0, [""].concat(n2)), { position: t2 }) : S.apply(void 0, ["", t2].concat(n2));
      }
      function Ge(t2, e2) {
        return void 0 === e2 && (e2 = t2), { height: t2, width: e2 };
      }
      var Ue = [void 0, null, "active", "focus", "hover"];
      function je(t2) {
        return 'input[type="color"]' + t2 + ',\n    input[type="date"]' + t2 + ',\n    input[type="datetime"]' + t2 + ',\n    input[type="datetime-local"]' + t2 + ',\n    input[type="email"]' + t2 + ',\n    input[type="month"]' + t2 + ',\n    input[type="number"]' + t2 + ',\n    input[type="password"]' + t2 + ',\n    input[type="search"]' + t2 + ',\n    input[type="tel"]' + t2 + ',\n    input[type="text"]' + t2 + ',\n    input[type="time"]' + t2 + ',\n    input[type="url"]' + t2 + ',\n    input[type="week"]' + t2 + ",\n    input:not([type])" + t2 + ",\n    textarea" + t2;
      }
      function Ve() {
        for (var t2 = arguments.length, e2 = new Array(t2), n2 = 0; n2 < t2; n2++) e2[n2] = arguments[n2];
        return De(e2, je, Ue);
      }
      function We() {
        for (var t2 = arguments.length, e2 = new Array(t2), n2 = 0; n2 < t2; n2++) e2[n2] = arguments[n2];
        if (Array.isArray(e2[0]) && 2 === e2.length) {
          var r2 = e2[1];
          if ("string" != typeof r2) throw new d(61);
          var i2 = e2[0].map(function(t3) {
            return t3 + " " + r2;
          }).join(", ");
          return { transition: i2 };
        }
        return { transition: e2.join(", ") };
      }
    }, function(t, e) {
      t.exports = function(t2, e2, n, r) {
        var i = n ? n.call(r, t2, e2) : void 0;
        if (void 0 !== i) return !!i;
        if (t2 === e2) return true;
        if ("object" != typeof t2 || !t2 || "object" != typeof e2 || !e2) return false;
        var o = Object.keys(t2), a = Object.keys(e2);
        if (o.length !== a.length) return false;
        for (var s = Object.prototype.hasOwnProperty.bind(e2), c = 0; c < o.length; c++) {
          var u = o[c];
          if (!s(u)) return false;
          var l = t2[u], h = e2[u];
          if (false === (i = n ? n.call(r, l, h, u) : void 0) || void 0 === i && l !== h) return false;
        }
        return true;
      };
    }, function(t, e, n) {
      "use strict";
      e.a = function(t2) {
        function e2(t3, e3, r2) {
          var i2 = e3.trim().split(f);
          e3 = i2;
          var o2 = i2.length, a2 = t3.length;
          switch (a2) {
            case 0:
            case 1:
              var s2 = 0;
              for (t3 = 0 === a2 ? "" : t3[0] + " "; s2 < o2; ++s2) e3[s2] = n2(t3, e3[s2], r2).trim();
              break;
            default:
              var c2 = s2 = 0;
              for (e3 = []; s2 < o2; ++s2) for (var u2 = 0; u2 < a2; ++u2) e3[c2++] = n2(t3[u2] + " ", i2[s2], r2).trim();
          }
          return e3;
        }
        function n2(t3, e3, n3) {
          var r2 = e3.charCodeAt(0);
          switch (33 > r2 && (r2 = (e3 = e3.trim()).charCodeAt(0)), r2) {
            case 38:
              return e3.replace(m, "$1" + t3.trim());
            case 58:
              return t3.trim() + e3.replace(m, "$1" + t3.trim());
            default:
              if (0 < 1 * n3 && 0 < e3.indexOf("\f")) return e3.replace(m, (58 === t3.charCodeAt(0) ? "" : "$1") + t3.trim());
          }
          return t3 + e3;
        }
        function r(t3, e3, n3, o2) {
          var a2 = t3 + ";", s2 = 2 * e3 + 3 * n3 + 4 * o2;
          if (944 === s2) {
            t3 = a2.indexOf(":", 9) + 1;
            var c2 = a2.substring(t3, a2.length - 1).trim();
            return c2 = a2.substring(0, t3).trim() + c2 + ";", 1 === L || 2 === L && i(c2, 1) ? "-webkit-" + c2 + c2 : c2;
          }
          if (0 === L || 2 === L && !i(a2, 1)) return a2;
          switch (s2) {
            case 1015:
              return 97 === a2.charCodeAt(10) ? "-webkit-" + a2 + a2 : a2;
            case 951:
              return 116 === a2.charCodeAt(3) ? "-webkit-" + a2 + a2 : a2;
            case 963:
              return 110 === a2.charCodeAt(5) ? "-webkit-" + a2 + a2 : a2;
            case 1009:
              if (100 !== a2.charCodeAt(4)) break;
            case 969:
            case 942:
              return "-webkit-" + a2 + a2;
            case 978:
              return "-webkit-" + a2 + "-moz-" + a2 + a2;
            case 1019:
            case 983:
              return "-webkit-" + a2 + "-moz-" + a2 + "-ms-" + a2 + a2;
            case 883:
              if (45 === a2.charCodeAt(8)) return "-webkit-" + a2 + a2;
              if (0 < a2.indexOf("image-set(", 11)) return a2.replace(T, "$1-webkit-$2") + a2;
              break;
            case 932:
              if (45 === a2.charCodeAt(4)) switch (a2.charCodeAt(5)) {
                case 103:
                  return "-webkit-box-" + a2.replace("-grow", "") + "-webkit-" + a2 + "-ms-" + a2.replace("grow", "positive") + a2;
                case 115:
                  return "-webkit-" + a2 + "-ms-" + a2.replace("shrink", "negative") + a2;
                case 98:
                  return "-webkit-" + a2 + "-ms-" + a2.replace("basis", "preferred-size") + a2;
              }
              return "-webkit-" + a2 + "-ms-" + a2 + a2;
            case 964:
              return "-webkit-" + a2 + "-ms-flex-" + a2 + a2;
            case 1023:
              if (99 !== a2.charCodeAt(8)) break;
              return "-webkit-box-pack" + (c2 = a2.substring(a2.indexOf(":", 15)).replace("flex-", "").replace("space-between", "justify")) + "-webkit-" + a2 + "-ms-flex-pack" + c2 + a2;
            case 1005:
              return d.test(a2) ? a2.replace(h, ":-webkit-") + a2.replace(h, ":-moz-") + a2 : a2;
            case 1e3:
              switch (e3 = (c2 = a2.substring(13).trim()).indexOf("-") + 1, c2.charCodeAt(0) + c2.charCodeAt(e3)) {
                case 226:
                  c2 = a2.replace(x, "tb");
                  break;
                case 232:
                  c2 = a2.replace(x, "tb-rl");
                  break;
                case 220:
                  c2 = a2.replace(x, "lr");
                  break;
                default:
                  return a2;
              }
              return "-webkit-" + a2 + "-ms-" + c2 + a2;
            case 1017:
              if (-1 === a2.indexOf("sticky", 9)) break;
            case 975:
              switch (e3 = (a2 = t3).length - 10, s2 = (c2 = (33 === a2.charCodeAt(e3) ? a2.substring(0, e3) : a2).substring(t3.indexOf(":", 7) + 1).trim()).charCodeAt(0) + (0 | c2.charCodeAt(7))) {
                case 203:
                  if (111 > c2.charCodeAt(8)) break;
                case 115:
                  a2 = a2.replace(c2, "-webkit-" + c2) + ";" + a2;
                  break;
                case 207:
                case 102:
                  a2 = a2.replace(c2, "-webkit-" + (102 < s2 ? "inline-" : "") + "box") + ";" + a2.replace(c2, "-webkit-" + c2) + ";" + a2.replace(c2, "-ms-" + c2 + "box") + ";" + a2;
              }
              return a2 + ";";
            case 938:
              if (45 === a2.charCodeAt(5)) switch (a2.charCodeAt(6)) {
                case 105:
                  return c2 = a2.replace("-items", ""), "-webkit-" + a2 + "-webkit-box-" + c2 + "-ms-flex-" + c2 + a2;
                case 115:
                  return "-webkit-" + a2 + "-ms-flex-item-" + a2.replace(_, "") + a2;
                default:
                  return "-webkit-" + a2 + "-ms-flex-line-pack" + a2.replace("align-content", "").replace(_, "") + a2;
              }
              break;
            case 973:
            case 989:
              if (45 !== a2.charCodeAt(3) || 122 === a2.charCodeAt(4)) break;
            case 931:
            case 953:
              if (true === S.test(t3)) return 115 === (c2 = t3.substring(t3.indexOf(":") + 1)).charCodeAt(0) ? r(t3.replace("stretch", "fill-available"), e3, n3, o2).replace(":fill-available", ":stretch") : a2.replace(c2, "-webkit-" + c2) + a2.replace(c2, "-moz-" + c2.replace("fill-", "")) + a2;
              break;
            case 962:
              if (a2 = "-webkit-" + a2 + (102 === a2.charCodeAt(5) ? "-ms-" + a2 : "") + a2, 211 === n3 + o2 && 105 === a2.charCodeAt(13) && 0 < a2.indexOf("transform", 10)) return a2.substring(0, a2.indexOf(";", 27) + 1).replace(p, "$1-webkit-$2") + a2;
          }
          return a2;
        }
        function i(t3, e3) {
          var n3 = t3.indexOf(1 === e3 ? ":" : "{"), r2 = t3.substring(0, 3 !== e3 ? n3 : 10);
          return n3 = t3.substring(n3 + 1, t3.length - 1), D(2 !== e3 ? r2 : r2.replace(M, "$1"), n3, e3);
        }
        function o(t3, e3) {
          var n3 = r(e3, e3.charCodeAt(0), e3.charCodeAt(1), e3.charCodeAt(2));
          return n3 !== e3 + ";" ? n3.replace(w, " or ($1)").substring(4) : "(" + e3 + ")";
        }
        function a(t3, e3, n3, r2, i2, o2, a2, s2, u2, l2) {
          for (var h2, d2 = 0, p2 = e3; d2 < O; ++d2) switch (h2 = R[d2].call(c, t3, p2, n3, r2, i2, o2, a2, s2, u2, l2)) {
            case void 0:
            case false:
            case true:
            case null:
              break;
            default:
              p2 = h2;
          }
          if (p2 !== e3) return p2;
        }
        function s(t3) {
          return void 0 !== (t3 = t3.prefix) && (D = null, t3 ? "function" != typeof t3 ? L = 1 : (L = 2, D = t3) : L = 0), s;
        }
        function c(t3, n3) {
          var s2 = t3;
          if (33 > s2.charCodeAt(0) && (s2 = s2.trim()), s2 = [s2], 0 < O) {
            var c2 = a(-1, n3, s2, s2, A, E, 0, 0, 0, 0);
            void 0 !== c2 && "string" == typeof c2 && (n3 = c2);
          }
          var h2 = function t4(n4, s3, c3, h3, d2) {
            for (var p2, f2, m2, x2, w2, _2 = 0, M2 = 0, S2 = 0, T2 = 0, R2 = 0, D2 = 0, N = m2 = p2 = 0, z = 0, k = 0, F = 0, B = 0, H = c3.length, G = H - 1, U = "", j = "", V = "", W = ""; z < H; ) {
              if (f2 = c3.charCodeAt(z), z === G && 0 !== M2 + T2 + S2 + _2 && (0 !== M2 && (f2 = 47 === M2 ? 10 : 47), T2 = S2 = _2 = 0, H++, G++), 0 === M2 + T2 + S2 + _2) {
                if (z === G && (0 < k && (U = U.replace(l, "")), 0 < U.trim().length)) {
                  switch (f2) {
                    case 32:
                    case 9:
                    case 59:
                    case 13:
                    case 10:
                      break;
                    default:
                      U += c3.charAt(z);
                  }
                  f2 = 59;
                }
                switch (f2) {
                  case 123:
                    for (p2 = (U = U.trim()).charCodeAt(0), m2 = 1, B = ++z; z < H; ) {
                      switch (f2 = c3.charCodeAt(z)) {
                        case 123:
                          m2++;
                          break;
                        case 125:
                          m2--;
                          break;
                        case 47:
                          switch (f2 = c3.charCodeAt(z + 1)) {
                            case 42:
                            case 47:
                              t: {
                                for (N = z + 1; N < G; ++N) switch (c3.charCodeAt(N)) {
                                  case 47:
                                    if (42 === f2 && 42 === c3.charCodeAt(N - 1) && z + 2 !== N) {
                                      z = N + 1;
                                      break t;
                                    }
                                    break;
                                  case 10:
                                    if (47 === f2) {
                                      z = N + 1;
                                      break t;
                                    }
                                }
                                z = N;
                              }
                          }
                          break;
                        case 91:
                          f2++;
                        case 40:
                          f2++;
                        case 34:
                        case 39:
                          for (; z++ < G && c3.charCodeAt(z) !== f2; ) ;
                      }
                      if (0 === m2) break;
                      z++;
                    }
                    switch (m2 = c3.substring(B, z), 0 === p2 && (p2 = (U = U.replace(u, "").trim()).charCodeAt(0)), p2) {
                      case 64:
                        switch (0 < k && (U = U.replace(l, "")), f2 = U.charCodeAt(1)) {
                          case 100:
                          case 109:
                          case 115:
                          case 45:
                            k = s3;
                            break;
                          default:
                            k = P;
                        }
                        if (B = (m2 = t4(s3, k, m2, f2, d2 + 1)).length, 0 < O && (w2 = a(3, m2, k = e2(P, U, F), s3, A, E, B, f2, d2, h3), U = k.join(""), void 0 !== w2 && 0 === (B = (m2 = w2.trim()).length) && (f2 = 0, m2 = "")), 0 < B) switch (f2) {
                          case 115:
                            U = U.replace(b, o);
                          case 100:
                          case 109:
                          case 45:
                            m2 = U + "{" + m2 + "}";
                            break;
                          case 107:
                            m2 = (U = U.replace(g, "$1 $2")) + "{" + m2 + "}", m2 = 1 === L || 2 === L && i("@" + m2, 3) ? "@-webkit-" + m2 + "@" + m2 : "@" + m2;
                            break;
                          default:
                            m2 = U + m2, 112 === h3 && (j += m2, m2 = "");
                        }
                        else m2 = "";
                        break;
                      default:
                        m2 = t4(s3, e2(s3, U, F), m2, h3, d2 + 1);
                    }
                    V += m2, m2 = F = k = N = p2 = 0, U = "", f2 = c3.charCodeAt(++z);
                    break;
                  case 125:
                  case 59:
                    if (1 < (B = (U = (0 < k ? U.replace(l, "") : U).trim()).length)) switch (0 === N && (p2 = U.charCodeAt(0), 45 === p2 || 96 < p2 && 123 > p2) && (B = (U = U.replace(" ", ":")).length), 0 < O && void 0 !== (w2 = a(1, U, s3, n4, A, E, j.length, h3, d2, h3)) && 0 === (B = (U = w2.trim()).length) && (U = "\0\0"), p2 = U.charCodeAt(0), f2 = U.charCodeAt(1), p2) {
                      case 0:
                        break;
                      case 64:
                        if (105 === f2 || 99 === f2) {
                          W += U + c3.charAt(z);
                          break;
                        }
                      default:
                        58 !== U.charCodeAt(B - 1) && (j += r(U, p2, f2, U.charCodeAt(2)));
                    }
                    F = k = N = p2 = 0, U = "", f2 = c3.charCodeAt(++z);
                }
              }
              switch (f2) {
                case 13:
                case 10:
                  47 === M2 ? M2 = 0 : 0 === 1 + p2 && 107 !== h3 && 0 < U.length && (k = 1, U += "\0"), 0 < O * I && a(0, U, s3, n4, A, E, j.length, h3, d2, h3), E = 1, A++;
                  break;
                case 59:
                case 125:
                  if (0 === M2 + T2 + S2 + _2) {
                    E++;
                    break;
                  }
                default:
                  switch (E++, x2 = c3.charAt(z), f2) {
                    case 9:
                    case 32:
                      if (0 === T2 + _2 + M2) switch (R2) {
                        case 44:
                        case 58:
                        case 9:
                        case 32:
                          x2 = "";
                          break;
                        default:
                          32 !== f2 && (x2 = " ");
                      }
                      break;
                    case 0:
                      x2 = "\\0";
                      break;
                    case 12:
                      x2 = "\\f";
                      break;
                    case 11:
                      x2 = "\\v";
                      break;
                    case 38:
                      0 === T2 + M2 + _2 && (k = F = 1, x2 = "\f" + x2);
                      break;
                    case 108:
                      if (0 === T2 + M2 + _2 + C && 0 < N) switch (z - N) {
                        case 2:
                          112 === R2 && 58 === c3.charCodeAt(z - 3) && (C = R2);
                        case 8:
                          111 === D2 && (C = D2);
                      }
                      break;
                    case 58:
                      0 === T2 + M2 + _2 && (N = z);
                      break;
                    case 44:
                      0 === M2 + S2 + T2 + _2 && (k = 1, x2 += "\r");
                      break;
                    case 34:
                    case 39:
                      0 === M2 && (T2 = T2 === f2 ? 0 : 0 === T2 ? f2 : T2);
                      break;
                    case 91:
                      0 === T2 + M2 + S2 && _2++;
                      break;
                    case 93:
                      0 === T2 + M2 + S2 && _2--;
                      break;
                    case 41:
                      0 === T2 + M2 + _2 && S2--;
                      break;
                    case 40:
                      if (0 === T2 + M2 + _2) {
                        if (0 === p2) switch (2 * R2 + 3 * D2) {
                          case 533:
                            break;
                          default:
                            p2 = 1;
                        }
                        S2++;
                      }
                      break;
                    case 64:
                      0 === M2 + S2 + T2 + _2 + N + m2 && (m2 = 1);
                      break;
                    case 42:
                    case 47:
                      if (!(0 < T2 + _2 + S2)) switch (M2) {
                        case 0:
                          switch (2 * f2 + 3 * c3.charCodeAt(z + 1)) {
                            case 235:
                              M2 = 47;
                              break;
                            case 220:
                              B = z, M2 = 42;
                          }
                          break;
                        case 42:
                          47 === f2 && 42 === R2 && B + 2 !== z && (33 === c3.charCodeAt(B + 2) && (j += c3.substring(B, z + 1)), x2 = "", M2 = 0);
                      }
                  }
                  0 === M2 && (U += x2);
              }
              D2 = R2, R2 = f2, z++;
            }
            if (0 < (B = j.length)) {
              if (k = s3, 0 < O && (void 0 !== (w2 = a(2, j, k, n4, A, E, B, h3, d2, h3)) && 0 === (j = w2).length)) return W + j + V;
              if (j = k.join(",") + "{" + j + "}", 0 != L * C) {
                switch (2 !== L || i(j, 2) || (C = 0), C) {
                  case 111:
                    j = j.replace(y, ":-moz-$1") + j;
                    break;
                  case 112:
                    j = j.replace(v, "::-webkit-input-$1") + j.replace(v, "::-moz-$1") + j.replace(v, ":-ms-input-$1") + j;
                }
                C = 0;
              }
            }
            return W + j + V;
          }(P, s2, n3, 0, 0);
          return 0 < O && (void 0 !== (c2 = a(-2, h2, s2, s2, A, E, h2.length, 0, 0, 0)) && (h2 = c2)), "", C = 0, E = A = 1, h2;
        }
        var u = /^\0+/g, l = /[\0\r\f]/g, h = /: */g, d = /zoo|gra/, p = /([,: ])(transform)/g, f = /,\r+?/g, m = /([\t\r\n ])*\f?&/g, g = /@(k\w+)\s*(\S*)\s*/, v = /::(place)/g, y = /:(read-only)/g, x = /[svh]\w+-[tblr]{2}/, b = /\(\s*(.*)\s*\)/g, w = /([\s\S]*?);/g, _ = /-self|flex-/g, M = /[^]*?(:[rp][el]a[\w-]+)[^]*/, S = /stretch|:\s*\w+\-(?:conte|avail)/, T = /([^-])(image-set\()/, E = 1, A = 1, C = 0, L = 1, P = [], R = [], O = 0, D = null, I = 0;
        return c.use = function t3(e3) {
          switch (e3) {
            case void 0:
            case null:
              O = R.length = 0;
              break;
            default:
              if ("function" == typeof e3) R[O++] = e3;
              else if ("object" == typeof e3) for (var n3 = 0, r2 = e3.length; n3 < r2; ++n3) t3(e3[n3]);
              else I = 0 | !!e3;
          }
          return t3;
        }, c.set = s, void 0 !== t2 && s(t2), c;
      };
    }, function(t, e, n) {
      "use strict";
      e.a = { animationIterationCount: 1, borderImageOutset: 1, borderImageSlice: 1, borderImageWidth: 1, boxFlex: 1, boxFlexGroup: 1, boxOrdinalGroup: 1, columnCount: 1, columns: 1, flex: 1, flexGrow: 1, flexPositive: 1, flexShrink: 1, flexNegative: 1, flexOrder: 1, gridRow: 1, gridRowEnd: 1, gridRowSpan: 1, gridRowStart: 1, gridColumn: 1, gridColumnEnd: 1, gridColumnSpan: 1, gridColumnStart: 1, msGridRow: 1, msGridRowSpan: 1, msGridColumn: 1, msGridColumnSpan: 1, fontWeight: 1, lineHeight: 1, opacity: 1, order: 1, orphans: 1, tabSize: 1, widows: 1, zIndex: 1, zoom: 1, WebkitLineClamp: 1, fillOpacity: 1, floodOpacity: 1, stopOpacity: 1, strokeDasharray: 1, strokeDashoffset: 1, strokeMiterlimit: 1, strokeOpacity: 1, strokeWidth: 1 };
    }, function(t, e, n) {
      "use strict";
      Object.defineProperty(e, "__esModule", { value: true }), Object.defineProperty(e, "BoltLoader", { enumerable: true, get: function() {
        return r.default;
      } }), Object.defineProperty(e, "BookLoader", { enumerable: true, get: function() {
        return i.default;
      } }), Object.defineProperty(e, "BoxesLoader", { enumerable: true, get: function() {
        return o.default;
      } }), Object.defineProperty(e, "CircleLoader", { enumerable: true, get: function() {
        return a.default;
      } }), Object.defineProperty(e, "FlipFlopLoader", { enumerable: true, get: function() {
        return s.default;
      } }), Object.defineProperty(e, "ScatterBoxLoader", { enumerable: true, get: function() {
        return c.default;
      } }), Object.defineProperty(e, "SquircleLoader", { enumerable: true, get: function() {
        return u.default;
      } }), Object.defineProperty(e, "SunspotLoader", { enumerable: true, get: function() {
        return l.default;
      } }), Object.defineProperty(e, "ThreeDLoader", { enumerable: true, get: function() {
        return h.default;
      } }), Object.defineProperty(e, "WifiLoader", { enumerable: true, get: function() {
        return d.default;
      } }), Object.defineProperty(e, "XlviLoader", { enumerable: true, get: function() {
        return p.default;
      } });
      var r = f(n(25)), i = f(n(30)), o = f(n(31)), a = f(n(32)), s = f(n(33)), c = f(n(34)), u = f(n(35)), l = f(n(44)), h = f(n(45)), d = f(n(46)), p = f(n(47));
      function f(t2) {
        return t2 && t2.__esModule ? t2 : { default: t2 };
      }
    }, function(t, e, n) {
      "use strict";
      function r(t2) {
        return (r = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(t3) {
          return typeof t3;
        } : function(t3) {
          return t3 && "function" == typeof Symbol && t3.constructor === Symbol && t3 !== Symbol.prototype ? "symbol" : typeof t3;
        })(t2);
      }
      Object.defineProperty(e, "__esModule", { value: true }), e.default = void 0;
      var i = function(t2) {
        if (t2 && t2.__esModule) return t2;
        if (null === t2 || "object" !== r(t2) && "function" != typeof t2) return { default: t2 };
        var e2 = l();
        if (e2 && e2.has(t2)) return e2.get(t2);
        var n2 = {}, i2 = Object.defineProperty && Object.getOwnPropertyDescriptor;
        for (var o2 in t2) if (Object.prototype.hasOwnProperty.call(t2, o2)) {
          var a2 = i2 ? Object.getOwnPropertyDescriptor(t2, o2) : null;
          a2 && (a2.get || a2.set) ? Object.defineProperty(n2, o2, a2) : n2[o2] = t2[o2];
        }
        n2.default = t2, e2 && e2.set(t2, n2);
        return n2;
      }(n(0)), o = n(7), a = u(n(1)), s = u(n(14)), c = n(2);
      function u(t2) {
        return t2 && t2.__esModule ? t2 : { default: t2 };
      }
      function l() {
        if ("function" != typeof WeakMap) return null;
        var t2 = /* @__PURE__ */ new WeakMap();
        return l = function() {
          return t2;
        }, t2;
      }
      function h() {
        var t2 = _(["\n  display: block;\n  width: ", "px;\n  height: ", "px;\n  background: ", ";\n  clip-path: polygon(40% 0%, 100% 0, 65% 40%, 88% 40%, 8% 100%, 36% 50%, 0 50%);\n"]);
        return h = function() {
          return t2;
        }, t2;
      }
      function d() {
        var t2 = _(['\n  display: block;\n  position: relative;\n  :before {\n    content: "";\n    position: absolute;\n    left: 50%;\n    top: 44%;\n    width: 112px;\n    height: 112px;\n    margin: -56px 0 0 -56px;\n    background: #cdd9ed;\n    filter: blur(124px);\n  }\n  :after {\n    content: "";\n    position: absolute;\n    left: 50%;\n    top: 44%;\n    width: 64px;\n    height: 64px;\n    margin: -32px 0 0 -32px;\n    background: ', ";\n    z-index: 1;\n    filter: blur(60px);\n  }\n"]);
        return d = function() {
          return t2;
        }, t2;
      }
      function p() {
        var t2 = _(["\n  --r: 20deg;\n  --s: -1;\n  right: 0;\n"]);
        return p = function() {
          return t2;
        }, t2;
      }
      function f() {
        var t2 = _(["\n  --r: -20deg;\n  left: 0;\n"]);
        return f = function() {
          return t2;
        }, t2;
      }
      function m() {
        var t2 = _(["\n  --r: 40deg;\n  right: -24px;\n"]);
        return m = function() {
          return t2;
        }, t2;
      }
      function g() {
        var t2 = _(["\n  --r: 130deg;\n  left: -24px;\n"]);
        return g = function() {
          return t2;
        }, t2;
      }
      function v() {
        var t2 = _(["\n  --r: 0deg;\n  --s: 1;\n  top: 30%;\n  z-index: 1;\n  stroke: #fff;\n  stroke-dashoffset: 241px;\n  stroke-dasharray: 0px 240px;\n  transform: rotate(var(--r)) scaleX(var(--s));\n"]);
        return v = function() {
          return t2;
        }, t2;
      }
      function y() {
        var t2 = _(["\n  --r: 0deg;\n  top: 95%;\n  width: 70px;\n  height: 3px;\n  stroke-dashoffset: 71px;\n  stroke-dasharray: 0px 70px;\n  transform: rotate(var(--r));\n"]);
        return y = function() {
          return t2;
        }, t2;
      }
      function x() {
        var t2 = _(["\n  left: 7px;\n  top: 100%;\n  width: 112px;\n  height: 44px;\n  stroke-dashoffset: 179px;\n  stroke-dasharray: 0px 178px;\n"]);
        return x = function() {
          return t2;
        }, t2;
      }
      function b() {
        var t2 = _(["\n  position: absolute;\n  display: block;\n  stroke-width: 4;\n  fill: none;\n  stroke-linecap: round;\n  stroke: ", ";\n"]);
        return b = function() {
          return t2;
        }, t2;
      }
      function w() {
        var t2 = _(["\n  width: ", "px;\n  height: ", "px;\n  position: relative;\n  padding: 20px;\n  background: ", ";\n"]);
        return w = function() {
          return t2;
        }, t2;
      }
      function _(t2, e2) {
        return e2 || (e2 = t2.slice(0)), Object.freeze(Object.defineProperties(t2, { raw: { value: Object.freeze(e2) } }));
      }
      var M = a.default.div(w(), function(t2) {
        return t2.bolterWidth;
      }, function(t2) {
        return t2.bolterHeight;
      }, function(t2) {
        return t2.background;
      }), S = a.default.svg(b(), function(t2) {
        return t2.boltColor;
      }), T = (0, a.default)(S)(x()), E = (0, a.default)(S)(y()), A = (0, a.default)(S)(v()), C = (0, a.default)(E)(g()), L = (0, a.default)(E)(m()), P = (0, a.default)(A)(f()), R = (0, a.default)(A)(p()), O = a.default.div(d(), function(t2) {
        return t2.backgroundBlurColor;
      }), D = a.default.span(h(), function(t2) {
        return t2.bolterWidth;
      }, function(t2) {
        return t2.bolterHeight;
      }, function(t2) {
        return t2.boltColor;
      }), I = function(t2) {
        var e2 = t2.className, n2 = void 0 === e2 ? "boltloader" : e2, r2 = t2.background, a2 = void 0 === r2 ? "transparent" : r2, u2 = t2.boltColor, l2 = void 0 === u2 ? "#f2de10" : u2, h2 = t2.backgroundBlurColor, d2 = void 0 === h2 ? "#fff9bc" : h2, p2 = t2.size, f2 = void 0 === p2 ? "64px" : p2, m2 = t2.desktopSize, g2 = void 0 === m2 ? "" : m2, v2 = t2.mobileSize, y2 = void 0 === v2 ? "" : v2, x2 = (0, c.useMediaQuery)({ query: "(min-width: 1224px)" }), b2 = (0, c.useMediaQuery)({ query: "(max-width: 1224px)" }), w2 = 0;
        x2 && (w2 = "" !== g2 ? parseFloat(g2) : 2 * parseFloat(f2)), b2 && (w2 = "" !== y2 ? parseFloat(y2) : parseFloat(f2));
        var _2 = parseFloat(w2), S2 = 63 * _2 / 64, E2 = 93 * _2 / 64;
        return (0, i.useEffect)(function() {
          (0, s.default)("." + n2).each(function(t3) {
            var e3 = (0, s.default)(this), n3 = (0, s.default)(this).children(".boltloadersparkdiv");
            e3.addClass("boltloaderanimatedelement");
            var r3 = o.gsap.timeline({ onComplete: function() {
              e3.removeClass("boltloaderanimatedelement"), setTimeout(function() {
                e3.addClass("boltloaderanimatedelement"), r3.restart();
              }, 400);
            } }).set(n3, { rotation: 360 }).to(n3, 0.7, { y: 80, rotation: 370 }).to(n3, 0.6, { y: -140, rotation: 20 }).to(n3, 0.1, { rotation: -24, y: 80 }).to(n3, 0.8, { ease: o.Back.easeOut.config(1.6), rotation: 0, y: 0 });
          });
        }), i.default.createElement("div", null, i.default.createElement("style", null, "\n          .".concat(n2, ".boltloaderanimatedelement div:before, .").concat(n2, ".boltloaderanimatedelement div:after {\n                animation: shine 2s ease; \n            } \n            .").concat(n2, ".boltloaderanimatedelement div span {\n                animation: morph 2s ease;\n            }\n            .").concat(n2, ".boltloaderanimatedelement svg.circle {\n                animation: circle 0.45s cubic-bezier(0.77, 0, 0.175, 1) forwards 1.3s;\n            }\n            .").concat(n2, ".boltloaderanimatedelement svg.line {\n                animation: line 0.45s cubic-bezier(0.77, 0, 0.175, 1) forwards 1.3s;\n            }\n            .").concat(n2, ".boltloaderanimatedelement svg.white {\n                animation: white 0.45s cubic-bezier(0.77, 0, 0.175, 1) forwards 1.45s;\n            }\n            .").concat(n2, ".boltloaderanimatedelement svg.white.right {\n                animation-delay: 1.6s;\n            }\n            @keyframes circle {\n                100% {\n                    stroke-dasharray: 178px 178px;\n            }\n            }\n            @keyframes white {\n                100% {\n                    stroke-dasharray: 240px 240px;\n            }\n            }\n            @keyframes line {\n                100% {\n                    stroke-dasharray: 70px 70px;\n            }\n            }\n            @keyframes shine {\n                30%, 70% {\n                    opacity: 0;\n            }\n            }\n            @keyframes morph {\n                12% {\n                    clip-path: polygon(40% 5%, 100% 0, 65% 40%, 65% 40%, 8% 100%, 24% 50%, 24% 50%);\n            }\n                24%, 72% {\n                    clip-path: polygon(36% 40%, 82% 40%, 82% 40%, 82% 40%, 36% 71%, 36% 40%, 36% 40%);\n            }\n                84% {\n                    clip-path: polygon(40% 5%, 100% 0, 65% 40%, 65% 40%, 8% 100%, 24% 50%, 24% 50%);\n            }\n            } \n    ")), i.default.createElement(M, { className: n2, background: a2, bolterWidth: S2, bolterHeight: E2 }, i.default.createElement(P, { boltColor: l2, viewBox: "0 0 170 57", className: "white left" }, i.default.createElement("path", { d: "M36.2701759,17.9733192 C-0.981139498,45.4810755 -7.86361824,57.6618438 15.6227397,54.5156241 C50.8522766,49.7962945 201.109341,31.1461782 161.361488,2" })), i.default.createElement(R, { boltColor: l2, viewBox: "0 0 170 57", className: "white right" }, i.default.createElement("path", { d: "M36.2701759,17.9733192 C-0.981139498,45.4810755 -7.86361824,57.6618438 15.6227397,54.5156241 C50.8522766,49.7962945 201.109341,31.1461782 161.361488,2" })), i.default.createElement(O, { className: "boltloadersparkdiv", backgroundBlurColor: d2 }, i.default.createElement(D, { boltColor: l2, bolterWidth: S2, bolterHeight: E2, className: "boltloadersparkdivspan" })), i.default.createElement(T, { boltColor: l2, viewBox: "0 0 112 44", className: "circle" }, i.default.createElement("path", { d: "M96.9355003,2 C109.46067,13.4022454 131.614152,42 56.9906735,42 C-17.6328048,42 1.51790702,13.5493875 13.0513641,2" })), i.default.createElement(C, { boltColor: l2, viewBox: "0 0 70 3", className: "line left" }, i.default.createElement("path", { transform: "translate(-2.000000, 0.000000)", d: "M2,1.5 L70,1.5" })), i.default.createElement(L, { boltColor: l2, viewBox: "0 0 70 3", className: "line right" }, i.default.createElement("path", { transform: "translate(-2.000000, 0.000000)", d: "M2,1.5 L70,1.5" }))));
      };
      e.default = I;
    }, function(t, e) {
      var n, r, i = t.exports = {};
      function o() {
        throw new Error("setTimeout has not been defined");
      }
      function a() {
        throw new Error("clearTimeout has not been defined");
      }
      function s(t2) {
        if (n === setTimeout) return setTimeout(t2, 0);
        if ((n === o || !n) && setTimeout) return n = setTimeout, setTimeout(t2, 0);
        try {
          return n(t2, 0);
        } catch (e2) {
          try {
            return n.call(null, t2, 0);
          } catch (e3) {
            return n.call(this, t2, 0);
          }
        }
      }
      !function() {
        try {
          n = "function" == typeof setTimeout ? setTimeout : o;
        } catch (t2) {
          n = o;
        }
        try {
          r = "function" == typeof clearTimeout ? clearTimeout : a;
        } catch (t2) {
          r = a;
        }
      }();
      var c, u = [], l = false, h = -1;
      function d() {
        l && c && (l = false, c.length ? u = c.concat(u) : h = -1, u.length && p());
      }
      function p() {
        if (!l) {
          var t2 = s(d);
          l = true;
          for (var e2 = u.length; e2; ) {
            for (c = u, u = []; ++h < e2; ) c && c[h].run();
            h = -1, e2 = u.length;
          }
          c = null, l = false, function(t3) {
            if (r === clearTimeout) return clearTimeout(t3);
            if ((r === a || !r) && clearTimeout) return r = clearTimeout, clearTimeout(t3);
            try {
              r(t3);
            } catch (e3) {
              try {
                return r.call(null, t3);
              } catch (e4) {
                return r.call(this, t3);
              }
            }
          }(t2);
        }
      }
      function f(t2, e2) {
        this.fun = t2, this.array = e2;
      }
      function m() {
      }
      i.nextTick = function(t2) {
        var e2 = new Array(arguments.length - 1);
        if (arguments.length > 1) for (var n2 = 1; n2 < arguments.length; n2++) e2[n2 - 1] = arguments[n2];
        u.push(new f(t2, e2)), 1 !== u.length || l || s(p);
      }, f.prototype.run = function() {
        this.fun.apply(null, this.array);
      }, i.title = "browser", i.browser = true, i.env = {}, i.argv = [], i.version = "", i.versions = {}, i.on = m, i.addListener = m, i.once = m, i.off = m, i.removeListener = m, i.removeAllListeners = m, i.emit = m, i.prependListener = m, i.prependOnceListener = m, i.listeners = function(t2) {
        return [];
      }, i.binding = function(t2) {
        throw new Error("process.binding is not supported");
      }, i.cwd = function() {
        return "/";
      }, i.chdir = function(t2) {
        throw new Error("process.chdir is not supported");
      }, i.umask = function() {
        return 0;
      };
    }, function(t, e, n) {
      "use strict";
      var r = 60103, i = 60106, o = 60107, a = 60108, s = 60114, c = 60109, u = 60110, l = 60112, h = 60113, d = 60120, p = 60115, f = 60116, m = 60121, g = 60122, v = 60117, y = 60129, x = 60131;
      if ("function" == typeof Symbol && Symbol.for) {
        var b = Symbol.for;
        r = b("react.element"), i = b("react.portal"), o = b("react.fragment"), a = b("react.strict_mode"), s = b("react.profiler"), c = b("react.provider"), u = b("react.context"), l = b("react.forward_ref"), h = b("react.suspense"), d = b("react.suspense_list"), p = b("react.memo"), f = b("react.lazy"), m = b("react.block"), g = b("react.server.block"), v = b("react.fundamental"), y = b("react.debug_trace_mode"), x = b("react.legacy_hidden");
      }
      function w(t2) {
        if ("object" == typeof t2 && null !== t2) {
          var e2 = t2.$$typeof;
          switch (e2) {
            case r:
              switch (t2 = t2.type) {
                case o:
                case s:
                case a:
                case h:
                case d:
                  return t2;
                default:
                  switch (t2 = t2 && t2.$$typeof) {
                    case u:
                    case l:
                    case f:
                    case p:
                    case c:
                      return t2;
                    default:
                      return e2;
                  }
              }
            case i:
              return e2;
          }
        }
      }
      var _ = c, M = r, S = l, T = o, E = f, A = p, C = i, L = s, P = a, R = h;
      e.ContextConsumer = u, e.ContextProvider = _, e.Element = M, e.ForwardRef = S, e.Fragment = T, e.Lazy = E, e.Memo = A, e.Portal = C, e.Profiler = L, e.StrictMode = P, e.Suspense = R, e.isAsyncMode = function() {
        return false;
      }, e.isConcurrentMode = function() {
        return false;
      }, e.isContextConsumer = function(t2) {
        return w(t2) === u;
      }, e.isContextProvider = function(t2) {
        return w(t2) === c;
      }, e.isElement = function(t2) {
        return "object" == typeof t2 && null !== t2 && t2.$$typeof === r;
      }, e.isForwardRef = function(t2) {
        return w(t2) === l;
      }, e.isFragment = function(t2) {
        return w(t2) === o;
      }, e.isLazy = function(t2) {
        return w(t2) === f;
      }, e.isMemo = function(t2) {
        return w(t2) === p;
      }, e.isPortal = function(t2) {
        return w(t2) === i;
      }, e.isProfiler = function(t2) {
        return w(t2) === s;
      }, e.isStrictMode = function(t2) {
        return w(t2) === a;
      }, e.isSuspense = function(t2) {
        return w(t2) === h;
      }, e.isValidElementType = function(t2) {
        return "string" == typeof t2 || "function" == typeof t2 || t2 === o || t2 === s || t2 === y || t2 === a || t2 === h || t2 === d || t2 === x || "object" == typeof t2 && null !== t2 && (t2.$$typeof === f || t2.$$typeof === p || t2.$$typeof === c || t2.$$typeof === u || t2.$$typeof === l || t2.$$typeof === v || t2.$$typeof === m || t2[0] === g);
      }, e.typeOf = w;
    }, function(t, e, n) {
      "use strict";
      t.exports = n(29);
    }, function(t, e, n) {
      "use strict";
      var r = "function" == typeof Symbol && Symbol.for, i = r ? Symbol.for("react.element") : 60103, o = r ? Symbol.for("react.portal") : 60106, a = r ? Symbol.for("react.fragment") : 60107, s = r ? Symbol.for("react.strict_mode") : 60108, c = r ? Symbol.for("react.profiler") : 60114, u = r ? Symbol.for("react.provider") : 60109, l = r ? Symbol.for("react.context") : 60110, h = r ? Symbol.for("react.async_mode") : 60111, d = r ? Symbol.for("react.concurrent_mode") : 60111, p = r ? Symbol.for("react.forward_ref") : 60112, f = r ? Symbol.for("react.suspense") : 60113, m = r ? Symbol.for("react.suspense_list") : 60120, g = r ? Symbol.for("react.memo") : 60115, v = r ? Symbol.for("react.lazy") : 60116, y = r ? Symbol.for("react.block") : 60121, x = r ? Symbol.for("react.fundamental") : 60117, b = r ? Symbol.for("react.responder") : 60118, w = r ? Symbol.for("react.scope") : 60119;
      function _(t2) {
        if ("object" == typeof t2 && null !== t2) {
          var e2 = t2.$$typeof;
          switch (e2) {
            case i:
              switch (t2 = t2.type) {
                case h:
                case d:
                case a:
                case c:
                case s:
                case f:
                  return t2;
                default:
                  switch (t2 = t2 && t2.$$typeof) {
                    case l:
                    case p:
                    case v:
                    case g:
                    case u:
                      return t2;
                    default:
                      return e2;
                  }
              }
            case o:
              return e2;
          }
        }
      }
      function M(t2) {
        return _(t2) === d;
      }
      e.AsyncMode = h, e.ConcurrentMode = d, e.ContextConsumer = l, e.ContextProvider = u, e.Element = i, e.ForwardRef = p, e.Fragment = a, e.Lazy = v, e.Memo = g, e.Portal = o, e.Profiler = c, e.StrictMode = s, e.Suspense = f, e.isAsyncMode = function(t2) {
        return M(t2) || _(t2) === h;
      }, e.isConcurrentMode = M, e.isContextConsumer = function(t2) {
        return _(t2) === l;
      }, e.isContextProvider = function(t2) {
        return _(t2) === u;
      }, e.isElement = function(t2) {
        return "object" == typeof t2 && null !== t2 && t2.$$typeof === i;
      }, e.isForwardRef = function(t2) {
        return _(t2) === p;
      }, e.isFragment = function(t2) {
        return _(t2) === a;
      }, e.isLazy = function(t2) {
        return _(t2) === v;
      }, e.isMemo = function(t2) {
        return _(t2) === g;
      }, e.isPortal = function(t2) {
        return _(t2) === o;
      }, e.isProfiler = function(t2) {
        return _(t2) === c;
      }, e.isStrictMode = function(t2) {
        return _(t2) === s;
      }, e.isSuspense = function(t2) {
        return _(t2) === f;
      }, e.isValidElementType = function(t2) {
        return "string" == typeof t2 || "function" == typeof t2 || t2 === a || t2 === d || t2 === c || t2 === s || t2 === f || t2 === m || "object" == typeof t2 && null !== t2 && (t2.$$typeof === v || t2.$$typeof === g || t2.$$typeof === u || t2.$$typeof === l || t2.$$typeof === p || t2.$$typeof === x || t2.$$typeof === b || t2.$$typeof === w || t2.$$typeof === y);
      }, e.typeOf = _;
    }, function(t, e, n) {
      "use strict";
      Object.defineProperty(e, "__esModule", { value: true }), e.default = void 0;
      var r = a(n(0)), i = a(n(1)), o = n(2);
      function a(t2) {
        return t2 && t2.__esModule ? t2 : { default: t2 };
      }
      function s() {
        var t2 = b(["\n  display: block;\n  top: 100%;\n  font-size: ", "px;\n  margin-top: 20px;\n  text-align: center;\n  color: ", ";\n"]);
        return s = function() {
          return t2;
        }, t2;
      }
      function c() {
        var t2 = b(["\n  --o: 1;\n"]);
        return c = function() {
          return t2;
        }, t2;
      }
      function u() {
        var t2 = b(["\n  @keyframes page-5 {\n    45% {\n      transform: rotateY(180deg);\n      opacity: 0;\n    }\n    65% {\n      opacity: 1;\n    }\n    80%,\n    100% {\n      opacity: 0;\n    }\n    95%,\n    100% {\n      transform: rotateY(0deg);\n    }\n  }\n  --c: ", ";\n  animation-name: page-5;\n"]);
        return u = function() {
          return t2;
        }, t2;
      }
      function l() {
        var t2 = b(["\n  @keyframes page-4 {\n    30% {\n      transform: rotateY(180deg);\n      opacity: 0;\n    }\n    50% {\n      opacity: 1;\n    }\n    65%,\n    100% {\n      opacity: 0;\n    }\n    80%,\n    100% {\n      transform: rotateY(0deg);\n    }\n  }\n  --c: ", ";\n  animation-name: page-4;\n"]);
        return l = function() {
          return t2;
        }, t2;
      }
      function h() {
        var t2 = b(["\n  @keyframes page-3 {\n    15% {\n      transform: rotateY(180deg);\n      opacity: 0;\n    }\n    35% {\n      opacity: 1;\n    }\n    50%,\n    100% {\n      opacity: 0;\n    }\n    65%,\n    100% {\n      transform: rotateY(0deg);\n    }\n  }\n  --c: ", ";\n  animation-name: page-3;\n"]);
        return h = function() {
          return t2;
        }, t2;
      }
      function d() {
        var t2 = b(["\n  @keyframes page-2 {\n    0% {\n      transform: rotateY(180deg);\n      opacity: 0;\n    }\n    20% {\n      opacity: 1;\n    }\n    35%,\n    100% {\n      opacity: 0;\n    }\n    50%,\n    100% {\n      transform: rotateY(0deg);\n    }\n  }\n  --c: ", ";\n  animation-name: page-2;\n"]);
        return d = function() {
          return t2;
        }, t2;
      }
      function p() {
        var t2 = b(["\n  --r: 0deg;\n  --o: 1;\n"]);
        return p = function() {
          return t2;
        }, t2;
      }
      function f() {
        var t2 = b(["\n  --r: 180deg;\n  --o: 0;\n  --c: ", ";\n  position: absolute;\n  top: ", "px;\n  left: ", "px;\n  transform-origin: 100% 50%;\n  color: var(--c);\n  opacity: var(--o);\n  transform: rotateY(var(--r));\n  animation: ", " ease infinite;\n"]);
        return f = function() {
          return t2;
        }, t2;
      }
      function m() {
        var t2 = b(["\n  width: ", "px;\n  height: ", "px;\n  display: block;\n"]);
        return m = function() {
          return t2;
        }, t2;
      }
      function g() {
        var t2 = b(["\n  margin: 0;\n  padding: 0;\n  list-style: none;\n  position: relative;\n"]);
        return g = function() {
          return t2;
        }, t2;
      }
      function v() {
        var t2 = b(["\n  width: 100%;\n  height: 100%;\n  border-radius: ", "px;\n  position: relative;\n  z-index: 1;\n  perspective: 600px;\n  box-shadow: 0 4px 6px ", ";\n  background-image: ", ";\n"]);
        return v = function() {
          return t2;
        }, t2;
      }
      function y() {
        var t2 = b(["\n  width: ", "px;\n  height: ", 'px;\n  position: relative;\n  &:before {\n    --r: -6deg;\n    content: "";\n    position: absolute;\n    width: ', "px;\n    box-shadow: 0 ", "px\n      ", "px ", ';\n    transform: rotate(var(--r));\n  }\n  &:after {\n    --r: -6deg;\n    content: "";\n    position: absolute;\n    box-shadow: 0 ', "px\n      ", "px ", ";\n    transform: rotate(var(--r));\n    --r: 6deg;\n  }\n"]);
        return y = function() {
          return t2;
        }, t2;
      }
      function x() {
        var t2 = b(['\n  -webkit-font-smoothing: antialiased;\n  display: flex;\n  font-family: "Roboto", Arial;\n  padding: 20px;\n']);
        return x = function() {
          return t2;
        }, t2;
      }
      function b(t2, e2) {
        return e2 || (e2 = t2.slice(0)), Object.freeze(Object.defineProperties(t2, { raw: { value: Object.freeze(e2) } }));
      }
      var w = i.default.div(x()), _ = i.default.div(y(), function(t2) {
        return t2.sizeParentWidth;
      }, function(t2) {
        return t2.sizeParentHeight;
      }, function(t2) {
        return t2.sizeParentBeforeWidth;
      }, function(t2) {
        return t2.sizeParentShadow1;
      }, function(t2) {
        return t2.sizeParentShadow2;
      }, function(t2) {
        return t2.shadowColor;
      }, function(t2) {
        return t2.sizeParentShadow1;
      }, function(t2) {
        return t2.sizeParentShadow2;
      }, function(t2) {
        return t2.shadowColor;
      }), M = i.default.div(v(), function(t2) {
        return t2.sizeDivBorderRadius;
      }, function(t2) {
        return t2.shadowColor;
      }, function(t2) {
        return t2.background;
      }), S = i.default.ul(g()), T = i.default.svg(m(), function(t2) {
        return t2.sizeSVGWidth;
      }, function(t2) {
        return t2.sizeSVGHeight;
      }), E = i.default.li(f(), function(t2) {
        return t2.pageColor;
      }, function(t2) {
        return t2.sizeLi;
      }, function(t2) {
        return t2.sizeLi;
      }, function(t2) {
        return t2.duration;
      }), A = (0, i.default)(E)(p()), C = (0, i.default)(E)(d(), function(t2) {
        return t2.foldPageColor;
      }), L = (0, i.default)(E)(h(), function(t2) {
        return t2.foldPageColor;
      }), P = (0, i.default)(E)(l(), function(t2) {
        return t2.foldPageColor;
      }), R = (0, i.default)(E)(u(), function(t2) {
        return t2.foldPageColor;
      }), O = (0, i.default)(E)(c()), D = i.default.span(s(), function(t2) {
        return t2.sizeText;
      }, function(t2) {
        return t2.textColor;
      }), I = function(t2) {
        var e2 = t2.className, n2 = void 0 === e2 ? "bookloader" : e2, i2 = t2.text, a2 = void 0 === i2 ? "Loading..." : i2, s2 = t2.background, c2 = void 0 === s2 ? "linear-gradient(135deg, #23c4f8, #275efe)" : s2, u2 = t2.shadowColor, l2 = void 0 === u2 ? "rgba(39, 94, 254, .28)" : u2, h2 = t2.textColor, d2 = void 0 === h2 ? "#6c7486" : h2, p2 = t2.pageColor, f2 = void 0 === p2 ? "rgba(255, 255, 255, .36)" : p2, m2 = t2.foldPageColor, g2 = void 0 === m2 ? "rgba(255, 255, 255, .52)" : m2, v2 = t2.duration, y2 = void 0 === v2 ? "3s" : v2, x2 = t2.size, b2 = void 0 === x2 ? "64px" : x2, E2 = t2.desktopSize, I2 = void 0 === E2 ? "" : E2, N = t2.mobileSize, z = void 0 === N ? "" : N, k = (0, o.useMediaQuery)({ query: "(min-width: 1224px)" }), F = (0, o.useMediaQuery)({ query: "(max-width: 1224px)" }), B = 0;
        k && (B = "" !== I2 ? parseFloat(I2) : 2 * parseFloat(b2)), F && (B = "" !== z ? parseFloat(z) : parseFloat(b2));
        var H = parseFloat(B), G = H / 64, U = 120 * H / 64, j = 200 * H / 64, V = 140 * H / 64, W = 16 * H / 64, q = 12 * H / 64, X = 13 * H / 64, Y = 10 * H / 64, Z = 90 * H / 64, J = 120 * H / 64, $ = 1.5 * G * 20 / 2;
        return 1 === G && ($ = 14), r.default.createElement(w, { className: n2 }, r.default.createElement(_, { sizeParentShadow1: W, sizeParentShadow2: q, sizeParentBeforeWidth: U, sizeParentWidth: j, sizeParentHeight: V, shadowColor: l2, className: "loader" }, r.default.createElement(M, { sizeDivBorderRadius: X, shadowColor: l2, background: c2 }, r.default.createElement(S, null, r.default.createElement(A, { sizeLi: Y, pageColor: f2, duration: y2 }, r.default.createElement(T, { sizeSVGWidth: Z, sizeSVGHeight: J, viewBox: "0 0 90 120", fill: "currentColor" }, r.default.createElement("path", { d: "M90,0 L90,120 L11,120 C4.92486775,120 0,115.075132 0,109 L0,11 C0,4.92486775 4.92486775,0 11,0 L90,0 Z M71.5,81 L18.5,81 C17.1192881,81 16,82.1192881 16,83.5 C16,84.8254834 17.0315359,85.9100387 18.3356243,85.9946823 L18.5,86 L71.5,86 C72.8807119,86 74,84.8807119 74,83.5 C74,82.1745166 72.9684641,81.0899613 71.6643757,81.0053177 L71.5,81 Z M71.5,57 L18.5,57 C17.1192881,57 16,58.1192881 16,59.5 C16,60.8254834 17.0315359,61.9100387 18.3356243,61.9946823 L18.5,62 L71.5,62 C72.8807119,62 74,60.8807119 74,59.5 C74,58.1192881 72.8807119,57 71.5,57 Z M71.5,33 L18.5,33 C17.1192881,33 16,34.1192881 16,35.5 C16,36.8254834 17.0315359,37.9100387 18.3356243,37.9946823 L18.5,38 L71.5,38 C72.8807119,38 74,36.8807119 74,35.5 C74,34.1192881 72.8807119,33 71.5,33 Z" }))), r.default.createElement(C, { sizeLi: Y, pageColor: f2, duration: y2, foldPageColor: g2 }, r.default.createElement(T, { sizeSVGWidth: Z, sizeSVGHeight: J, viewBox: "0 0 90 120", fill: "currentColor" }, r.default.createElement("path", { d: "M90,0 L90,120 L11,120 C4.92486775,120 0,115.075132 0,109 L0,11 C0,4.92486775 4.92486775,0 11,0 L90,0 Z M71.5,81 L18.5,81 C17.1192881,81 16,82.1192881 16,83.5 C16,84.8254834 17.0315359,85.9100387 18.3356243,85.9946823 L18.5,86 L71.5,86 C72.8807119,86 74,84.8807119 74,83.5 C74,82.1745166 72.9684641,81.0899613 71.6643757,81.0053177 L71.5,81 Z M71.5,57 L18.5,57 C17.1192881,57 16,58.1192881 16,59.5 C16,60.8254834 17.0315359,61.9100387 18.3356243,61.9946823 L18.5,62 L71.5,62 C72.8807119,62 74,60.8807119 74,59.5 C74,58.1192881 72.8807119,57 71.5,57 Z M71.5,33 L18.5,33 C17.1192881,33 16,34.1192881 16,35.5 C16,36.8254834 17.0315359,37.9100387 18.3356243,37.9946823 L18.5,38 L71.5,38 C72.8807119,38 74,36.8807119 74,35.5 C74,34.1192881 72.8807119,33 71.5,33 Z" }))), r.default.createElement(L, { sizeLi: Y, pageColor: f2, duration: y2, foldPageColor: g2 }, r.default.createElement(T, { sizeSVGWidth: Z, sizeSVGHeight: J, viewBox: "0 0 90 120", fill: "currentColor" }, r.default.createElement("path", { d: "M90,0 L90,120 L11,120 C4.92486775,120 0,115.075132 0,109 L0,11 C0,4.92486775 4.92486775,0 11,0 L90,0 Z M71.5,81 L18.5,81 C17.1192881,81 16,82.1192881 16,83.5 C16,84.8254834 17.0315359,85.9100387 18.3356243,85.9946823 L18.5,86 L71.5,86 C72.8807119,86 74,84.8807119 74,83.5 C74,82.1745166 72.9684641,81.0899613 71.6643757,81.0053177 L71.5,81 Z M71.5,57 L18.5,57 C17.1192881,57 16,58.1192881 16,59.5 C16,60.8254834 17.0315359,61.9100387 18.3356243,61.9946823 L18.5,62 L71.5,62 C72.8807119,62 74,60.8807119 74,59.5 C74,58.1192881 72.8807119,57 71.5,57 Z M71.5,33 L18.5,33 C17.1192881,33 16,34.1192881 16,35.5 C16,36.8254834 17.0315359,37.9100387 18.3356243,37.9946823 L18.5,38 L71.5,38 C72.8807119,38 74,36.8807119 74,35.5 C74,34.1192881 72.8807119,33 71.5,33 Z" }))), r.default.createElement(P, { sizeLi: Y, pageColor: f2, duration: y2, foldPageColor: g2 }, r.default.createElement(T, { sizeSVGWidth: Z, sizeSVGHeight: J, viewBox: "0 0 90 120", fill: "currentColor" }, r.default.createElement("path", { d: "M90,0 L90,120 L11,120 C4.92486775,120 0,115.075132 0,109 L0,11 C0,4.92486775 4.92486775,0 11,0 L90,0 Z M71.5,81 L18.5,81 C17.1192881,81 16,82.1192881 16,83.5 C16,84.8254834 17.0315359,85.9100387 18.3356243,85.9946823 L18.5,86 L71.5,86 C72.8807119,86 74,84.8807119 74,83.5 C74,82.1745166 72.9684641,81.0899613 71.6643757,81.0053177 L71.5,81 Z M71.5,57 L18.5,57 C17.1192881,57 16,58.1192881 16,59.5 C16,60.8254834 17.0315359,61.9100387 18.3356243,61.9946823 L18.5,62 L71.5,62 C72.8807119,62 74,60.8807119 74,59.5 C74,58.1192881 72.8807119,57 71.5,57 Z M71.5,33 L18.5,33 C17.1192881,33 16,34.1192881 16,35.5 C16,36.8254834 17.0315359,37.9100387 18.3356243,37.9946823 L18.5,38 L71.5,38 C72.8807119,38 74,36.8807119 74,35.5 C74,34.1192881 72.8807119,33 71.5,33 Z" }))), r.default.createElement(R, { sizeLi: Y, pageColor: f2, duration: y2, foldPageColor: g2 }, r.default.createElement(T, { sizeSVGWidth: Z, sizeSVGHeight: J, viewBox: "0 0 90 120", fill: "currentColor" }, r.default.createElement("path", { d: "M90,0 L90,120 L11,120 C4.92486775,120 0,115.075132 0,109 L0,11 C0,4.92486775 4.92486775,0 11,0 L90,0 Z M71.5,81 L18.5,81 C17.1192881,81 16,82.1192881 16,83.5 C16,84.8254834 17.0315359,85.9100387 18.3356243,85.9946823 L18.5,86 L71.5,86 C72.8807119,86 74,84.8807119 74,83.5 C74,82.1745166 72.9684641,81.0899613 71.6643757,81.0053177 L71.5,81 Z M71.5,57 L18.5,57 C17.1192881,57 16,58.1192881 16,59.5 C16,60.8254834 17.0315359,61.9100387 18.3356243,61.9946823 L18.5,62 L71.5,62 C72.8807119,62 74,60.8807119 74,59.5 C74,58.1192881 72.8807119,57 71.5,57 Z M71.5,33 L18.5,33 C17.1192881,33 16,34.1192881 16,35.5 C16,36.8254834 17.0315359,37.9100387 18.3356243,37.9946823 L18.5,38 L71.5,38 C72.8807119,38 74,36.8807119 74,35.5 C74,34.1192881 72.8807119,33 71.5,33 Z" }))), r.default.createElement(O, { sizeLi: Y, pageColor: f2, duration: y2 }, r.default.createElement(T, { sizeSVGWidth: Z, sizeSVGHeight: J, viewBox: "0 0 90 120", fill: "currentColor" }, r.default.createElement("path", { d: "M90,0 L90,120 L11,120 C4.92486775,120 0,115.075132 0,109 L0,11 C0,4.92486775 4.92486775,0 11,0 L90,0 Z M71.5,81 L18.5,81 C17.1192881,81 16,82.1192881 16,83.5 C16,84.8254834 17.0315359,85.9100387 18.3356243,85.9946823 L18.5,86 L71.5,86 C72.8807119,86 74,84.8807119 74,83.5 C74,82.1745166 72.9684641,81.0899613 71.6643757,81.0053177 L71.5,81 Z M71.5,57 L18.5,57 C17.1192881,57 16,58.1192881 16,59.5 C16,60.8254834 17.0315359,61.9100387 18.3356243,61.9946823 L18.5,62 L71.5,62 C72.8807119,62 74,60.8807119 74,59.5 C74,58.1192881 72.8807119,57 71.5,57 Z M71.5,33 L18.5,33 C17.1192881,33 16,34.1192881 16,35.5 C16,36.8254834 17.0315359,37.9100387 18.3356243,37.9946823 L18.5,38 L71.5,38 C72.8807119,38 74,36.8807119 74,35.5 C74,34.1192881 72.8807119,33 71.5,33 Z" }))))), r.default.createElement(D, { sizeText: $, textColor: d2 }, a2)));
      };
      e.default = I;
    }, function(t, e, n) {
      "use strict";
      function r(t2) {
        return (r = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(t3) {
          return typeof t3;
        } : function(t3) {
          return t3 && "function" == typeof Symbol && t3.constructor === Symbol && t3 !== Symbol.prototype ? "symbol" : typeof t3;
        })(t2);
      }
      Object.defineProperty(e, "__esModule", { value: true }), e.default = void 0;
      var i, o = (i = n(0)) && i.__esModule ? i : { default: i }, a = function(t2) {
        if (t2 && t2.__esModule) return t2;
        if (null === t2 || "object" !== r(t2) && "function" != typeof t2) return { default: t2 };
        var e2 = u();
        if (e2 && e2.has(t2)) return e2.get(t2);
        var n2 = {}, i2 = Object.defineProperty && Object.getOwnPropertyDescriptor;
        for (var o2 in t2) if (Object.prototype.hasOwnProperty.call(t2, o2)) {
          var a2 = i2 ? Object.getOwnPropertyDescriptor(t2, o2) : null;
          a2 && (a2.get || a2.set) ? Object.defineProperty(n2, o2, a2) : n2[o2] = t2[o2];
        }
        n2.default = t2, e2 && e2.set(t2, n2);
        return n2;
      }(n(1)), s = n(2), c = n(20);
      function u() {
        if ("function" != typeof WeakMap) return null;
        var t2 = /* @__PURE__ */ new WeakMap();
        return u = function() {
          return t2;
        }, t2;
      }
      function l() {
        var t2 = f(["\n  --background: ", ";\n  --top: ", ";\n  --right: ", ";\n  --bottom: ", ";\n  --left: ", ";\n  --translateZ: ", ";\n  --rotateY: ", ";\n  --rotateX: ", ";\n  position: absolute;\n  width: 100%;\n  height: 100%;\n  background: var(--background);\n  top: var(--top);\n  right: var(--right);\n  bottom: var(--bottom);\n  left: var(--left);\n  transform: rotateY(var(--rotateY)) rotateX(var(--rotateX))\n    translateZ(var(--translateZ));\n"]);
        return l = function() {
          return t2;
        }, t2;
      }
      function h() {
        var t2 = f(["\n  --size: ", "px;\n  --duration: 800ms;\n  width: var(--size);\n  height: var(--size);\n  top: 0;\n  left: 0;\n  position: absolute;\n  transform-style: preserve-3d;\n  transform: translate(\n    ", "%,\n    ", "%\n  );\n  animation: ", " var(--duration) linear\n    infinite;\n\n  & > div {\n    --background: ", ";\n    --top: auto;\n    --right: auto;\n    --bottom: auto;\n    --left: auto;\n    --translateZ: calc(var(--size) / 2);\n    --rotateY: 0deg;\n    --rotateX: 0deg;\n    position: absolute;\n    width: 100%;\n    height: 100%;\n    background: var(--background);\n    top: var(--top);\n    right: var(--right);\n    bottom: var(--bottom);\n    left: var(--left);\n    transform: rotateY(var(--rotateY)) rotateX(var(--rotateX))\n      translateZ(var(--translateZ));\n  }\n\n  & > div:nth-child(1) {\n    --top: 0;\n    --left: 0;\n  }\n  & > div:nth-child(2) {\n    --background: ", ";\n    --right: 0;\n    --rotateY: 90deg;\n  }\n  & > div:nth-child(3) {\n    --background: ", ";\n    --rotateX: -90deg;\n  }\n  & > div:nth-child(4) {\n    --background: ", ";\n    --top: 0;\n    --left: 0;\n    --translateZ: calc(var(--size) * 3 * -1);\n  }\n"]);
        return h = function() {
          return t2;
        }, t2;
      }
      function d() {
        var t2 = f(["\n  --size: ", "px;\n  --duration: 800ms;\n  height: calc(var(--size) * 2);\n  width: calc(var(--size) * 3);\n  position: relative;\n  transform-style: preserve-3d;\n  transform-origin: 50% 50%;\n  margin-bottom: ", "px;\n  // margin-top: calc(var(--size) * 1.5 * -1);\n  padding: 70px;\n  transform: rotateX(60deg) rotateZ(45deg) rotateY(0deg) translateZ(0px);\n"]);
        return d = function() {
          return t2;
        }, t2;
      }
      function p() {
        var t2 = f(["\n0%{\n    transform: translate(", "%, ", "%);\n}\n50% {\n    transform: translate(", "%, ", "%);\n}\n100% {\n    transform: translate(", "%, ", "%);\n}\n"]);
        return p = function() {
          return t2;
        }, t2;
      }
      function f(t2, e2) {
        return e2 || (e2 = t2.slice(0)), Object.freeze(Object.defineProperties(t2, { raw: { value: Object.freeze(e2) } }));
      }
      var m = a.default.div(d(), function(t2) {
        return t2.sizeBoxes;
      }, function(t2) {
        return t2.sizeMarginBottom;
      }), g = a.default.div(h(), function(t2) {
        return t2.sizeBoxes;
      }, function(t2) {
        return t2.boxTransforms[0];
      }, function(t2) {
        return t2.boxTransforms[1];
      }, function(t2) {
        return e2 = t2.animParams, (0, a.keyframes)(p(), e2.start[0], e2.end[0], e2.start[1], e2.end[1], e2.start[2], e2.end[2]);
        var e2;
      }, function(t2) {
        return t2.colors.main;
      }, function(t2) {
        return t2.colors.right;
      }, function(t2) {
        return t2.colors.left;
      }, function(t2) {
        return t2.colors.shadow;
      }), v = a.default.div(l(), function(t2) {
        return t2.boxDivParams.background;
      }, function(t2) {
        return t2.boxDivParams.top;
      }, function(t2) {
        return t2.boxDivParams.right;
      }, function(t2) {
        return t2.boxDivParams.bottom;
      }, function(t2) {
        return t2.boxDivParams.left;
      }, function(t2) {
        return t2.boxDivParams.translateZ;
      }, function(t2) {
        return t2.boxDivParams.rotateX;
      }, function(t2) {
        return t2.boxDivParams.rotateY;
      }), y = function(t2) {
        var e2 = t2.className, n2 = void 0 === e2 ? "boxesloader" : e2, r2 = t2.boxColor, i2 = void 0 === r2 ? "#5C8DF6" : r2, a2 = t2.shadowColor, u2 = void 0 === a2 ? "#dbe3f4" : a2, l2 = t2.duration, h2 = void 0 === l2 ? 800 : l2, d2 = t2.size, p2 = void 0 === d2 ? "64px" : d2, f2 = t2.desktopSize, y2 = void 0 === f2 ? "" : f2, x = t2.mobileSize, b = void 0 === x ? "" : x, w = (0, s.useMediaQuery)({ query: "(min-width: 1224px)" }), _ = (0, s.useMediaQuery)({ query: "(max-width: 1224px)" }), M = 0;
        w && (M = "" !== y2 ? parseFloat(y2) : 2 * parseFloat(p2)), _ && (M = "" !== b ? parseFloat(b) : parseFloat(p2));
        var S = parseFloat(M), T = 32 * S / 64, E = 50 * S / 64, A = (0, c.darken)(0.15, i2), C = (0, c.darken)(0.05, i2), L = { main: i2, right: A, left: C, shadow: u2 }, P = [{ start: [100, 100, 200], end: [0, 0, 0] }, { start: [0, 0, 100], end: [100, 0, 0] }, { start: [100, 100, 0], end: [100, 100, 100] }, { start: [200, 200, 100], end: [0, 100, 100] }], R = [[100, 0], [0, 100], [100, 100], [200, 0]], O = [{ top: "0", right: "auto", bottom: "auto", left: "0", background: i2, rotateX: "0deg", rotateY: "0deg", translateZ: "calc(var(--size) / 2)" }, { top: "auto", right: "0", bottom: "auto", left: "auto", background: A, rotateX: "0deg", rotateY: "90deg", translateZ: "calc(var(--size) / 2)" }, { top: "auto", right: "auto", bottom: "auto", left: "auto", background: C, rotateX: "-90deg", rotateY: "0deg", translateZ: "calc(var(--size) / 2)" }, { top: "0", right: "auto", bottom: "auto", left: "0", background: u2, rotateX: "0deg", rotateY: "0deg", translateZ: "calc(var(--size) * 3 * -1)" }];
        return o.default.createElement(m, { sizeMarginBottom: E, duration: h2, sizeBoxes: T, className: n2 }, o.default.createElement(g, { duration: h2, colors: L, sizeBoxes: T, animParams: P[0], boxTransforms: R[0] }, o.default.createElement(v, { boxDivParams: O[0] }), o.default.createElement(v, { boxDivParams: O[1] }), o.default.createElement(v, { boxDivParams: O[2] }), o.default.createElement(v, { boxDivParams: O[3] })), o.default.createElement(g, { duration: h2, colors: L, sizeBoxes: T, animParams: P[1], boxTransforms: R[1] }, o.default.createElement(v, { boxDivParams: O[0] }), o.default.createElement(v, { boxDivParams: O[1] }), o.default.createElement(v, { boxDivParams: O[2] }), o.default.createElement(v, { boxDivParams: O[3] })), o.default.createElement(g, { duration: h2, colors: L, sizeBoxes: T, animParams: P[2], boxTransforms: R[2] }, o.default.createElement(v, { boxDivParams: O[0] }), o.default.createElement(v, { boxDivParams: O[1] }), o.default.createElement(v, { boxDivParams: O[2] }), o.default.createElement(v, { boxDivParams: O[3] })), o.default.createElement(g, { duration: h2, colors: L, sizeBoxes: T, animParams: P[3], boxTransforms: R[3] }, o.default.createElement(v, { boxDivParams: O[0] }), o.default.createElement(v, { boxDivParams: O[1] }), o.default.createElement(v, { boxDivParams: O[2] }), o.default.createElement(v, { boxDivParams: O[3] })));
      };
      e.default = y;
    }, function(t, e, n) {
      "use strict";
      function r(t2) {
        return (r = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(t3) {
          return typeof t3;
        } : function(t3) {
          return t3 && "function" == typeof Symbol && t3.constructor === Symbol && t3 !== Symbol.prototype ? "symbol" : typeof t3;
        })(t2);
      }
      Object.defineProperty(e, "__esModule", { value: true }), e.default = void 0;
      var i = u(n(0)), o = u(n(10)), a = n(7), s = n(2);
      function c() {
        if ("function" != typeof WeakMap) return null;
        var t2 = /* @__PURE__ */ new WeakMap();
        return c = function() {
          return t2;
        }, t2;
      }
      function u(t2) {
        if (t2 && t2.__esModule) return t2;
        if (null === t2 || "object" !== r(t2) && "function" != typeof t2) return { default: t2 };
        var e2 = c();
        if (e2 && e2.has(t2)) return e2.get(t2);
        var n2 = {}, i2 = Object.defineProperty && Object.getOwnPropertyDescriptor;
        for (var o2 in t2) if (Object.prototype.hasOwnProperty.call(t2, o2)) {
          var a2 = i2 ? Object.getOwnPropertyDescriptor(t2, o2) : null;
          a2 && (a2.get || a2.set) ? Object.defineProperty(n2, o2, a2) : n2[o2] = t2[o2];
        }
        return n2.default = t2, e2 && e2.set(t2, n2), n2;
      }
      var l = function(t2) {
        var e2 = t2.className, n2 = void 0 === e2 ? "circleloader" : e2, r2 = t2.meshColor, c2 = void 0 === r2 ? "#6366F1" : r2, u2 = t2.lightColor, l2 = void 0 === u2 ? "#FFFFFF" : u2, h = t2.lightIntensity, d = void 0 === h ? 0.4 : h, p = t2.ambientLightColor, f = void 0 === p ? "#E8EBFB" : p, m = t2.duration, g = void 0 === m ? 1 : m, v = t2.size, y = void 0 === v ? "64px" : v, x = t2.desktopSize, b = void 0 === x ? "" : x, w = t2.mobileSize, _ = void 0 === w ? "" : w, M = (0, s.useMediaQuery)({ query: "(min-width: 1224px)" }), S = (0, s.useMediaQuery)({ query: "(max-width: 1224px)" }), T = 0;
        M && (T = "" !== b ? parseFloat(b) : 2 * parseFloat(y)), S && (T = "" !== _ ? parseFloat(_) : parseFloat(y));
        var E = 220 * parseFloat(T) / 64;
        return (0, i.useEffect)(function() {
          var t3 = E, e3 = E, r3 = function(t4) {
            var e4 = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : document;
            return e4.querySelector(t4);
          }("." + n2), i2 = new o.WebGLRenderer({ canvas: r3, context: r3.getContext("webgl2"), antialias: true, alpha: true }), s2 = function() {
            var t4 = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : 13, e4 = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 20, n3 = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : 6, r4 = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : 60, i3 = new o.Shape(), a2 = new o.Path();
            i3.moveTo(e4, 0), i3.absarc(0, 0, e4, 0, 2 * Math.PI, false), a2.moveTo(t4, 0), a2.absarc(0, 0, t4, 0, 2 * Math.PI, true), i3.holes.push(a2);
            var s3 = new o.ExtrudeGeometry(i3, { depth: n3, bevelEnabled: false, curveSegments: r4 }), u4 = new o.MeshLambertMaterial({ color: c2 }), l3 = new o.Mesh(s3, u4), h3 = new Proxy({ z: null, s: null }, { set: function(t5, e5, n4) {
              return t5[e5] = n4, null !== t5.z && (l3.position.z = t5.z), null !== t5.s && (l3.scale.x = t5.s, l3.scale.y = t5.s), true;
            }, get: function(t5, e5) {
              return t5[e5];
            } });
            return l3.castShadow = true, l3.receiveShadow = true, { geometry: s3, object: l3, proxy: h3 };
          };
          i2.setSize(t3, e3), i2.setPixelRatio(2), i2.shadowMap.enabled = true, i2.shadowMap.type = o.PCFSoftShadowMap;
          var u3 = new o.Scene(), h2 = new o.PerspectiveCamera(17, t3 / e3, 0.1, 1e3);
          h2.position.z = 100, h2.position.y = -160, h2.rotation.x = o.Math.degToRad(60);
          var p2 = new o.PlaneGeometry(200, 200), m2 = new o.ShadowMaterial();
          m2.opacity = 0.1;
          var v2 = new o.Mesh(p2, m2);
          v2.position.y = 6, v2.receiveShadow = true, u3.add(v2);
          var y2 = new o.DirectionalLight(l2, d);
          y2.position.set(100, 100, 200), y2.castShadow = true;
          y2.shadow.camera.left = -40, y2.shadow.camera.right = 40, y2.shadow.camera.top = 40, y2.shadow.camera.bottom = -40, y2.shadow.radius = 8, u3.add(y2), u3.add(new o.AmbientLight(f));
          var x2 = s2(), b2 = s2(), w2 = s2();
          u3.add(x2.object), u3.add(b2.object), u3.add(w2.object), x2.proxy.s = 0.8, b2.proxy.z = 9, b2.proxy.s = 0.55, w2.proxy.z = 18, w2.proxy.s = 0.35, a.gsap.to(x2.proxy, { repeat: -1, duration: g, keyframes: [{ z: 9, s: 0.95 }, { z: 18, s: 0.35 }, { z: 0, s: 0.3 }, { z: 0, s: 0.8, delay: -0.1 }] }), a.gsap.to(b2.proxy, { repeat: -1, duration: g, keyframes: [{ z: 10, s: 0.5 }, { z: 0, s: 0.5 }, { z: 4, s: 0.65 }, { z: 8, s: 0.55 }] }), a.gsap.to(w2.proxy, { repeat: -1, duration: g, keyframes: [{ z: 0, s: 0.3 }, { z: 0, s: 0.8, delay: -0.1 }, { z: 9, s: 0.95 }, { z: 18, s: 0.35 }] });
          !function t4() {
            requestAnimationFrame(t4), i2.render(u3, h2);
          }();
        }, []), i.default.createElement("canvas", { className: n2 });
      };
      e.default = l;
    }, function(t, e, n) {
      "use strict";
      function r(t2) {
        return (r = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(t3) {
          return typeof t3;
        } : function(t3) {
          return t3 && "function" == typeof Symbol && t3.constructor === Symbol && t3 !== Symbol.prototype ? "symbol" : typeof t3;
        })(t2);
      }
      Object.defineProperty(e, "__esModule", { value: true }), e.default = void 0;
      var i, o = h(n(0)), a = h(n(10)), s = n(7), c = (i = n(1)) && i.__esModule ? i : { default: i }, u = n(2);
      function l() {
        if ("function" != typeof WeakMap) return null;
        var t2 = /* @__PURE__ */ new WeakMap();
        return l = function() {
          return t2;
        }, t2;
      }
      function h(t2) {
        if (t2 && t2.__esModule) return t2;
        if (null === t2 || "object" !== r(t2) && "function" != typeof t2) return { default: t2 };
        var e2 = l();
        if (e2 && e2.has(t2)) return e2.get(t2);
        var n2 = {}, i2 = Object.defineProperty && Object.getOwnPropertyDescriptor;
        for (var o2 in t2) if (Object.prototype.hasOwnProperty.call(t2, o2)) {
          var a2 = i2 ? Object.getOwnPropertyDescriptor(t2, o2) : null;
          a2 && (a2.get || a2.set) ? Object.defineProperty(n2, o2, a2) : n2[o2] = t2[o2];
        }
        return n2.default = t2, e2 && e2.set(t2, n2), n2;
      }
      function d() {
        var t2 = v(["\n  transform: translateX(calc(var(--x-l) * -1px));\n"]);
        return d = function() {
          return t2;
        }, t2;
      }
      function p() {
        var t2 = v(["\n  transform: translateX(calc(var(--x-f) * 1px));\n"]);
        return p = function() {
          return t2;
        }, t2;
      }
      function f() {
        var t2 = v(['\n  display: block;\n  font-family: "Roboto", Arial;\n  font-size: ', "px;\n  font-weight: 900;\n  color: ", ";\n  letter-spacing: 4px;\n"]);
        return f = function() {
          return t2;
        }, t2;
      }
      function m() {
        var t2 = v(["\n  display: block;\n  width: ", "px;\n  height: ", "px;\n  transform: translateY(-1px);\n"]);
        return m = function() {
          return t2;
        }, t2;
      }
      function g() {
        var t2 = v(["\n  display: flex;\n  align-items: center;\n"]);
        return g = function() {
          return t2;
        }, t2;
      }
      function v(t2, e2) {
        return e2 || (e2 = t2.slice(0)), Object.freeze(Object.defineProperties(t2, { raw: { value: Object.freeze(e2) } }));
      }
      var y = c.default.div(g()), x = c.default.canvas(m(), function(t2) {
        return t2.sizeRing;
      }, function(t2) {
        return t2.sizeRing;
      }), b = c.default.span(f(), function(t2) {
        return t2.sizeFont;
      }, function(t2) {
        return t2.textColor;
      }), w = (0, c.default)(b)(p()), _ = (0, c.default)(b)(d()), M = function(t2) {
        var e2 = t2.className, n2 = void 0 === e2 ? "flipfloploader" : e2, r2 = t2.textColor, i2 = void 0 === r2 ? "#4F46E5" : r2, c2 = t2.ringColor, l2 = void 0 === c2 ? "#4F46E5" : c2, h2 = t2.ringShiness, d2 = void 0 === h2 ? 20 : h2, p2 = t2.ringOpacity, f2 = void 0 === p2 ? 0.96 : p2, m2 = t2.ringTransparency, g2 = void 0 === m2 || m2, v2 = t2.ringLightColor, b2 = void 0 === v2 ? "#FFFFFF" : v2, M2 = t2.ringLightIntensity, S = void 0 === M2 ? 0 : M2, T = t2.ringAmbientLightColor, E = void 0 === T ? "#eef4ff" : T, A = t2.textBeforeRing, C = void 0 === A ? "FL" : A, L = t2.textAfterRing, P = void 0 === L ? "P..." : L, R = t2.size, O = void 0 === R ? "64px" : R, D = t2.desktopSize, I = void 0 === D ? "" : D, N = t2.mobileSize, z = void 0 === N ? "" : N, k = (0, u.useMediaQuery)({ query: "(min-width: 1224px)" }), F = (0, u.useMediaQuery)({ query: "(max-width: 1224px)" }), B = 0;
        k && (B = "" !== I ? parseFloat(I) : 2 * parseFloat(O)), F && (B = "" !== z ? parseFloat(z) : parseFloat(O));
        var H = parseFloat(B), G = 40 * H / 64, U = 32 * H / 64, j = 8 * H / 64, V = 5 * H / 64, W = 14 * H / 64, q = 12 * H / 64;
        return (0, o.useEffect)(function() {
          var t3 = document.querySelector(".flipflop-loader-canvas"), e3 = new a.WebGLRenderer({ canvas: t3, context: t3.getContext("webgl2"), antialias: true, alpha: true });
          e3.setSize(G, G), e3.setPixelRatio(8), e3.shadowMap.enabled = true;
          var r3 = new a.Scene(), i3 = new a.PerspectiveCamera(45, 1, 0.1, 1e3);
          i3.position.z = 89;
          var o2 = function(t4, e4, n3, r4) {
            var i4 = { depth: n3, bevelEnabled: false, curveSegments: r4 }, o3 = new a.Shape();
            o3.moveTo(e4, 0), o3.absarc(0, 0, e4, 0, 2 * Math.PI, false);
            var s2 = new a.Path();
            return s2.moveTo(t4, 0), s2.absarc(0, 0, t4, 0, 2 * Math.PI, true), o3.holes.push(s2), new a.ExtrudeGeometry(o3, i4);
          }(12, 20, 9, 60);
          o2.translate(0, 0, -4.5);
          var c3 = new a.MeshPhongMaterial({ color: l2, shininess: d2, opacity: f2, transparent: g2 }), u2 = new a.Mesh(o2, c3);
          r3.add(u2);
          var h3 = new a.DirectionalLight(b2, S);
          h3.position.set(0, 40, 80), h3.castShadow = true, r3.add(h3);
          var p3 = new a.DirectionalLight(b2, S);
          p3.position.set(0, 20, 0), p3.castShadow = true, r3.add(p3);
          var m3 = new a.DirectionalLight(b2, S);
          m3.position.set(0, -40, 80), m3.castShadow = true, r3.add(m3), r3.add(new a.AmbientLight(E));
          var v3 = document.getElementsByClassName(n2)[0], y2 = { xf: j, xl: V };
          console.log(v3), new s.gsap.timeline({ repeat: -1, yoyo: true, onUpdate: function() {
            v3.style.setProperty("--x-f", y2.xf), v3.style.setProperty("--x-l", y2.xl);
          }, repeatDelay: 0.32 }).to(y2, 1.6, { ease: s.Elastic.easeInOut.config(1.2, 0.5), xf: W, xl: q }).to(u2.rotation, 1.6, { ease: s.Elastic.easeInOut.config(1.2, 0.5), x: a.Math.degToRad(90), y: a.Math.degToRad(90) }, 0);
          !function t4() {
            requestAnimationFrame(t4), e3.render(r3, i3);
          }();
        }), o.default.createElement(y, { className: n2 }, o.default.createElement(w, { sizeFont: U, textColor: i2 }, C), o.default.createElement(x, { sizeRing: G, className: "flipflop-loader-canvas" }), o.default.createElement(_, { sizeFont: U, textColor: i2 }, P));
      };
      e.default = M;
    }, function(t, e, n) {
      "use strict";
      function r(t2) {
        return (r = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(t3) {
          return typeof t3;
        } : function(t3) {
          return t3 && "function" == typeof Symbol && t3.constructor === Symbol && t3 !== Symbol.prototype ? "symbol" : typeof t3;
        })(t2);
      }
      Object.defineProperty(e, "__esModule", { value: true }), e.default = void 0;
      var i, o = (i = n(0)) && i.__esModule ? i : { default: i }, a = function(t2) {
        if (t2 && t2.__esModule) return t2;
        if (null === t2 || "object" !== r(t2) && "function" != typeof t2) return { default: t2 };
        var e2 = c();
        if (e2 && e2.has(t2)) return e2.get(t2);
        var n2 = {}, i2 = Object.defineProperty && Object.getOwnPropertyDescriptor;
        for (var o2 in t2) if (Object.prototype.hasOwnProperty.call(t2, o2)) {
          var a2 = i2 ? Object.getOwnPropertyDescriptor(t2, o2) : null;
          a2 && (a2.get || a2.set) ? Object.defineProperty(n2, o2, a2) : n2[o2] = t2[o2];
        }
        n2.default = t2, e2 && e2.set(t2, n2);
        return n2;
      }(n(1)), s = n(20);
      function c() {
        if ("function" != typeof WeakMap) return null;
        var t2 = /* @__PURE__ */ new WeakMap();
        return c = function() {
          return t2;
        }, t2;
      }
      function u() {
        var t2 = E(["\n  --x: -240px;\n  --y: 200px;\n  left: 58px;\n  top: 87px;\n  animation-name: ", ";\n  & > div {\n    animation-name: ", ";\n  }\n"]);
        return u = function() {
          return t2;
        }, t2;
      }
      function l() {
        var t2 = E(["\n  --x: -260px;\n  --y: 120px;\n  left: 91px;\n  top: 76px;\n  animation-name: ", ";\n  & > div {\n    animation-name: ", ";\n  }\n"]);
        return l = function() {
          return t2;
        }, t2;
      }
      function h() {
        var t2 = E(["\n  --x: -220px;\n  --y: -120px;\n  left: 25px;\n  top: 76px;\n  animation-name: ", ";\n  & > div {\n    animation-name: ", ";\n  }\n"]);
        return h = function() {
          return t2;
        }, t2;
      }
      function d() {
        var t2 = E(["\n  --x: 60px;\n  --y: 200px;\n  left: 58px;\n  top: 132px;\n  animation-name: ", ";\n  & > div {\n    animation-name: ", ";\n  }\n"]);
        return d = function() {
          return t2;
        }, t2;
      }
      function p() {
        var t2 = E(["\n  --x: 280px;\n  --y: -40px;\n  left: 91px;\n  top: 120px;\n  animation-name: ", ";\n  & > div {\n    animation-name: ", ";\n  }\n"]);
        return p = function() {
          return t2;
        }, t2;
      }
      function f() {
        var t2 = E(["\n  --x: 120px;\n  --y: -190px;\n  left: 58px;\n  top: 64px;\n  animation-name: ", ";\n  & > div {\n    animation-name: ", ";\n  }\n"]);
        return f = function() {
          return t2;
        }, t2;
      }
      function m() {
        var t2 = E(["\n  --x: -260px;\n  --y: 120px;\n  left: 25px;\n  top: 120px;\n  animation-name: ", ";\n  & > div {\n    animation-name: ", ";\n  }\n"]);
        return m = function() {
          return t2;
        }, t2;
      }
      function g() {
        var t2 = E(["\n  --x: -220px;\n  --y: -120px;\n  left: 58px;\n  top: 108px;\n  animation-name: ", ";\n  & > div {\n    animation-name: ", ";\n  }\n"]);
        return g = function() {
          return t2;
        }, t2;
      }
      function v() {
        var t2 = E(['\n  --x: 0px;\n  --y: 0px;\n  position: absolute;\n  animation: var(--duration) linear forwards infinite;\n  transform: translate(var(--x), var(--y));\n  & > div {\n    background-color: var(--primary);\n    width: 48px;\n    height: 48px;\n    position: relative;\n    transform-style: preserve-3d;\n    animation: var(--duration) ease forwards infinite;\n    transform: rotateY(-47deg) rotateX(-15deg) rotateZ(15deg) scale(0);\n  }\n  & > div:before,\n  & > div:after {\n    --rx: 90deg;\n    --ry: 0deg;\n    --z: 24px;\n    --y: -24px;\n    --x: 0;\n    content: "";\n    position: absolute;\n    background-color: inherit;\n    width: inherit;\n    height: inherit;\n    transform: rotateX(var(--rx)) rotateY(var(--ry))\n      translate(var(--x), var(--y)) translateZ(var(--z));\n    filter: brightness(var(--b, 1.2));\n  }\n  & > div:after {\n    --rx: 0deg;\n    --ry: 90deg;\n    --x: 24px;\n    --y: 0;\n    --b: 1.4;\n  }\n']);
        return v = function() {
          return t2;
        }, t2;
      }
      function y() {
        var t2 = E(["\n  position: absolute;\n  left: -50px;\n  bottom: -120px;\n  transform-style: preserve-3d;\n  transform: rotateY(-47deg) rotateX(-15deg) rotateZ(15deg) scale(1);\n"]);
        return y = function() {
          return t2;
        }, t2;
      }
      function x() {
        var t2 = E(["\n  transform: rotateX(90deg) rotateY(0deg) translate(-48px, -120px)\n    translateZ(100px) scale(0);\n  width: 200px;\n  height: 200px;\n  background: var(--primary);\n  background: linear-gradient(\n    45deg,\n    var(--primary) 0%,\n    var(--primary) 50%,\n    var(--primary-light) 50%,\n    var(--primary-light) 100%\n  );\n  transform-style: preserve-3d;\n  animation: ", ' var(--duration) linear forwards infinite;\n  :before,\n  :after {\n    --rx: 90deg;\n    --ry: 0deg;\n    --x: 44px;\n    --y: 162px;\n    --z: -50px;\n    content: "";\n    width: 156px;\n    height: 300px;\n    opacity: 0;\n    background: linear-gradient(var(--primary), var(--primary-rgba));\n    position: absolute;\n    transform: rotateX(var(--rx)) rotateY(var(--ry))\n      translate(var(--x), var(--y)) translateZ(var(--z));\n    animation: ', " var(--duration) linear forwards infinite;\n  }\n  :after {\n    --rx: 90deg;\n    --ry: 90deg;\n    --x: 0;\n    --y: 177px;\n    --z: 150px;\n  }\n"]);
        return x = function() {
          return t2;
        }, t2;
      }
      function b() {
        var t2 = E(["\n  --background: ", "; //#121621;\n  --duration: ", "s;\n  --primary: ", "; //rgba(39, 94, 254, 1);\n  --primary-light: ", "; //#2f71ff;\n  --primary-rgba: ", '00; //rgba(39, 94, 254, 0);\n  width: 200px;\n  height: 320px;\n  position: relative;\n  transform-style: preserve-3d;\n  @media (max-width: 480px) {\n    zoom: 0.44;\n  }\n  :before,\n  :after {\n    --r: 20.5deg;\n    content: "";\n    width: 320px;\n    height: 140px;\n    position: absolute;\n    right: 32%;\n    bottom: -11px;\n    background: var(--background);\n    transform: translateZ(200px) rotate(var(--r));\n    animation: ', " var(--duration) linear forwards infinite;\n  }\n  :after {\n    --r: -20.5deg;\n    right: auto;\n    left: 32%;\n  }\n"]);
        return b = function() {
          return t2;
        }, t2;
      }
      function w() {
        var t2 = E(["\n0%, 65% {\n    opacity: 0;\n}\n66%, 100% {\n    opacity: 1;\n}\n"]);
        return w = function() {
          return t2;
        }, t2;
      }
      function _() {
        var t2 = E(["\n0%, 70% {\n    opacity: 0;\n}\n75%, 87% {\n    opacity: 0.2;\n}\n100% {\n    opacity: 0;\n}\n"]);
        return _ = function() {
          return t2;
        }, t2;
      }
      function M() {
        var t2 = E(["\n0%, 65% {\n    transform: rotateX(90deg) rotateY(0deg) translate(-48px, -120px) translateZ(100px) scale(0);\n}\n75%, 90% {\n    transform: rotateX(90deg) rotateY(0deg) translate(-48px, -120px) translateZ(100px) scale(1);\n}\n100% {\n    transform: rotateX(90deg) rotateY(0deg) translate(-48px, -120px) translateZ(100px) scale(0);\n}\n"]);
        return M = function() {
          return t2;
        }, t2;
      }
      function S() {
        var t2 = E(["\n", "% {\n    transform: rotateY(-47deg) rotateX(-15deg) rotateZ(15deg) scale(0);\n}\n", "%, 100% {\n    transform: rotateY(-47deg) rotateX(-15deg) rotateZ(15deg) scale(1);\n}\n"]);
        return S = function() {
          return t2;
        }, t2;
      }
      function T() {
        var t2 = E(["\n", "% {\n    transform: translate(var(--x), var(--y));\n}\n", "%, 52% {\n    transform: translate(0, 0);\n}\n80% {\n    transform: translate(0, -32px);\n}\n90%, 100% {\n    transform: translate(0, 188px);\n}\n"]);
        return T = function() {
          return t2;
        }, t2;
      }
      function E(t2, e2) {
        return e2 || (e2 = t2.slice(0)), Object.freeze(Object.defineProperties(t2, { raw: { value: Object.freeze(e2) } }));
      }
      var A = function(t2) {
        return (0, a.keyframes)(T(), t2[0], t2[1]);
      }, C = function(t2) {
        return (0, a.keyframes)(S(), t2[0], t2[1]);
      }, L = (0, a.keyframes)(M()), P = (0, a.keyframes)(_()), R = (0, a.keyframes)(w()), O = a.default.div(b(), function(t2) {
        return t2.background;
      }, function(t2) {
        return t2.duration;
      }, function(t2) {
        return t2.primaryColor;
      }, function(t2) {
        return t2.primary;
      }, function(t2) {
        return t2.primaryRGBA;
      }, R), D = a.default.div(x(), L, P), I = a.default.div(y()), N = a.default.div(v()), z = (0, a.default)(N)(g(), function(t2) {
        return A(t2.boxMoveParams);
      }, function(t2) {
        return C(t2.boxScaleParams);
      }), k = (0, a.default)(N)(m(), function(t2) {
        return A(t2.boxMoveParams);
      }, function(t2) {
        return C(t2.boxScaleParams);
      }), F = (0, a.default)(N)(f(), function(t2) {
        return A(t2.boxMoveParams);
      }, function(t2) {
        return C(t2.boxScaleParams);
      }), B = (0, a.default)(N)(p(), function(t2) {
        return A(t2.boxMoveParams);
      }, function(t2) {
        return C(t2.boxScaleParams);
      }), H = (0, a.default)(N)(d(), function(t2) {
        return A(t2.boxMoveParams);
      }, function(t2) {
        return C(t2.boxScaleParams);
      }), G = (0, a.default)(N)(h(), function(t2) {
        return A(t2.boxMoveParams);
      }, function(t2) {
        return C(t2.boxScaleParams);
      }), U = (0, a.default)(N)(l(), function(t2) {
        return A(t2.boxMoveParams);
      }, function(t2) {
        return C(t2.boxScaleParams);
      }), j = (0, a.default)(N)(u(), function(t2) {
        return A(t2.boxMoveParams);
      }, function(t2) {
        return C(t2.boxScaleParams);
      }), V = function(t2) {
        var e2 = t2.className, n2 = void 0 === e2 ? "scatterboxloader" : e2, r2 = t2.background, i2 = void 0 === r2 ? "#FFFFFF" : r2, a2 = t2.primaryColor, c2 = void 0 === a2 ? "#2f71ff" : a2, u2 = t2.duration, l2 = void 0 === u2 ? 5 : u2, h2 = (t2.size, t2.desktopSize, t2.mobileSize, (0, s.darken)(0.15, c2)), d2 = (0, s.lighten)(0.15, c2), p2 = [[12, 25], [16, 29], [20, 33], [24, 37], [28, 41], [32, 45], [36, 49], [40, 53]], f2 = [[6, 14], [10, 18], [14, 22], [18, 26], [22, 30], [26, 34], [30, 38], [34, 42]];
        return o.default.createElement(O, { duration: l2, background: i2, primary: h2, primaryColor: c2, primaryRGBA: d2, className: n2 }, o.default.createElement(z, { boxMoveParams: p2[0], boxScaleParams: f2[0] }, o.default.createElement("div", null)), o.default.createElement(k, { boxMoveParams: p2[1], boxScaleParams: f2[1] }, o.default.createElement("div", null)), o.default.createElement(F, { boxMoveParams: p2[2], boxScaleParams: f2[2] }, o.default.createElement("div", null)), o.default.createElement(B, { boxMoveParams: p2[3], boxScaleParams: f2[3] }, o.default.createElement("div", null)), o.default.createElement(H, { boxMoveParams: p2[4], boxScaleParams: f2[4] }, o.default.createElement("div", null)), o.default.createElement(G, { boxMoveParams: p2[5], boxScaleParams: f2[5] }, o.default.createElement("div", null)), o.default.createElement(U, { boxMoveParams: p2[6], boxScaleParams: f2[6] }, o.default.createElement("div", null)), o.default.createElement(j, { boxMoveParams: p2[0], boxScaleParams: f2[0] }, o.default.createElement("div", null)), o.default.createElement(I, null, o.default.createElement(D, null)));
      };
      e.default = V;
    }, function(t, e, n) {
      "use strict";
      function r(t2) {
        return (r = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(t3) {
          return typeof t3;
        } : function(t3) {
          return t3 && "function" == typeof Symbol && t3.constructor === Symbol && t3 !== Symbol.prototype ? "symbol" : typeof t3;
        })(t2);
      }
      Object.defineProperty(e, "__esModule", { value: true }), e.default = void 0;
      var i, o = function(t2) {
        if (t2 && t2.__esModule) return t2;
        if (null === t2 || "object" !== r(t2) && "function" != typeof t2) return { default: t2 };
        var e2 = l();
        if (e2 && e2.has(t2)) return e2.get(t2);
        var n2 = {}, i2 = Object.defineProperty && Object.getOwnPropertyDescriptor;
        for (var o2 in t2) if (Object.prototype.hasOwnProperty.call(t2, o2)) {
          var a2 = i2 ? Object.getOwnPropertyDescriptor(t2, o2) : null;
          a2 && (a2.get || a2.set) ? Object.defineProperty(n2, o2, a2) : n2[o2] = t2[o2];
        }
        n2.default = t2, e2 && e2.set(t2, n2);
        return n2;
      }(n(0)), a = (i = n(1)) && i.__esModule ? i : { default: i }, s = n(7), c = n(36), u = n(2);
      function l() {
        if ("function" != typeof WeakMap) return null;
        var t2 = /* @__PURE__ */ new WeakMap();
        return l = function() {
          return t2;
        }, t2;
      }
      function h() {
        var t2 = function(t3, e2) {
          e2 || (e2 = t3.slice(0));
          return Object.freeze(Object.defineProperties(t3, { raw: { value: Object.freeze(e2) } }));
        }(["\n  width: ", "px;\n  heigt: ", "px;\n"]);
        return h = function() {
          return t2;
        }, t2;
      }
      var d = a.default.div(h(), function(t2) {
        return t2.sizeDiv;
      }, function(t2) {
        return t2.sizeDiv;
      });
      function p(t2) {
        return t2 * (Math.PI / 180);
      }
      var f = function(t2) {
        var e2 = t2.className, n2 = void 0 === e2 ? "squircleloader" : e2, r2 = t2.color, i2 = void 0 === r2 ? "#EF4444" : r2, a2 = t2.backfaceColor, l2 = void 0 === a2 ? "#4F46E5" : a2, h2 = t2.alternateColor, f2 = void 0 === h2 ? "#10B981" : h2, m = t2.size, g = void 0 === m ? "64px" : m, v = t2.desktopSize, y = void 0 === v ? "" : v, x = t2.mobileSize, b = void 0 === x ? "" : x, w = (0, u.useMediaQuery)({ query: "(min-width: 1224px)" }), _ = (0, u.useMediaQuery)({ query: "(max-width: 1224px)" }), M = 0;
        w && (M = "" !== y ? parseFloat(y) : 2 * parseFloat(g)), _ && (M = "" !== b ? parseFloat(b) : parseFloat(g));
        var S = 200 * parseFloat(M) / 64;
        return (0, o.useEffect)(function() {
          var t3 = function(t4, e4, n4) {
            var r4, i3 = s.gsap.parseEase(t4), o2 = s.gsap.parseEase(e4);
            return n4 = "function" == typeof (r4 = n4) ? r4 : s.gsap.parseEase("power4.inOut"), function(t5) {
              var e5 = n4(t5);
              return i3(t5) * (1 - e5) + o2(t5) * e5;
            };
          }("expo.in", "circ"), e3 = document.querySelector(".zdog-svg-squircle-loader"), n3 = new c.Anchor({ translate: { x: 400, y: 300 }, scale: 2 }), r3 = new c.Cylinder({ addTo: n3, diameter: 200, length: 200, stroke: false, color: i2, backface: l2 });
          s.gsap.timeline({ repeat: -1, onUpdate: function() {
            n3.updateGraph(), n3.renderGraphSvg(e3);
          } }).to(r3.rotate, { y: "+=".concat(p(90)), ease: t3 }, "+=0.5").to(r3.rotate, { y: "+=".concat(p(90)), ease: t3 }, "+=0.5").call(function() {
            s.gsap.to(r3, { color: r3.color === i2 ? l2 : r3.color === l2 ? f2 : i2 });
          }), console.log(r3);
        }), o.default.createElement(d, { className: n2, sizeDiv: S }, o.default.createElement("svg", { className: "zdog-svg-squircle-loader", viewBox: "0 0 800 600" }));
      };
      e.default = f;
    }, function(t, e, n) {
      var r, i, o, a, s, c, u, l, h, d, p, f, m, g, v, y, x, b, w, _, M, S;
      a = this, t.exports ? t.exports = (s = n(3), c = n(15), u = n(16), l = n(6), h = n(4), d = n(17), p = n(37), f = n(8), m = n(5), g = n(18), v = n(19), y = n(38), x = n(9), b = n(39), w = n(40), _ = n(41), M = n(42), S = n(43), s.CanvasRenderer = c, s.SvgRenderer = u, s.Vector = l, s.Anchor = h, s.Dragger = d, s.Illustration = p, s.PathCommand = f, s.Shape = m, s.Group = g, s.Rect = v, s.RoundedRect = y, s.Ellipse = x, s.Polygon = b, s.Hemisphere = w, s.Cylinder = _, s.Cone = M, s.Box = S, s) : (i = [], r = a.Zdog, void 0 === (o = "function" == typeof r ? r.apply(e, i) : r) || (t.exports = o));
    }, function(t, e, n) {
      !function(e2, r) {
        if (t.exports) t.exports = r(n(3), n(4), n(17));
        else {
          var i = e2.Zdog;
          i.Illustration = r(i, i.Anchor, i.Dragger);
        }
      }(this, function(t2, e2, n2) {
        function r() {
        }
        var i = t2.TAU, o = e2.subclass({ element: void 0, centered: true, zoom: 1, dragRotate: false, resize: false, onPrerender: r, onDragStart: r, onDragMove: r, onDragEnd: r, onResize: r });
        return t2.extend(o.prototype, n2.prototype), o.prototype.create = function(t3) {
          e2.prototype.create.call(this, t3), n2.prototype.create.call(this, t3), this.setElement(this.element), this.setDragRotate(this.dragRotate), this.setResize(this.resize);
        }, o.prototype.setElement = function(t3) {
          if (!(t3 = this.getQueryElement(t3))) throw new Error("Zdog.Illustration element required. Set to " + t3);
          var e3 = t3.nodeName.toLowerCase();
          "canvas" == e3 ? this.setCanvas(t3) : "svg" == e3 && this.setSvg(t3);
        }, o.prototype.setSize = function(t3, e3) {
          t3 = Math.round(t3), e3 = Math.round(e3), this.isCanvas ? this.setSizeCanvas(t3, e3) : this.isSvg && this.setSizeSvg(t3, e3);
        }, o.prototype.setResize = function(t3) {
          this.resize = t3, this.resizeListener || (this.resizeListener = this.onWindowResize.bind(this)), t3 ? (window.addEventListener("resize", this.resizeListener), this.onWindowResize()) : window.removeEventListener("resize", this.resizeListener);
        }, o.prototype.onWindowResize = function() {
          this.setMeasuredSize(), this.onResize(this.width, this.height);
        }, o.prototype.setMeasuredSize = function() {
          var t3, e3;
          if ("fullscreen" == this.resize) t3 = window.innerWidth, e3 = window.innerHeight;
          else {
            var n3 = this.element.getBoundingClientRect();
            t3 = n3.width, e3 = n3.height;
          }
          this.setSize(t3, e3);
        }, o.prototype.renderGraph = function(t3) {
          this.isCanvas ? this.renderGraphCanvas(t3) : this.isSvg && this.renderGraphSvg(t3);
        }, o.prototype.updateRenderGraph = function(t3) {
          this.updateGraph(), this.renderGraph(t3);
        }, o.prototype.setCanvas = function(t3) {
          this.element = t3, this.isCanvas = true, this.ctx = this.element.getContext("2d"), this.setSizeCanvas(t3.width, t3.height);
        }, o.prototype.setSizeCanvas = function(t3, e3) {
          this.width = t3, this.height = e3;
          var n3 = this.pixelRatio = window.devicePixelRatio || 1;
          this.element.width = this.canvasWidth = t3 * n3, this.element.height = this.canvasHeight = e3 * n3, n3 > 1 && !this.resize && (this.element.style.width = t3 + "px", this.element.style.height = e3 + "px");
        }, o.prototype.renderGraphCanvas = function(t3) {
          t3 = t3 || this, this.prerenderCanvas(), e2.prototype.renderGraphCanvas.call(t3, this.ctx), this.postrenderCanvas();
        }, o.prototype.prerenderCanvas = function() {
          var t3 = this.ctx;
          if (t3.lineCap = "round", t3.lineJoin = "round", t3.clearRect(0, 0, this.canvasWidth, this.canvasHeight), t3.save(), this.centered) {
            var e3 = this.width / 2 * this.pixelRatio, n3 = this.height / 2 * this.pixelRatio;
            t3.translate(e3, n3);
          }
          var r2 = this.pixelRatio * this.zoom;
          t3.scale(r2, r2), this.onPrerender(t3);
        }, o.prototype.postrenderCanvas = function() {
          this.ctx.restore();
        }, o.prototype.setSvg = function(t3) {
          this.element = t3, this.isSvg = true, this.pixelRatio = 1;
          var e3 = t3.getAttribute("width"), n3 = t3.getAttribute("height");
          this.setSizeSvg(e3, n3);
        }, o.prototype.setSizeSvg = function(t3, e3) {
          this.width = t3, this.height = e3;
          var n3 = t3 / this.zoom, r2 = e3 / this.zoom, i2 = this.centered ? -n3 / 2 : 0, o2 = this.centered ? -r2 / 2 : 0;
          this.element.setAttribute("viewBox", i2 + " " + o2 + " " + n3 + " " + r2), this.resize ? (this.element.removeAttribute("width"), this.element.removeAttribute("height")) : (this.element.setAttribute("width", t3), this.element.setAttribute("height", e3));
        }, o.prototype.renderGraphSvg = function(t3) {
          t3 = t3 || this, function(t4) {
            for (; t4.firstChild; ) t4.removeChild(t4.firstChild);
          }(this.element), this.onPrerender(this.element), e2.prototype.renderGraphSvg.call(t3, this.element);
        }, o.prototype.setDragRotate = function(t3) {
          t3 && (true === t3 && (t3 = this), this.dragRotate = t3, this.bindDrag(this.element));
        }, o.prototype.dragStart = function() {
          this.dragStartRX = this.dragRotate.rotate.x, this.dragStartRY = this.dragRotate.rotate.y, n2.prototype.dragStart.apply(this, arguments);
        }, o.prototype.dragMove = function(t3, e3) {
          var r2 = e3.pageX - this.dragStartX, o2 = e3.pageY - this.dragStartY, a = Math.min(this.width, this.height), s = r2 / a * i, c = o2 / a * i;
          this.dragRotate.rotate.x = this.dragStartRX - c, this.dragRotate.rotate.y = this.dragStartRY - s, n2.prototype.dragMove.apply(this, arguments);
        }, o;
      });
    }, function(t, e, n) {
      !function(e2, r) {
        if (t.exports) t.exports = r(n(5));
        else {
          var i = e2.Zdog;
          i.RoundedRect = r(i.Shape);
        }
      }(this, function(t2) {
        var e2 = t2.subclass({ width: 1, height: 1, cornerRadius: 0.25, closed: false });
        return e2.prototype.setPath = function() {
          var t3 = this.width / 2, e3 = this.height / 2, n2 = Math.min(t3, e3), r = Math.min(this.cornerRadius, n2), i = t3 - r, o = e3 - r, a = [{ x: i, y: -e3 }, { arc: [{ x: t3, y: -e3 }, { x: t3, y: -o }] }];
          o && a.push({ x: t3, y: o }), a.push({ arc: [{ x: t3, y: e3 }, { x: i, y: e3 }] }), i && a.push({ x: -i, y: e3 }), a.push({ arc: [{ x: -t3, y: e3 }, { x: -t3, y: o }] }), o && a.push({ x: -t3, y: -o }), a.push({ arc: [{ x: -t3, y: -e3 }, { x: -i, y: -e3 }] }), i && a.push({ x: i, y: -e3 }), this.path = a;
        }, e2;
      });
    }, function(t, e, n) {
      !function(e2, r) {
        if (t.exports) t.exports = r(n(3), n(5));
        else {
          var i = e2.Zdog;
          i.Polygon = r(i, i.Shape);
        }
      }(this, function(t2, e2) {
        var n2 = e2.subclass({ sides: 3, radius: 0.5 }), r = t2.TAU;
        return n2.prototype.setPath = function() {
          this.path = [];
          for (var t3 = 0; t3 < this.sides; t3++) {
            var e3 = t3 / this.sides * r - r / 4, n3 = Math.cos(e3) * this.radius, i = Math.sin(e3) * this.radius;
            this.path.push({ x: n3, y: i });
          }
        }, n2;
      });
    }, function(t, e, n) {
      !function(e2, r) {
        if (t.exports) t.exports = r(n(3), n(6), n(4), n(9));
        else {
          var i = e2.Zdog;
          i.Hemisphere = r(i, i.Vector, i.Anchor, i.Ellipse);
        }
      }(this, function(t2, e2, n2, r) {
        var i = r.subclass({ fill: true }), o = t2.TAU;
        i.prototype.create = function() {
          r.prototype.create.apply(this, arguments), this.apex = new n2({ addTo: this, translate: { z: this.diameter / 2 } }), this.renderCentroid = new e2();
        }, i.prototype.updateSortValue = function() {
          this.renderCentroid.set(this.renderOrigin).lerp(this.apex.renderOrigin, 3 / 8), this.sortValue = this.renderCentroid.z;
        }, i.prototype.render = function(t3, e3) {
          this.renderDome(t3, e3), r.prototype.render.apply(this, arguments);
        }, i.prototype.renderDome = function(t3, e3) {
          if (this.visible) {
            var n3 = this.getDomeRenderElement(t3, e3), r2 = Math.atan2(this.renderNormal.y, this.renderNormal.x), i2 = this.diameter / 2 * this.renderNormal.magnitude(), a = this.renderOrigin.x, s = this.renderOrigin.y;
            if (e3.isCanvas) {
              var c = r2 + o / 4, u = r2 - o / 4;
              t3.beginPath(), t3.arc(a, s, i2, c, u);
            } else e3.isSvg && (r2 = (r2 - o / 4) / o * 360, this.domeSvgElement.setAttribute("d", "M " + -i2 + ",0 A " + i2 + "," + i2 + " 0 0 1 " + i2 + ",0"), this.domeSvgElement.setAttribute("transform", "translate(" + a + "," + s + " ) rotate(" + r2 + ")"));
            e3.stroke(t3, n3, this.stroke, this.color, this.getLineWidth()), e3.fill(t3, n3, this.fill, this.color), e3.end(t3, n3);
          }
        };
        return i.prototype.getDomeRenderElement = function(t3, e3) {
          if (e3.isSvg) return this.domeSvgElement || (this.domeSvgElement = document.createElementNS("http://www.w3.org/2000/svg", "path"), this.domeSvgElement.setAttribute("stroke-linecap", "round"), this.domeSvgElement.setAttribute("stroke-linejoin", "round")), this.domeSvgElement;
        }, i;
      });
    }, function(t, e, n) {
      !function(e2, r) {
        if (t.exports) t.exports = r(n(3), n(8), n(5), n(18), n(9));
        else {
          var i = e2.Zdog;
          i.Cylinder = r(i, i.PathCommand, i.Shape, i.Group, i.Ellipse);
        }
      }(this, function(t2, e2, n2, r, i) {
        function o() {
        }
        var a = r.subclass({ color: "#333", updateSort: true });
        a.prototype.create = function() {
          r.prototype.create.apply(this, arguments), this.pathCommands = [new e2("move", [{}]), new e2("line", [{}])];
        }, a.prototype.render = function(t3, e3) {
          this.renderCylinderSurface(t3, e3), r.prototype.render.apply(this, arguments);
        }, a.prototype.renderCylinderSurface = function(t3, e3) {
          if (this.visible) {
            var n3 = this.getRenderElement(t3, e3), r2 = this.frontBase, i2 = this.rearBase, o2 = r2.renderNormal.magnitude(), a2 = r2.diameter * o2 + r2.getLineWidth();
            this.pathCommands[0].renderPoints[0].set(r2.renderOrigin), this.pathCommands[1].renderPoints[0].set(i2.renderOrigin), e3.isCanvas && (t3.lineCap = "butt"), e3.renderPath(t3, n3, this.pathCommands), e3.stroke(t3, n3, true, this.color, a2), e3.end(t3, n3), e3.isCanvas && (t3.lineCap = "round");
          }
        };
        a.prototype.getRenderElement = function(t3, e3) {
          if (e3.isSvg) return this.svgElement || (this.svgElement = document.createElementNS("http://www.w3.org/2000/svg", "path")), this.svgElement;
        }, a.prototype.copyGraph = o, i.subclass().prototype.copyGraph = o;
        var s = n2.subclass({ diameter: 1, length: 1, frontFace: void 0, fill: true }), c = t2.TAU;
        s.prototype.create = function() {
          n2.prototype.create.apply(this, arguments), this.group = new a({ addTo: this, color: this.color, visible: this.visible });
          var t3 = this.length / 2, e3 = this.backface || true;
          this.frontBase = this.group.frontBase = new i({ addTo: this.group, diameter: this.diameter, translate: { z: t3 }, rotate: { y: c / 2 }, color: this.color, stroke: this.stroke, fill: this.fill, backface: this.frontFace || e3, visible: this.visible }), this.rearBase = this.group.rearBase = this.frontBase.copy({ translate: { z: -t3 }, rotate: { y: 0 }, backface: e3 });
        }, s.prototype.render = function() {
        };
        return ["stroke", "fill", "color", "visible"].forEach(function(t3) {
          var e3 = "_" + t3;
          Object.defineProperty(s.prototype, t3, { get: function() {
            return this[e3];
          }, set: function(n3) {
            this[e3] = n3, this.frontBase && (this.frontBase[t3] = n3, this.rearBase[t3] = n3, this.group[t3] = n3);
          } });
        }), s;
      });
    }, function(t, e, n) {
      !function(e2, r) {
        if (t.exports) t.exports = r(n(3), n(6), n(8), n(4), n(9));
        else {
          var i = e2.Zdog;
          i.Cone = r(i, i.Vector, i.PathCommand, i.Anchor, i.Ellipse);
        }
      }(this, function(t2, e2, n2, r, i) {
        var o = i.subclass({ length: 1, fill: true }), a = t2.TAU;
        o.prototype.create = function() {
          i.prototype.create.apply(this, arguments), this.apex = new r({ addTo: this, translate: { z: this.length } }), this.renderApex = new e2(), this.renderCentroid = new e2(), this.tangentA = new e2(), this.tangentB = new e2(), this.surfacePathCommands = [new n2("move", [{}]), new n2("line", [{}]), new n2("line", [{}])];
        }, o.prototype.updateSortValue = function() {
          this.renderCentroid.set(this.renderOrigin).lerp(this.apex.renderOrigin, 1 / 3), this.sortValue = this.renderCentroid.z;
        }, o.prototype.render = function(t3, e3) {
          this.renderConeSurface(t3, e3), i.prototype.render.apply(this, arguments);
        }, o.prototype.renderConeSurface = function(t3, e3) {
          if (this.visible) {
            this.renderApex.set(this.apex.renderOrigin).subtract(this.renderOrigin);
            var n3 = this.renderNormal.magnitude(), r2 = this.renderApex.magnitude2d(), i2 = this.renderNormal.magnitude2d(), o2 = Math.acos(i2 / n3), s = Math.sin(o2), c = this.diameter / 2 * n3;
            if (c * s < r2) {
              var u = Math.atan2(this.renderNormal.y, this.renderNormal.x) + a / 2, l = r2 / s, h = Math.acos(c / l), d = this.tangentA, p = this.tangentB;
              d.x = Math.cos(h) * c * s, d.y = Math.sin(h) * c, p.set(this.tangentA), p.y *= -1, d.rotateZ(u), p.rotateZ(u), d.add(this.renderOrigin), p.add(this.renderOrigin), this.setSurfaceRenderPoint(0, d), this.setSurfaceRenderPoint(1, this.apex.renderOrigin), this.setSurfaceRenderPoint(2, p);
              var f = this.getSurfaceRenderElement(t3, e3);
              e3.renderPath(t3, f, this.surfacePathCommands), e3.stroke(t3, f, this.stroke, this.color, this.getLineWidth()), e3.fill(t3, f, this.fill, this.color), e3.end(t3, f);
            }
          }
        };
        return o.prototype.getSurfaceRenderElement = function(t3, e3) {
          if (e3.isSvg) return this.surfaceSvgElement || (this.surfaceSvgElement = document.createElementNS("http://www.w3.org/2000/svg", "path"), this.surfaceSvgElement.setAttribute("stroke-linecap", "round"), this.surfaceSvgElement.setAttribute("stroke-linejoin", "round")), this.surfaceSvgElement;
        }, o.prototype.setSurfaceRenderPoint = function(t3, e3) {
          this.surfacePathCommands[t3].renderPoints[0].set(e3);
        }, o;
      });
    }, function(t, e, n) {
      !function(e2, r) {
        if (t.exports) t.exports = r(n(3), n(4), n(5), n(19));
        else {
          var i = e2.Zdog;
          i.Box = r(i, i.Anchor, i.Shape, i.Rect);
        }
      }(this, function(t2, e2, n2, r) {
        var i = r.subclass();
        i.prototype.copyGraph = function() {
        };
        var o = t2.TAU, a = ["frontFace", "rearFace", "leftFace", "rightFace", "topFace", "bottomFace"], s = t2.extend({}, n2.defaults);
        delete s.path, a.forEach(function(t3) {
          s[t3] = true;
        }), t2.extend(s, { width: 1, height: 1, depth: 1, fill: true });
        var c = e2.subclass(s);
        c.prototype.create = function(t3) {
          e2.prototype.create.call(this, t3), this.updatePath(), this.fill = this.fill;
        }, c.prototype.updatePath = function() {
          a.forEach(function(t3) {
            this[t3] = this[t3];
          }, this);
        }, a.forEach(function(t3) {
          var e3 = "_" + t3;
          Object.defineProperty(c.prototype, t3, { get: function() {
            return this[e3];
          }, set: function(n3) {
            this[e3] = n3, this.setFace(t3, n3);
          } });
        }), c.prototype.setFace = function(t3, e3) {
          var n3 = t3 + "Rect", r2 = this[n3];
          if (e3) {
            var o2 = this.getFaceOptions(t3);
            o2.color = "string" == typeof e3 ? e3 : this.color, r2 ? r2.setOptions(o2) : r2 = this[n3] = new i(o2), r2.updatePath(), this.addChild(r2);
          } else this.removeChild(r2);
        }, c.prototype.getFaceOptions = function(t3) {
          return { frontFace: { width: this.width, height: this.height, translate: { z: this.depth / 2 } }, rearFace: { width: this.width, height: this.height, translate: { z: -this.depth / 2 }, rotate: { y: o / 2 } }, leftFace: { width: this.depth, height: this.height, translate: { x: -this.width / 2 }, rotate: { y: -o / 4 } }, rightFace: { width: this.depth, height: this.height, translate: { x: this.width / 2 }, rotate: { y: o / 4 } }, topFace: { width: this.width, height: this.depth, translate: { y: -this.height / 2 }, rotate: { x: -o / 4 } }, bottomFace: { width: this.width, height: this.depth, translate: { y: this.height / 2 }, rotate: { x: o / 4 } } }[t3];
        };
        return ["color", "stroke", "fill", "backface", "front", "visible"].forEach(function(t3) {
          var e3 = "_" + t3;
          Object.defineProperty(c.prototype, t3, { get: function() {
            return this[e3];
          }, set: function(n3) {
            this[e3] = n3, a.forEach(function(e4) {
              var r2 = this[e4 + "Rect"], i2 = "string" == typeof this[e4];
              r2 && !("color" == t3 && i2) && (r2[t3] = n3);
            }, this);
          } });
        }), c;
      });
    }, function(t, e, n) {
      "use strict";
      function r(t2) {
        return (r = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(t3) {
          return typeof t3;
        } : function(t3) {
          return t3 && "function" == typeof Symbol && t3.constructor === Symbol && t3 !== Symbol.prototype ? "symbol" : typeof t3;
        })(t2);
      }
      Object.defineProperty(e, "__esModule", { value: true }), e.default = void 0;
      var i, o = function(t2) {
        if (t2 && t2.__esModule) return t2;
        if (null === t2 || "object" !== r(t2) && "function" != typeof t2) return { default: t2 };
        var e2 = u();
        if (e2 && e2.has(t2)) return e2.get(t2);
        var n2 = {}, i2 = Object.defineProperty && Object.getOwnPropertyDescriptor;
        for (var o2 in t2) if (Object.prototype.hasOwnProperty.call(t2, o2)) {
          var a2 = i2 ? Object.getOwnPropertyDescriptor(t2, o2) : null;
          a2 && (a2.get || a2.set) ? Object.defineProperty(n2, o2, a2) : n2[o2] = t2[o2];
        }
        n2.default = t2, e2 && e2.set(t2, n2);
        return n2;
      }(n(0)), a = n(2), s = (i = n(1)) && i.__esModule ? i : { default: i }, c = n(7);
      function u() {
        if ("function" != typeof WeakMap) return null;
        var t2 = /* @__PURE__ */ new WeakMap();
        return u = function() {
          return t2;
        }, t2;
      }
      function l() {
        var t2 = d(["\n  width: 100%;\n  height: 100%;\n  visibility: hidden;\n"]);
        return l = function() {
          return t2;
        }, t2;
      }
      function h() {
        var t2 = d(["\n  width: ", "px;\n  height: ", "px;\n  background: ", ";\n"]);
        return h = function() {
          return t2;
        }, t2;
      }
      function d(t2, e2) {
        return e2 || (e2 = t2.slice(0)), Object.freeze(Object.defineProperties(t2, { raw: { value: Object.freeze(e2) } }));
      }
      var p = s.default.div(h(), function(t2) {
        return t2.sizeSVG;
      }, function(t2) {
        return t2.sizeSVG;
      }, function(t2) {
        return t2.background;
      }), f = s.default.svg(l()), m = function(t2) {
        var e2 = t2.className, n2 = void 0 === e2 ? "sunspotloader" : e2, r2 = t2.background, i2 = void 0 === r2 ? "transparent" : r2, s2 = t2.gradientColors, u2 = void 0 === s2 ? ["#FF4F59", "#FFFC31"] : s2, l2 = t2.shadowColor, h2 = void 0 === l2 ? "#5B1E00" : l2, d2 = t2.shadowOpacity, m2 = void 0 === d2 ? "0.05" : d2, g = t2.size, v = void 0 === g ? "64px" : g, y = t2.desktopSize, x = void 0 === y ? "" : y, b = t2.mobileSize, w = void 0 === b ? "" : b, _ = [];
        if (u2.constructor === String && ("" === u2 && (u2 = "#FF4F59"), _.push(u2)), u2.constructor === Array) {
          var M = u2.length;
          0 === M && (u2.push("#FF4F59"), M = u2.length);
          for (var S = 0; S < 2; S += 1) S < M ? _.push(u2[S]) : _.push(u2[M - 1]);
        }
        var T = (0, a.useMediaQuery)({ query: "(min-width: 1224px)" }), E = (0, a.useMediaQuery)({ query: "(max-width: 1224px)" }), A = 0;
        T && (A = "" !== x ? parseFloat(x) : 2 * parseFloat(v)), E && (A = "" !== w ? parseFloat(w) : parseFloat(v));
        var C = 150 * parseFloat(A) / 64;
        return (0, o.useEffect)(function() {
          var t3 = function(t4) {
            return document.querySelector(t4);
          }, e3 = (t3("#mainSVG"), t3("#container")), n3 = t3(".seg"), r3 = [];
          c.gsap.set("svg", { visibility: "visible" });
          r3.push(n3);
          for (var i3 = 1; i3 < 16; i3++) {
            var o2 = n3.cloneNode(true);
            e3.appendChild(o2), c.gsap.set(o2, { rotation: 15 * i3, svgOrigin: "400 300" }), r3.push(o2);
          }
          var a2 = c.gsap.timeline({});
          r3.forEach(function(t4, e4) {
            var n4 = c.gsap.timeline();
            n4.to(t4, { rotation: "-=120", svgOrigin: "400 300", repeat: -1, repeatRefresh: true, ease: "sine.inOut", repeatDelay: 3.5 }), a2.add(n4, 0.25 * e4);
          }), c.gsap.to(e3, { duration: 1, rotation: 360, svgOrigin: "400 300", ease: "linear", repeat: -1 }, 0), c.gsap.globalTimeline.timeScale(0.5);
        }, []), o.default.createElement(p, { sizeSVG: C, background: i2, className: n2 }, o.default.createElement(f, { id: "mainSVG", xmlns: "http://www.w3.org/2000/svg", viewBox: "335 235 150 150" }, o.default.createElement("defs", null, o.default.createElement("g", { id: "container", filter: "url(#goo)" }, o.default.createElement("path", { className: "seg", d: "M412.9,251.7c-4.1-1.1-8.5-1.7-12.9-1.7" })), o.default.createElement("filter", { id: "goo", colorInterpolationFilters: "sRGB", filterUnits: "objectBoundingBox", x: "-100%", y: "-100%", width: "250%", height: "250%" }, o.default.createElement("feGaussianBlur", { in: "SourceGraphic", stdDeviation: "8", result: "blur" }), o.default.createElement("feColorMatrix", { in: "blur", mode: "matrix", values: "1 0 0 0 0  0 1 0 0 0  0 0 1 0 0  0 0 0 21 -9", result: "cm" }), o.default.createElement("feBlend", null)), o.default.createElement("radialGradient", { id: "grad", cx: "400.5176", cy: "298.0287", r: "125.9247", gradientUnits: "userSpaceOnUse" }, o.default.createElement("stop", { offset: "0.39", style: { stopColor: _[0] } }), o.default.createElement("stop", { offset: "0.45", style: { stopColor: _[1] } }))), o.default.createElement("g", { id: "wrapper" }, o.default.createElement("use", { x: "20", y: "20", xlinkHref: "#container", fill: "none", strokeWidth: "20", strokeMiterlimit: "10", strokeLinejoin: "round", strokeLinecap: "round", stroke: h2, opacity: m2 }), o.default.createElement("use", { xlinkHref: "#container", fill: "none", strokeWidth: "20", strokeMiterlimit: "10", strokeLinejoin: "round", strokeLinecap: "round", stroke: "url(#grad)" }))));
      };
      e.default = m;
    }, function(t, e, n) {
      "use strict";
      function r(t2) {
        return (r = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(t3) {
          return typeof t3;
        } : function(t3) {
          return t3 && "function" == typeof Symbol && t3.constructor === Symbol && t3 !== Symbol.prototype ? "symbol" : typeof t3;
        })(t2);
      }
      Object.defineProperty(e, "__esModule", { value: true }), e.default = void 0;
      var i = h(n(0)), o = h(n(10)), a = u(n(14)), s = u(n(1)), c = n(2);
      function u(t2) {
        return t2 && t2.__esModule ? t2 : { default: t2 };
      }
      function l() {
        if ("function" != typeof WeakMap) return null;
        var t2 = /* @__PURE__ */ new WeakMap();
        return l = function() {
          return t2;
        }, t2;
      }
      function h(t2) {
        if (t2 && t2.__esModule) return t2;
        if (null === t2 || "object" !== r(t2) && "function" != typeof t2) return { default: t2 };
        var e2 = l();
        if (e2 && e2.has(t2)) return e2.get(t2);
        var n2 = {}, i2 = Object.defineProperty && Object.getOwnPropertyDescriptor;
        for (var o2 in t2) if (Object.prototype.hasOwnProperty.call(t2, o2)) {
          var a2 = i2 ? Object.getOwnPropertyDescriptor(t2, o2) : null;
          a2 && (a2.get || a2.set) ? Object.defineProperty(n2, o2, a2) : n2[o2] = t2[o2];
        }
        return n2.default = t2, e2 && e2.set(t2, n2), n2;
      }
      function d() {
        var t2 = f(["\n  width: ", "px;\n  height: ", "px;\n"]);
        return d = function() {
          return t2;
        }, t2;
      }
      function p() {
        var t2 = f(["\n  box-sizing: border-box;\n  -webkit-font-smoothing: antialiased;\n"]);
        return p = function() {
          return t2;
        }, t2;
      }
      function f(t2, e2) {
        return e2 || (e2 = t2.slice(0)), Object.freeze(Object.defineProperties(t2, { raw: { value: Object.freeze(e2) } }));
      }
      var m = s.default.div(p()), g = s.default.canvas(d(), function(t2) {
        return t2.sizeCanvas;
      }, function(t2) {
        return t2.sizeCanvas;
      }), v = function(t2) {
        var e2 = t2.className, n2 = void 0 === e2 ? "threedloader" : e2, r2 = t2.colorRing1, s2 = void 0 === r2 ? "#4F46E5" : r2, u2 = t2.colorRing2, l2 = void 0 === u2 ? "#4F46E5" : u2, h2 = t2.colorLight, d2 = void 0 === h2 ? "#FFFFFF" : h2, p2 = t2.colorAmbientLight, f2 = void 0 === p2 ? "#cdd9ed" : p2, v2 = t2.size, y = void 0 === v2 ? "64px" : v2, x = t2.desktopSize, b = void 0 === x ? "" : x, w = t2.mobileSize, _ = void 0 === w ? "" : w, M = (0, c.useMediaQuery)({ query: "(min-width: 1224px)" }), S = (0, c.useMediaQuery)({ query: "(max-width: 1224px)" }), T = 0;
        M && (T = "" !== b ? parseFloat(b) : 2 * parseFloat(y)), S && (T = "" !== _ ? parseFloat(_) : parseFloat(y));
        var E = 240 * parseFloat(T) / 64;
        return (0, i.useEffect)(function() {
          (0, a.default)(document).ready(function() {
            var t3 = (0, a.default)(".threed-loader-canvas"), e3 = t3[0], n3 = new o.WebGLRenderer({ canvas: e3, context: e3.getContext("webgl2"), antialias: true, alpha: true });
            n3.setSize(t3.width(), t3.height()), n3.setPixelRatio(window.devicePixelRatio || 1), n3.shadowMap.enabled = true;
            var r3 = new o.Scene(), i2 = new o.PerspectiveCamera(45, t3.width() / t3.height(), 0.1, 1e3);
            i2.position.z = 500;
            var c2 = new o.MeshPhongMaterial({ color: s2, shininess: 20 }), u3 = new o.MeshPhongMaterial({ color: l2, shininess: 20 }), h3 = new o.TorusGeometry(60, 20, 60, 180), p3 = new o.Mesh(h3, c2), m2 = new o.Mesh(h3, u3);
            p3.castShadow = true, p3.receiveShadow = true, m2.castShadow = true, m2.receiveShadow = true, r3.add(p3), m2.position.set(60, 0, 0);
            var g2 = new o.Object3D();
            g2.castShadow = true, g2.receiveShadow = true, g2.add(m2), r3.add(g2), g2.rotation.y -= Math.PI / 2, p3.rotation.x -= Math.PI / 2;
            var v3 = new o.PointLight(d2, 0.25);
            v3.position.set(0, 300, 300), v3.castShadow = true, r3.add(v3);
            var y2 = new o.PointLight(d2, 0.4);
            y2.position.set(0, 0, 400), y2.castShadow = true, r3.add(y2);
            var x2 = new o.PointLight(d2, 0.1);
            x2.position.set(0, -300, 0), x2.castShadow = true, r3.add(x2), r3.add(new o.AmbientLight(f2));
            !function t4() {
              requestAnimationFrame(t4), p3.rotation.x -= 0.024, g2.rotation.x -= 0.024, g2.rotation.y += 0.024, n3.render(r3, i2);
            }();
          });
        }), i.default.createElement(m, { className: n2 }, i.default.createElement(g, { sizeCanvas: E, className: "threed-loader-canvas" }));
      };
      e.default = v;
    }, function(t, e, n) {
      "use strict";
      function r(t2) {
        return (r = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(t3) {
          return typeof t3;
        } : function(t3) {
          return t3 && "function" == typeof Symbol && t3.constructor === Symbol && t3 !== Symbol.prototype ? "symbol" : typeof t3;
        })(t2);
      }
      Object.defineProperty(e, "__esModule", { value: true }), e.default = void 0;
      var i, o = (i = n(0)) && i.__esModule ? i : { default: i }, a = function(t2) {
        if (t2 && t2.__esModule) return t2;
        if (null === t2 || "object" !== r(t2) && "function" != typeof t2) return { default: t2 };
        var e2 = c();
        if (e2 && e2.has(t2)) return e2.get(t2);
        var n2 = {}, i2 = Object.defineProperty && Object.getOwnPropertyDescriptor;
        for (var o2 in t2) if (Object.prototype.hasOwnProperty.call(t2, o2)) {
          var a2 = i2 ? Object.getOwnPropertyDescriptor(t2, o2) : null;
          a2 && (a2.get || a2.set) ? Object.defineProperty(n2, o2, a2) : n2[o2] = t2[o2];
        }
        n2.default = t2, e2 && e2.set(t2, n2);
        return n2;
      }(n(1)), s = n(2);
      function c() {
        if ("function" != typeof WeakMap) return null;
        var t2 = /* @__PURE__ */ new WeakMap();
        return c = function() {
          return t2;
        }, t2;
      }
      function u() {
        var t2 = P(["\n  position: absolute;\n  display: flex;\n  justify-content: center;\n  align-items: center;\n  font-weight: 500;\n  font-size: ", "px;\n  letter-spacing: 0.2px;\n  margin-top: ", "px;\n  ::before {\n    content: attr(data-text);\n    color: ", ";\n  }\n  ::after {\n    content: attr(data-text);\n    color: ", ";\n    animation: ", " 3.6s ease infinite;\n    position: absolute;\n  }\n"]);
        return u = function() {
          return t2;
        }, t2;
      }
      function l() {
        var t2 = P(["\n  animation: ", " 1.8s ease infinite 0.05s;\n  stroke: ", ";\n"]);
        return l = function() {
          return t2;
        }, t2;
      }
      function h() {
        var t2 = P(["\n  animation: ", " 1.8s ease infinite 0.2s;\n  stroke: ", ";\n"]);
        return h = function() {
          return t2;
        }, t2;
      }
      function d() {
        var t2 = P(["\n  stroke-dasharray: 22 66;\n"]);
        return d = function() {
          return t2;
        }, t2;
      }
      function p() {
        var t2 = P(["\n  animation: ", " 1.8s ease infinite 0.1s;\n  stroke: ", ";\n"]);
        return p = function() {
          return t2;
        }, t2;
      }
      function f() {
        var t2 = P(["\n  animation: ", " 1.8s ease infinite 0.25s;\n  stroke: ", ";\n"]);
        return f = function() {
          return t2;
        }, t2;
      }
      function m() {
        var t2 = P(["\n  stroke-dasharray: 42.5 127.5;\n"]);
        return m = function() {
          return t2;
        }, t2;
      }
      function g() {
        var t2 = P(["\n  animation: ", " 1.8s ease infinite 0.15s;\n  stroke: ", ";\n"]);
        return g = function() {
          return t2;
        }, t2;
      }
      function v() {
        var t2 = P(["\n  animation: ", " 1.8s ease infinite 0.3s;\n  stroke: ", ";\n"]);
        return v = function() {
          return t2;
        }, t2;
      }
      function y() {
        var t2 = P(["\n  stroke-dasharray: 62.75 188.25;\n"]);
        return y = function() {
          return t2;
        }, t2;
      }
      function x() {
        var t2 = P(["\n  position: absolute;\n  fill: none;\n  stroke-width: 6px;\n  stroke-linecap: round;\n  stroke-linejoin: round;\n  transform: rotate(-100deg);\n  transform-origin: center;\n"]);
        return x = function() {
          return t2;
        }, t2;
      }
      function b() {
        var t2 = P(["\n  height: ", "px;\n  width: ", "px;\n"]);
        return b = function() {
          return t2;
        }, t2;
      }
      function w() {
        var t2 = P(["\n  height: ", "px;\n  width: ", "px;\n"]);
        return w = function() {
          return t2;
        }, t2;
      }
      function _() {
        var t2 = P(["\n  height: ", "px;\n  width: ", "px;\n"]);
        return _ = function() {
          return t2;
        }, t2;
      }
      function M() {
        var t2 = P(["\n  position: absolute;\n  display: flex;\n  justify-content: center;\n  align-items: center;\n"]);
        return M = function() {
          return t2;
        }, t2;
      }
      function S() {
        var t2 = P(["\n  background: ", ";\n  width: ", "px;\n  height: ", "px;\n  border-radius: 50px;\n  position: relative;\n  display: flex;\n  justify-content: center;\n  align-items: center;\n"]);
        return S = function() {
          return t2;
        }, t2;
      }
      function T() {
        var t2 = P(["\n  background: ", ';\n  font: 400 16px "Varela Round", sans-serif;\n  display: flex;\n  flex-direction: column;\n  padding: ', "px;\n"]);
        return T = function() {
          return t2;
        }, t2;
      }
      function E() {
        var t2 = P(["\n0% {\n    clip-path: inset(0 100% 0 0);\n}\n50% {\n    clip-path: inset(0);\n}\n100% {\n    clip-path: inset(0 0 0 100%);\n}\n"]);
        return E = function() {
          return t2;
        }, t2;
      }
      function A() {
        var t2 = P(["\n0% {\n    stroke-dashoffset: 9;\n}\n25% {\n    stroke-dashoffset: 0;\n}\n65% {\n    stroke-dashoffset: 106;\n}\n80% {\n    stroke-dashoffset: 97;\n}\n100% {\n    stroke-dashoffset: 97;\n}\n"]);
        return A = function() {
          return t2;
        }, t2;
      }
      function C() {
        var t2 = P(["\n0% {\n    stroke-dashoffset: 17;\n}\n25% {\n    stroke-dashoffset: 0;\n}\n65% {\n    stroke-dashoffset: 204;\n}\n80% {\n    stroke-dashoffset: 187;\n}\n100% {\n    stroke-dashoffset: 187;\n}\n"]);
        return C = function() {
          return t2;
        }, t2;
      }
      function L() {
        var t2 = P(["\n    0% {\n        stroke-dashoffset: 25;\n    }\n    25% {\n        stroke-dashoffset: 0;\n    }\n    65% {\n        stroke-dashoffset: 301;\n    }\n    80% {\n        stroke-dashoffset: 276;\n    }\n    100% {\n        stroke-dashoffset: 276;\n    }\n"]);
        return L = function() {
          return t2;
        }, t2;
      }
      function P(t2, e2) {
        return e2 || (e2 = t2.slice(0)), Object.freeze(Object.defineProperties(t2, { raw: { value: Object.freeze(e2) } }));
      }
      var R = (0, a.keyframes)(L()), O = (0, a.keyframes)(C()), D = (0, a.keyframes)(A()), I = (0, a.keyframes)(E()), N = a.default.div(T(), function(t2) {
        return t2.background;
      }, function(t2) {
        return t2.paddingPassed;
      }), z = a.default.div(S(), function(t2) {
        return t2.background;
      }, function(t2) {
        return t2.passedSize;
      }, function(t2) {
        return t2.passedSize;
      }), k = a.default.svg(M()), F = (0, a.default)(k)(_(), function(t2) {
        return t2.passedSize;
      }, function(t2) {
        return t2.passedSize;
      }), B = (0, a.default)(k)(w(), function(t2) {
        return t2.passedSize;
      }, function(t2) {
        return t2.passedSize;
      }), H = (0, a.default)(k)(b(), function(t2) {
        return t2.passedSize;
      }, function(t2) {
        return t2.passedSize;
      }), G = a.default.circle(x()), U = (0, a.default)(G)(y()), j = (0, a.default)(U)(v(), R, function(t2) {
        return t2.backColor;
      }), V = (0, a.default)(U)(g(), R, function(t2) {
        return t2.frontColor;
      }), W = (0, a.default)(G)(m()), q = (0, a.default)(W)(f(), O, function(t2) {
        return t2.backColor;
      }), X = (0, a.default)(W)(p(), O, function(t2) {
        return t2.frontColor;
      }), Y = (0, a.default)(G)(d()), Z = (0, a.default)(Y)(h(), D, function(t2) {
        return t2.backColor;
      }), J = (0, a.default)(Y)(l(), D, function(t2) {
        return t2.frontColor;
      }), $ = a.default.div(u(), function(t2) {
        return t2.passedSize;
      }, function(t2) {
        return t2.passedMargin;
      }, function(t2) {
        return t2.textColor;
      }, function(t2) {
        return t2.frontColor;
      }, I), Q = function(t2) {
        var e2 = t2.className, n2 = void 0 === e2 ? "wifiloader" : e2, r2 = t2.text, i2 = void 0 === r2 ? "Loading..." : r2, a2 = t2.background, c2 = void 0 === a2 ? "transparent" : a2, u2 = t2.frontColor, l2 = void 0 === u2 ? "#4F29F0" : u2, h2 = t2.backColor, d2 = void 0 === h2 ? "#C3C8DE" : h2, p2 = t2.textColor, f2 = void 0 === p2 ? "#414856" : p2, m2 = t2.size, g2 = void 0 === m2 ? "64px" : m2, v2 = t2.desktopSize, y2 = void 0 === v2 ? "" : v2, x2 = t2.mobileSize, b2 = void 0 === x2 ? "" : x2, w2 = (0, s.useMediaQuery)({ query: "(min-width: 1224px)" }), _2 = (0, s.useMediaQuery)({ query: "(max-width: 1224px)" }), M2 = 0;
        w2 && (M2 = "" !== y2 ? parseFloat(y2) : 2 * parseFloat(g2)), _2 && (M2 = "" !== b2 ? parseFloat(b2) : parseFloat(g2));
        var S2 = parseFloat(M2), T2 = S2 / 64, E2 = 20 * S2 / 64, A2 = 1.5 * T2 * 14 / 2, C2 = 120 * S2 / 64, L2 = 86 * S2 / 64, P2 = 60 * S2 / 64, R2 = 34 * S2 / 64;
        return 1 === T2 && (A2 = 14), console.log(L2), console.log(P2), console.log(R2), o.default.createElement(N, { background: c2, paddingPassed: E2, className: n2 }, o.default.createElement(z, { id: "wifi-loader", background: c2, passedSize: S2 }, o.default.createElement(F, { className: "circle-outer", passedSize: L2, viewBox: "0 0 86 86" }, o.default.createElement(j, { className: "back", backColor: d2, cx: "43", cy: "43", r: "40" }), o.default.createElement(V, { className: "front", frontColor: l2, cx: "43", cy: "43", r: "40" })), o.default.createElement(B, { className: "circle-middle", passedSize: P2, viewBox: "0 0 60 60" }, o.default.createElement(q, { className: "back", backColor: d2, cx: "30", cy: "30", r: "27" }), o.default.createElement(X, { className: "front", frontColor: l2, cx: "30", cy: "30", r: "27" })), o.default.createElement(H, { className: "circle-inner", passedSize: R2, viewBox: "0 0 34 34" }, o.default.createElement(Z, { className: "back", backColor: d2, cx: "17", cy: "17", r: "14" }), o.default.createElement(J, { className: "front", frontColor: l2, cx: "17", cy: "17", r: "14" })), o.default.createElement($, { textColor: f2, frontColor: l2, passedSize: A2, passedMargin: C2, "data-text": i2 })));
      };
      e.default = Q;
    }, function(t, e, n) {
      "use strict";
      function r(t2) {
        return (r = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(t3) {
          return typeof t3;
        } : function(t3) {
          return t3 && "function" == typeof Symbol && t3.constructor === Symbol && t3 !== Symbol.prototype ? "symbol" : typeof t3;
        })(t2);
      }
      Object.defineProperty(e, "__esModule", { value: true }), e.default = void 0;
      var i, o = (i = n(0)) && i.__esModule ? i : { default: i }, a = function(t2) {
        if (t2 && t2.__esModule) return t2;
        if (null === t2 || "object" !== r(t2) && "function" != typeof t2) return { default: t2 };
        var e2 = c();
        if (e2 && e2.has(t2)) return e2.get(t2);
        var n2 = {}, i2 = Object.defineProperty && Object.getOwnPropertyDescriptor;
        for (var o2 in t2) if (Object.prototype.hasOwnProperty.call(t2, o2)) {
          var a2 = i2 ? Object.getOwnPropertyDescriptor(t2, o2) : null;
          a2 && (a2.get || a2.set) ? Object.defineProperty(n2, o2, a2) : n2[o2] = t2[o2];
        }
        n2.default = t2, e2 && e2.set(t2, n2);
        return n2;
      }(n(1)), s = n(2);
      function c() {
        if ("function" != typeof WeakMap) return null;
        var t2 = /* @__PURE__ */ new WeakMap();
        return c = function() {
          return t2;
        }, t2;
      }
      function u() {
        var t2 = d(["\n  box-sizing: border-box;\n  position: absolute;\n  display: block;\n  border-radius: ", "px;\n  border: ", "px solid\n    ", ";\n  width: ", "px;\n  height: ", "px;\n  margin-top: ", "px;\n  margin-left: ", "px;\n  animation: ", " 3s 0s forwards\n    cubic-bezier(0.25, 0.1, 0.25, 1) infinite;\n"]);
        return u = function() {
          return t2;
        }, t2;
      }
      function l() {
        var t2 = d(["\n  background: ", ";\n  width: ", "px;\n  height: ", "px;\n  padding: 20px;\n"]);
        return l = function() {
          return t2;
        }, t2;
      }
      function h() {
        var t2 = d(["\n0% {\n    width: ", "px;\n    height: ", "px;\n    margin-top: ", "px;\n    margin-left: ", "px;\n}\n\n12.5% {\n    width: ", "px;\n    height: ", "px;\n    margin-top: ", "px;\n    margin-left: ", "px;\n}\n\n25% {\n    width: ", "px;\n    height: ", "px;\n    margin-top: ", "px;\n    margin-left: ", "px;\n}\n\n37.5% {\n    width: ", "px;\n    height: ", "px;\n    margin-top: ", "px;\n    margin-left: ", "px;\n}\n\n50% {\n    width: ", "px;\n    height: ", "px;\n    margin-top: ", "px;\n    margin-left: ", "px;\n}\n\n62.5% {\n    width: ", "px;\n    height: ", "px;\n    margin-top: ", "px;\n    margin-left: ", "px;\n}\n\n75% {\n    width: ", "px;\n    height: ", "px;\n    margin-top: ", "px;\n    margin-left: ", "px;\n}\n\n87.5% {\n    width: ", "px;\n    height: ", "px;\n    margin-top: ", "px;\n    margin-left: ", "px;\n}\n\n100% {\n    width: ", "px;\n    height: ", "px;\n    margin-top: ", "px;\n    margin-left: ", "px;\n}\n"]);
        return h = function() {
          return t2;
        }, t2;
      }
      function d(t2, e2) {
        return e2 || (e2 = t2.slice(0)), Object.freeze(Object.defineProperties(t2, { raw: { value: Object.freeze(e2) } }));
      }
      var p = a.default.div(l(), function(t2) {
        return t2.background;
      }, function(t2) {
        return t2.sizeContainer;
      }, function(t2) {
        return t2.sizeContainer;
      }), f = a.default.div(u(), function(t2) {
        return t2.sizeBorderRadius;
      }, function(t2) {
        return t2.sizeBorderThickness;
      }, function(t2) {
        return t2.borderColor;
      }, function(t2) {
        return t2.boxParams.w;
      }, function(t2) {
        return t2.boxParams.h;
      }, function(t2) {
        return t2.boxParams.mt;
      }, function(t2) {
        return t2.boxParams.ml;
      }, function(t2) {
        return e2 = t2.animParams, (0, a.keyframes)(h(), e2.w[0], e2.h[0], e2.mt[0], e2.ml[0], e2.w[1], e2.h[1], e2.mt[1], e2.ml[1], e2.w[2], e2.h[2], e2.mt[2], e2.ml[2], e2.w[3], e2.h[3], e2.mt[3], e2.ml[3], e2.w[4], e2.h[4], e2.mt[4], e2.ml[4], e2.w[5], e2.h[5], e2.mt[5], e2.ml[5], e2.w[6], e2.h[6], e2.mt[6], e2.ml[6], e2.w[7], e2.h[7], e2.mt[7], e2.ml[7], e2.w[8], e2.h[8], e2.mt[8], e2.ml[8]);
        var e2;
      }), m = function(t2) {
        var e2 = t2.className, n2 = void 0 === e2 ? "xlviloader" : e2, r2 = t2.backgound, i2 = void 0 === r2 ? "transparent" : r2, a2 = t2.boxColors, c2 = void 0 === a2 ? ["#333"] : a2, u2 = t2.size, l2 = void 0 === u2 ? "64px" : u2, h2 = t2.desktopSize, d2 = void 0 === h2 ? "" : h2, m2 = t2.mobileSize, g = void 0 === m2 ? "" : m2, v = [];
        if (c2.constructor === String && ("" === c2 && (c2 = "#333"), v.push(c2)), c2.constructor === Array) {
          var y = c2.length;
          0 === y && (c2.push("#333"), y = c2.length);
          for (var x = 0; x < 3; x += 1) x < y ? v.push(c2[x]) : v.push(c2[y - 1]);
        }
        var b = (0, s.useMediaQuery)({ query: "(min-width: 1224px)" }), w = (0, s.useMediaQuery)({ query: "(max-width: 1224px)" }), _ = 0;
        b && (_ = "" !== d2 ? parseFloat(d2) : 2 * parseFloat(l2)), w && (_ = "" !== g ? parseFloat(g) : parseFloat(l2));
        var M = parseFloat(_), S = 112 * M / 64, T = 24 * M / 64, E = 16 * M / 64, A = { w: 112 * M / 64, h: 48 * M / 64, mt: 64 * M / 64, ml: 0 }, C = { w: 48 * M / 64, h: 48 * M / 64, mt: 0, ml: 0 }, L = { w: 48 * M / 64, h: 48 * M / 64, mt: 0, ml: 64 * M / 64 }, P = { w: [112 * M / 64, 48 * M / 64, 48 * M / 64, 48 * M / 64, 48 * M / 64, 48 * M / 64, 48 * M / 64, 48 * M / 64, 48 * M / 64], h: [48 * M / 64, 48 * M / 64, 48 * M / 64, 48 * M / 64, 48 * M / 64, 48 * M / 64, 112 * M / 64, 48 * M / 64, 48 * M / 64], mt: [64 * M / 64, 64 * M / 64, 64 * M / 64, 64 * M / 64, 64 * M / 64, 64 * M / 64, 0, 0, 0], ml: [0, 0, 0, 0, 0, 0, 0, 0, 0] }, R = { w: [48 * M / 64, 48 * M / 64, 48 * M / 64, 48 * M / 64, 112 * M / 64, 48 * M / 64, 48 * M / 64, 48 * M / 64, 48 * M / 64], h: [48 * M / 64, 48 * M / 64, 48 * M / 64, 48 * M / 64, 48 * M / 64, 48 * M / 64, 48 * M / 64, 48 * M / 64, 48 * M / 64], mt: [0, 0, 0, 0, 0, 0, 0, 0, 0], ml: [0, 0, 0, 0, 0, 64 * M / 64, 64 * M / 64, 64 * M / 64, 64 * M / 64] }, O = { w: [48 * M / 64, 48 * M / 64, 48 * M / 64, 48 * M / 64, 48 * M / 64, 48 * M / 64, 48 * M / 64, 48 * M / 64, 112 * M / 64], h: [48 * M / 64, 48 * M / 64, 112 * M / 64, 48 * M / 64, 48 * M / 64, 48 * M / 64, 48 * M / 64, 48 * M / 64, 48 * M / 64], mt: [0, 0, 0, 64 * M / 64, 64 * M / 64, 64 * M / 64, 64 * M / 64, 64 * M / 64, 64 * M / 64], ml: [64 * M / 64, 64 * M / 64, 64 * M / 64, 64 * M / 64, 64 * M / 64, 64 * M / 64, 64 * M / 64, 64 * M / 64, 0] };
        return o.default.createElement(p, { sizeContainer: S, background: i2, className: n2 }, o.default.createElement(f, { boxParams: A, sizeBorderRadius: T, sizeBorderThickness: E, borderColor: v[0], animParams: P, className: "box1" }), o.default.createElement(f, { boxParams: C, sizeBorderRadius: T, sizeBorderThickness: E, borderColor: v[1], animParams: R, className: "box2" }), o.default.createElement(f, { boxParams: L, sizeBorderRadius: T, sizeBorderThickness: E, borderColor: v[2], animParams: O, className: "box3" }));
      };
      e.default = m;
    }]);
  }
});
export default require_lib();
/*! Bundled license information:

react-awesome-loaders/lib/index.js:
  (*
  object-assign
  (c) Sindre Sorhus
  @license MIT
  *)
  (*!
   * Zdog v1.1.2
   * Round, flat, designer-friendly pseudo-3D engine
   * Licensed MIT
   * https://zzz.dog
   * Copyright 2020 Metafizzy
   *)
  (*!
   * GSAP 3.6.0
   * https://greensock.com
   *
   * @license Copyright 2008-2021, GreenSock. All rights reserved.
   * Subject to the terms at https://greensock.com/standard-license or for
   * Club GreenSock members, the agreement issued with that membership.
   * @author: Jack Doyle, jack@greensock.com
  *)
  (*!
   * CSSPlugin 3.6.0
   * https://greensock.com
   *
   * Copyright 2008-2021, GreenSock. All rights reserved.
   * Subject to the terms at https://greensock.com/standard-license or for
   * Club GreenSock members, the agreement issued with that membership.
   * @author: Jack Doyle, jack@greensock.com
  *)
  (*!
   * jQuery JavaScript Library v3.5.1
   * https://jquery.com/
   *
   * Includes Sizzle.js
   * https://sizzlejs.com/
   *
   * Copyright JS Foundation and other contributors
   * Released under the MIT license
   * https://jquery.org/license
   *
   * Date: 2020-05-04T22:49Z
   *)
  (** @license React v17.0.1
   * react-is.production.min.js
   *
   * Copyright (c) Facebook, Inc. and its affiliates.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   *)
  (** @license React v16.13.1
   * react-is.production.min.js
   *
   * Copyright (c) Facebook, Inc. and its affiliates.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   *)
*/
//# sourceMappingURL=react-awesome-loaders.js.map
